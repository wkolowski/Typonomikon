<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">B6: Inne światy [TODO]</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Typonomikon</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">B5</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab229"></a><h1 class="section">Inne aksjomaty? (TODO)</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">PropExt</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">P</span> &lt;-&gt; <span class="id" title="var">Q</span>) -&gt; <span class="id" title="var">P</span> = <span class="id" title="var">Q</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ProofIrrelevance</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">P</span>), <span class="id" title="var">p1</span> = <span class="id" title="var">p2</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">UIP</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>), <span class="id" title="var">p</span> = <span class="id" title="var">q</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">K</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span>), <span class="id" title="var">p</span> = <span class="id" title="var">eq_refl</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">PropExt_simpl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">PropExt</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> = <span class="id" title="var">True</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">PropExt_ProofIrrelevance</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">PropExt</span> -&gt; <span class="id" title="var">ProofIrrelevance</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ProofIrrelevance_UIP</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">ProofIrrelevance</span> -&gt; <span class="id" title="var">UIP</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">UIP_K</span> : <span class="id" title="var">UIP</span> -&gt; <span class="id" title="var">K</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">K_UIP</span> : <span class="id" title="var">K</span> -&gt; <span class="id" title="var">UIP</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ProofIrrelevance_K</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">ProofIrrelevance</span> -&gt; <span class="id" title="var">K</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">PropExt_UIP</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">PropExt</span> -&gt; <span class="id" title="var">UIP</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab230"></a><h1 class="section">Inne systemy dowodzenia? (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab231"></a><h2 class="section">Systemy w stylu Hilberta</h2>

<div class="paragraph"> </div>

<a id="lab232"></a><h2 class="section">Rachunek sekwentów</h2>

<div class="paragraph"> </div>

<a id="lab233"></a><h1 class="section">Inne logiki?</h1>

<div class="paragraph"> </div>

 Słowo "logika" zazwyczaj występuje w liczbie pojedynczej i nie bez
    przyczyny - zazwyczaj naucza się jednej (a nawet jedynej słusznej)
    logiki. Porównawszy logiki konstruktywną i klasyczną nie pozostaje
    nam nic innego jak tylko skonstatować, że jesteśmy bardzo wyjątkowymi
    płatkami śniegu, bo znamy już dwie logiki. Do głowy powinno nam zatem
    przyjść jedyne słuszne w tej sytuacji pytanie: czy są jeszcze jakieś
    inne logiki? Odpowiedź brzmi: tak, i to nawet nieskończenie wiele.

<div class="paragraph"> </div>

    W niniejszym podrozdziale zapoznamy się z krótką klasyfikacją innych
    logik wraz z ich opisami i oceną ideologicznej słuszności (tak żebyś
    wiedział, za czym nie warto gonić - za dużo swojego cennego czasu
    zmarnowałem na rozmyślanie o bezużytecznych logikach i chciałbym,
    aby przyszłe pokolenia nie musiały tyle cierpieć), zaś w dalszej
    części niniejszego rozdziału poznamy te z owych innych logik, które
    znać warto. 
<div class="paragraph"> </div>

<a id="lab234"></a><h2 class="section">Logiki (sub- i super-)intuicjonistyczne oraz logiki pośrednie</h2>

<div class="paragraph"> </div>

 Na wstępie przypomnijmy, że "logika intuicjonistyczna" to inna
    nazwa na logikę konstruktywną, ale ja unikam tej nazwy, bo jest
    mało obrazowa (nie mówiąc już o tym, że jest upiornie przydługa).

<div class="paragraph"> </div>

    Są dwa podstawowe sposoby, żeby uzyskać logikę inną od logiki
    konstruktywnej:
<ul class="doclist">
<li> weź logikę konstruktywną i coś z niej zabierz

</li>
<li> weź logikę konstruktywną i coś do niej dodaj

</li>
</ul>

<div class="paragraph"> </div>

    Logiki z pierwszego przypadku to logiki subintuicjonistyczne (po
    łacinie "sub" znaczy "poniżej"), bo można w nich udowodnić mniej
    twierdzeń, niż w logice intuicjonistycznej. To co zabieramy to
    zazwyczaj spójniki logiczne lub jakieś aspekty ich działania. I
    tak możemy mieć logikę z samą implikacją albo logikę, w której
    są wszystkie spójniki, ale nie zachodzi <i>ex falso quodlibet</i>
    (czyli nie jest prawdą, że z fałszu wynika wszystko).

<div class="paragraph"> </div>

    Logiki subintuicjonistyczne są głupie (bo po co się ograniczać?),
    więc nie będziemy się nimi zajmować. Zresztą już je trochę znasz.
    Spróbuj przypomnieć sobie jakieś twierdzenie, które udowodniłeś,
    a w którym nie było np. koniunkcji - jest to twierdzenie w
    subintuicjonistycznej logice bez koniunkcji. Jeżeli w jakimś
    dowodzie nie użyłeś <i>ex falso</i> (ani wprost, ani pośrednio, np.
    przez użycie lematu, którego dowód używał <i>ex falso</i>) to znaczy,
    że to twierdzenie zachodzi w subintuicjonistycznej logice bez
    <i>ex falso</i>... widzisz do czego to zmierza, prawda?

<div class="paragraph"> </div>

    Logiki z drugiego przypadku to logiki superintuicjonistyczne (po
    łacinie "super" znaczy "powyżej"), bo można w nich udowodnić
    więcej twierdzeń, niż w logice intuicjonistycznej. To co dodajemy
    to zazwyczaj aksjomaty. Wesołym przykładem superintuicjonistycznej
    logiki jest logika sprzeczna - jest to logika, w której aksjomatem
    jest fałsz. Można w niej udowodnić wszystko, a więc istotnie więcej,
    niż w zwykłej logice konstruktywnej.

<div class="paragraph"> </div>

    Znanym ci już przykładem superintuicjonistycznej logiki jest logika
    klasyczna, która powstaje z dodania do logiki konstruktywnej jako
    aksjomatu prawa wyłączonego środka (albo jakiegoś jego zamiennika).
    Logika klasyczna jest
    maksymalną logiką superintuicjonistyczną, bo można w niej udowodnić
    najwięcej twierdzeń ze wszystkich logik superintuicjonistycznych
    (oczywiście pomijając logikę sprzeczną). Oznacza to, że dodanie do
    logiki klasycznej jako aksjomatu jakiegoś zdania, którego nie można
    w niej udowodnić, daje w efekcie logikę sprzeczną.

<div class="paragraph"> </div>

    Ponieważ logika intuicjonistyczna jest naszym punktem wyjściowym
    (jest "najsłabsza"), a logika klasyczna docelowym (maksimum pod
    względem liczby twierdzeń, które można udowodnić), wszystkie
    logiki będące pomiędzy tymi dwoma nazywa się często logikami
    pośrednimi.

<div class="paragraph"> </div>

    Ciekawym przykładem logiki pośredniej, który poznamy, jest logika
    de Morgana (a przynajmniej ja ją tak nazwałem - nie wiem, jak zwie
    się ona w poważnej literaturze). Powstaje ona poprzez dorzucenie
    do logiki konstruktywnej dodatkowego aksjomatu, którym jest prawo
    de Morgana.

<div class="paragraph"> </div>

    Oczywiście świat jest nieco skomplikowańszy niż go przedstawiłem.
    Jakiś zwichrowany umysł mógłby bez problemu wymyślić sobie logikę
    subsuperintuicjonistyczną. Wystarczy z logiki konstruktywnej zabrać
    np. koniunkcję, a dodać np. prawo wyłączonego środka. Nie muszę
    chyba nadmieniać, że tego typu zabawy przypominają budowę potwora
    Frankensteina, co? 
<div class="paragraph"> </div>

<a id="lab235"></a><h2 class="section">Logiki modalne</h2>

<div class="paragraph"> </div>

 Logiki modalne to logiki, w których oprócz znanych nam już spójników
    czy kwantyfikatorów występują też modalności. Czym jest modalność?
    Najpierw trochę etymologii.

<div class="paragraph"> </div>

    Łacińskie słowo "modus" oznacza "sposób". Występuje ono w takich
    wyrażeniach jak "modus operandi" ("sposób działania") czy "modus
    vivendi" ("sposób życia"; po dzisiejszemu powiedzielibyśmy "styl
    życia", a amerykańce - "way of life" albo "lifestyle"). Od niego
    w średniowiecznej
    łacinie powstał przymiotnik "modalis", który oznacza "dotyczący
    sposobu". Przymiotnik ten przedostał się do języków narodowych,
    dając polskie "modalny" czy angielskie "modal", od których potem
    utworzono rzeczowniki (pol. "modalność", ang. "modality") znaczące
    mniej więcej to samo, co oryginalne łacińskie "modus" - "sposób".
    Historia słów bywa pokręcona...

<div class="paragraph"> </div>

    W językach naturalnych modalności często występują pod postacią
    czasowników zwanych na ich cześć modalnymi, takich jak "móc" czy
    "musieć" - o ile nie mieszkasz pod kamieniem na pustyni, to pewnie
    spotkałeś się z nimi ucząc się języków obcych. Jednak nas bardziej
    będzie interesować inna forma, pod którą modalności występują, a są
    nią przysłówki. Porównajmy poniższe zdania:
<ul class="doclist">
<li> Pada deszcz.

</li>
<li> Być może pada deszcz.

</li>
<li> Na pewno pada deszcz.

</li>
</ul>

<div class="paragraph"> </div>

    Wszystkie mówią o tym samym zjawisku, czyli deszczu, ale robią to
    w różny sposób (i ten sposób to właśnie modalność!) - pierwszy
    sposób jest neutralny, drugi wyraża niepewność (czyli możliwość),
    a trzeci pewność (czyli konieczność).

<div class="paragraph"> </div>

    Najpopularniejsze logiki modalne skupiają się na próbie formalizacji
    właśnie tych dwóch sposobów - możliwości i konieczności. Rozważa się
    różne reguły i/lub aksjomaty, np. "jeśli P zachodzi, to jest możliwe"
    czy "jeżeli P jest konieczne, to zachodzi" oraz próbuje sformalizować
    znaczenie zdań modalnych za pomocą tworu zwanego "możliwymi światami"
    (ang. possible worlds). Idea jest taka, że światów jest bardzo wiele
    i zwykłe zdania mówią o naszym świecie, a zdania modalne o światach
    innych niż nasz. Coś jest możliwe, gdy zachodzi w jednym ze światów,
    zaś konieczne, jeżeli zachodzi we wszystkich światach.

<div class="paragraph"> </div>

    Modalności z powyższej logiki (możliwość i konieczność) nazywane
    bywają aletycznymi (od greckiego "ἀλήθεια" / "aletheia" - "prawda"),
    gdyż modyfikują prawdziwość zdań. Inne warianty logiki modalnej to:
<ul class="doclist">
<li> logika deontyczna (od gr. "δέον" / "déon" - "to co jest wiążące"),
      w której występują takie modalności jak "trzeba", "należy", "wolno",
      "nie wolno", "powinno się", "wypadałoby" etc.

</li>
<li> logika epistemiczna (od gr. "ἐπιστήμη" / "epistēmē" - "wiedza"),
      w której modalności reprezentują stan wiedzy różnych osób

</li>
<li> logika doksastyczna (od gr. "δόξα" / "dόxa" - "wiara", "opinia"),
      w której modalności reprezentują, w jakie zdania wierzą osoby

</li>
</ul>

<div class="paragraph"> </div>

    Jak nietrudno domyślić się po dużej liczbie greckich słów, które
    się nagle pojawiły, wszystkie powyższe logiki modalne mają raczej
    charakter filozoficzny, co sprawia, że z punktu widzenia zarówno
    matematyki jak i informatyki są zupełnie bezużyteczne. Szczególnie
    bolesne jest to, że każdy z powyższych wariantów logiki modalnej
    sam ma ogrom wariantów, gdyż filozofowie za cholerę nie mogą się
    zgodzić co do tego, czym tak naprawdę jest możliwość, konieczność,
    wiedza, wiara, etc. To powoduje, że wszystkie te logiki są mocno
    niejasne. Z tego powodu nie będziemy się nimi zajmować.

<div class="paragraph"> </div>

    Na szczęście nie wszystkie logiki modalne są mętne. Dość ciekawą
    logiką modalną jest logika dowodliwości (ang. provability logic),
    w której występuje operator modalny oznaczający "da się udowodnić,
    że...".

<div class="paragraph"> </div>

    Wróćmy po raz kolejny do prawa wyłączonego środka. W Coqu nie
    umiemy udowodnić, że <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, ale czy to
    znaczy, że zdanie to jest fałszywe? Gdyby spróbować udowodnić
    <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, to okaże się, że... też raczej
    nie potrafimy, ale czy to znaczy, że prawo wyłączonego środka
    jest prawdziwe?

<div class="paragraph"> </div>

    Widzimy więc, że prawo wyłączonego środka jest niejako zawieszone
    w próżni: nie umiemy go udowodnić ani obalić. Jak fakt ten wpływa
    na jego prawdziwość? Możemy przyjąć prawo wyłączonego środka jako
    aksjomat, ale możemy też jako aksjomat przyjąć jego zaprzeczenie.
    Oba te aksjomaty po dodaniu do Coqowej logiki nie doprowadzą nas
    do sprzeczności... ale czy na pewno? Skąd niby wiesz, że cię nie
    okłamałem? Czy to, że po dodaniu aksjomatu nie natrafiliśmy na
    żadną sprzeczność znaczy, że nie da się na nią natrafić?

<div class="paragraph"> </div>

    Jak widzisz, pytania te są dość mocno pogmatwane, a co gorsza,
    nie możemy użyć Coqa, żeby upewnić się, że nasze odpowiedzi na
    nie są poprawne. Cobyś nie czuł nadmiarowego niepokoju, zapewnię
    cię tylko, że aksjomat wyłączonego środka faktycznie może zostać
    dodany do Coqa bez popadania w sprzeczność. Jednak żeby być tego
    faktu pewnym, paru kolesi, znacznie mądrzejszych od nas, musiało
    zakasać rękawy, kupić 100 kilo kredy i parę ryz papieru, i ostro
    się napracować, nie mając tej błogiej pewności, że poprawny dowód
    zaświeci się na zielono.

<div class="paragraph"> </div>

    Logika dowodliwości to logika, która teoretycznie próbuje zaradzić
    tego typu sytuacjom i dlatego jest intrygująca... ale ponieważ nas
    bardziej interesuje praktyczne dowodzenie poprawności programów (w
    przyszłych rozdziałach, kiedy już nauczymy się programować), a nie
    zamartwianie się aksjomatami, to logika dowodliwości jest dla nas
    zupełnie bezużyteczna i z tego powodu nie będziemy się nią zajmować.

<div class="paragraph"> </div>

    Ostatnią rodziną logik modalnych wartych wspomnienia są logiki
    temporalne (z łac. "tempus" - "czas"). Występują tam modalności
    wyrażające czas, np. "teraz", "zawsze w przeszłości", "zawsze w
    przyszłości", "kiedyś w przeszłości", "kiedyś w przyszłości" i
    tak dalej.

<div class="paragraph"> </div>

    Napisałem "logiki temporalne" w liczbie mnogiej, bo jest ich wiele,
    a główne różnice dotyczą struktury czasu, która jest wyrażana przez
    prawa rządzące modalnościami, jak np. te dwa:
<ul class="doclist">
<li> "jeżeli P zachodzi, to w przyszłości zawsze będzie prawdą, że P
      zaszło kiedyś w przeszłości" - brzmi całkiem rozsądnie

</li>
<li> "jeżeli P zachodzi, to w przeszłości zawsze było prawdą, że P
      zajdzie kiedyś w przyszłości" - brzmi mega deterministycznie i
      niektórzy mogą się przeciw niemu zbuntować.

</li>
</ul>

<div class="paragraph"> </div>

    Tego typu filozoficzne dywagacje prowadzą nas do pytania o naturę
    czasu: czy czas jest liniowy (istnieje jedna możliwa przyszłość,
    czyli świat jest zdeterminowany), czy raczej rozgałęziony (jest
    wiele możliwych przyszłości, czyli świat nie jest zdeterminowany),
    co w praktyce oznacza kolejne wcielenie idei możliwych światów.

<div class="paragraph"> </div>

    Mimo filozoficznego smrodku, który dobywa się z powyższego opisu,
    niektóre logiki temporalne są całkiem użyteczne i to do czegoś,
    na czym i nam zależy: weryfikacji poprawności programów (a także
    sprzętu, ale o tym ja sam nic nie wiem). Idea jest taka, że możemy robić
    zdania wyrażające różne pożądane właściwości programów, na przykład:
<ul class="doclist">
<li> bezpieczeństwo (and. safety) - program NIGDY nie zrobi niczego złego

</li>
<li> żywotność (ang. liveness) - na każde żądanie serwer KIEDYŚ udzieli odpowiedzi

</li>
</ul>

<div class="paragraph"> </div>

    Mimo tego powiewu przydatności, nie będzie zajmować się logikami
    temporalnymi, ponieważ ich podejście do weryfikacji poprawności
    programów jest diametralnie różne i niekompatybilne z naszym.

<div class="paragraph"> </div>

    Na koniec krótka przestroga. Przeczytawszy niniejszy podrozdział
    mógłbyś dojść do wniosku, że logiki modalne są bezużyteczne, ale
    wcale tak nie jest. Modalności to nie tylko możliwość, czas albo
    wiedza, których w Coqowej logice brak. Modalności stanowią także
    bardzo ogólny i elegancki sposób patrzenia na rzeczy dobrze nam
    znane, jak logika klasyczna czy podwójna negacja. 
<div class="paragraph"> </div>

<a id="lab236"></a><h2 class="section">Paradoks pieniądza i kebaba (TODO)</h2>

<div class="paragraph"> </div>

 Przestrzegłem cię już przed nieopatrznym interpretowaniem zdań języka
    naturalnego za pomocą zdań logiki formalnej. Gdybyś jednak wciąż
    był skłonny to robić, przyjrzyjmy się kolejnemu "paradoksowi". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">copy</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> /\ <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe niewinnie wyglądające twierdzenie mówi nam, że <span class="inlinecode"><span class="id" title="var">P</span></span> implikuje
    <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span>. Spróbujmy przerobić je na paradoks, wymyślając jakąś wesołą
    interpretację dla <span class="inlinecode"><span class="id" title="var">P</span></span>.

<div class="paragraph"> </div>

    Niech zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> znaczy "mam złotówkę". Wtedy powyższe twierdzenie mówi,
    że jeżeli mam złotówkę, to mam dwa złote. Widać, że jeżeli jedną z tych
    dwóch złotówek znów wrzucimy do twierdzenia, to będziemy mieli już trzy
    złote. Tak więc jeżeli mam złotówkę, to mam dowolną ilość pieniędzy.

<div class="paragraph"> </div>

    Dla jeszcze lepszego efektu powiedzmy, że za 10 złotych możemy kupić
    kebaba. W ostatecznej formie nasze twierdzenie brzmi więc: jeżeli mam
    złotówkę, to mogę kupić nieograniczoną ilość kebabów.

<div class="paragraph"> </div>

    Jak widać, logika formalna (przynajmniej w takiej postaci, w jakiej ją
    poznajemy) nie nadaje się do rozumowania na temat zasobów. Zasobów, bo
    tym właśnie są pieniądze i kebaby. Zasoby to byty, które można
    przetwarzać, przemieszczać i zużywać, ale nie można ich kopiować i
    tworzyć z niczego. Powyższe twierdzenie dobitnie pokazuje, że zdania
    logiczne nie mają nic wspólnego z zasobami, gdyż ich dowody mogą być
    bez ograniczeń kopiowane. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab237"></a><h4 class="section">Ćwiczenie (formalizacja paradoksu)</h4>

<div class="paragraph"> </div>

 UWAGA TODO: to ćwiczenie wymaga znajomości rozdziału 2, w szczególności
    indukcji i rekursji na liczbach naturalnych.

<div class="paragraph"> </div>

    Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">andn</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, taką, że <span class="inlinecode"><span class="id" title="var">andn</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
    to n-krotna koniunkcja zdania <span class="inlinecode"><span class="id" title="var">P</span></span>, np. <span class="inlinecode"><span class="id" title="var">andn</span></span> <span class="inlinecode">5</span> <span class="inlinecode"><span class="id" title="var">P</span></span> to
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Następnie pokaż, że <span class="inlinecode"><span class="id" title="var">P</span></span> implikuje <span class="inlinecode"><span class="id" title="var">andn</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
    dla dowolnego <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Na końcu sformalizuj resztę paradoksu, tzn. zapisz jakoś, co to znaczy
    mieć złotówkę i że za 10 złotych można kupić kebaba. Wywnioskuj stąd,
    że mając złotówkę, możemy kupić dowolną liczbę kebabów.

<div class="paragraph"> </div>

    Szach mat, Turcjo bankrutuj! 
<div class="paragraph"> </div>

<a id="lab238"></a><h2 class="section">Logiki substrukturalne - kwantowa teoria relewantnego hajsu</h2>

<div class="paragraph"> </div>

 W jednym z poprzednich podrozdziałów dowiedzieliśmy się, że łatwym
    sposobem na uzyskanie nowej logiki jest wziąć logikę konstruktywną
    i coś z niej wyrzucić (spójniki lub ich aspekty, jak np. <i>ex falso
    quodlibet</i>). Tak powstałe logiki nazywaliśmy subintuicjonistycznymi.

<div class="paragraph"> </div>

    Logiki substrukturalne opierają się na podobnym pomyśle: weź
    logikę konstruktywną i coś z niej wyrzuć. O ile jednak większość
    logik subintuicjonistycznych jest mało ciekawa, a wyrzucanie ma
    na celu jedynie upozorowanie uzyskania nowej logiki, o tyle w
    przypadku logik substrukturalnych jest inaczej. Dzieje się tak,
    gdyż tym, co wyrzucamy, są reguły strukturalne. Stąd też nazwa:
    logiki substrukturalne.

<div class="paragraph"> </div>

    Czym są reguły strukturalne? Sa to reguły, które mówią, jakie
    operacje wolno wykonywać na hipotezach, które mamy w kontekście:
<ul class="doclist">
<li> reguła zamiany (ang. exchange) pozwala zamieniać hipotezy
      miejscami

</li>
<li> reguła kontrakcji (ang. contraction) pozwala kopiować hipotezy

</li>
<li> reguła osłabiania (ang. weakening) pozwala kasować hipotezy

</li>
</ul>

<div class="paragraph"> </div>

    W Coqu objawiają się one tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">structural_rules_test</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">R</span>) -&gt; (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">R</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">H</span> <span class="id" title="var">q</span> <span class="id" title="var">p</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reguła&nbsp;zamiany&nbsp;-&nbsp;zamieniamy&nbsp;<span class="inlinecode"><span class="id" title="var">p</span></span>&nbsp;i&nbsp;<span class="inlinecode"><span class="id" title="var">q</span></span>&nbsp;miejscami&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">move</span> <span class="id" title="var">p</span> <span class="id" title="keyword">after</span> <span class="id" title="var">q</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reguła&nbsp;kontrakcji&nbsp;-&nbsp;kopiujemy&nbsp;<span class="inlinecode"><span class="id" title="var">p</span></span>&nbsp;i&nbsp;nazywamy&nbsp;kopię&nbsp;<span class="inlinecode"><span class="id" title="var">p'</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> <span class="id" title="var">p'</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reguła&nbsp;osłabiania&nbsp;-&nbsp;kasujemy&nbsp;<span class="inlinecode"><span class="id" title="var">p'</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">p'</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Zauważ,&nbsp;że&nbsp;nie&nbsp;trzeba&nbsp;tych&nbsp;reguł&nbsp;używać explicite&nbsp;-<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taktyki&nbsp;same&nbsp;potrafią znajdować hipotezy&nbsp;w&nbsp;kontekście.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">q</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jako, że kontekst jest rzeczą absolutnie podstawową przy dowodzeniu
    czegokolwiek, (nie)obecność tych reguł ma absolutnie kluczowy wpływ
    na to, co da się w danej logice udowodnić, a w związku z tym także
    na to, jak możemy daną logikę interpretować.

<div class="paragraph"> </div>

    Jeżeli zastanawiasz się, dlaczego nie spotkaliśmy się dotychczas z
    tymi regułami, skoro są one tak ważne, to powód tego jest prosty:
    ręczne ich używanie byłoby upierdliwe, więc są one wbudowane w
    działanie Coqowych kontekstów oraz taktyk i z tego powodu zazwyczaj
    są zupełnie niewidzialne. Nie musimy zamieniać hipotez miejscami, bo
    taktyki <span class="inlinecode"><span class="id" title="tactic">exact</span></span> czy <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> same potrafią znaleźć odpowiednią
    hipotezę. Dzięki temu dowodzenie jest bardzo wygodne.

<div class="paragraph"> </div>

    Dobra, czas najwyższy poznać poszczególne logiki substrukturalne i
    dowiedzieć się, do czego można ich użyć. Na dobry początek rzućmy
    okiem na poniższe twierdzenia: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">yes_deleting</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">True</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">yes_cloning</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> /\ <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Ich nazwy mają z założenia przywodzić na myśl twierdzenia znane
    z kwantowej teorii informacji:
<ul class="doclist">
<li> twierdzenie o nieusuwaniu (ang. no-deleting theorem)

</li>
<li> twierdzenie o nieklonowaniu (ang. no-cloning theorem).

</li>
</ul>

<div class="paragraph"> </div>

    Twierdzenia te w uproszczeniu (sorry, nie jestem fizykiem) mówią,
    że kwantowa informacja nie może ot tak sobie pojawiać się i znikać
    (w przeciwieństwie do pewnego polskiego rapera).
    Bardziej poetycko można powiedzieć, że zachodzi prawo
    zachowania kwantowej informacji. Ponieważ w Coqu udało nam się
    bez problemu udowodnić przeczące im twierdzenia o usuwaniu
    (<span class="inlinecode"><span class="id" title="var">yes_deleting</span></span>) oraz klonowaniu (<span class="inlinecode"><span class="id" title="var">yes_cloning</span></span>), Coqowa logika
    nie nadaje się do rozumowania na temat kwantowej teorii informacji.

<div class="paragraph"> </div>

    Nadaje się za to do tego logika zwana liniową, czyli taka, w której
    nie ma reguły osłabiania ani reguły kontrakcji. W logice tej musimy
    dokładnie jeden raz użyć każdej hipotezy, którą mamy w kontekście.
    Hipotezy w logice liniowej mogą płynąć przez nasz dowód w dowolnej
    kolejności, ale nie mogą pojawiać się ani znikać, niczym kwantowa
    informacja. To sprawia, że logika liniowa jest dobrym kandydatem
    na logikę kwantową.

<div class="paragraph"> </div>

    Ale zejdźmy na ziemię - można tutaj znaleźć wystarczająco dużo
    rzeczy, których nie ima się zwyczajna logika, jak na przykład
    wungiel. Wungiel jest znacznie bardziej podobny do kwantowej
    informacji niż do zdań znanych z logiki konstruktywnej czy
    klasycznej:
<ul class="doclist">
<li> Elektrownia może wungiel spalić (wywołując tym sposobem globalne
      ocieplenie... albo i nie - zależy w co kto wierzy), ale nie może
      go skasować tak, żeby zniknął ze wszechświata bez śladu.

</li>
<li> Podobnie górnik może wungiel wykopać z ziemii, ale nijak nie
      może go skopiować, tak żeby za darmo uzyskać więcej.

</li>
</ul>

<div class="paragraph"> </div>

    A więc logika liniowa to nie tylko logika kwantowej informacji, ale
    także logika wungla i w ogólności logika zasobów. Jej zdania możemy
    interpretować jako zasoby (np. <span class="inlinecode"><span class="id" title="var">P</span></span> może oznaczać 5 kilo wungla, a
    <span class="inlinecode"><span class="id" title="var">Q</span></span> - ilość energii potrzebną do zasilania twojego komputera przez
    godzinę), zaś spójniki możemy interpretować jako operacje na tych
    zasobach, np. liniową implikację <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> można interpretować jako
    "z 5 kilo wungla da się  wyprodukować tyle energii, żeby zasilić
    twój komputer przez godzinę". Dowody w logice liniowej oznaczają
    w takim wypadku sposoby na przekształcenie zasobów reprezentowanych
    przez hipotezy w zasoby reprezentowane przez konkluzję.

<div class="paragraph"> </div>

    Z deczka odmienne spojrzenie na zasoby ma logika afiniczna: jest
    to logika substrukturalna, w której są reguły zamiany i osłabiania,
    ale nie ma reguły kontrakcji. Parafrazując: logika afiniczna wymusza
    użycie każdej hipotezy znajdującej się w kontekście co najwyżej raz.

<div class="paragraph"> </div>

    Rodzajem zasobów, o których można rozumować za pomocą tej logiki,
    są na przykład pieniądze (pomijając kwestie związane z fałszowaniem):
    jeżeli masz banknot o nominale 100 zł, nie możesz go skopiować żeby
    uzyskać 200 zł, ale możesz go zniszczyć (np. pociąć), żeby uzyskać
    0 zł.

<div class="paragraph"> </div>

    Jednak rodzajem zasobów, do rozumowania o których logika afiniczna
    nadaje się najlepiej, są zasoby abstrakcyjne, takie jak uchwyty do
    plików czy połączenia z bazą danych. Pisząc program możemy chcieć
    otworzyć plik lub nie (co najwyżej jedno użycie uchwytu), ale jak
    ognia unikać chcemy sytuacji, kiedy dwa programy na raz otworzą
    ten sam plik i zaczną coś do niego zapisywać, niwecząc nawzajem
    swoje starania (dwa użycia uchwytu). Logika afiniczna pozwala łatwo
    rozumować o tego typu sytuacjach i dlatego jest ona raczej domeną
    informatyków niż fizyków kwantowych czy filozofów.

<div class="paragraph"> </div>

    Podobną logiką substrukturalną, która tym razem najbliższa jest
    sercu filozofów, jest logika relewantna (słowo "relewantny" znaczy
    mniej więcej "istotny" albo "związany z czymś") . To logika, która
    ma reguły zamiany i kontrakcji, ale brak reguły osłabiania. W efekcie
    każdej hipotezy znajdującej się w kontekście musimy użyć co najmniej
    raz. Filozofowie (przynajmniej niektórzy) kochają tę logikę, gdyż to
    ograniczenie sprawia, że przesłanki implikacji muszą być powiązane z
    konkluzją (czyli właśnie relewantne).

<div class="paragraph"> </div>

    Typowym przykładem implikacji z irrelewantną przesłanką jest zdanie
    w stylu "jeżeli księżyc jest zrobiony z sera, to 2 + 2 = 4". Zdanie
    to jest prawdziwe w logice konstruktywnej i klasycznej, gdyż jego
    konkluzja, <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">4</span>, jest słuszna (jak w Coqu działają liczby,
    dowiemy się już niedługo!). Jednak tego typu implikacje
    są mocno nieintuicyjne i często sprawiają problem niematematycznym
    osobom, a także studentom pierwszego roku i co po niektórym filozofom
    właśnie.

<div class="paragraph"> </div>

    Powód tego jest prosty: co ma piernik do wiatraka? W języku polskim
    (i każdym innym) mowiąc "jeżeli ..., to ..." zazwyczaj mamy na myśli
    jakiś rodzaj związku przyczynowo-skutkowego ("jeżeli pada deszcz to
    jest mokro"), którego w powyższym zdaniu z serowym księżycem brakuje.
    Z tego powodu laikom wydaje się ono nienaturalne i mylą się oni w
    ocenie jego matematycznej słuszności. Logika relewantna rozwiązuje
    problem, który filozofowie mają z takimi zdaniami, gdyż nie można
    ich w tej logice udowodnić: każdej hipotezy musimy użyć co najmniej
    raz, ale ponieważ hipoteza "księżyc jest zrobiony z sera" nie została
    użyta, dowód implikacji nie przechodzi.

<div class="paragraph"> </div>

    Czy to już wszystkie logiki substrukturalne? Niezupełnie: unikalną
    logikę substrukturalną daje każda kombinacja reguł strukturalnych
    (poza sytuacją, gdy mamy wszystkie - wtedy logika jest "normalna",
    czyli po prostu strukturalna). Niektóre kombinacje reguł nie są
    jednak zbyt popularne - wszystkie omówione wyżej logiki miały regułę
    zamiany. Wynika to z faktu, że brak tej reguły jest naprawdę srogo
    upierdliwy, a pozostałe reguły mają w przypadku jej nieobecności dużo
    mniejszą moc i znaczenie.

<div class="paragraph"> </div>

    Mimo to nic nie stoi na przeszkodzie, by rozważać logiki bez żadnych
    reguł strukturalnych. W logikach takich jesteśmy zmuszeni użyć
    wszystkich hipotez z kontekstu dokładnie raz w kolejności, w której
    je wprowadzono. Mogłoby się wydawać, że w tak ograniczonej logice
    nie da się udowodnić niczego ciekawego. Dla przykładu, zastosowanie
    reguły modus ponens może być niemożliwe, jeżeli hipotezy są ułożone
    w kontekście w niesprzyjającej kolejności.

<div class="paragraph"> </div>

    Tego typu rozważania prowadzą jednak do konkluzji: jeżeli nasza
    implikacja ma przesłanki nie po kolei, to... wprowadźmy drugą
    implikację, która bierze przesłanki w odwrotnej kolejności. To
    rozwiązanie może się wydawać dziwne (i jest!), ale okazuje się,
    że co najmniej jeden człowiek próbował takiej poczwarnej logiki
    użyć do reprezentowania języka naturalnego, i to z niemałym sukcesem.

<div class="paragraph"> </div>

    Zresztą, język naturalny ze swoimi ograniczeniami na szyk zdania
    i kolejność słów zdaje się być dobrym kandydatem do spożytkowania
    takiej logiki: zdanie "otworzyłem drzwi i wszedłem do środka"
    wygląda całkiem normalnie, ale "wszedłem do środka i otworzyłem
    drzwi" jest już nieco podejrzane. Może to sugerować, że w języku
    naturalnym koniunkcja (czyli "i") nie jest przemienna, a zatem
    pozbycie się reguły zamiany (co uniemożliwia udowodnienie prawa
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">&lt;-&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span>) sprawia, że <span class="inlinecode">/\</span> lepiej wyraża znaczenie "i".

<div class="paragraph"> </div>

    Jednak dużo ważniejsza od całej tej powyższej logiki była uwaga
    o wprowadzeniu dodatkowej implikacji. Odkrywanie dodatkowych
    spójników, które potrafią wyrażać rzeczy niemożliwe do wyrażenia
    w logice konstruktywnej, albo rozkładają znaczenia spójników tej
    logiki na kawałki, jest jednym z głównych powodów zainteresowania
    logikami substrukturalnymi.

<div class="paragraph"> </div>

    Dla przykładu, określenie "logika liniowa", którego użyłem wcześniej
    jako nazwy logiki bez reguł kontrakcji i osłabiania, w poważnej
    literaturze oznacza wprawdzie logikę bez tych reguł, ale mającą też
    parę dodatkowych spójników. Pojawia się między innymi jednoargumentowy
    spójnik <span class="inlinecode">!</span> (wykrzyknik), który wyraża kopiowanie: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> oznacza
    "wungiel", to <span class="inlinecode">!<span class="id" title="var">A</span></span> oznacza "dowolna ilość wungla". Dzięki niemu można
    w logice liniowej rozumować nie tylko o zasobach (albo kwantowej
    informacji, co kto lubi), ale także przeprowadzać rozumowania znane
    z logiki konstruktywnej - wystarczy w odpowiednie miejsca powstawiać
    wykrzykniki. Daje nam to nowy obraz konstruktywnych spójników jako
    połączenia operacji na zasobach oraz operacji kopiowania zasobów w
    nieskończoność.

<div class="paragraph"> </div>

    Podsumowując, logiki substrukturalne bywają użyteczne w całej
    gamie różnych zastosowań, od fizyki kwantowej, przez filozofię
    i lingwistykę, a na informatyce teoretycznej kończąc. W tej
    książce nie będziemy się jednak nimi zajmować, gdyż nie ma do
    tego wystarczających możliwości technicznych: logika Coqa jest
    z gruntu strukturalna i nic nie możemy na to poradzić (badania
    nad połączeniem języków pokroju Coqa z logiką substrukturalną
    trwają, ale nie przyniosły jeszcze zadowalających rezultatów).

<div class="paragraph"> </div>

    Na samiuśki koniec koło ratunkowe: jeżeli pogubiłeś się w tych
    wszystkich nazwach, regułach, warunkach, etc., to tutaj jest
    <a class='link'
        href='https://github.com/wkolowski/Typonomikon/blob/master/txt/ściągi/substrukturalne.md'>
    ściąga</a>. 
<div class="paragraph"> </div>

<a id="lab239"></a><h2 class="section">Logiki wielowartościowe</h2>

<div class="paragraph"> </div>

 Innym sposobem klasyfikacji logik jest liczba wartości logicznych,
    które w nich występują. Ponieważ wartości logiczne nie występują
    we wszystkich logikach, a w szczególności nie ma ich w logice
    konstruktywnej, zacznijmy od wytłumaczenia, czym są.

<div class="paragraph"> </div>

    W skrócie: wartości logiczne mówią, jaki może być "status" danego
    zdania. Dwiema wartościami logicznymi, które występują praktycznie
    zawsze, są "prawda" i "fałsz". Odpowiadają one stwierdzeniom takim
    jak "zdanie P jest prawdziwe" oraz "zdanie P jest fałszywe".

<div class="paragraph"> </div>

    Najpopularniejszą logiką, którą można zaprezentować za pomocą
    wartości logicznych (i prawie zawsze się tak robi - my oczywiście
    jesteśmy wyjątkiem) jest logika klasyczna. Logika klasyczna to
    logika, w której każde zdanie jest albo prawdziwe, albo fałszywe
    i nie ma żadnych innych możliwości.

<div class="paragraph"> </div>

    Nie powinno cię to dziwić - jeżeli przyjrzeć się mu bliżej, to
    właśnie mówi aksjomat wyłączonego środka: dla każdego zdania
    albo mamy jego dowód (co odpowiada wartości logicznej "prawda"),
    albo mamy dowód jego zaprzeczenia (co odpowiada wartości logicznej
    "fałsz").

<div class="paragraph"> </div>

    Skoro już wiemy, czym są wartości logiczne, czas powiedzieć, czym
    są logiki wielowartościowe. Otóż są to logiki, w których są więcej
    niż dwie wartości logiczne. Zazwyczaj są to "prawda", "fałsz" i
    jakieś dodatkowe, np. "być może", "jednocześnie prawda i fałsz",
    "nie obchodzi mnie to nic a nic", "brak danych", "twoja stara", etc. -
    każdy może sobie wymyślić własną logikę z własną paletą wartości logicznych.

<div class="paragraph"> </div>

    Przykładem ciekawej logiki wielowartościowej jest logika sygnałów
    w obwodach elektronicznych, ustandaryzowana przez IEEE. Jest to
    logika czterowartościowa, w której są następujące wartości logiczne:
<ul class="doclist">
<li> 1, interpretowane jako "prawda"

</li>
<li> 0, interpretowane jako "fałsz"

</li>
<li> X, interpretowane jako "nieważne" - może zostać uznana za
      1 albo 0 w zależności od tego, co jest wygodniejsze w danej
      sytuacji (w praktyce wybiera się to, co daje szybsze obliczenia)

</li>
<li> Z, interpretowane jako "wysoka impedancja" - reprezentuje sytuację,
      w której prąd w obwodzie nie płynie tak jak powinien, czyli pewien
      rodzaj błędu

</li>
</ul>

<div class="paragraph"> </div>

    Przykładem nieciekawej logiki wielowartościowej jest logika rozmyta.
    Motywacją dla tej logiki są pytania w stylu "Czy koleś o wzroście
    180 cm jest wysoki?". Żeby móc na nie odpowiadać, jako wartości
    logiczne bierzemy liczby rzeczywiste z przedziału <span class="inlinecode">[0;</span> <span class="inlinecode">1]</span>, gdzie 0
    reprezentuje fałsz, 1 prawdę, a wszystkie inne liczby - pewne
    pośrednie stopnie pewności. I tak odpowiedzią na pytanie "Czy 180
    cm to wysoki wzrost?" może być np. 0.9, czyli raczej tak, ale nie
    do końca, zaś na pytanie "Czy 140 cm to wysoki wzrost?" odpowiedź
    może brzmieć 0.1, czyli raczej niski, ale przecież dzieci i karły
    są niższe.

<div class="paragraph"> </div>

    Powiązanym przykładem nieciekawej logiki jest logika probabilistyczna.
    Pomysł jest taki, że większość rzeczy w prawdziwym świecie jest dość
    niepewna, więc zamiast przypisywać zdaniom wartości logiczne w stylu
    "prawda" czy "fałsz", należy zastąpić je ocenami prawdopodobieństwa,
    czyli podobnie jak w logice rozmytej, liczbami z przedziału <span class="inlinecode">[0;</span> <span class="inlinecode">1]</span>.

<div class="paragraph"> </div>

    O ile teoria prawdopodobieństwa jest bardzo mądra i użyteczna, to
    dwie powyższe logiki (i wszelkie ich warianty) są zupełnie do dupy
    i bezużyteczne właśnie dlatego, że są próbami wsadzenia
    prawdopodobieństwa do logiki na siłę, czego efekt jest marny.

<div class="paragraph"> </div>

    Ogólnie logiki wielowartościowe nie są zbyt ciekawe ani przydatne,
    więc nie będziemy ich zgłębiać.

<div class="paragraph"> </div>

    Na koniec wypadałoby jeszcze wspomnieć w ramach ciekawostki, że
    wbrew temu, co napisałem na samym początku, logika konstruktywna
    również może być uznana za logikę wielowartościową, jednak bardzo
    nietypową: wartości logicznych jest nieskończenie wiele (a nawet
    nieprzeliczalnie wiele, czyli tyle co liczb rzeczywistych). Nie
    będziemy jednak drążyć tego tematu. 
<div class="paragraph"> </div>

<a id="lab240"></a><h2 class="section">Logika szalonego Gruzina</h2>

<div class="paragraph"> </div>

 Logika szalonego Gruzina, oficjalnie zwana logiką obliczeń
    (ang. Computability Logic, w skrócie CoL), jest szalenie
    ciekawa i właśnie dlatego się tutaj znalazła. Żeby jednak
    nie odciągać cię od jakże wartościowego zajęcia, jakim jest
    czytanie niniejszej książki, nie podam tu żadnych linków do
    źródeł na temat tej logiki.

<div class="paragraph"> </div>

    Czym jest CoL? Zdania w CoL reprezentują problemy obliczeniowe,
    (czyli zagadnienia w stylu "czy da się napisać program, który
    robi cośtam"), zaś dowody to rozwiązania tych problemów. Żeby
    było ciekawiej, problemy są interaktywne i przybierają formę
    gier, w której naprzeciw siebie staje dwóch graczy: maszyna
    (nasz faworyt) i środowisko (diabeł wcielony). Maszyna musi
    w tych grach posługiwać się strategiami obliczalnymi (czyli,
    krótko mówiąc, nie może brać swoich ruchów z sufitu), jednak
    środowisko już niekoniecznie. Skoro zdania to interaktywne gry,
    dowody zdań reprezentują strategie wygrywające w tych grach.

<div class="paragraph"> </div>

    Spójników logicznych jest tu cała masa i są naprawdę fikuśne,
    np. negacja zamienia graczy stronami. Jeżeli zdanie <span class="inlinecode"><span class="id" title="var">Chess</span></span>
    reprezentuje partię szachów gdzie maszyna gra białymi (lub,
    precyzyjniej pisząc, problem "czy istnieje niezawodny sposób
    na wygranie partii szachów białymi?"), to zdanie <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">Chess</span></span> to
    partia szachów, w której maszyna gra czarnymi (lub, precyzyjniej
    pisząc, problem "czy istnieje niezawodny sposób na wygranie partii
    szachów czarnymi?").

<div class="paragraph"> </div>

    Dalej mamy takie cuda jak równoległa koniunkcja i dysjunkcja
    gier, które polegają na tym, że toczą się na raz dwie gry i
    żeby wygrać, trzeba wygrać w obu (koniunkcja) lub co najmniej
    jednej z nich (dysjunkcja).

<div class="paragraph"> </div>

    Spójniki równoległe zachowują się tak jak spójniki w logice
    klasycznej, w szczególności zachodzi prawo wyłączonego środka.
    W ramach przykładu rozważmy zdanie <span class="inlinecode"><span class="id" title="var">Chess</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">Chess</span></span>. Jest to
    gra, która składa się z dwóch partii szachów rozgrywanych w tym
    samym czasie. W pierwszej partii maszyna gra białymi, a środowisko
    czarnymi, a w drugiej na odwrót. Wygrywa ten, kto wygra choć jedną
    partię.

<div class="paragraph"> </div>

    Istnieje bardzo prosta strategia, żeby wygrać <span class="inlinecode"><span class="id" title="var">Chess</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">Chess</span></span>:
    wystarczy w jednej z partii małpować ruchy, które przeciwnik robi
    w drugiej partii. Wtedy jedna gra jest przegrana a druga wygrana,
    czyli zwycięzcą całej równoległodysjunkcjowej gry jest maszyna.

<div class="paragraph"> </div>

    Są też spójniki wyborowe: wyborowa koniunkcja i wyborowa dysjunkcja.
    Polegają one na tym, że na początku są dwie gry i w pierwszym ruchu
    wybiera się, w którą grę będzie się grać (w przypadku dysjunkcji
    wybiera maszyna, w przypadku koniunkcji - środowisko). Tutaj prawo
    wyłączonego środka już nie zachodzi - jeżeli maszyna jest kiepska w
    szachy, to przegra niezależnie od tego, czy będzie grać białymi czy
    czarnymi. Spójniki wyborowe zachowują się tak, jak spójniki znane z
    logiki konstruktywnej.

<div class="paragraph"> </div>

    Wesoło, prawda? A to nie wszystko, bo rodzajów spójników jest co
    najmniej dwa razy więcej. Jakby tego było mało, spójniki uogólniają
    się potem na kwantyfikatory i dzięki temu mamy różne wesołe zdania,
    które reprezentują np. rozgrywanie nieskończenie wielu partii szachów
    na raz. Brzmi dobrze? Jasne, a jak jeszcze zauważysz, że nawet słowem
    nie zająknąłem się dotychczas o implikacji... oj, w logice szalonego
    Gruzina zabawy jest co nie miara. Na koniec dodam jeszcze tylko, że
    fragmentami CoL są nie tylko logika klasyczna (spójniki równoległe)
    oraz logika konstruktywna (spójniki wyborowe), ale też logika liniowa
    (jedna z tych opisanych w podrozdziale o logikach substrukturalnych)
    i jeszcze kilka innych, których nie ogarniają nawet najstarsi górale. 
<div class="paragraph"> </div>

<a id="lab241"></a><h1 class="section">Pluralizm logiczny</h1>

<div class="paragraph"> </div>

 Celem niniejszego rozdziału było zapoznanie się z logikami innymi
    niż nasza ulubiona i domyślna logika konstruktywna, tak na wypadek
    gdybyś się zastanawiał, czy są jakieś.

<div class="paragraph"> </div>

    Obraz, który się z niego wyłania, jest niesamowicie ciekawy oraz
    zaskakujący, gdyż mocno kontrastuje z tradycyjnym postrzeganiem
    i zwyczajem nauczania logiki:
<ul class="doclist">
<li> nie ma jednej logiki, lecz wiele (i to nieskończenie wiele)

</li>
<li> każda z wielu logik opisuje nieco inny świat, choć można też
      patrzeć na to w ten sposób, że każda logika opisuje nasz świat
      w nieco inny sposób

</li>
<li> logiki nie są równoprawne - najlepsza jest logika konstruktywna,
      najpopularniejsza wśród matematyków jest logika klasyczna, ale
      jest też cała (nieskończona) masa logik niewartych nawet splunięcia

</li>
<li> różne logiki nie są sobie wrogie, nieprzyjazne czy sprzeczne ze
      sobą, lecz harmonijnie współistnieją dzięki modalnościom, za pomocą
      których można je wyrażać

</li>
</ul>

<div class="paragraph"> </div>

    Powyższy pogląd możemy nazwać pluralizmem logicznym. Jego podstawowe
    wcielenie zostało wymyślone i nazwane przez filozofów i w związku z
    tym dotyczyło raczej logiki filozoficznej niż logiki matematycznej
    (a już na pewno nie miało nic wspólnego z informatyką). Niektórzy
    filozofowie wyznają go pewnie do dziś, inni zaś są jego zawziętymi
    przeciwnikami. Filozofowie jednak są mało ważni i nikt nie traktuje
    ich poważnie, więc to nie im należy zawdzięczać rozprzestrzenianie
    się tego poglądu.

<div class="paragraph"> </div>

    Nie należy go też zawdzięczać matematykom. Nie jest on wśród nich
    zbyt popularny, gdyż w zasadzie wszyscy matematycy są fanatykami
    logiki klasycznej. Nie żeby matematycy znali się na logice - co
    to, to nie. Typowy matematyk nie ma bladego pojęcia o logice.
    Matematycy po prostu robią swoje, a tym, co naturalnie im z tego
    wychodzi, jest logika klasyczna. Nawet matematycy zajmujący się
    stricte logiką (a może w szczególności oni) posługują się na codzień
    logiką klasyczną, a inne logiki są co najwyżej przedmiotem ich badań,
    niczym zwierzątka w cyrku, zoo czy na safari.

<div class="paragraph"> </div>

    Pragmatycznymi zwolennikami tego poglądu są z pewnością olbrzymie
    masy informatyków (teoretycznych, nie kolesi od podłączania kabli).
    W dziedzinie tej wymyślono tabuny przeróżnych logik, które służą
    do jakiegoś konkretnego celu, zazwyczaj do rozumowania o jednym
    rodzaju obiektów czy sytuacji. Dla przykładu, logika temporalna
    (z takimi operatorami jak "zawsze", "nigdy", "kiedyś" etc.) bywa
    używana w formalnej weryfikacji sprzętu... albo czegoś tam innego,
    nie wiem, nie znam się na tym.

<div class="paragraph"> </div>

    Poparcie dla pluralizmu logicznego jest w
    informatyce uniwersalne i nieświadome. Przyczyną tego jest fakt, że
    logiki są tu traktowane jak narzędzia - logika temporalna ma ten sam
    status co młotek lub wiertarka. Jeżeli ktoś powie ci, że twój młotek
    jest sprzeczny, a jego narzędzie jest najlepsze do wszystkiego, nie
    będziesz przecież traktował go poważnie, prawda? W ostateczności
    jednak, to również nie informatycy są powodem tego, że w tej właśnie
    chwili czytasz o pluralizmie logicznym.

<div class="paragraph"> </div>

    Prawdziwą przyczyną popularności tego poglądu jest bardzo wąski krąg,
    wręcz sekta, dziwacznych ezoteryków (do których i ja należę) żyjących
    gdzieś w otchłani pomiędzy matematyką i informatyką, a takżę trochę
    fizyką i filozofią. Ludzie ci nie mają jednej nazwy, a zajmują się
    wieloma dziedzinami - teorią typów, teorią kategorii, teorią języków
    programowania, podstawami matematyki (ang. foundations), matematyką
    konstruktywną, matematyką syntetyczną, etc. - mniejsza o to.

<div class="paragraph"> </div>

    Podstawowym filarem naszej
    wiary (nieopartym jednak na dogmatach, ani nawet na aksjomatach, lecz
    raczej na twierdzeniach i obserwacjach) jest pewna konstatacja: każdy
    rodzaj (abstrakcyjnych) obiektów ma swój własny język, w którym mówi
    się o nich najlepiej - można je łatwo opisywać, konstruować, a także
    dowodzić ich właściwości. Każdy rodzaj bytów to osobny abstrakcyjny
    świat, a każdy taki świat ma swój język.

<div class="paragraph"> </div>

    Ponieważ światów jest wiele,
    to i języków jest wiele. Ponieważ światy są ze sobą związane różnymi
    ciekawymi relacjami, języki również są powiązane. Niektóre obiekty
    są bardziej ogólne od innych, więc w niektórych językach można
    powiedzieć więcej, a w innych mniej. Niektóre obiekty są tak ogólne,
    że można ich użyć do reprezentowania wszystkich innych obiektów, a
    zatem niektóre języki mają status uniwersalny i umożliwiają
    powiedzenie wszystkiego.

<div class="paragraph"> </div>

    Logika konstruktywna oczywiście nie jest takim uniwersalnym językiem.
    Prawdę mówiąc, jest ona bardzo biedna i prymitywna, gdyż jest jedynie
    przejawem dużo potężniejszego języka, a mianowicie teorii typów, którą
    implementuje Coq. Naszym celem w tej książce (a szczególnie poczynając
    od następnego rozdziału) będzie dogłębnie poznać tę teorię i nauczyć
    się nią posługiwać. 
<div class="paragraph"> </div>

<a id="lab242"></a><h2 class="section">Pluralizm w praktyce: płytkie zanurzenie</h2>

<div class="paragraph"> </div>

 Tutaj nie wiem o czym, może o omówionej już logice modalnej? 
<div class="paragraph"> </div>

<a id="lab243"></a><h2 class="section">Pluralizm w praktyce: uniwersum <span class="inlinecode"><span class="id" title="var">SProp</span></span> i logika klasyczno-konstruktywna (TODO)</h2>

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;TODO:&nbsp;Tutaj&nbsp;można&nbsp;opisać&nbsp;świat,&nbsp;w&nbsp;którym&nbsp;<span class="inlinecode"><span class="id" title="var">SProp</span></span>&nbsp;ma&nbsp;logikę&nbsp;klasyczną,&nbsp;a<br/>
&nbsp;&nbsp;&nbsp;TODO:&nbsp;<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>&nbsp;konstruktywną.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a id="lab244"></a><h1 class="section">Zadania: logiki pośrednie (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab245"></a><h2 class="section">Logika słabego wyłączonego środka</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">WLEM</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WLEM_hard</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Irrefutable_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ ~ (~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">LEM_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">LEM</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">MI_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">MI</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ME_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">ME</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">DNE_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">DNE</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">CM_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">CM</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Peirce_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">Peirce</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Contra_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">Contra</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">LEM3</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">LEM3_WLEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">LEM3</span> -&gt; <span class="id" title="var">WLEM</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WLEM_LEM3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">WLEM</span> -&gt; <span class="id" title="var">LEM3</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">LEM_LEM3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">LEM</span> -&gt; <span class="id" title="var">LEM3</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab246"></a><h3 class="section">Logika zdań słabo określonych</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_True</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">True</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_False</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_impl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_or</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> \/ <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_and</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_iff</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> &lt;-&gt; <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_not</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">WeaklyDefinite</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">WeaklyDefinite</span> (~ <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_forall_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">WeaklyDefinite</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">WDP</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">right</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">np</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">np</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">WeaklyDefinite_exists_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">WeaklyDefinite</span> (<span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">WeaklyDefinite</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">WDP</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">right</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">np</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab247"></a><h2 class="section">Silna negacja koniunkcji i logika de Morgana</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nand'</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := ~ <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">Q</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nand_nand'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nand'</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">nand</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nand'_nand_classically</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">P</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nand</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">nand'</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nand'_nand_tabu</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">nand</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">nand'</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt;<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">P</span>).<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Irrefutable_deMorgan</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, ~ ~ (~ (<span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span>) -&gt; ~ <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">deMorgan_WLEM</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, ~ (<span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span>) -&gt; ~ <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">LEM_deMorgan_big</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">P</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(~ <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt; <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">deMorgan_big_WLEM</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(~ <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt; <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ <span class="id" title="var">P</span> \/ ~ ~ <span class="id" title="var">P</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab248"></a><h2 class="section">Inne mało ważne logiki pośrednie</h2>

<div class="paragraph"> </div>

<a id="lab249"></a><h3 class="section"><span class="inlinecode"><span class="id" title="var">IOR</span></span></h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">IOR</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> \/ <span class="id" title="var">R</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) \/ (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">R</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Irrefutable_IOR</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;~ ~ ((<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> \/ <span class="id" title="var">R</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) \/ (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">R</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IOR_LEM</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">LEM</span> -&gt; <span class="id" title="var">IOR</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab250"></a><h3 class="section">Logika zdań IORowych</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> \/ <span class="id" title="var">R</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) \/ (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">R</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_True</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">True</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_False</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_impl_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">IORable</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">I1</span> <span class="id" title="var">I2</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">qr</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_or_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">IORable</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> \/ <span class="id" title="var">Q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">I1</span> <span class="id" title="var">I2</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">qr</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_and_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">IORable</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">I1</span> <span class="id" title="var">I2</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">qr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">p1</span> <span class="id" title="var">p2</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">qr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">q</span> | <span class="id" title="var">r</span>]; [<span class="id" title="var">easy</span> | <span class="id" title="tactic">assumption</span> |].<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_iff</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">IORable</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> &lt;-&gt; <span class="id" title="var">Q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">I1</span> <span class="id" title="var">I2</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">qr</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_not</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">IORable</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">IORable</span> (~ <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">I</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">qr</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_forall_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">IORable</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">HD</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IORable_exists_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">IORable</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">IORable</span> (<span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IORable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">HD</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab251"></a><h3 class="section">Gödel-Dummet</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">GD</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) \/ (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Irrefutable_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, ~ ~ ((<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) \/ (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">LEM_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">LEM</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">MI_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">MI</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ME_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">ME</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">DNE_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">DNE</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">CM_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">CM</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Peirce_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">Peirce</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Contra_GD</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">Contra</span> -&gt; <span class="id" title="var">GD</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab252"></a><h1 class="section">Jakieś podsumowanie (TODO)</h1>

<div class="paragraph"> </div>

 Gratulacje! Udało ci się przebrnąć przez pierwszy (poważny) rozdział
    moich wypocin, czyli rozdział o logice. W nagrodę już nigdy nie
    będziesz musiał ręcznie walczyć ze spójnikami czy prawami logiki -
    zrobi to za ciebie taktyka <span class="inlinecode"><span class="id" title="tactic">firstorder</span></span>. Jak sama nazwa wskazuje,
    służy ona do radzenia sobie z czysto logicznymi dowodami w logice
    pierwszego rzędu (czyli w takiej, gdzie nie kwantyfikujemy po
    funkcjach albo tympodobnie skomplikowanych rzeczach).

<div class="paragraph"> </div>

    TODO: zrobić w Anki:
<ul class="doclist">
<li> test diagnostyczny tak/nie

</li>
<li> talię do nauki nazw praw

</li>
<li> talię do nauki tautologia/nietautologia

</li>
<li> talię do nauki pozytywny/negatywny

</li>
<li> inne przydatne talie 
</li>
</ul>

<div class="paragraph"> </div>

 Taktyka <span class="inlinecode"><span class="id" title="tactic">firstorder</span></span> dopiero na samym końcu! Podobnie <span class="inlinecode"><span class="id" title="tactic">tauto</span></span>. </div>
<div class="code">
</div>
