<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">BC1c: Podstawy programowania funkcyjnego [TODO]</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W poprzednim rozdziale dowiedzieliśmy się już co nieco o typach, a
    także spotkaliśmy kilka z nich oraz kilka sposobów tworzenia nowych
    typów ze starych (takich jak np. koniunkcja; pamiętaj, że zdania są
    typami). W tym rozdziale dowiemy się, jak definiować nowe typy przy
    pomocy indukcji oraz jak użyć rekursji do definiowania funkcji, które
    operują na tych typach. 
<div class="paragraph"> </div>

 W Coqu są trzy główne rodzaje typów: produkt zależny, typy induktywne
    i typy koinduktywne. Z pierwszym z nich już się zetknęliśmy, drugi
    poznamy w tym rozdziale, trzeci na razie pominiemy.

<div class="paragraph"> </div>

    Typ induktywny definiuje się przy pomocy zbioru konstruktorów, które
    służą, jak sama nazwa wskazuje, do budowania termów tego typu.
    Konstruktory te są funkcjami (być może zależnymi), których
    przeciwdziedziną jest definiowany typ, ale niczego nie
    obliczają — nadają jedynie termom ich "kształt". W szczególności, nie
    mają nic wspólnego z konstruktorami w takich językach jak C++ lub Java
    — nie mogą przetwarzać swoich argumentów, alokować pamięci, dokonywać
    operacji wejścia/wyjścia etc.

<div class="paragraph"> </div>

    Tym, co jest ważne w przypadku konstruktorów, jest ich ilość, nazwy
    oraz ilość i typy przyjmowanych argumentów. To te cztery rzeczy decydują
    o tym, jakie "kształty" będą miały termy danego typu, a więc i czym
    będzie sam typ. W ogolności każdy term jest skończonym, ukorzenionym
    drzewem, którego kształt zależy od charakterystyki konstruktorów tak:
<ul class="doclist">
<li> każdy konstruktor to inny rodzaj węzła (nazwa konstruktora to nazwa
      węzła)

</li>
<li> konstruktory nierekurencyjne to liście, a rekurencyjne — węzły
      wewnętrzne

</li>
<li> argumenty konstruktorów to dane przechowywane w danym węźle 
</li>
</ul>

<div class="paragraph"> </div>

 Typ induktywny można wyobrażać sobie jako przestrzeń zawierającą
    te i tylko te drzewa, które można zrobić przy pomocy jego
    konstruktorów. Nie przejmuj się, jeżeli opis ten wydaje ci się
    dziwny — sposób definiowania typów induktywnych i ich wartości
    w Coqu jest diametralnie różny od sposobu definiowania klas i
    obiektów w językach imperatywnych i wymaga przyzwyczajenia się
    do niego. Zobaczmy, jak powyższy opis ma się do konkretnych
    przykładów. 
<div class="paragraph"> </div>

<a id="lab112"></a><h1 class="section">Wstęp</h1>

<div class="paragraph"> </div>

<a id="lab113"></a><h2 class="section">Typy i typowanie statyczne (TODO)</h2>

<div class="paragraph"> </div>

 Tutaj historyjka o tym, że im bardziej statyczne jest typowanie, tym
    szybciej po popełnieniu błędu jesteśmy w stanie go wykryć. 
<div class="paragraph"> </div>

<a id="lab114"></a><h3 class="section">Typy vs testy</h3>

<div class="paragraph"> </div>

<a id="lab115"></a><h1 class="section">Typy, programy, zdania, dowody i specyfikacje (TODO)</h1>

<div class="paragraph"> </div>

 Tu zestawić ze sobą P : Prop, A : Type, p : P, x : A.

<div class="paragraph"> </div>

    Wytłumaczyć relację między typami, zdaniami, specyfikacjami
    programów, przestrzeniami, etc. 
<div class="paragraph"> </div>

<a id="lab116"></a><h2 class="section">Przydatne komendy</h2>

<div class="paragraph"> </div>

 Czas, aby opisać kilka przydatnych komend. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;unit&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, że komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> wyświetla typ danego jej termu,
    a <span class="inlinecode"><span class="id" title="keyword">Print</span></span> wypisuje jego definicję. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Search</span></span> wyświetla wszystkie obiekty, które zawierają podaną nazwę.
    W naszym przypadku pokazały się wszystkie funkcje, w których
    sygnaturze występuje typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span><span class="id" title="var">Pattern</span> (<span class="id" title="var">_</span> + <span class="id" title="var">_</span> = <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchPattern</span></span> jako argument bierze wzorzec i wyświetla wszystkie
    obiekty, które zawierają podterm pasujący do danego wzorca. W naszym
    przypadku pokazały się twierdzenia, w których występuje podterm
    mający po lewej dodawanie, a po prawej cokolwiek.

<div class="paragraph"> </div>

    Dokładny opis wszystkich komend znajdziesz
    <a class='link' href='https://coq.inria.fr/refman/coq-cmdindex.html'>tutaj</a>. 
<div class="paragraph"> </div>

<a id="lab117"></a><h1 class="section">Typy wbudowane (TODO)</h1>

<div class="paragraph"> </div>

 Tutaj będą opisane typy, która można spotkać w normalnych językach
    programowania, takie jak <span class="inlinecode"><span class="id" title="var">int</span></span> czy <span class="inlinecode"><span class="id" title="var">float</span></span>. 
<div class="paragraph"> </div>

<a id="lab118"></a><h1 class="section">Funkcje (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab119"></a><h1 class="section">Enumeracje (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Najprostszym rodzajem typów induktywnych są enumeracje, czyli typy,
    których wszystkie konstruktory są stałymi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">true</span> : <span class="id" title="var">bool</span><br/>
| <span class="id" title="var">false</span> : <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja typu induktywnego ma następującą postać: najpierw występuje
    słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, następnie nazwa typu, a po dwukropku sort
    (<span class="inlinecode"><span class="id" title="keyword">Set</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>). Następnie wymieniamy konstruktory typu —
    dla czytelności każdy w osobnej linii. Mają one swoje unikalne nazwy i
    są funkcjami, których przeciwdziedziną jest definiowany typ. W naszym
    przypadku mamy 2 konstruktory, zwane <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="var">false</span></span>, które są
    funkcjami zeroargumentowymi.

<div class="paragraph"> </div>

    Definicję tę możemy odczytać następująco: "<span class="inlinecode"><span class="id" title="var">true</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    <span class="inlinecode"><span class="id" title="var">false</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i nie ma żadnych więcej wartości typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span>".

<div class="paragraph"> </div>

    Uwaga: należy odróżnić symbole <span class="inlinecode">:=</span> oraz <span class="inlinecode">=</span>. Pierwszy z nich służy
    do definiowania, a drugi do zapisywania równości.

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">term</span></span> oznacza "niech od teraz <span class="inlinecode"><span class="id" title="var">name</span></span> będzie inną nazwą
    dla <span class="inlinecode"><span class="id" title="var">term</span></span>". Jest to komenda, a nie zdanie logiczne. Od teraz jeżeli
    natkniemy się na nazwę <span class="inlinecode"><span class="id" title="var">name</span></span>, będziemy mogli odwinąć jej definicję i
    wstawić w jej miejsce <span class="inlinecode"><span class="id" title="var">term</span></span>. Przykład: <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span>.
    Antyprzykład: <span class="inlinecode">2</span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span> (błąd składni).

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> oznacza "<span class="inlinecode"><span class="id" title="var">a</span></span> jest równe <span class="inlinecode"><span class="id" title="var">b</span></span>". Jest to zdanie logiczne,
    a nie komenda. Zdanie to rzecz jasna nie musi być prawdziwe. Przykład:
    <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>. Antyprzykład: <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> (jeżeli <span class="inlinecode"><span class="id" title="var">five</span></span> nie jest zdefiniowane,
    to dostajemy komunikat w stylu "nie znaleziono nazwy <span class="inlinecode"><span class="id" title="var">five</span></span>"). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">false</span><br/>
| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji wygląda tak: najpierw mamy słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>
    (jeżeli funkcja nie jest rekurencyjna), następnie argumenty funkcji
    w postaci <span class="inlinecode">(<span class="id" title="var">name</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>; po dwukropku przeciwdziedzina, a po symbolu
    <span class="inlinecode">:=</span> ciało funkcji.

<div class="paragraph"> </div>

    Podstawowym narzędziem służącym do definiowania funkcji jest
    dopasowanie do wzorca (ang. pattern matching). Pozwala ono sprawdzić,
    którego konstruktora użyto do zrobienia dopasowywanej wartości.
    Podobnym tworem występującym w językach imperatywnych jest instrukcja
    switch, ale dopasowanie do wzorca jest od niej dużo potężniejsze.

<div class="paragraph"> </div>

    Nasza funkcja działa następująco: sprawdzamy, którym konstruktorem
    zrobiono argument <span class="inlinecode"><span class="id" title="var">b</span></span> — jeżeli było to <span class="inlinecode"><span class="id" title="var">true</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">false</span></span>, a
    gdy było to <span class="inlinecode"><span class="id" title="var">false</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a id="lab120"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">andb</span></span> i <span class="inlinecode"><span class="id" title="var">orb</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">andb</span></span> (koniunkcja boolowska) i <span class="inlinecode"><span class="id" title="var">orb</span></span> (alternatywa
    boolowska). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zanim odpalimy naszą funkcję, powinniśmy zadać sobie pytanie: w jaki
    sposób programy są wykonywane? W celu lepszego zrozumienia tego
    zagadnienia porównamy ewaluację programów napisanych w językach
    imperatywnych oraz funkcyjnych.

<div class="paragraph"> </div>

    Rozważmy bardzo uproszczony model: interpreter wykonuje program,
    który nie dokonuje operacji wejścia/wyjścia, napisany w jakimś
    języku imperatywnym. W tej sytuacji działanie interpretera
    sprowadza się do tego, że czyta on kod programu instrukcja po
    instrukcji, a następnie w zależności od przeczytanej instrukcji
    odpowiednio zmienia swój stan.

<div class="paragraph"> </div>

    W języku czysto funkcyjnym taki model ewaluacji jest niemożliwy,
    gdyż nie dysponujemy globalnym stanem. Zamiast tego, w Coqu
    wykonanie programu polega na jego redukcji. O co chodzi?
    Przypomnijmy najpierw, że program to term, którego typem jest
    specyfikacja, czyli typ sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Termy mogą być redukowane,
    czyli zamieniane na równoważne, ale prostsze, przy użyciu
    reguł redukcji. Prześledźmy wykonanie programu <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    krok po kroku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;(fun&nbsp;b&nbsp;:&nbsp;bool&nbsp;=&gt;&nbsp;match&nbsp;b&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja delta odwija definicje. Żeby użyć jakiejś redukcji, używamy
    komendy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> <span class="inlinecode"><span class="id" title="var">redukcje</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">term</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;match&nbsp;true&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja beta podstawia argument do funkcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">iota</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja jota dopasowuje term do wzorca i zamienia go na term
    znajdujący się po prawej stronie <span class="inlinecode">=&gt;</span> dla dopasowanego przypadku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żeby zredukować term za jednym zamachem, możemy pominąć nazwy
    redukcji występujące po <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> — w taki wypadku zostaną zaaplikowane
    wszystkie możliwe redukcje, czyli program zostanie wykonany. Do jego
    wykonania możemy też użyć komend <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (a
    także <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ale taktyka <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> jest przestarzała, więc nie
    polecam). 
<div class="paragraph"> </div>

<a id="lab121"></a><h4 class="section">Ćwiczenie (redukcja)</h4>

<div class="paragraph"> </div>

 Zredukuj "ręcznie" programy <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> oraz <span class="inlinecode"><span class="id" title="var">orb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 Jak widać, wykonanie programu w Coqu jest dość toporne. Wynika to
    z faktu, że Coq nie został stworzony do wykonywania programów, a
    jedynie do ich definiowania i dowodzenia ich poprawności. Aby użyć
    programu napisanego w Coqu w świecie rzeczywistym, stosuje się
    zazwyczaj mechanizm ekstrakcji, który pozwala z programu napisanego
    w Coqu automatycznie uzyskać program w Scheme, OCamlu lub Haskellu,
    które są od Coqa dużo szybsze i dużo powszechniej używane. My jednak
    nie będziemy się tym przejmować. 

<div class="paragraph"> </div>

    Zdefiniowawszy naszą funkcję, możemy zadać sobie pytanie:
    czy definicja jest poprawna? Gdybyśmy pisali w jednym z
    języków imperatywnych, moglibyśmy napisać dla niej testy
    jednostkowe, polegające np. na tym, że generujemy losowo
    wejście funkcji i sprawdzamy, czy wynik posiada żądaną przez
    nas właściwość. Coq umożliwia nam coś dużo silniejszego:
    możemy wyrazić przy pomocy twierdzenia, że funkcja posiada
    interesującą nas własność, a następnie spróbować je udowodnić.
    Jeżeli nam się powiedzie, mamy całkowitą pewność, że funkcja
    rzeczywiście posiada żądaną własność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_involutive</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie głosi, że funkcja <span class="inlinecode"><span class="id" title="var">negb</span></span> jest inwolucją,
    tzn. że dwukrotne jej zaaplikowanie do danego argumentu
    nie zmienia go, lub też, innymi słowy, że <span class="inlinecode"><span class="id" title="var">negb</span></span> jest
    swoją własną odwrotnością.

<div class="paragraph"> </div>

    Dowód przebiega w następujący sposób: taktyką <span class="inlinecode"><span class="id" title="tactic">intro</span></span>
    wprowadzamy zmienną <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu, a następnie
    używamy taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, aby sprawdzić, którym
    konstruktorem została zrobiona. Ponieważ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma
    dwa konstruktory, taktyka ta generuje nam dwa podcele:
    musimy udowodnić twierdzenie osobno dla przypadku, gdy
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz dla <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. Potem przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> redukujemy (czyli wykonujemy) programy
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span>. Zauważ, że
    byłoby to niemożliwe, gdyby argument był postaci <span class="inlinecode"><span class="id" title="var">b</span></span>
    (nie można wtedy zaaplikować żadnej redukcji), ale jest
    jak najbardziej możliwe, gdy jest on postaci <span class="inlinecode"><span class="id" title="var">true</span></span> albo
    <span class="inlinecode"><span class="id" title="var">false</span></span> (wtedy redukcja przebiega jak w przykładzie). Na
    koniec używamy taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, która potrafi udowodnić
    cel postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> jest taktykowym odpowiednikiem dopasowania do wzorca
    i bardzo często jest używany, gdy mamy do czynienia z czymś,
    co zostało za jego pomocą zdefiniowane.

<div class="paragraph"> </div>

    Być może poczułeś dyskomfort spowodowany tym, że cel postaci
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> można udowodnić dwoma różnymi taktykami (<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>) albo że termy można redukować na cztery różne
    sposoby (<span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>).
    Niestety, będziesz musiał się do tego przyzwyczaić — język
    taktyka Coqa jest strasznie zabałaganiony i niesie ze sobą
    spory bagaż swej mrocznej przeszłości. Na szczęście od niedawna
    trwają prace nad jego ucywilizowaniem, czego pierwsze efekty
    widać już od wersji 8.5. W chwilach desperacji uratować może
    cię jedynie dokumentacja:
<ul class="doclist">
<li> <a class='link' href='https://coq.inria.fr/refman/coq-tacindex.html'>Indeks taktyk</a>

</li>
<li> <a class='link' href='https://coq.inria.fr/refman/proof-engine/ltac.html'>Ltac</a> 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_involutive'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że nie musimy używać taktyki <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, żeby wprowadzić
    <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu: taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sama jest w stanie wykryć,
    że nie ma go w kontekście i wprowadzić je tam przed rozbiciem
    go na konstruktory. Zauważmy też, że oba podcele rozwiązaliśmy
    w ten sam sposób, więc możemy użyć kombinatora <span class="inlinecode">;</span> (średnika),
    żeby rozwiązać je oba za jednym zamachem. 
<div class="paragraph"> </div>

<a id="lab122"></a><h4 class="section">Ćwiczenie (logika boolowska)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">andb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">orb</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_true_elim</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">b1</span> = <span class="id" title="var">true</span> /\ <span class="id" title="var">b2</span> = <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab123"></a><h4 class="section">Ćwiczenie (róża kierunków)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj typ opisujący kierunki podstawowe (północ, południe, wschód,
    zachód - dodatkowe punkty za nadanie im sensownych nazw). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>, które reprezentują obrót o 90
    stopni przeciwnie/zgodnie z ruchem wskazówek zegara. Sformułuj i
    udowodnij twierdzenia mówiące, że:
<ul class="doclist">
<li> obrót cztery razy w lewo/prawo niczego nie zmienia

</li>
<li> obrót trzy razy w prawo to tak naprawdę obrót w lewo (jest to tzw.
      pierwsze twierdzenie korwinizmu)

</li>
<li> obrót trzy razy w lewo to obrót w prawo (jest to tzw. drugie
      twierdzenie korwinizmu)

</li>
<li> obrót w prawo, a potem w lewo niczego nie zmienia

</li>
<li> obrót w lewo, a potem w prawo niczego nie zmienia

</li>
<li> każdy kierunek to północ, południe, wschód lub zachód (tzn. nie ma
      innych kierunków) 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">opposite</span></span>, które danemu kierunkowi przyporządkowuje
    kierunek do niego przeciwny (czyli północy przyporządkowuje południe
    etc.). Wymyśl i udowodnij jakąś ciekawę specyfikację dla tej funkcji
    (wskazówka: powiąż ją z <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">is_opposite</span></span>, która bierze dwa kierunki i zwraca
    <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy są one przeciwne oraz <span class="inlinecode"><span class="id" title="var">false</span></span> w przeciwnym wypadku. Wymyśl
    i udowodnij jakąś specyfikację dla tej funkcji. Wskazówka: jakie są jej
    związku z <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> i <span class="inlinecode"><span class="id" title="var">opposite</span></span>? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Pokaż, że funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> oraz <span class="inlinecode"><span class="id" title="var">opposite</span></span> są injekcjami i
    surjekcjami (co to dokładnie znacz, dowiemy się później). Uwaga: to
    zadanie wymaga użyci taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, która jest opisana w
    podrozdziale o polimorfizmie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnL</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnR</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">opposite</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab124"></a><h4 class="section">Ćwiczenie (różne enumeracje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj typy induktywne reprezentujące:
<ul class="doclist">
<li> dni tygodnia

</li>
<li> miesiące

</li>
<li> kolory podstawowe systemu RGB 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Wymyśl do nich jakieś ciekawe funkcje i twierdzenia. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab125"></a><h2 class="section">Ważne enumeracje</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab126"></a><h3 class="section">Typ pusty</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty_set</span> : <span class="id" title="keyword">Set</span> := .<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Empty_set</span></span> jest, jak sama nazwa wskazuje, typem pustym. Żaden term
    nie jest tego typu. Innymi słowy: jeżeli jakiś term jest typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    to mamy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">create</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli mamy term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, to możemy w sposób niemal magiczny
    wyczarować term dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span>, używając dopasowania do wzorca z
    pustym wzorcem. 
<div class="paragraph"> </div>

<a id="lab127"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">create_unique</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij, że powyższa funkcja jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">create_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">Empty_set</span> -&gt; <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>, <span class="id" title="var">create</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab128"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">no_fun_from_nonempty_to_empty</span></span>)</h4>

<div class="paragraph"> </div>

 Pokaż, że nie istnieją funkcje z typu niepustego w pusty. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">no_fun_from_nonempty_to_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>), <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab129"></a><h3 class="section">Singleton</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">unit</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">tt</span> : <span class="id" title="var">unit</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">unit</span></span> jest typem, który ma tylko jeden term, zwany <span class="inlinecode"><span class="id" title="var">tt</span></span> (nazwa ta
    jest wzięta z sufitu). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">delete</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">unit</span> := <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest w pewien sposób "dualna" do napotkanej przez
    nas wcześniej funkcji <span class="inlinecode"><span class="id" title="var">create</span></span>. Mając term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span> mogliśmy
    stworzyć term dowolnego innego typu, zaś mając term dowolnego typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>, możemy "zapomnieć o nim" albo "skasować go", wysyłając go
    funkcją <span class="inlinecode"><span class="id" title="var">delete</span></span> w jedyny term typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, czyli <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

    Uwaga: określenie "skasować" nie ma nic wspólnego z fizycznym
    niszczeniem albo dealokacją pamięci. Jest to tylko metafora. 
<div class="paragraph"> </div>

<a id="lab130"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">delete_unique</span></span>)</h4>

<div class="paragraph"> </div>

 Pokaż, że funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">delete_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">unit</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">delete</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab131"></a><h2 class="section">Reguły eliminacji dla enumeracji</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">enum</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : <span class="id" title="var">I</span><br/>
| <span class="id" title="var">c1</span> : <span class="id" title="var">I</span><br/>
| <span class="id" title="var">c2</span> : <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
Najprymitywniejszymi z typów induktywnych są enumeracje. Definiując je,
    wymieniamy po prostu wszystkie ich elementy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">I</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Reguła definiowania przez przypadki jest banalnie prosta: jeżeli w
    jakimś inny typie <span class="inlinecode"><span class="id" title="var">P</span></span> uda nam się znaleźć po jednym elemencie dla każdego
    z elementów naszego typu <span class="inlinecode"><span class="id" title="var">I</span></span>, to możemy zrobić funkcję <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span> : <span class="id" title="var">I_case_nondep_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> <span class="id" title="var">c1'</span> <span class="id" title="var">c2'</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">c0</span> =&gt; <span class="id" title="var">c0'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">c1</span> =&gt; <span class="id" title="var">c1'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">c2</span> =&gt; <span class="id" title="var">c2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Regułę zdefiniować możemy za pomocą dopasowania do wzorca. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c0</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c1</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
Zależną regułę definiowania przez przypadki możemy uzyskać z poprzedniej
    uzależniając przeciwdziedzinę <span class="inlinecode"><span class="id" title="var">P</span></span> od dziedziny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span> : <span class="id" title="var">I_case_dep_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c0</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c1</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c2</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">c0</span> =&gt; <span class="id" title="var">c0'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">c1</span> =&gt; <span class="id" title="var">c1'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">c2</span> =&gt; <span class="id" title="var">c2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja, jak widać, jest taka sama jak poprzednio, więc obliczeniowo
    obie reguły zachowują się tak samo. Różnica leży jedynie w typach -
    druga reguła jest ogólniejsza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">enum</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab132"></a><h1 class="section">Sumy (TODO)</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MySum</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sum</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">inl</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">inr</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inl</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inr</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Suma <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termy są albo termami typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    zawiniętymi w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span>, albo termami typu <span class="inlinecode"><span class="id" title="var">B</span></span>, zawiniętymi
    w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Suma, w przeciwieństwie do produktu, zdecydowanie
    nie ma projekcji. 
<div class="paragraph"> </div>

<a id="lab133"></a><h4 class="section">Ćwiczenie (sumy bez projekcji)</h4>

<div class="paragraph"> </div>

 Pokaż, że suma nie ma projekcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sum_no_fst</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sum_no_snd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MySum</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab134"></a><h1 class="section">Enumeracje z argumentami (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab135"></a><h1 class="section">Produkty (TODO)</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyProd</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">prod</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">pair</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">pair</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Produkt typów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termami są pary. Pierwszy
    element pary to term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugi to term typu <span class="inlinecode"><span class="id" title="var">B</span></span>. Tym, co
    charakteryzuje produkt, są projekcje:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">fst</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wyciąga z pary jej
      pierwszy element

</li>
<li> <span class="inlinecode"><span class="id" title="var">snd</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wyciąga z pary jej
      drugi element 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab136"></a><h4 class="section">Ćwiczenie (projekcje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj projekcje i udowodnij poprawność swoich definicji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">proj_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> = <span class="id" title="var">pair</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyProd</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab137"></a><h1 class="section">Rekordy (TODO)</h1>

<div class="paragraph"> </div>

 W wielu językach programowania występują typy rekordów (ang. record
    types). Charakteryzują się one tym, że mają z góry określoną ilość
    pól o potencjalnie różnych typach. W językach imperatywnych rekordy
    wyewoluowały zaś w obiekty, które różnią się od rekordów tym, że mogą
    zawierać również funkcje, których dziedziną jest obiekt, w którym
    funkcja się znajduje.

<div class="paragraph"> </div>

    W Coqu mamy do dyspozycji rekordy, ale nie obiekty. Trzeba tu po raz
    kolejny pochwalić siłę systemu typów Coqa — o ile w większości języków
    rekordy są osobnym konstruktem językowym, o tyle w Coqu mogą być one z
    łatwością reprezentowane przez typy induktywne z jednym konstruktorem
    (wraz z odpowiednimi projekcjami, które dekonstruują rekord). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">rational2</span>.<br/>

<br/>
<span class="id" title="keyword">Record</span> <span class="id" title="var">rational</span> : <span class="id" title="keyword">Set</span> :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id" title="var">sign</span> : <span class="id" title="var">bool</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">numerator</span> : <span class="id" title="var">nat</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">denominator</span> : <span class="id" title="var">nat</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">denominator_not_zero</span> : <span class="id" title="var">denominator</span> &lt;&gt; 0<br/>
}.<br/>

<br/>
</div>

<div class="doc">
Z typem induktywnym o jednym konstruktorze już się zetknęliśmy,
    próbując zdefiniować liczby wymierne. Powyższa definicja używająca
    rekordu ma drobną przewagę nad poprzednią, w której słowo kluczowe
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pada explicité:
<ul class="doclist">
<li> wygląda ładniej

</li>
<li> ma projekcje 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">sign</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;sign&nbsp;:&nbsp;rational&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">denominator_not_zero</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;denominator_not_zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;r&nbsp;:&nbsp;rational,&nbsp;denominator&nbsp;r&nbsp;&lt;&gt;&nbsp;0&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Dzięki projekcjom mamy dostęp do poszczególnych pól rekordu bez
    konieczności jego dekonstruowania — nie musimy używać konstruktu
    <span class="inlinecode"><span class="id" title="keyword">match</span></span> ani taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, jeżeli nie chcemy. Często bywa to
    bardzo wygodne.

<div class="paragraph"> </div>

    Projekcję <span class="inlinecode"><span class="id" title="var">sign</span></span> możemy interpretować jako funkcję, która bierze
    liczbę wymierną <span class="inlinecode"><span class="id" title="var">r</span></span> i zwraca jej znak, zaś projekcja
    <span class="inlinecode"><span class="id" title="var">denominator_not_zero</span></span> mówi nam, że mianownik żadnej liczb wymiernej
    nie jest zerem.

<div class="paragraph"> </div>

    Pozwa tymi wizualno-praktycznymi drobnostkami, obie definicje są
    równoważne (w szczególności, powyższa definicja, podobnie jak
    poprzednia, nie jest dobrą reprezentacją liczb wymiernych). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">rational2</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab138"></a><h4 class="section">Ćwiczenie (kalendarz)</h4>

<div class="paragraph"> </div>

 Zdefiniuj typ induktywny reprezentujący datę i napisz ręcznie
    wszystkie projekcje. Następnie zdefiniuj rekord reprezentujący
    datę i zachwyć się tym, ile czasu i głupiego pisania zaoszczędziłbyś,
    gdybyś od razu użył rekordu... 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab139"></a><h1 class="section">Prymitywne rekordy (TODO)</h1>

<div class="paragraph"> </div>

 Tutaj wprowadzić prymitywne projekcje i porównać ze zwykłymi rekordami. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoInductive</span> <span class="id" title="var">product</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> : <span class="id" title="var">A</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">snd</span> : <span class="id" title="var">B</span>;<br/>
}.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">swap</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">product</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">product</span> <span class="id" title="var">B</span> <span class="id" title="var">A</span> :=<br/>
{|<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> := <span class="id" title="var">snd</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">snd</span> := <span class="id" title="var">fst</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">p</span>;<br/>
|}.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">para_liczb</span> : <span class="id" title="var">product</span> <span class="id" title="var">nat</span> <span class="id" title="var">nat</span> :=<br/>
{|<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> := 42;<br/>
&nbsp;&nbsp;<span class="id" title="var">snd</span> := 1;<br/>
|}.<br/>

<br/>
<span class="comment">(*<br/>
Compute&nbsp;fst&nbsp;nat&nbsp;nat&nbsp;para_liczb.<br/>
Compute&nbsp;snd&nbsp;nat&nbsp;nat&nbsp;para_liczb.<br/>
*)</span><br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eq_product</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="var">product</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fst</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">p</span> = <span class="id" title="var">fst</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">q</span> -&gt; <span class="id" title="var">snd</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">p</span> = <span class="id" title="var">snd</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">q</span> -&gt; <span class="id" title="var">p</span> = <span class="id" title="var">q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>, <span class="id" title="var">q</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">intros</span> -&gt; -&gt;. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab140"></a><h1 class="section">Programowanie a dowodzenie - eliminacja zdań (TODO)</h1>

<div class="paragraph"> </div>

 Tutaj opisać ograniczenia na eliminację dowodów zdań. 
<div class="paragraph"> </div>

<a id="lab141"></a><h1 class="section">Typy hybrydowe</h1>

<div class="paragraph"> </div>

 Ostatnim z typów istotnych z punktu widzenia silnych specyfikacji
    jest typ o wdzięcznej nazwie <span class="inlinecode"><span class="id" title="var">sumor</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">sumor</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sumor</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">inleft</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sumor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">inright</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sumor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Jak sama nazwa wskazuje, <span class="inlinecode"><span class="id" title="var">sumor</span></span> jest hybrydą sumy rozłącznej <span class="inlinecode"><span class="id" title="var">sum</span></span>
    oraz dysjunkcji <span class="inlinecode"><span class="id" title="var">or</span></span>. Możemy go interpretować jako typ, którego
    elementami są elementy <span class="inlinecode"><span class="id" title="var">A</span></span> albo wymówki w stylu "nie mam elementu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    ponieważ zachodzi zdanie <span class="inlinecode"><span class="id" title="var">B</span></span>". <span class="inlinecode"><span class="id" title="var">B</span></span> nie zależy od <span class="inlinecode"><span class="id" title="var">A</span></span>, a więc jest to
    zwykła suma (a nie suma zależna, czyli uogólnienie produktu). <span class="inlinecode"><span class="id" title="var">sumor</span></span>
    żyje w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a więc jest to specyfikacja i liczy się konkretna
    postać jego termów, a nie jedynie fakt ich istnienia. 
<div class="paragraph"> </div>

<a id="lab142"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">pred'</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">pred'</span></span>, która przypisuje liczbie naturalnej jej
    poprzednik. Poprzednikiem <span class="inlinecode">0</span> nie powinno być <span class="inlinecode">0</span>. Mogą przydać ci
    się typ <span class="inlinecode"><span class="id" title="var">sumor</span></span> oraz sposób definiowania za pomocą taktyk, omówiony
    w podrozdziale dotyczącym sum zależnych. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">sumor</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab143"></a><h1 class="section">Typy pozytywne i negatywne (TODO)</h1>

<div class="paragraph"> </div>

 Tutaj tłumaczenie co to znaczy, że typ jest pozytywny/negatywny. 
<div class="paragraph"> </div>

<a id="lab144"></a><h1 class="section">Moduły (TODO)</h1>

<div class="paragraph"> </div>

 Nie lubię Coqowego systemu modułów, więc w tym rozdziale jeszcze
    długo nic nie zagości. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab145"></a><h1 class="section">Styl, czyli formatowanie, wcięcia i komentarze (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Tu będzie rozdział o stylu, czyli rzeczach takich jak czytelne
    formatowanie kodu czy pisanie zrozumiałych komentarzy. 
<div class="paragraph"> </div>

<a id="lab146"></a><h2 class="section">Formatowanie kodu i wcięcia</h2>

<div class="paragraph"> </div>

<a id="lab147"></a><h2 class="section">Komentarze</h2>

<div class="paragraph"> </div>

<a id="lab148"></a><h2 class="section">Ars nazywandi, czyli trudna sztuka wymyślania nazw</h2>
</div>
<div class="code">
</div>
