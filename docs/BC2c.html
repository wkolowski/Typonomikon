<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">BC2c: Polimorfizm, funkcje wyższego rzędu i klasy typów [TODO]</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

<a id="lab204"></a><h1 class="section">Typy polimorficzne i właściwości konstruktorów</h1>

<div class="paragraph"> </div>

 Przy pomocy komendy <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> możemy definiować nie tylko typy
    induktywne, ale także rodziny typów induktywnych. Jeżeli taka
    rodzina parametryzowana jest typem, to mamy do czynienia z
    polimorfizmem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Some</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option</span> <span class="id" title="var">A</span><br/>
| <span class="id" title="var">None</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">option</span></span> jest rodziną typów, zaś samo <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dla ustalonego <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest typem, który reprezentuje możliwość istnienia wartości typu <span class="inlinecode"><span class="id" title="var">A</span></span>
    (konstruktor <span class="inlinecode"><span class="id" title="var">Some</span></span>) albo i nie (konstruktor <span class="inlinecode"><span class="id" title="var">None</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span> <span class="id" title="var">nat</span> 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;nat&nbsp;5&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">None</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Some</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">None</span> {<span class="id" title="var">A</span>}.<br/>

<br/>
</div>

<div class="doc">
Jak widać typ <span class="inlinecode"><span class="id" title="var">A</span></span>, będący parametrem <span class="inlinecode"><span class="id" title="var">option</span></span>, jest też pierwszym
    argumentem każdego z konstruktorów.
    Pisanie go bywa uciążliwe, ale na szczęście Coq może sam wywnioskować
    jego wartość, jeżeli mu każemy. Komenda <span class="inlinecode"><span class="id" title="var">Arguments</span></span> pozwala nam
    określić, które argumenty mają być domyślne — chcemy, aby argument <span class="inlinecode"><span class="id" title="var">A</span></span>
    był domyślny, gdyż w przypadku konstruktura <span class="inlinecode"><span class="id" title="var">Some</span></span> może być wywnioskowany
    z drugiego argumentu, a w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> — zazwyczaj z kontekstu.

<div class="paragraph"> </div>

    Konstruktory typów induktywnych mają kilka właściwości, o którch
    warto wiedzieć. Po pierwsze, wartości zrobione za pomocą różnych
    konstruktorów są różne. Jest to konieczne, gdyż za pomocą dopasowania
    do wzorca możemy rozróżnić różne konstruktory — gdyby były one
    równe, uzyskalibyśmy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isSome</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">a</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">Some</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">True</span><br/>
| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">False</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Pomocnicza funkcja <span class="inlinecode"><span class="id" title="var">isSome</span></span> ma za zadanie sprawdzić, którym
    konstruktorem zrobiono wartość typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span>
    oznacza, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest argumentem domyślnym funkcji — Coq może go
    wywnioskować, gdyż zna typ argumentu <span class="inlinecode"><span class="id" title="var">a</span></span> (jest nim <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).
    Zauważ też, że funkcja ta zwraca zdania logiczne, a nie wartości
    boolowskie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_not_none</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">change</span> <span class="id" title="var">False</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">isSome</span> (@<span class="id" title="var">None</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Możemy użyć tej pomocniczej funkcji, aby udowodnić, że konstruktory
    <span class="inlinecode"><span class="id" title="var">Some</span></span> i <span class="inlinecode"><span class="id" title="var">None</span></span> tworzą różne wartości. Taktyka <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span>
    pozwala nam zamienić term <span class="inlinecode"><span class="id" title="var">t1</span></span> na <span class="inlinecode"><span class="id" title="var">t2</span></span> pod warunkiem, że są one
    konwertowalne (czyli jeden z nich redukuje się do drugiego). W naszym
    wypadku chcemy zastąpić <span class="inlinecode"><span class="id" title="var">False</span></span> przez <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(@<span class="id" title="var">None</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, który
    redukuje się do <span class="inlinecode"><span class="id" title="var">False</span></span> (spróbuj zredukować to wyrażenie ręcznie).

<div class="paragraph"> </div>

    Użycie symbolu <span class="inlinecode">@</span> pozwala nam dla danego wyrażenia zrezygnować z
    próby automatycznego wywnioskowania argumentów domyślnych — w tym
    przypadku Coq nie potrafiłby wywnioskować argumentu dla konstruktora
    <span class="inlinecode"><span class="id" title="var">None</span></span>, więc musimy podać ten argument ręcznie. 

<div class="paragraph"> </div>

    Następnie możemy skorzystać z równania <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>, żeby
    uzyskać cel postaci <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(<span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>. Cel ten redukuje się
    do <span class="inlinecode"><span class="id" title="var">True</span></span>, którego udowodnienie jest trywialne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_not_none'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">inversion</span> 1. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Cała procedura jest dość skomplikowana — w szczególności wymaga
    napisania funkcji pomocniczej. Na szczęście Coq jest w stanie
    sam wywnioskować, że konstruktory są różne. Możemy zrobić to
    przy pomocy znanej nam z poprzedniego rozdziału taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Zapis <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> oznacza: wprowadź zmienne związane przez
    kwantyfikację uniwersaną do kontekstu i użyj taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    na pierwszej przesłance implikacji. W naszym przypadku implikacja
    jest ukryta w definicji negacji: <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">None</span></span> to tak naprawdę
    <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną właściwością konstruktorów jest fakt, że są one injekcjami,
    tzn. jeżeli dwa termy zrobione tymi samymi konstruktorami są równe,
    to argumenty tych konstruktorów też są równe.

<div class="paragraph"> </div>

    Aby skorzystać z tej właściwości w dowodzie, możemy użyć taktyki
    <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, podając jej jako argument nazwę hipotezy. Jeżeli
    hipoteza jest postaci <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">yn</span></span>, to nasz cel <span class="inlinecode"><span class="id" title="var">G</span></span>
    zostanie zastąpiony przez implikację <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">yn</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>.
    Po wprowadzeniu hipotez do kontekstu możemy użyć ich do udowodnienia
    <span class="inlinecode"><span class="id" title="var">G</span></span>, zazwyczaj przy pomocy taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">H</span></span> miało postać <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a cel <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    więc <span class="inlinecode"><span class="id" title="tactic">injection</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> przekształciło cel do postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    który jest trywialny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_inj'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> może nam pomóc również wtedy, kiedy chcemy skorzystać
    z injektywności konstruktorów. W zasadzie jest ona nawet bardziej
    przydatna — działa ona tak jak <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, ale zamiast zostawiać cel w
    postaci <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>, wprowadza ona wygenerowane hipotezy do
    kontekstu, a następnie przepisuje w celu wszystkie, których przepisanie
    jest możliwe. W ten sposób oszczędza nam ona nieco pisania.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">inverson</span></span> <span class="inlinecode">1</span> dodała do kontekstu hipotezę <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    a następnie przepisała ją w celu (który miał postać <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>), dając
    cel postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_inj''</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">injection</span> 1. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyką ułatwiającą pracę z <span class="inlinecode"><span class="id" title="tactic">injection</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> jest <span class="inlinecode"><span class="id" title="tactic">subst</span></span>.
    Taktyka ta wyszukuje w kontekście hipotezy postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>,
    przepisuje je we wszystkich hipotezach w kontekście i celu, w których
    jest to możliwe, a następnie usuwa. Szczególnie często spotykana
    jest kombinacja <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, gdyż <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> często
    generuje sporą ilość hipotez postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, które <span class="inlinecode"><span class="id" title="tactic">subst</span></span> następnie
    "sprząta".

<div class="paragraph"> </div>

    W naszym przypadku hipoteza <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> została przepisana nie tylko
    w celu, dając <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, ale także w hipotezie <span class="inlinecode"><span class="id" title="var">H</span></span>, dając
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
<div class="paragraph"> </div>

<a id="lab205"></a><h4 class="section">Ćwiczenie (zero i jeden)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenie bez używania taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Żeby było trudniej, nie pisz osobnej funkcji pomocniczej — zdefiniuj
    swoją funkcję bezpośrednio w miejscu, w którym chcesz jej użyć.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">zero_not_one</span> : 0 &lt;&gt; 1.<br/>

<br/>
</div>

<div class="doc">
Dwie opisane właściwości, choć pozornie niewinne, a nawet przydatne,
    mają bardzo istotne i daleko idące konsekwencje. Powoduję one na
    przykład, że nie istnieją typy ilorazowe. Dokładne znaczenie tego
    faktu omówimy później, zaś teraz musimy zadowolić się jedynie
    prostym przykładem w formie ćwiczenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">rational</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">mk_rational</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">sign</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">numerator</span> <span class="id" title="var">denominator</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">denominator</span> &lt;&gt; 0 -&gt; <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">rational_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> <span class="id" title="var">p'</span> <span class="id" title="var">q</span> <span class="id" title="var">q'</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="var">q</span> &lt;&gt; 0) (<span class="id" title="var">H'</span> : <span class="id" title="var">q'</span> &lt;&gt; 0), <span class="id" title="var">p</span> * <span class="id" title="var">q'</span> = <span class="id" title="var">p'</span> * <span class="id" title="var">q</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mk_rational</span> <span class="id" title="var">s</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">H</span> = <span class="id" title="var">mk_rational</span> <span class="id" title="var">s'</span> <span class="id" title="var">p'</span> <span class="id" title="var">q'</span> <span class="id" title="var">H'</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">rational</span></span> ma reprezentować liczby wymierne. Znak jest typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span> — możemy interpretować, że <span class="inlinecode"><span class="id" title="var">true</span></span> oznacza obecność znaku
    minus, a <span class="inlinecode"><span class="id" title="var">false</span></span> brak znaku. Dwie liczby naturalne będą oznaczać
    kolejno licznik i mianownik, a na końcu żądamy jeszcze dowodu na
    to, że mianownik nie jest zerem.

<div class="paragraph"> </div>

    Oczywiście typ ten sam w sobie niewiele ma wspólnego z liczbami
    wymiernymi — jest to po prostu trójka elementów o typach <span class="inlinecode"><span class="id" title="var">bool</span>,</span>
    <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, z których ostatni nie jest zerem. Żeby rzeczywiście
    reprezentował liczby wymierne musimy zapewnić, że termy, które
    reprezentują te same wartości, są równe, np. 1/2 musi być równa
    2/4.

<div class="paragraph"> </div>

    W tym celu postulujemy aksjomat, który zapewni nam pożądane
    właściwości relacji równości. Komenda <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> pozwala nam
    wymusić istnienie termu pożądanego typu i nadać mu nazwę,
    jednak jest szalenie niebezpieczna — jeżeli zapostulujemy
    aksjomat, który jest sprzeczny, jesteśmy zgubieni.

<div class="paragraph"> </div>

    W takiej sytuacji całe nasze dowodzenie idzie na marne, gdyż
    ze sprzecznego aksjomatu możemy wywnioskować <span class="inlinecode"><span class="id" title="var">False</span></span>, z
    <span class="inlinecode"><span class="id" title="var">False</span></span> zaś możemy wywnioskować cokolwiek, o czym przekonaliśmy
    się w rozdziale pierwszym. Tak też jest w tym przypadku —
    aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny, gdyż łamie zasadę
    injektywności konstruktorów. 
<div class="paragraph"> </div>

<a id="lab206"></a><h4 class="section">Ćwiczenie (niedobry aksjomat)</h4>

<div class="paragraph"> </div>

 Udowodnij, że aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny. Wskazówka: znajdź
    dwie liczby wymierne, które są równe na mocy tego aksjomatu, ale które
    można rozróżnić za pomocą dopasowania do wzorca. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rational_eq_inconsistent</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">rational</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab207"></a><h1 class="section">Parametryzowane enumeracje (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab208"></a><h2 class="section">Reguły eliminacji (TODO)</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">param</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">c1</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">c2</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">c0</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">c1</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">c2</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną innowacją są parametry, których głównym zastosowaniem jest
    polimorfizm. Dzięki parametrom możemy za jednym zamachem (tylko bez
    skojarzeń z Islamem!) zdefiniować nieskończenie wiele typów, po jednym
    dla każdego parametru. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ rekursora jest oczywisty: jeżeli znajdziemy rzeczy o kształtach
    takich jak konstruktory <span class="inlinecode"><span class="id" title="var">I</span></span> z <span class="inlinecode"><span class="id" title="var">I</span></span> zastąpionym przez <span class="inlinecode"><span class="id" title="var">P</span></span>, to możemy
    zrobić funkcję <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jako, że parametry są zawsze takie samo,
    możemy skwantyfikować je na samym początku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">c0</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">a</span><br/>
| <span class="id" title="var">c1</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c1'</span> <span class="id" title="var">b</span><br/>
| <span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c2'</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c1'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c1</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c2'</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> (<span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
A regułę indukcji uzyskujemy przez uzależnienie <span class="inlinecode"><span class="id" title="var">P</span></span> od <span class="inlinecode"><span class="id" title="var">I</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c1'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c1</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c2'</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> (<span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">P</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">c0</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">a</span><br/>
| <span class="id" title="var">c1</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c1'</span> <span class="id" title="var">b</span><br/>
| <span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c2'</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">param</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab209"></a><h1 class="section">Parametryzowane rekordy (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab210"></a><h1 class="section">Klasy (TODO)</h1>

<div class="paragraph"> </div>

 Mechanizmem ułatwiającym życie jeszcze bardziej niż rekordy są klasy.
    Niech nie zmyli cię ta nazwa — nie mają one nic wspólnego z klasami
    znanymi z języków imperatywnych. Bliżej im raczej do interfejsów,
    od których są zresztą dużo silniejsze.

<div class="paragraph"> </div>

    W językach imperatywnych interfejs możemy zaimplementować zazwyczaj
    definiując nowy typ. W Coqu możemy uczynić typ instancją klasy w
    dowolnym miejscu — nawet jeżeli to nie my go zdefiniowaliśmy. Co
    więcej, instancjami klas mogą być nie tylko typy, ale dowolne termy.
    Klasy są w Coqu pełnoprawnym tworem — mogą mieć argumenty, zawierać
    inne klasy, być przekazywane jako argumenty do funkcji etc. Używa się
    ich zazwyczaj dwojako:
<ul class="doclist">
<li> zamiast rekordów (zwiększa to nieco czytelność)

</li>
<li> jako interfejsy 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="var">EqDec</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id" title="var">eq_dec</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">eq_dec_spec</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">eq_dec</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> = <span class="id" title="var">true</span> &lt;-&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span><br/>
}.<br/>

<br/>
</div>

<div class="doc">
Nie będziemy po raz trzeci powtarzać (kulawej) definicji liczb
    wymiernych — użycie do tego klas zamiast rekordów sprowadza się
    do zamienienia słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Record</span></span> na <span class="inlinecode"><span class="id" title="keyword">Class</span></span> w poprzedniej
    definicji.

<div class="paragraph"> </div>

    Przyjrzyjmmy się za to wykorzystaniu klasy w roli interfejsu.
    Argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> po nazwie klasy mówi nam, że nasz interfejs
    będą mogły implementować typy. Dalej zapis <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> mówi nam, że
    nasza klasa jest typem — klasy, jako ulepszone rekordy, są typami
    induktywnymi z jednym konstruktorem.

<div class="paragraph"> </div>

    Nasza klasa ma dwa pola, które będzie musiał podać użytkownik chcący
    uczynić swój typ jej instancją: funkcję <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> oraz jej specyfikację,
    która mówi nam, że <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span> wtedy i tylko wtedy, gdy jej
    argumenty są równe.

<div class="paragraph"> </div>

    Wobec tego typy będące instancjami <span class="inlinecode"><span class="id" title="var">EqDec</span></span> można interpretować jako
    typy, dla których równość elementów można sprawdzić za pomocą jakiegoś
    algorytmu. Nie wszystkie typy posiadają tę własność — problematyczne
    są szczególnie te, których elementy są w jakiś sposób "nieskończone". 
</div>
<div class="code">

<br/>
#[<span class="id" title="tactic">refine</span>]<br/>
#[<span class="id" title="var">export</span>]<br/>
<span class="id" title="keyword">Instance</span> <span class="id" title="var">EqDec_bool</span> : <span class="id" title="var">EqDec</span> <span class="id" title="var">bool</span> :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id" title="var">eq_dec</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span> : <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span>, <span class="id" title="var">b'</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span>, <span class="id" title="var">true</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span>, <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>, <span class="id" title="var">y</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">trivial</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Instancje klas definiujemy przy pomocy słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>.
    Jeżeli używamy klasy jako interfejsu, który implementować mogą typy,
    to zazwyczaj będziemy potrzebować tylko jednej instancji, więc jej
    nazwa będzie niemal identyczna jak jej typ (dzięki temu łatwo będzie
    ją zapamiętać).

<div class="paragraph"> </div>

    Po symbolu <span class="inlinecode">:=</span> w nawiasach klamrowych definiujemy pola, które
    nie są dowodami. Całość, jako komenda, musi kończyć się kropką. Gdy
    klasa nie zawiera żadnych pól będących dowodami, definicja jest
    zakończona. W przeciwnym przypadku Coq przechodzi w tryb dowodzenia,
    w którym każdemu polu będącemu dowodem odpowiada jeden podcel. Po
    rozwiązaniu wszystkich podcelów instancja jest zdefiniowana.

<div class="paragraph"> </div>

    W naszym przypadku klasa ma dwa pola — funkcję i dowód na to, że
    funkcja spełnia specyfikację — więc w nawiasach klamrowych musimy
    podać jedynie funkcję. Zauważmy, że nie musimy koniecznie definiować
    jej właśnie w tym miejscu — możemy zrobić to wcześniej, np. za pomocą
    komendy <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> albo <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, a tutaj odnieść się do niej
    używając jej nazwy. W przypadku bardziej skomplikowanych definicji
    jest to nawet lepsze wyjście, gdyż zyskujemy dzięki niemu kontrolę
    nad tym, w którym miejscu rozwinąć definicję, dzięki czemu kontekst
    i cel stają się czytelniejsze.

<div class="paragraph"> </div>

    Ponieważ nasza klasa ma pole, które jest dowodem, Coq przechodzi w tryb
    dowodzenia. Dowód, mimo iż wymaga rozpatrzenia ośmiu przypadków, mieści
    się w jednej linijce — widać tutaj moc automatyzacji. Prześledźmy, co
    się w nim dzieje.

<div class="paragraph"> </div>

    Najpierw rozbijamy wartości boolowskie <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span>. Nie musimy wcześniej
    wprowadzać ich do kontekstu taktyką <span class="inlinecode"><span class="id" title="tactic">intros</span></span>, gdyż <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sam potrafi
    to zrobić. W wyniku tego dostajemy cztere podcele. W każdym z nich
    taktyką <span class="inlinecode"><span class="id" title="tactic">split</span></span> rozbijamy równoważność na dwie implikacje. Sześć z nich
    ma postać <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, więc radzi sobie z nimi taktyka <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>. Dwie
    pozostałe mają przesłanki postaci <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> albo <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>,
    które są sprzeczne na mocy omówionych wcześniej właściwości konstruktorów.
    Taktyką <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> wskazujemy, że pierwsza przesłanka implikacji
    zawiera taką właśnie sprzeczną równość termów zrobionych różnymi
    konstruktorami, a Coq załatwia za nas resztę.

<div class="paragraph"> </div>

    Jeżeli masz problem z odczytaniem tego dowodu, koniecznie przeczytaj
    ponownie fragment rozdziału pierwszego dotyczący kombinatorów taktyk.
    Jeżeli nie potrafisz wyobrazić sobie podcelów generowanych przez
    kolejne taktyki, zastąp chwilowo średniki kropkami, a jeżeli to nie
    pomaga, udowodnij całe twierdzenie bez automatyzacji.

<div class="paragraph"> </div>

    Dzięki takim ćwiczeniom prędzej czy później oswoisz się z tym sposobem
    dowodzenia, choć nie jest to sztuka prosta — czytanie cudzych dowodów
    jest równie trudne jak czytanie cudzych programów.

<div class="paragraph"> </div>

    Prawie nigdy zresztą nowopowstałe dowody nie są od razu zautomatyzowane
    aż w takim stopniu — najpierw są przeprowadzone w części lub w całości
    ręcznie. Automatyzacja jest wynikiem dostrzeżenia w dowodzie pewnych
    powtarzających się wzorców. Proces ten przypomina trochę
    refaktoryzację kodu — gdy dostrzeżemy powtarzające się fragmenty kodu,
    przenosimy je do osobnych procedur. Analogicznie, gdy dostrzegamy
    powtarzające się fragmenty dowodu, łączymy je kombinatorami taktyk
    lub piszemy własne, zupełnie nowe taktyki (temat pisania własnych
    taktyk poruszę prędzej czy później).

<div class="paragraph"> </div>

    Od teraz będę zakładał, że nie masz problemów ze zrozumieniem takich
    dowodów i kolejne przykładowe dowody będę pisał w bardziej zwratej
    formie.

<div class="paragraph"> </div>

    Zauważ, że definicję instancji kończymy komendą <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>, a nie <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>,
    jak to było w przypadku dowodów twierdzeń. Wynika to z faktu, że Coq
    inaczej traktuje specyfikacje i programy, a inaczej zdania i dowody.
    W przypadku dowodu liczy się sam fakt jego istnienia, a nie jego treść,
    więc komenda <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> każe Coqowi zapamiętać jedynie, że twierdzenie
    udowodniono, a zapomnieć, jak dokładnie wyglądał proofterm. W przypadku
    programów takie zachowanie jest niedopuszczalne, więc <span class="inlinecode"><span class="id" title="keyword">Defined</span></span> każe
    Coqowi zapamiętać term ze wszystkimi szczegółami. Jeżeli nie wiesz,
    której z tych dwóch komend użyć, użyj <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>. 
<div class="paragraph"> </div>

<a id="lab211"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">EqDec</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj instancje klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla typów <span class="inlinecode"><span class="id" title="var">unit</span></span> oraz <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab212"></a><h4 class="section">Ćwiczenie (równość funkcji)</h4>

<div class="paragraph"> </div>

 Czy możliwe jest zdefiniowanie instancji klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla typu:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Jeżeli tak, udowodnij w Coqu. Jeżeli nie, zaargumentuj słownie. 
</div>
<div class="code">

<br/>

<br/>
#[<span class="id" title="tactic">refine</span>]<br/>
#[<span class="id" title="var">export</span>]<br/>
<span class="id" title="keyword">Instance</span> <span class="id" title="var">EqDec_option</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">_</span> : <span class="id" title="var">EqDec</span> <span class="id" title="var">A</span>) : <span class="id" title="var">EqDec</span> (<span class="id" title="var">option</span> <span class="id" title="var">A</span>) :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id" title="var">eq_dec</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">opt1</span> <span class="id" title="var">opt2</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">opt1</span>, <span class="id" title="var">opt2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">a</span>, <span class="id" title="var">Some</span> <span class="id" title="var">a'</span> =&gt; <span class="id" title="var">eq_dec</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span>, <span class="id" title="var">None</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>, <span class="id" title="var">y</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">trivial</span>; <span class="id" title="tactic">try</span> (<span class="id" title="tactic">inversion</span> 1; <span class="id" title="tactic">fail</span>); <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">eq_dec_spec</span> <span class="id" title="var">a</span> <span class="id" title="var">a0</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">eq_dec_spec</span> <span class="id" title="var">a</span> <span class="id" title="var">a0</span>). <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Instancje klas mogą przyjmować argumenty, w tym również instancje innych
    klas albo inne instancje tej samej klasy. Dzięki temu możemy wyrazić
    ideę interfejsów warunkowych.

<div class="paragraph"> </div>

    W naszym przypadku typ <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> może być instancją klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span>
    jedynie pod warunkiem, że jego argument również jest instancją tej
    klasy. Jest to konieczne, gdyż porównywanie termów typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    sprowadza się do porównywania termów typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Zauważ, że kod <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">a'</span></span> nie odwołuje się do definiowanej właśnie
    funkcji <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> dla typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> — odnosi się do funkcji <span class="inlinecode"><span class="id" title="var">eq_dec</span></span>,
    której dostarcza nam instancja <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">EqDec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Jak widać, nie musimy
    nawet nadawać jej nazwy — Coqa interesuje tylko jej obecność.

<div class="paragraph"> </div>

    Na podstawie typów termów <span class="inlinecode"><span class="id" title="var">a</span></span> i <span class="inlinecode"><span class="id" title="var">a'</span></span>, które są Coqowi znane, potrafi
    on wywnioskować, że <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">a'</span></span> nie jest wywołaniem rekurencyjnym,
    lecz odnosi się do instancji innej niż obecnie definiowana. Coq może
    ją znaleźć i odnosić się do niej, mimo że my nie możemy (gdybyśmy
    chcieli odnosić się do tej instancji, musielibyśmy zmienić nazwę z
    <span class="inlinecode"><span class="id" title="var">_</span></span> na coś innego). 
<div class="paragraph"> </div>

<a id="lab213"></a><h4 class="section">Ćwiczenie (równość list)</h4>

<div class="paragraph"> </div>

 Zdefiniuj instancję klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab214"></a><h4 class="section">Ćwiczenie (równość funkcji 2)</h4>

<div class="paragraph"> </div>

 Niech <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> będą dowolnymi typami. Zastanów się, kiedy możliwe
    jest zdefiniowanie instancji klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. </div>
<div class="code">
</div>
