<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">D1: Indukcja i rekursja</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W poprzednim rozdziale dowiedzieliśmy się już co nieco o typach, a
    także spotkaliśmy kilka z nich oraz kilka sposobów tworzenia nowych
    typów ze starych (takich jak np. koniunkcja; pamiętaj, że zdania są
    typami). W tym rozdziale dowiemy się, jak definiować nowe typy przy
    pomocy indukcji oraz jak użyć rekursji do definiowania funkcji, które
    operują na tych typach. 
<div class="paragraph"> </div>

<a id="lab230"></a><h1 class="section">Typy induktywne</h1>

<div class="paragraph"> </div>

 W Coqu są trzy główne rodzaje typów: produkt zależny, typy induktywne
    i typy koinduktywne. Z pierwszym z nich już się zetknęliśmy, drugi
    poznamy w tym rozdziale, trzeci na razie pominiemy.

<div class="paragraph"> </div>

    Typ induktywny definiuje się przy pomocy zbioru konstruktorów, które
    służą, jak sama nazwa wskazuje, do budowania termów tego typu.
    Konstruktory te są funkcjami (być może zależnymi), których
    przeciwdziedziną jest definiowany typ, ale niczego nie
    obliczają — nadają jedynie termom ich "kształt". W szczególności, nie
    mają nic wspólnego z konstruktorami w takich językach jak C++ lub Java
    — nie mogą przetwarzać swoich argumentów, alokować pamięci, dokonywać
    operacji wejścia/wyjścia etc.

<div class="paragraph"> </div>

    Tym, co jest ważne w przypadku konstruktorów, jest ich ilość, nazwy
    oraz ilość i typy przyjmowanych argumentów. To te cztery rzeczy decydują
    o tym, jakie "kształty" będą miały termy danego typu, a więc i czym
    będzie sam typ. W ogolności każdy term jest skończonym, ukorzenionym
    drzewem, którego kształt zależy od charakterystyki konstruktorów tak:
<ul class="doclist">
<li> każdy konstruktor to inny rodzaj węzła (nazwa konstruktora to nazwa
      węzła)

</li>
<li> konstruktory nierekurencyjne to liście, a rekurencyjne — węzły
      wewnętrzne

</li>
<li> argumenty konstruktorów to dane przechowywane w danym węźle 
</li>
</ul>

<div class="paragraph"> </div>

 Typ induktywny można wyobrażać sobie jako przestrzeń zawierającą
    te i tylko te drzewa, które można zrobić przy pomocy jego
    konstruktorów. Nie przejmuj się, jeżeli opis ten wydaje ci się
    dziwny — sposób definiowania typów induktywnych i ich wartości
    w Coqu jest diametralnie różny od sposobu definiowania klas i
    obiektów w językach imperatywnych i wymaga przyzwyczajenia się
    do niego. Zobaczmy, jak powyższy opis ma się do konkretnych
    przykładów. 
<div class="paragraph"> </div>

<a id="lab231"></a><h2 class="section">Enumeracje</h2>

<div class="paragraph"> </div>

 Najprostszym rodzajem typów induktywnych są enumeracje, czyli typy,
    których wszystkie konstruktory są stałymi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> : <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja typu induktywnego ma następującą postać: najpierw występuje
    słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, następnie nazwa typu, a po dwukropku sort
    (<span class="inlinecode"><span class="id" title="keyword">Set</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>). Następnie wymieniamy konstruktory typu —
    dla czytelności każdy w osobnej linii. Mają one swoje unikalne nazwy i
    są funkcjami, których przeciwdziedziną jest definiowany typ. W naszym
    przypadku mamy 2 konstruktory, zwane <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="var">false</span></span>, które są
    funkcjami zeroargumentowymi.

<div class="paragraph"> </div>

    Definicję tę możemy odczytać następująco: "<span class="inlinecode"><span class="id" title="var">true</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    <span class="inlinecode"><span class="id" title="var">false</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i nie ma żadnych więcej wartości typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span>".

<div class="paragraph"> </div>

    Uwaga: należy odróżnić symbole <span class="inlinecode">:=</span> oraz <span class="inlinecode">=</span>. Pierwszy z nich służy
    do definiowania, a drugi do zapisywania równości.

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">term</span></span> oznacza "niech od teraz <span class="inlinecode"><span class="id" title="var">name</span></span> będzie inną nazwą
    dla <span class="inlinecode"><span class="id" title="var">term</span></span>". Jest to komenda, a nie zdanie logiczne. Od teraz jeżeli
    natkniemy się na nazwę <span class="inlinecode"><span class="id" title="var">name</span></span>, będziemy mogli odwinąć jej definicję i
    wstawić w jej miejsce <span class="inlinecode"><span class="id" title="var">term</span></span>. Przykład: <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span>.
    Antyprzykład: <span class="inlinecode">2</span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span> (błąd składni).

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> oznacza "<span class="inlinecode"><span class="id" title="var">a</span></span> jest równe <span class="inlinecode"><span class="id" title="var">b</span></span>". Jest to zdanie logiczne,
    a nie komenda. Zdanie to rzecz jasna nie musi być prawdziwe. Przykład:
    <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>. Antyprzykład: <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> (jeżeli <span class="inlinecode"><span class="id" title="var">five</span></span> nie jest zdefiniowane,
    to dostajemy komunikat w stylu "nie znaleziono nazwy <span class="inlinecode"><span class="id" title="var">five</span></span>"). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji wygląda tak: najpierw mamy słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>
    (jeżeli funkcja nie jest rekurencyjna), następnie argumenty funkcji
    w postaci <span class="inlinecode">(<span class="id" title="var">name</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>; po dwukropku przeciwdziedzina, a po symbolu
    <span class="inlinecode">:=</span> ciało funkcji.

<div class="paragraph"> </div>

    Podstawowym narzędziem służącym do definiowania funkcji jest
    dopasowanie do wzorca (ang. pattern matching). Pozwala ono sprawdzić,
    którego konstruktora użyto do zrobienia dopasowywanej wartości.
    Podobnym tworem występującym w językach imperatywnych jest instrukcja
    switch, ale dopasowanie do wzorca jest od niej dużo potężniejsze.

<div class="paragraph"> </div>

    Nasza funkcja działa następująco: sprawdzamy, którym konstruktorem
    zrobiono argument <span class="inlinecode"><span class="id" title="var">b</span></span> — jeżeli było to <span class="inlinecode"><span class="id" title="var">true</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">false</span></span>, a
    gdy było to <span class="inlinecode"><span class="id" title="var">false</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a id="lab232"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">andb</span></span> i <span class="inlinecode"><span class="id" title="var">orb</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">andb</span></span> (koniunkcja boolowska) i <span class="inlinecode"><span class="id" title="var">orb</span></span> (alternatywa
    boolowska). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zanim odpalimy naszą funkcję, powinniśmy zadać sobie pytanie: w jaki
    sposób programy są wykonywane? W celu lepszego zrozumienia tego
    zagadnienia porównamy ewaluację programów napisanych w językach
    imperatywnych oraz funkcyjnych.

<div class="paragraph"> </div>

    Rozważmy bardzo uproszczony model: interpreter wykonuje program,
    który nie dokonuje operacji wejścia/wyjścia, napisany w jakimś
    języku imperatywnym. W tej sytuacji działanie interpretera
    sprowadza się do tego, że czyta on kod programu instrukcja po
    instrukcji, a następnie w zależności od przeczytanej instrukcji
    odpowiednio zmienia swój stan.

<div class="paragraph"> </div>

    W języku czysto funkcyjnym taki model ewaluacji jest niemożliwy,
    gdyż nie dysponujemy globalnym stanem. Zamiast tego, w Coqu
    wykonanie programu polega na jego redukcji. O co chodzi?
    Przypomnijmy najpierw, że program to term, którego typem jest
    specyfikacja, czyli typ sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Termy mogą być redukowane,
    czyli zamieniane na równoważne, ale prostsze, przy użyciu
    reguł redukcji. Prześledźmy wykonanie programu <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    krok po kroku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;(fun&nbsp;b&nbsp;:&nbsp;bool&nbsp;=&gt;&nbsp;match&nbsp;b&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja delta odwija definicje. Żeby użyć jakiejś redukcji, używamy
    komendy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> <span class="inlinecode"><span class="id" title="var">redukcje</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">term</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;match&nbsp;true&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja beta podstawia argument do funkcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">iota</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja jota dopasowuje term do wzorca i zamienia go na term
    znajdujący się po prawej stronie <span class="inlinecode">=&gt;</span> dla dopasowanego przypadku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żeby zredukować term za jednym zamachem, możemy pominąć nazwy
    redukcji występujące po <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> — w taki wypadku zostaną zaaplikowane
    wszystkie możliwe redukcje, czyli program zostanie wykonany. Do jego
    wykonania możemy też użyć komend <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (a
    także <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ale taktyka <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> jest przestarzała, więc nie
    polecam). 
<div class="paragraph"> </div>

<a id="lab233"></a><h4 class="section">Ćwiczenie (redukcja)</h4>

<div class="paragraph"> </div>

 Zredukuj "ręcznie" programy <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> oraz <span class="inlinecode"><span class="id" title="var">orb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 Jak widać, wykonanie programu w Coqu jest dość toporne. Wynika to
    z faktu, że Coq nie został stworzony do wykonywania programów, a
    jedynie do ich definiowania i dowodzenia ich poprawności. Aby użyć
    programu napisanego w Coqu w świecie rzeczywistym, stosuje się
    zazwyczaj mechanizm ekstrakcji, który pozwala z programu napisanego
    w Coqu automatycznie uzyskać program w Scheme, OCamlu lub Haskellu,
    które są od Coqa dużo szybsze i dużo powszechniej używane. My jednak
    nie będziemy się tym przejmować. 

<div class="paragraph"> </div>

    Zdefiniowawszy naszą funkcję, możemy zadać sobie pytanie:
    czy definicja jest poprawna? Gdybyśmy pisali w jednym z
    języków imperatywnych, moglibyśmy napisać dla niej testy
    jednostkowe, polegające np. na tym, że generujemy losowo
    wejście funkcji i sprawdzamy, czy wynik posiada żądaną przez
    nas właściwość. Coq umożliwia nam coś dużo silniejszego:
    możemy wyrazić przy pomocy twierdzenia, że funkcja posiada
    interesującą nas własność, a następnie spróbować je udowodnić.
    Jeżeli nam się powiedzie, mamy całkowitą pewność, że funkcja
    rzeczywiście posiada żądaną własność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_involutive</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie głosi, że funkcja <span class="inlinecode"><span class="id" title="var">negb</span></span> jest inwolucją,
    tzn. że dwukrotne jej zaaplikowanie do danego argumentu
    nie zmienia go, lub też, innymi słowy, że <span class="inlinecode"><span class="id" title="var">negb</span></span> jest
    swoją własną odwrotnością.

<div class="paragraph"> </div>

    Dowód przebiega w następujący sposób: taktyką <span class="inlinecode"><span class="id" title="tactic">intro</span></span>
    wprowadzamy zmienną <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu, a następnie
    używamy taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, aby sprawdzić, którym
    konstruktorem została zrobiona. Ponieważ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma
    dwa konstruktory, taktyka ta generuje nam dwa podcele:
    musimy udowodnić twierdzenie osobno dla przypadku, gdy
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz dla <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. Potem przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> redukujemy (czyli wykonujemy) programy
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span>. Zauważ, że
    byłoby to niemożliwe, gdyby argument był postaci <span class="inlinecode"><span class="id" title="var">b</span></span>
    (nie można wtedy zaaplikować żadnej redukcji), ale jest
    jak najbardziej możliwe, gdy jest on postaci <span class="inlinecode"><span class="id" title="var">true</span></span> albo
    <span class="inlinecode"><span class="id" title="var">false</span></span> (wtedy redukcja przebiega jak w przykładzie). Na
    koniec używamy taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, która potrafi udowodnić
    cel postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> jest taktykowym odpowiednikiem dopasowania do wzorca
    i bardzo często jest używany, gdy mamy do czynienia z czymś,
    co zostało za jego pomocą zdefiniowane.

<div class="paragraph"> </div>

    Być może poczułeś dyskomfort spowodowany tym, że cel postaci
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> można udowodnić dwoma różnymi taktykami (<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>) albo że termy można redukować na cztery różne
    sposoby (<span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>).
    Niestety, będziesz musiał się do tego przyzwyczaić — język
    taktyka Coqa jest strasznie zabałaganiony i niesie ze sobą
    spory bagaż swej mrocznej przeszłości. Na szczęście od niedawna
    trwają prace nad jego ucywilizowaniem, czego pierwsze efekty
    widać już od wersji 8.5. W chwilach desperacji uratować może
    cię jedynie dokumentacja:
<ul class="doclist">
<li> https://coq.inria.fr/refman/coq-tacindex.html

</li>
<li> https://coq.inria.fr/refman/proof-engine/ltac.html 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_involutive'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że nie musimy używać taktyki <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, żeby wprowadzić
    <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu: taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sama jest w stanie wykryć,
    że nie ma go w kontekście i wprowadzić je tam przed rozbiciem
    go na konstruktory. Zauważmy też, że oba podcele rozwiązaliśmy
    w ten sam sposób, więc możemy użyć kombinatora <span class="inlinecode">;</span> (średnika),
    żeby rozwiązać je oba za jednym zamachem. 
<div class="paragraph"> </div>

<a id="lab234"></a><h4 class="section">Ćwiczenie (logika boolowska)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">andb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">orb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">orb</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">orb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">b1</span> = <span class="id" title="var">true</span> /\ <span class="id" title="var">b2</span> = <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab235"></a><h4 class="section">Ćwiczenie (róża kierunków)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj typ opisujący kierunki podstawowe (północ, południe, wschód,
    zachód - dodatkowe punkty za nadanie im sensownych nazw). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>, które reprezentują obrót o 90
    stopni przeciwnie/zgodnie z ruchem wskazówek zegara. Sformułuj i
    udowodnij twierdzenia mówiące, że:
<ul class="doclist">
<li> obrót cztery razy w lewo/prawo niczego nie zmienia

</li>
<li> obrót trzy razy w prawo to tak naprawdę obrót w lewo (jest to tzw.
      pierwsze twierdzenie korwinizmu)

</li>
<li> obrót trzy razy w lewo to obrót w prawo (jest to tzw. drugie
      twierdzenie korwinizmu)

</li>
<li> obrót w prawo, a potem w lewo niczego nie zmienia

</li>
<li> obrót w lewo, a potem w prawo niczego nie zmienia

</li>
<li> każdy kierunek to północ, południe, wschód lub zachód (tzn. nie ma
      innych kierunków) 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">opposite</span></span>, które danemu kierunkowi przyporządkowuje
    kierunek do niego przeciwny (czyli północy przyporządkowuje południe
    etc.). Wymyśl i udowodnij jakąś ciekawę specyfikację dla tej funkcji
    (wskazówka: powiąż ją z <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">is_opposite</span></span>, która bierze dwa kierunki i zwraca
    <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy są one przeciwne oraz <span class="inlinecode"><span class="id" title="var">false</span></span> w przeciwnym wypadku. Wymyśl
    i udowodnij jakąś specyfikację dla tej funkcji. Wskazówka: jakie są jej
    związku z <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> i <span class="inlinecode"><span class="id" title="var">opposite</span></span>? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Pokaż, że funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> oraz <span class="inlinecode"><span class="id" title="var">opposite</span></span> są injekcjami i
    surjekcjami (co to dokładnie znacz, dowiemy się później). Uwaga: to
    zadanie wymaga użyci taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, która jest opisana w
    podrozdziale o polimorfizmie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnL</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnR</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">opposite</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab236"></a><h4 class="section">Ćwiczenie (różne enumeracje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj typy induktywne reprezentujące:
<ul class="doclist">
<li> dni tygodnia

</li>
<li> miesiące

</li>
<li> kolory podstawowe systemu RGB 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Wymyśl do nich jakieś ciekawe funkcje i twierdzenia. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab237"></a><h2 class="section">Konstruktory rekurencyjne</h2>

<div class="paragraph"> </div>

 Powiedzieliśmy, że termy typów induktywnych są drzewami. W przypadku
    enumeracji jest to słabo widoczne, gdyż drzewa te są zdegenerowane —
    są to po prostu punkciki oznaczone nazwami konstruktorów. Efekt
    rozgałęzienia możemy uzyskać, gdy jeden z konstruktorów będzie
    rekurencyjny, tzn. gdy jako argument będzie przyjmował term typu,
    który właśnie definiujemy. Naszym przykładem będą liczby naturalne
    (choć i tutaj rozgałęzienie będzie nieco zdegenerowane — każdy term
    będzie mógł mieć co najwyżej jedno). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatDef</span>.<br/>

<br/>
</div>

<div class="doc">
Mechanizm modułów jest podobny do mechanizmu sekcji i na razie nie
    będzie nas interesował — użyjemy go, żeby nie zaśmiecać głównej
    przestrzeni nazw (mechanizm sekcji w tym przypadku by nie pomógł). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;0" := <span class="id" title="var">O</span>.<br/>

<br/>
</div>

<div class="doc">
Uwaga: nazwa pierwszego konstruktora to duża litera O, a nie cyfra 0
    — cyfry nie mogą być nazwami. Żeby obejść tę niedogodność, musimy
    posłużyć się mechanizmem notacji — dzięki temu będziemy mogli pisać
    0 zamiast O.

<div class="paragraph"> </div>

    Definicję tę możemy odczytać w następujący sposób: "<span class="inlinecode">0</span> jest liczbą
    naturalną; jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbą naturalną, to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> również jest
    liczbą naturalną". Konstruktor <span class="inlinecode"><span class="id" title="var">S</span></span> odpowiada tutaj dodawaniu jedynki:
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> to 1, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span> to 2, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0))</span> to 3 i tak dalej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0))).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;S&nbsp;(S&nbsp;(S&nbsp;0))&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatDef</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;3&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Ręczne liczenie ilości <span class="inlinecode"><span class="id" title="var">S</span></span> w każdej liczbie szybko staje się trudne
    nawet dla małych liczb. Na szczęście standardowa biblioteka Coqa
    udostępnia notacje, które pozwalają nam zapisywać liczby naturalne
    przy pomocy dobrze znanych nam cyfr arabskich. Żeby uzyskać do nich
    dostęp, musimy opuścić zdefiniowany przez nas moduł <span class="inlinecode"><span class="id" title="var">NatDef</span></span>, żeby
    nasza definicja <span class="inlinecode"><span class="id" title="var">nat</span></span> nie przysłaniała tej bibliotecznej. Zaczniemy
    za to nowy moduł, żebyśmy mogli swobodnie zredefiniować działania
    na liczbach naturalnych z biblioteki standardowej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatOps</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
W zapisie unarnym liczby naturalne możemy wyobrażać sobie jako kupki
    <span class="inlinecode"><span class="id" title="var">S</span></span>-ów, więc dodawanie dwóch liczb sprowadza się do przerzucenia <span class="inlinecode"><span class="id" title="var">S</span></span>-ów
    z jednej kupki na drugą.

<div class="paragraph"> </div>

    Definiowanie funkcji dla typów z konstruktorami rekurencyjnymi
    wygląda podobnie jak dla enumeracji, ale występują drobne różnice:
    jeżeli będziemy używać rekurencji, musimy zaznaczyć to za pomocą
    słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (zamiast wcześniejszego <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>).
    Zauważmy też, że jeżeli funkcja ma wiele argumentów tego samego typu,
    możemy napisać <span class="inlinecode">(<span class="id" title="var">arg1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">argN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span> zamiast dłuższego <span class="inlinecode">(<span class="id" title="var">arg1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>
    <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">argN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>.

<div class="paragraph"> </div>

    Jeżeli konstruktor typu induktywnego bierze jakieś argumenty, to wzorce,
    które go dopasowują, stają się nieco bardziej skomplikowane: poza nazwą
    konstruktora muszą też dopasowywać argumenty — w naszym przypadku używamy
    zmiennej o nazwie <span class="inlinecode"><span class="id" title="var">n'</span></span>, która istnieje tylko lokalnie (tylko we wzorcu
    dopasowania oraz po prawej stronie strzałki <span class="inlinecode">=&gt;</span>).

<div class="paragraph"> </div>

    Naszą funkcję zdefiniowaliśmy przy pomocy najbardziej elementarnego
    rodzaju rekursji, jaki jest dostępny w Coqu: rekursji strukturalnej.
    W przypadku takiej rekursji wywołania rekurencyjne mogą odbywać się
    jedynie na termach strukturalnie mniejszych, niż obecny argument
    główny rekurencji. W naszym przypadku argumentem głównym jest <span class="inlinecode"><span class="id" title="var">n</span></span>
    (bo on jest dopasowywany), zaś rekurencyjnych wywołań dokonujemy na
    <span class="inlinecode"><span class="id" title="var">n'</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. <span class="inlinecode"><span class="id" title="var">n'</span></span> jest strukturalnie mniejszy od <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>,
    gdyż składa się z jednego <span class="inlinecode"><span class="id" title="var">S</span></span> mniej. Jeżeli wyobrazimy sobie nasze
    liczby jako kupki <span class="inlinecode"><span class="id" title="var">S</span></span>-ów, to wywołania rekurencyjne możemy robić
    jedynie po zdjęciu z kupki co najmniej jednego <span class="inlinecode"><span class="id" title="var">S</span></span>. 
<div class="paragraph"> </div>

<a id="lab238"></a><h4 class="section">Ćwiczenie (rekursja niestrukturalna)</h4>

<div class="paragraph"> </div>

 Wymyśl funkcję z liczb naturalnych w liczby naturalne,
    która jest rekurencyjna, ale nie jest strukturalnie rekurencyjna.
    Precyzyjniej pisząc: później okaże się, że wszystkie formy
    rekurencji to tak naprawdę rekursja strukturalna pod przykrywką.
    Wymyśl taką definicję, która na pierwszy rzut oka nie jest
    strukturalnie rekurencyjna. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Podobnie jak w przypadku funkcji <span class="inlinecode"><span class="id" title="var">negb</span></span>, tak i tym razem w celu
    sprawdzenia poprawności naszej definicji spróbujemy udowodnić, że
    posiada ona właściwości, których się spodziewamy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_O_n</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> 0 <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Tak prosty dowód nie powinien nas dziwić — wszakże twierdzenie to
    wynika wprost z definicji (spróbuj zredukować "ręcznie" wyrażenie
    <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O_try1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">f_equal</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem nie jest już tak prosto — <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie wynika z definicji
    przez prostą redukcję, gdyż argumentem głównym funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> jest
    jej pierwszy argument, czyli <span class="inlinecode"><span class="id" title="var">n</span></span>. Żeby móc zredukować to wyrażenie,
    musimy rozbić <span class="inlinecode"><span class="id" title="var">n</span></span>. Pokazanie, że <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> jest trywialne, ale
    drugi przypadek jest już beznadziejny. Ponieważ funkcje zachowują
    równość (czyli <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> implikuje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>), to aby pokazać, że
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, wystarczyć pokazać, że <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> — w ten właśnie sposób
    działa taktyka <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>. Nie pomogła nam ona jednak — po jej
    użyciu mamy do pokazania to samo, co na początku, czyli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Do udowodnienia tego twierdzenia musimy posłużyć się indukcją.
    Indukcja jest sposobem dowodzenia właściwości typów induktywnych
    i funkcji rekurencyjnych, który działa mniej więcej tak: żeby
    udowodnić, że każdy term typu <span class="inlinecode"><span class="id" title="var">A</span></span> posiada własność <span class="inlinecode"><span class="id" title="var">P</span></span>, pokazujemy
    najpierw, że konstruktory nierekurencyjne posiadają tę własność
    dla dowolnych argumentów, a następnie, że konstruktory rekurencyjne
    zachowują tę własność.

<div class="paragraph"> </div>

    W przypadku liczb naturalnych indukcja wygląda tak: żeby pokazać,
    że każda liczba naturalna ma własność <span class="inlinecode"><span class="id" title="var">P</span></span>, najpierw należy
    pokazać, że zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">0</span>, a następnie, że jeżeli zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    to zachodzi także <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. Z tych dwóch reguł możemy zbudować
    dowód na to, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> zachodzi dla dowolnego <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Ten sposób rozumowania możemy zrealizować w Coqu przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. Działa ona podobnie do <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, czyli
    rozbija podany term na konstruktory, ale w przypadku konstruktorów
    rekurencyjnych robi coś jeszcze — daje nam założenie indukcyjne,
    które mówi, że dowodzone przez nas twierdzenie zachodzi dla
    rekurencyjnych argumentów konstruktora. Właśnie tego było nam
    trzeba: założenie indukcyjne pozwala nam dokończyć dowód. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">plus</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm'</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pojedyncza indukcja nie zawsze wystarcza, co obrazuje powyższy przypadek.
    Zauważmy, że przed użyciem <span class="inlinecode"><span class="id" title="tactic">induction</span></span> nie musimy wprowadzać zmiennych
    do kontekstu — taktyka ta robi to sama, podobnie jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>.
    Również podobnie jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, możemy przekazać jej wzorzec, którym
    nadajemy nazwy argumentom konstruktorów, na które rozbijany jest term.

<div class="paragraph"> </div>

    W ogólności wzorzec ma postać <span class="inlinecode">[<span class="id" title="var">a11</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">a1n</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">am1</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">amk</span>]</span>. Pionowa
    kreska oddziela argumenty poszczególnych konstruktorów: <span class="inlinecode"><span class="id" title="var">a11</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">a1n</span></span>
    to argumenty pierwszego konstruktora, zaś <span class="inlinecode"><span class="id" title="var">am1</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">amk</span></span> to argumenty
    m-tego konstruktora. <span class="inlinecode"><span class="id" title="var">nat</span></span> ma dwa konstruktory, z czego pierwszy nie
    bierze argumentów, a drugi bierze jeden, więc nasz wzorzec ma postać
    <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">n'</span>]</span>. Dzięki temu nie musimy polegać na domyślnych nazwach nadawanych
    argumentom przez Coqa, które często wprowadzają zamęt.

<div class="paragraph"> </div>

    Jeżeli damy taktyce <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> nazwę hipotezy lub twierdzenia, którego
    konkluzją jest <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, to zamienia ona w obecnym podcelu wszystkie
    wystąpienia <span class="inlinecode"><span class="id" title="var">a</span></span> na <span class="inlinecode"><span class="id" title="var">b</span></span> oraz generuje tyle podcelów, ile przesłanek ma
    użyta hipoteza lub twierdzenie. W naszym przypadku użyliśmy udowodnionego
    uprzednio twierdzenia <span class="inlinecode"><span class="id" title="var">plus_n_O</span></span>, które nie ma przesłanek, czego efektem
    było po prostu przepisanie <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    Przepisywać możemy też w drugą stronę pisząc <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>. Wtedy jeżeli
    konkluzją danego <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> twierdzenia lub hipotezy jest <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, to
    w celu wszystkie <span class="inlinecode"><span class="id" title="var">b</span></span> zostaną zastąpione przez <span class="inlinecode"><span class="id" title="var">a</span></span>. 
<div class="paragraph"> </div>

<a id="lab239"></a><h4 class="section">Ćwiczenie (mnożenie)</h4>

<div class="paragraph"> </div>

 Zdefiniuj mnożenie i udowodnij jego właściwości. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> 0 <span class="id" title="var">n</span> = 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> <span class="id" title="var">n</span> 0 = 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_1_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> 1 <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_1_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> <span class="id" title="var">n</span> 1 = <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli ćwiczenie było za proste i czytałeś podrozdział o kombinatorach
    taktyk, to spróbuj udowodnić:
<ul class="doclist">
<li> dwa pierwsze twierdzenia używając nie więcej niż 2 taktyk

</li>
<li> trzecie bez użycia indukcji, używając nie więcej niż 4 taktyk

</li>
<li> czwarte używając nie więcej niż 4 taktyk 
</li>
</ul>

<div class="paragraph"> </div>

 Wszystkie dowody powinny być nie dłuższe niż pół linijki. 
<div class="paragraph"> </div>

<a id="lab240"></a><h4 class="section">Ćwiczenie (inne dodawanie)</h4>

<div class="paragraph"> </div>

 Dodawanie można alternatywnie zdefiniować także w sposób przedstawiony
    poniżej. Udowodnij, że ta definicja jest równoważna poprzedniej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">plus'</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_n_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_S</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">m</span> = <span class="id" title="var">S</span> (<span class="id" title="var">plus'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_0_n</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> 0 <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">plus'</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_is_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatOps</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab241"></a><h2 class="section">Typy polimorficzne i właściwości konstruktorów</h2>

<div class="paragraph"> </div>

 Przy pomocy komendy <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> możemy definiować nie tylko typy
    induktywne, ale także rodziny typów induktywnych. Jeżeli taka
    rodzina parametryzowana jest typem, to mamy do czynienia z
    polimorfizmem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">option</span></span> jest rodziną typów, zaś samo <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dla ustalonego <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest typem, który reprezentuje możliwość istnienia wartości typu <span class="inlinecode"><span class="id" title="var">A</span></span>
    (konstruktor <span class="inlinecode"><span class="id" title="var">Some</span></span>) albo i nie (konstruktor <span class="inlinecode"><span class="id" title="var">None</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span> <span class="id" title="var">nat</span> 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;nat&nbsp;5&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">None</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Some</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">None</span> {<span class="id" title="var">A</span>}.<br/>

<br/>
</div>

<div class="doc">
Jak widać typ <span class="inlinecode"><span class="id" title="var">A</span></span>, będący parametrem <span class="inlinecode"><span class="id" title="var">option</span></span>, jest też pierwszym
    argumentem każdego z konstruktorów.
    Pisanie go bywa uciążliwe, ale na szczęście Coq może sam wywnioskować
    jego wartość, jeżeli mu każemy. Komenda <span class="inlinecode"><span class="id" title="var">Arguments</span></span> pozwala nam
    określić, które argumenty mają być domyślne — chcemy, aby argument <span class="inlinecode"><span class="id" title="var">A</span></span>
    był domyślny, gdyż w przypadku konstruktura <span class="inlinecode"><span class="id" title="var">Some</span></span> może być wywnioskowany
    z drugiego argumentu, a w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> — zazwyczaj z kontekstu.

<div class="paragraph"> </div>

    Konstruktory typów induktywnych mają kilka właściwości, o którch
    warto wiedzieć. Po pierwsze, wartości zrobione za pomocą różnych
    konstruktorów są różne. Jest to konieczne, gdyż za pomocą dopasowania
    do wzorca możemy rozróżnić różne konstruktory — gdyby były one
    równe, uzyskalibyśmy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isSome</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">a</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">False</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Pomocnicza funkcja <span class="inlinecode"><span class="id" title="var">isSome</span></span> ma za zadanie sprawdzić, którym
    konstruktorem zrobiono wartość typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span>
    oznacza, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest argumentem domyślnym funkcji — Coq może go
    wywnioskować, gdyż zna typ argumentu <span class="inlinecode"><span class="id" title="var">a</span></span> (jest nim <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).
    Zauważ też, że funkcja ta zwraca zdania logiczne, a nie wartości
    boolowskie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_not_none</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">change</span> <span class="id" title="var">False</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">isSome</span> (@<span class="id" title="var">None</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Możemy użyć tej pomocniczej funkcji, aby udowodnić, że konstruktory
    <span class="inlinecode"><span class="id" title="var">Some</span></span> i <span class="inlinecode"><span class="id" title="var">None</span></span> tworzą różne wartości. Taktyka <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span>
    pozwala nam zamienić term <span class="inlinecode"><span class="id" title="var">t1</span></span> na <span class="inlinecode"><span class="id" title="var">t2</span></span> pod warunkiem, że są one
    konwertowalne (czyli jeden z nich redukuje się do drugiego). W naszym
    wypadku chcemy zastąpić <span class="inlinecode"><span class="id" title="var">False</span></span> przez <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(@<span class="id" title="var">None</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, który
    redukuje się do <span class="inlinecode"><span class="id" title="var">False</span></span> (spróbuj zredukować to wyrażenie ręcznie).

<div class="paragraph"> </div>

    Użycie symbolu <span class="inlinecode">@</span> pozwala nam dla danego wyrażenia zrezygnować z
    próby automatycznego wywnioskowania argumentów domyślnych — w tym
    przypadku Coq nie potrafiłby wywnioskować argumentu dla konstruktora
    <span class="inlinecode"><span class="id" title="var">None</span></span>, więc musimy podać ten argument ręcznie. 

<div class="paragraph"> </div>

    Następnie możemy skorzystać z równania <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>, żeby
    uzyskać cel postaci <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(<span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>. Cel ten redukuje się
    do <span class="inlinecode"><span class="id" title="var">True</span></span>, którego udowodnienie jest trywialne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_not_none'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">inversion</span> 1. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Cała procedura jest dość skomplikowana — w szczególności wymaga
    napisania funkcji pomocniczej. Na szczęście Coq jest w stanie
    sam wywnioskować, że konstruktory są różne. Możemy zrobić to
    przy pomocy znanej nam z poprzedniego rozdziału taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Zapis <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> oznacza: wprowadź zmienne związane przez
    kwantyfikację uniwersaną do kontekstu i użyj taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    na pierwszej przesłance implikacji. W naszym przypadku implikacja
    jest ukryta w definicji negacji: <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">None</span></span> to tak naprawdę
    <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną właściwością konstruktorów jest fakt, że są one injekcjami,
    tzn. jeżeli dwa termy zrobione tymi samymi konstruktorami są równe,
    to argumenty tych konstruktorów też są równe.

<div class="paragraph"> </div>

    Aby skorzystać z tej właściwości w dowodzie, możemy użyć taktyki
    <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, podając jej jako argument nazwę hipotezy. Jeżeli
    hipoteza jest postaci <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">yn</span></span>, to nasz cel <span class="inlinecode"><span class="id" title="var">G</span></span>
    zostanie zastąpiony przez implikację <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">yn</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>.
    Po wprowadzeniu hipotez do kontekstu możemy użyć ich do udowodnienia
    <span class="inlinecode"><span class="id" title="var">G</span></span>, zazwyczaj przy pomocy taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">H</span></span> miało postać <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a cel <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    więc <span class="inlinecode"><span class="id" title="tactic">injection</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> przekształciło cel do postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    który jest trywialny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_inj'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> może nam pomóc również wtedy, kiedy chcemy skorzystać
    z injektywności konstruktorów. W zasadzie jest ona nawet bardziej
    przydatna — działa ona tak jak <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, ale zamiast zostawiać cel w
    postaci <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>, wprowadza ona wygenerowane hipotezy do
    kontekstu, a następnie przepisuje w celu wszystkie, których przepisanie
    jest możliwe. W ten sposób oszczędza nam ona nieco pisania.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">inverson</span></span> <span class="inlinecode">1</span> dodała do kontekstu hipotezę <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    a następnie przepisała ją w celu (który miał postać <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>), dając
    cel postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_inj''</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">injection</span> 1. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyką ułatwiającą pracę z <span class="inlinecode"><span class="id" title="tactic">injection</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> jest <span class="inlinecode"><span class="id" title="tactic">subst</span></span>.
    Taktyka ta wyszukuje w kontekście hipotezy postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>,
    przepisuje je we wszystkich hipotezach w kontekście i celu, w których
    jest to możliwe, a następnie usuwa. Szczególnie często spotykana
    jest kombinacja <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, gdyż <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> często
    generuje sporą ilość hipotez postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, które <span class="inlinecode"><span class="id" title="tactic">subst</span></span> następnie
    "sprząta".

<div class="paragraph"> </div>

    W naszym przypadku hipoteza <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> została przepisana nie tylko
    w celu, dając <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, ale także w hipotezie <span class="inlinecode"><span class="id" title="var">H</span></span>, dając
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
<div class="paragraph"> </div>

<a id="lab242"></a><h4 class="section">Ćwiczenie (zero i jeden)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenie bez używania taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Żeby było trudniej, nie pisz osobnej funkcji pomocniczej — zdefiniuj
    swoją funkcję bezpośrednio w miejscu, w którym chcesz jej użyć.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_not_one</span> : 0 &lt;&gt; 1.<br/>

<br/>
</div>

<div class="doc">
Dwie opisane właściwości, choć pozornie niewinne, a nawet przydatne,
    mają bardzo istotne i daleko idące konsekwencje. Powoduję one na
    przykład, że nie istnieją typy ilorazowe. Dokładne znaczenie tego
    faktu omówimy później, zaś teraz musimy zadowolić się jedynie
    prostym przykładem w formie ćwiczenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">rational</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mk_rational</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">sign</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">numerator</span> <span class="id" title="var">denominator</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">denominator</span> &lt;&gt; 0 -&gt; <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">rational_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> <span class="id" title="var">p'</span> <span class="id" title="var">q</span> <span class="id" title="var">q'</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="var">q</span> &lt;&gt; 0) (<span class="id" title="var">H'</span> : <span class="id" title="var">q'</span> &lt;&gt; 0), <span class="id" title="var">p</span> * <span class="id" title="var">q'</span> = <span class="id" title="var">p'</span> * <span class="id" title="var">q</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mk_rational</span> <span class="id" title="var">s</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">H</span> = <span class="id" title="var">mk_rational</span> <span class="id" title="var">s'</span> <span class="id" title="var">p'</span> <span class="id" title="var">q'</span> <span class="id" title="var">H'</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">rational</span></span> ma reprezentować liczby wymierne. Znak jest typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span> — możemy interpretować, że <span class="inlinecode"><span class="id" title="var">true</span></span> oznacza obecność znaku
    minus, a <span class="inlinecode"><span class="id" title="var">false</span></span> brak znaku. Dwie liczby naturalne będą oznaczać
    kolejno licznik i mianownik, a na końcu żądamy jeszcze dowodu na
    to, że mianownik nie jest zerem.

<div class="paragraph"> </div>

    Oczywiście typ ten sam w sobie niewiele ma wspólnego z liczbami
    wymiernymi — jest to po prostu trójka elementów o typach <span class="inlinecode"><span class="id" title="var">bool</span>,</span>
    <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, z których ostatni nie jest zerem. Żeby rzeczywiście
    reprezentował liczby wymierne musimy zapewnić, że termy, które
    reprezentują te same wartości, są równe, np. 1/2 musi być równa
    2/4.

<div class="paragraph"> </div>

    W tym celu postulujemy aksjomat, który zapewni nam pożądane
    właściwości relacji równości. Komenda <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> pozwala nam
    wymusić istnienie termu pożądanego typu i nadać mu nazwę,
    jednak jest szalenie niebezpieczna — jeżeli zapostulujemy
    aksjomat, który jest sprzeczny, jesteśmy zgubieni.

<div class="paragraph"> </div>

    W takiej sytuacji całe nasze dowodzenie idzie na marne, gdyż
    ze sprzecznego aksjomatu możemy wywnioskować <span class="inlinecode"><span class="id" title="var">False</span></span>, z
    <span class="inlinecode"><span class="id" title="var">False</span></span> zaś możemy wywnioskować cokolwiek, o czym przekonaliśmy
    się w rozdziale pierwszym. Tak też jest w tym przypadku —
    aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny, gdyż łamie zasadę
    injektywności konstruktorów. 
<div class="paragraph"> </div>

<a id="lab243"></a><h4 class="section">Ćwiczenie (niedobry aksjomat)</h4>

<div class="paragraph"> </div>

 Udowodnij, że aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny. Wskazówka: znajdź
    dwie liczby wymierne, które są równe na mocy tego aksjomatu, ale które
    można rozróżnić za pomocą dopasowania do wzorca. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rational_eq_inconsistent</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">rational</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab244"></a><h2 class="section">Listy, czyli parametry + rekursja</h2>

<div class="paragraph"> </div>

 Połączenie funkcji zależnych, konstruktorów rekurencyjnych i
    polimorfizmu pozwala nam na opisywanie (prawie) dowolnych typów.
    Jednym z najbardziej podstawowych i najbardziej przydatnych
    narzędzi w programowaniu funkcyjnym (i w ogóle w życiu) są listy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyList</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Lista przechowuje wartości pewnego ustalonego typu <span class="inlinecode"><span class="id" title="var">A</span></span> (a więc nie
    można np. trzymać w jednej liście jednocześnie wartości typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i
    <span class="inlinecode"><span class="id" title="var">nat</span></span>) i może mieć jedną z dwóch postaci: może być pusta (konstruktor
    <span class="inlinecode"><span class="id" title="var">nil</span></span>) albo składać się z głowy i ogona (konstruktor <span class="inlinecode"><span class="id" title="var">cons</span></span>). Głowa
    listy to wartość typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś jej ogon to inna lista przechowująca
    wartości typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nil</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nil&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">cons</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;cons&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">nil</span>  {<span class="id" title="var">A</span>}.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">cons</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Jak już wspomnieliśmy, jeżeli typ induktywny ma argument (w naszym
    przypadku <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), to argument ten jest też pierwszym argumentem
    każdego z konstruktorów. W przypadku konstruktora <span class="inlinecode"><span class="id" title="var">cons</span></span> podawanie
    argumentu <span class="inlinecode"><span class="id" title="var">A</span></span> jest zbędne, gdyż kolejnym jego argumentem jest wartość
    tego typu. Wobec tego Coq może sam go wywnioskować, jeżeli mu każemy.

<div class="paragraph"> </div>

    Robimy to za pomocą komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span> <span class="inlinecode"><span class="id" title="var">konstruktor</span></span> <span class="inlinecode"><span class="id" title="var">argumenty</span></span>.
    Argumenty w nawiasach kwadratowych Coq będzie traktował jako domyślne,
    a te oznaczone podkreślnikiem trzeba będzie zawsze podawać ręcznie.
    Nazwa argumentu domyślnego musi być taka sama jak w definicji typu
    (w naszym przypadku w definicji <span class="inlinecode"><span class="id" title="var">list</span></span> argument nazywał się <span class="inlinecode"><span class="id" title="var">A</span></span>,
    więc tak też musimy go nazwać używając komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span>). Musimy
    wypisać wszystkie argumenty danego konstruktora — ich ilość możemy
    sprawdzić np. komendą <span class="inlinecode"><span class="id" title="keyword">Check</span></span>.

<div class="paragraph"> </div>

    Warto w tym momencie zauważyć, że Coq zna typy wszystkich termów,
    które zostały skonstruowane — gdyby tak nie było, nie mógłby
    sam uzupełniać argumentów domyślnych, a komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> nie mogłaby
    działać. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;[]" := <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Infix</span> &quot;::" := (<span class="id" title="var">cons</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span> ).<br/>

<br/>
<span class="id" title="keyword">Check</span> [].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[]</span>&nbsp;:&nbsp;list&nbsp;?254&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> 0 :: 1 :: 2 :: <span class="id" title="var">nil</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[0;</span> <span class="inlinecode">1;</span> <span class="inlinecode">2]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Nazwy <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span> są zdecydowanie za długie w porównaniu do swej
    częstości występowania. Dzięki powyższym eleganckim notacjom
    zaoszczędzimy sobie trochę pisania. Jeżeli jednak notacje utrudniają
    nam np. odczytanie celu, który mamy udowodnić, możemy je wyłączyć
    odznaczając w CoqIDE View &gt; Display Notations.

<div class="paragraph"> </div>

    Wynik <span class="inlinecode">[]</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">?254</span> (lub podobny) wyświetlony przez Coqa dla <span class="inlinecode">[]</span>
    mówi nam, że <span class="inlinecode">[]</span> jest listą pewnego ustalonego typu, ale Coq jeszcze
    nie wie, jakiego (bo ma za mało informacji, bo wywnioskować argument
    domyślny konstruktora <span class="inlinecode"><span class="id" title="var">nil</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ]" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">nil</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ; y ; .. ; z ]" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cons</span> <span class="id" title="var">x</span> (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> .. (<span class="id" title="var">cons</span> <span class="id" title="var">z</span> <span class="id" title="var">nil</span>) .. )).<br/>

<br/>
<span class="id" title="keyword">Check</span> [5].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[5]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> [0; 1; 2; 3].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[0;</span> <span class="inlinecode">1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zauważ, że system notacji Coqa jest bardzo silny — ostatnia notacja
    (ta zawierająca <span class="inlinecode">..</span>) jest rekurencyjna. W innych językach tego typu
    notacje są zazwyczaj wbudowane w język i ograniczają się do podstawowych
    typów, takich jak listy właśnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> =&gt; <span class="id" title="var">h</span> :: <span class="id" title="var">app</span> <span class="id" title="var">t</span> <span class="id" title="var">l2</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;l1 ++ l2" := (<span class="id" title="var">app</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
</div>

<div class="doc">
Funkcje na listach możemy definiować analogicznie do funkcji na
    liczbach naturalnych. Zaczniemy od słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>,
    gdyż będziemy potrzebować rekurencji. Pierwszym argumentem naszej
    funkcji będzie typ <span class="inlinecode"><span class="id" title="var">A</span></span> — musimy go wymienić, bo inaczej nie będziemy
    mogli mieć argumentów typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> (pamiętaj, że samo <span class="inlinecode"><span class="id" title="var">list</span></span>
    jest rodziną typów, a nie typem). Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span> oznacza,
    że Coq ma traktować <span class="inlinecode"><span class="id" title="var">A</span></span> jako argument domyślny — jest to szybszy
    sposób, niż użycie komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span>.

<div class="paragraph"> </div>

    Nasz funkcja ma za zadanie dokleić na końcu (ang. append) pierwszej
    listy drugą listę. Definicja jest dość intuicyjna: doklejenie jakiejś
    listy na koniec listy pustej daje pierwszą listę, a doklejenie listy
    na koniec listy mającej głowę i ogon jest doklejeniem jej na koniec
    ogona. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> [1; 2; 3] ++ [4; 5; 6].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Wynik działania naszej funkcji wygląda poprawnie, ale niech cię
    nie zwiodą ładne oczka — jedynym sposobem ustalenia poprawności
    naszego kodu jest udowodnienie, że posiada on pożądane przez
    nas właściwości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), [] ++ <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">l</span> ++ [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHt</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Sposoby dowodzenia są analogiczne jak w przypadku liczb naturalnych.
    Pierwsze twierdzenie zachodzi na mocy samej definicji funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>
    i dowód sprowadza się do wykonania programu za pomocą taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span>.
    Drugie jest analogiczne do twierdzenia <span class="inlinecode"><span class="id" title="var">plus_n_0</span></span>, z tą różnicą, że
    w drugim celu zamiast <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> posłużyliśmy się taktyką <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    Zauważ też, że zmianie uległa postać wzorca przekazanego taktyce
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> — teraz ma on postać <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>]</span>, gdyż <span class="inlinecode"><span class="id" title="var">list</span></span> ma 2
    konstruktory, z których pierwszy, <span class="inlinecode"><span class="id" title="var">nil</span></span>, nie bierze argumentów
    (argumenty domyślne nie są wymieniane we wzorcach), zaś drugi, <span class="inlinecode"><span class="id" title="var">cons</span></span>,
    ma dwa argumenty — głowę, tutaj nazwaną <span class="inlinecode"><span class="id" title="var">h</span></span> (jako skrót od ang. head)
    oraz ogon, tutaj nazwany <span class="inlinecode"><span class="id" title="var">t</span></span> (jako skrót od ang. tail). 
<div class="paragraph"> </div>

<a id="lab245"></a><h4 class="section">Ćwiczenie (właściwości funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe właściwości funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>. Wskazówka: może ci się
    przydać taktyka <span class="inlinecode"><span class="id" title="tactic">specialize</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ <span class="id" title="var">l3</span>) = (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_not_comm</span> :<br/>
&nbsp;&nbsp;~ <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span> = <span class="id" title="var">l2</span> ++ <span class="id" title="var">l1</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab246"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">length</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">length</span></span>, która oblicza długość listy, a następnie
    udowodnij poprawność swojej implementacji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_nil</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">length</span> (@<span class="id" title="var">nil</span> <span class="id" title="var">A</span>) = 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_cons</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">length</span> (<span class="id" title="var">h</span> :: <span class="id" title="var">t</span>) &lt;&gt; 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_app</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l1</span> + <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyList</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab247"></a><h2 class="section">Przydatne komendy</h2>

<div class="paragraph"> </div>

 Czas, aby opisać kilka przydatnych komend. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;unit&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, że komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> wyświetla typ danego jej termu,
    a <span class="inlinecode"><span class="id" title="keyword">Print</span></span> wypisuje jego definicję. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Search</span></span> wyświetla wszystkie obiekty, które zawierają podaną nazwę.
    W naszym przypadku pokazały się wszystkie funkcje, w których
    sygnaturze występuje typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span><span class="id" title="var">Pattern</span> (<span class="id" title="var">_</span> + <span class="id" title="var">_</span> = <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchPattern</span></span> jako argument bierze wzorzec i wyświetla wszystkie
    obiekty, które zawierają podterm pasujący do danego wzorca. W naszym
    przypadku pokazały się twierdzenia, w których występuje podterm
    mający po lewej dodawanie, a po prawej cokolwiek.

<div class="paragraph"> </div>

    Dokładny opis wszystkich komend znajdziesz tutaj:
    https://coq.inria.fr/refman/coq-cmdindex.html 
<div class="paragraph"> </div>

<a id="lab248"></a><h2 class="section">Ważne typy induktywne</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab249"></a><h3 class="section">Typ pusty</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty_set</span> : <span class="id" title="keyword">Set</span> := .<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Empty_set</span></span> jest, jak sama nazwa wskazuje, typem pustym. Żaden term
    nie jest tego typu. Innymi słowy: jeżeli jakiś term jest typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    to mamy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">create</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli mamy term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, to możemy w sposób niemal magiczny
    wyczarować term dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span>, używając dopasowania do wzorca z
    pustym wzorcem. 
<div class="paragraph"> </div>

<a id="lab250"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">create_unique</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij, że powyższa funkcja jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">create_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">Empty_set</span> -&gt; <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>, <span class="id" title="var">create</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab251"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">no_fun_from_nonempty_to_empty</span></span>)</h4>

<div class="paragraph"> </div>

 Pokaż, że nie istnieją funkcje z typu niepustego w pusty. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">no_fun_from_nonempty_to_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>), <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab252"></a><h3 class="section">Singleton</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">unit</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tt</span> : <span class="id" title="var">unit</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">unit</span></span> jest typem, który ma tylko jeden term, zwany <span class="inlinecode"><span class="id" title="var">tt</span></span> (nazwa ta
    jest wzięta z sufitu). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">delete</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">unit</span> := <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest w pewien sposób "dualna" do napotkanej przez
    nas wcześniej funkcji <span class="inlinecode"><span class="id" title="var">create</span></span>. Mając term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span> mogliśmy
    stworzyć term dowolnego innego typu, zaś mając term dowolnego typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>, możemy "zapomnieć o nim" albo "skasować go", wysyłając go
    funkcją <span class="inlinecode"><span class="id" title="var">delete</span></span> w jedyny term typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, czyli <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

    Uwaga: określenie "skasować" nie ma nic wspólnego z fizycznym
    niszczeniem albo dealokacją pamięci. Jest to tylko metafora. 
<div class="paragraph"> </div>

<a id="lab253"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">delete_unique</span></span>)</h4>
 Pokaż, że funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">delete_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">unit</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">delete</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab254"></a><h3 class="section">Produkt</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">prod</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">pair</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">pair</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Produkt typów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termami są pary. Pierwszy
    element pary to term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugi to term typu <span class="inlinecode"><span class="id" title="var">B</span></span>. Tym, co
    charakteryzuje produkt, są projekcje:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">fst</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wyciąga z pary jej
      pierwszy element

</li>
<li> <span class="inlinecode"><span class="id" title="var">snd</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wyciąga z pary jej
      drugi element 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab255"></a><h4 class="section">Ćwiczenie (projekcje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj projekcje i udowodnij poprawność swoich definicji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">proj_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> = <span class="id" title="var">pair</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab256"></a><h3 class="section">Suma</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sum</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inl</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inr</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">inl</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">inr</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Suma <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termy są albo termami typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    zawiniętymi w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span>, albo termami typu <span class="inlinecode"><span class="id" title="var">B</span></span>, zawiniętymi
    w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Suma, w przeciwieństwie do produktu, zdecydowanie
    nie ma projekcji. 
<div class="paragraph"> </div>

<a id="lab257"></a><h4 class="section">Ćwiczenie (sumy bez projekcji)</h4>

<div class="paragraph"> </div>

 Pokaż, że suma nie ma projekcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">sum_no_fst</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">sum_no_snd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab258"></a><h2 class="section">Kiedy typ induktywny jest pusty?</h2>

<div class="paragraph"> </div>

 Typy puste to typy, które nie mają żadnych elementów. Z jednym z nich
    już się spotkaliśmy — był to <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, który jest pusty, gdyż nie
    ma żadnych konstruktorów. Czy wszystkie typy puste to typy, które
    nie mają konstruktorów? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c</span> : <span class="id" title="var">Empty_set</span> -&gt; <span class="id" title="var">Empty</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Empty_is_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">empty</span> : <span class="id" title="var">Empty</span>, <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">empty</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Okazuje się, że nie. Pustość i niepustość jest kwestią czegoś więcej,
    niż tylko ilości konstruktorów. Powyższy przykład pokazuje dobitnie,
    że ważne są też typy argumentów konstruktorów. Jeżeli typ któregoś z
    argumentów konstruktora jest pusty, to nie można użyć go do zrobienia
    żadnego termu. Jeżeli każdy konstruktor typu <span class="inlinecode"><span class="id" title="var">T</span></span> ma argument, którego
    typ jest pusty, to sam typ <span class="inlinecode"><span class="id" title="var">T</span></span> również jest pusty.

<div class="paragraph"> </div>

    Wobec powyższych rozważań możemy sformułować następujące kryterium:
    typ <span class="inlinecode"><span class="id" title="var">T</span></span> jest niepusty, jeżeli ma co najmniej jeden konstruktor, który
    nie bierze argumentów, których typy są puste. Jakkolwiek jest to bardzo
    dobre kryterium, to jednak nie rozwiewa ono niestety wszystkich możliwych
    wątpliwości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">InfiniteList</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">InfiniteCons</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">InfiniteList</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">InfiniteList</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Czy typ <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest niepusty? Skorzystajmy z naszego kryterium:
    ma on jeden konstruktor biorący dwa argumenty, jeden typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz drugi
    typu <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. W zależności od tego, czym jest <span class="inlinecode"><span class="id" title="var">A</span></span>, może on być
    pusty lub nie — przyjmijmy, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest niepusty. W przypadku drugiego
    argumentu napotykamy jednak na problem: to, czy <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest
    niepusty zależy od tego, czy typ argumentu jego konstruktora, również
    <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, jest niepusty. Sytuacja jest więc beznadziejna — mamy
    błędne koło.

<div class="paragraph"> </div>

    Powyższy przykład pokazuje, że nasze kryterium może nie poradzić sobie
    z rekurencją. Jak zatem rozstrzygnąć, czy typ ten jest niepusty? Musimy
    odwołać się bezpośrednio do definicji i zastanowić się, czy możliwe jest
    skonstruowanie jakichś jego termów. W tym celu przypomnijmy, czym są typy
    induktywne:
<ul class="doclist">
<li> Typ induktywny to rodzaj planu, który pokazuje, w jaki sposób można
      konstruować jego termy, które są drzewami.

</li>
<li> Konstruktory to węzły drzewa. Ich nazwy oraz ilość i typy argumentów
      nadają drzewu kształt i znaczenie.

</li>
<li> Konstruktory nierekurencyjne to liście drzewa.

</li>
<li> Konstruktory rekurencyjne to węzły wewnętrzne drzewa. 
</li>
</ul>

<div class="paragraph"> </div>

 Kluczowym faktem jest rozmiar termów: o ile rozgałęzienia mogą być
    potencjalnie nieskończone, o tyle wszystkie gałęzie muszą mieć
    skończoną długość. Pociąga to za sobą bardzo istotny fakt: typy
    mające jedynie konstruktory rekurencyjne są puste, gdyż bez użycia
    konstruktorów nierekurencyjnych możemy konstruować jedynie drzewa
    nieskończone (i to tylko przy nierealnym założeniu, że możliwe jest
    zakończenie konstrukcji liczącej sobie nieskończoność kroków). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">InfiniteList_is_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">InfiniteList</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span> <span class="id" title="var">t</span>]. <span class="id" title="tactic">exact</span> <span class="id" title="var">IHt</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pokazanie, że <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, jest bardzo proste —
    wystarczy posłużyć się indukcją. Indukcja po <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    daje nam hipotezę indukcyjną <span class="inlinecode"><span class="id" title="var">IHt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, której możemy użyć,
    aby natychmiast zakończyć dowód.

<div class="paragraph"> </div>

    Zaraz, co właściwie się stało? Dlaczego dostaliśmy zupełnie za darmo
    hipotezę <span class="inlinecode"><span class="id" title="var">IHt</span></span>, która jest szukanym przez nas dowodem? W ten właśnie
    sposób przeprowadza się dowody indukcyjne: zakładamy, że hipoteza <span class="inlinecode"><span class="id" title="var">P</span></span>
    zachodzi dla termu <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a następnie musimy pokazać,
    że <span class="inlinecode"><span class="id" title="var">P</span></span> zachodzi także dla termu <span class="inlinecode"><span class="id" title="var">InfiniteCons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. Zazwyczaj <span class="inlinecode"><span class="id" title="var">P</span></span> jest
    predykatem i wykonanie kroku indukcyjnego jest nietrywialne, w naszym
    przypadku jest jednak inaczej — postać <span class="inlinecode"><span class="id" title="var">P</span></span> jest taka sama dla <span class="inlinecode"><span class="id" title="var">t</span></span> oraz
    dla <span class="inlinecode"><span class="id" title="var">InfiniteCons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> i jest nią <span class="inlinecode"><span class="id" title="var">False</span></span>.

<div class="paragraph"> </div>

    Czy ten konfundujący fakt nie oznacza jednak, że <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, czyli typ
    zwykłych list, również jest pusty? Spróbujmy pokazać, że tak jest. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">list_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;2: { <span class="id" title="tactic">exact</span> <span class="id" title="var">IHt</span>. }<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pokazanie, że typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, jest rzecz jasna niemożliwe,
    gdyż typ ten zdecydowanie pusty nie jest — w jego definicji stoi
    jak byk napisane, że dla dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span> istnieje lista termów
    typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Jest nią oczywiście <span class="inlinecode">@<span class="id" title="var">nil</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Przyjrzyjmy się naszej próbie dowodu. Próbujemy posłużyć się indukcją
    w ten sam sposób co poprzednio. Taktyka <span class="inlinecode"><span class="id" title="tactic">induction</span></span> generuje nam dwa
    podcele, gdyż <span class="inlinecode"><span class="id" title="var">list</span></span> ma dwa konstruktory — pierwszy podcel dla <span class="inlinecode"><span class="id" title="var">nil</span></span>,
    a drugi dla <span class="inlinecode"><span class="id" title="var">cons</span></span>. Komenda <span class="inlinecode"><span class="id" title="var">n</span>:</span> <span class="inlinecode">{</span> <span class="inlinecode">...</span> <span class="inlinecode">}</span> pozwala nam przełączyć się do
    n-tego celu (w naszym przypadku celu nr 2, czyli gdy <span class="inlinecode"><span class="id" title="var">l</span></span> jest postaci
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>). Uwaga: przestarzałym sposobem na przełączanie celów jest
    komenda <span class="inlinecode"><span class="id" title="var">Focus</span></span> - jeżeli zobaczysz gdzieś jej użycie, to znaczy, że po
    prostu zapomniałem tego poprawić.

<div class="paragraph"> </div>

    Sprawa wygląda identycznie jak poprzednio — za darmo dostajemy hipotezę
    <span class="inlinecode"><span class="id" title="var">IHt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, której używamy do natychmiastowego rozwiązania naszego
    celu. Tym, co stanowi przeszkodę nie do pokonania, jest cel nr 1, czyli
    gdy <span class="inlinecode"><span class="id" title="var">l</span></span> zrobiono za pomocą konstruktora <span class="inlinecode"><span class="id" title="var">nil</span></span>. Ten konstruktor nie jest
    rekurencyjny, więc nie dostajemy żadnej hipotezy indukcyjnej. Lista <span class="inlinecode"><span class="id" title="var">l</span></span>
    zostaje w każdym miejscu, w którym występuje, zastąpiona przez <span class="inlinecode">[]</span>, a
    ponieważ nie występuje nigdzie — znika. Musimy teraz udowodnić fałsz
    wiedząc jedynie, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem, co jest niemożliwe. 
<div class="paragraph"> </div>

<a id="lab259"></a><h1 class="section">Induktywne zdania i predykaty</h1>

<div class="paragraph"> </div>

 Wiemy, że słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pozwala nam definiować nowe typy
    (a nawet rodziny typów, jak w przypadku <span class="inlinecode"><span class="id" title="var">option</span></span>). Wiemy też, że zdania
    są typami. Wobec tego nie powinno nas dziwić, że induktywnie możemy
    definiować także zdania, spójniki logiczne, predykaty oraz relacje. 
<div class="paragraph"> </div>

<a id="lab260"></a><h2 class="section">Induktywne zdania</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">false_prop</span> : <span class="id" title="keyword">Prop</span> := .<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">true_prop</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">obvious_proof</span> : <span class="id" title="var">true_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tricky_proof</span> : <span class="id" title="var">true_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">weird_proof</span> : <span class="id" title="var">true_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">magical_proof</span> : <span class="id" title="var">true_prop</span>.<br/>

<br/>
</div>

<div class="doc">
Induktywne definicje zdań nie są zbyt ciekawe, gdyż pozwalają definiować
    jedynie zdania fałszywe (zero konstruktorów) lub prawdziwe (jeden lub
    więcej konstruktorów). Pierwsze z naszych zdań jest fałszywe (a więc
    rónoważne z <span class="inlinecode"><span class="id" title="var">False</span></span>), drugie zaś jest prawdziwe (czyli równoważne z <span class="inlinecode"><span class="id" title="var">True</span></span>)
    i to na cztery sposoby! 
<div class="paragraph"> </div>

<a id="lab261"></a><h4 class="section">Ćwiczenie (induktywne zdania)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">false_prop_iff_False</span> : <span class="id" title="var">false_prop</span> &lt;-&gt; <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">true_prop_iff_True</span> : <span class="id" title="var">true_prop</span> &lt;-&gt; <span class="id" title="var">True</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab262"></a><h2 class="section">Induktywne predykaty</h2>

<div class="paragraph"> </div>

 Przypomnijmy, że predykaty to funkcje, których przeciwdziedziną jest
    sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, czyli funkcje zwracające zdania logiczne. Predykat
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> można rozumieć jako właściwość, którą mogą posiadać
    termy typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś dla konkretnego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> zapis <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> interpretować
    można "term <span class="inlinecode"><span class="id" title="var">x</span></span> posiada właściwóść <span class="inlinecode"><span class="id" title="var">P</span></span>".

<div class="paragraph"> </div>

    O ile istnieją tylko dwa rodzaje induktwynych zdań (prawdziwe i fałszywe),
    o tyle induktywnie zdefiniowane predykaty są dużo bardziej ciekawe i
    użyteczne, gdyż dla jednych termów mogą być prawdziwe, a dla innych nie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenSS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
Predykat <span class="inlinecode"><span class="id" title="var">even</span></span> ma oznaczać właściwość "bycia liczbą parzystą". Jego
    definicję można zinterpretować tak:
<ul class="doclist">
<li> "<span class="inlinecode">0</span> jest liczbą przystą"

</li>
<li> "jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbą parzystą, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> również jest
       liczbą parzystą" 
</li>
</ul>

<div class="paragraph"> </div>

 Jak widać, induktywna definicja parzystości różni się od powszechnie
    używanej definicji, która głosi, że "liczba jest parzysta, gdy
    dzieli się bez reszty przez 2". Różnica jest natury filozoficznej:
    definicja induktywna mówi, jak konstruować liczby parzyste, podczas
    gdy druga, "klasyczna" definicja mówi, jak sprawdzić, czy liczba
    jest parzysta.

<div class="paragraph"> </div>

    Przez wzgląd na swą konstruktywność, w Coqu induktywne definicje
    predykatów czy relacji są często dużo bardziej użyteczne od tych
    nieinduktywnych, choć nie wszystko można zdefiniować induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_is_even</span> : <span class="id" title="var">even</span> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">even0</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak możemy udowodnić, że <span class="inlinecode">0</span> jest liczbą parzystą? Posłuży nam
    do tego konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>, który wprost głosi, że <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>.
    Nie daj się zwieść: <span class="inlinecode"><span class="id" title="var">even0</span></span>, pisane bez spacji, jest nazwą
    konstruktora, podczas gdy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>, ze spacją, jest zdaniem
    (czyli termem typu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), które można interpretować jako
    "<span class="inlinecode">0</span> jest liczbą parzystą". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">two_is_even</span> : <span class="id" title="var">even</span> 2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">evenSS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even0</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak możemy udowodnić, że <span class="inlinecode">2</span> jest parzyste? Konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>
    nam nie pomoże, gdyż jego postać (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>) nie pasuje do postaci
    naszego twierdzenia (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">2</span>). Pozostaje nam jednak konstruktor
    <span class="inlinecode"><span class="id" title="var">evenSS</span></span>.

<div class="paragraph"> </div>

    Jeżeli przypomnimy sobie, że <span class="inlinecode">2</span> to tak naprawdę <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>,
    natychmiast dostrzeżemy, że jego konkluzja pasuje do postaci naszego
    twierdzenia. Możemy go więc zaaplikować (pamiętaj, że konstruktory są
    jak zwykłe funkcje, tylko że niczego nie obliczają — nadają one typom
    ich kształty). Teraz wystarczy pokazać, że <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span> zachodzi, co już
    potrafimy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">four_is_even</span> : <span class="id" title="var">even</span> 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak pokazać, że <span class="inlinecode">4</span> jest parzyste? Tą samą metodą, która pokazaliśmy,
    że <span class="inlinecode">2</span> jest parzyste. <span class="inlinecode">4</span> to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span>, więc możemy użyć
    konstruktora <span class="inlinecode"><span class="id" title="var">evenSS</span></span>. Zamiast jednak pisać <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, możemy
    użyć taktyki <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>. Taktyka ta działa na celach, w których
    chcemy skonstruować wartość jakiegoś typu induktywnego (a więc także
    gdy dowodzimy twierdzeń o induktywnych predykatach). Szuka ona
    konstruktora, który może zaaplikować na celu, i jeżeli znajdzie, to
    aplikuje go, a gdy nie — zawodzi.

<div class="paragraph"> </div>

    W naszym przypadku pierwsze dwa użycia <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> aplikują
    konstruktor <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, a trzecie — konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">the_answer_is_even</span> : <span class="id" title="var">even</span> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A co, gdy chcemy pokazać, że <span class="inlinecode">42</span> jest parzyste? Czy musimy 22 razy
    napisać <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>? Na szczęście nie — wystarczy posłużyć się
    kombinatorem <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> (jeżeli nie pamiętasz, jak działa, zajrzyj do
    rozdziału 1). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">one_not_even_failed</span> : ~ <span class="id" title="var">even</span> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">one_not_even</span> : ~ <span class="id" title="var">even</span> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A jak pokazać, że <span class="inlinecode">1</span> nie jest parzyste? Mając w kontekście dowód
    na to, że <span class="inlinecode">1</span> jest parzyste (<span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span>), możemy zastantowić się,
    w jaki sposób dowód ten został zrobiony. Nie mógł zostać zrobiony
    konstruktorem <span class="inlinecode"><span class="id" title="var">even0</span></span>, gdyż ten dowodzi, że <span class="inlinecode">0</span> jest parzyste, a
    przecież przekonaliśmy się już, że <span class="inlinecode">0</span> to nie <span class="inlinecode">1</span>. Nie mógł też
    zostać zrobiony konstruktorem <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyż ten ma w konkluzji
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>, podczas gdy <span class="inlinecode">1</span> jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> — nie pasuje
    on do konkluzji <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyż "ma za mało <span class="inlinecode"><span class="id" title="var">S</span></span>ów".

<div class="paragraph"> </div>

    Nasze rozumowanie prowadzi do wniosku, że za pomocą <span class="inlinecode"><span class="id" title="var">even0</span></span> i <span class="inlinecode"><span class="id" title="var">evenSS</span></span>,
    które są jedynymi konstruktorami <span class="inlinecode"><span class="id" title="var">even</span></span>, nie można skonstruować <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span>,
    więc <span class="inlinecode">1</span> nie może być parzyste. Na podstawie wcześniejszych doświadczeń
    mogłoby się nam wydawać, że <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> załatwi sprawę, jednak tak nie
    jest — taktyka ta jest w tym przypadku upośledzona i nie potrafi nam
    pomóc. Zamiast tego możemy się posłużyć taktyką <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>. Działa ona
    dokładnie w sposób opisany w poprzednim akapicie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">three_not_even</span> : ~ <span class="id" title="var">even</span> 3.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak pokazać, że <span class="inlinecode">3</span> nie jest parzyste? Pomoże nam w tym, jak poprzednio,
    inwersja. Tym razem jednak nie załatwia ona sprawy od razu. Jeżeli
    zastanowimy się, jak można pokazać <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">3</span>, to dojdziemy do wniosku,
    że można to zrobić konstruktorem <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyż <span class="inlinecode">3</span> to tak naprawdę
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">1)</span>. To właśnie robi pierwsza inwersja: mówi nam, że <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">3</span>
    można uzyskać z zaaplikowania <span class="inlinecode"><span class="id" title="var">evenSS</span></span> do <span class="inlinecode">1</span>, jeżeli tylko mamy dowód
    <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span> na to, że <span class="inlinecode">1</span> jest parzyste. Jak pokazać, że <span class="inlinecode">1</span> nie
    jest parzyste, już wiemy. 
<div class="paragraph"> </div>

<a id="lab263"></a><h4 class="section">Ćwiczenie (odd)</h4>

<div class="paragraph"> </div>

 Zdefiniuj induktywny predykat <span class="inlinecode"><span class="id" title="var">odd</span></span>, który ma oznaczać "bycie liczbą
    nieparzystą" i udowodnij, że zachowuje się on jak należy. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">one_odd</span> : <span class="id" title="var">odd</span> 1.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">seven_odd</span> : <span class="id" title="var">odd</span> 7.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_not_odd</span> : ~ <span class="id" title="var">odd</span> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">two_not_odd</span> : ~ <span class="id" title="var">odd</span> 2.<br/>

<br/>
</div>

<div class="doc">
<a id="lab264"></a><h2 class="section">Indukcja po dowodzie</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
</div>

<div class="doc">
Biblioteka <span class="inlinecode"><span class="id" title="var">Arith</span></span> zawiera różne definicje i twierdzenia dotyczące
    arytmetyki. Będzie nam ona potrzebna w tym podrozdziale.

<div class="paragraph"> </div>

    Jak udowodnić, że suma liczb parzystych jest parzysta? Być może
    właśnie pomyślałeś o indukcji. Spróbujmy zatem: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_sum_failed1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Próbując jednak indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a potem po <span class="inlinecode"><span class="id" title="var">m</span></span>, docieramy do martwego
    punktu. Musimy udowodnić <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, podczas gdy zachodzi <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>
    (czyli <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest fałszywe). Wynika to z faktu, że przy indukcji
    <span class="inlinecode"><span class="id" title="var">n</span></span> zwiększa się o 1 (<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>), podczas gdy w definicji
    <span class="inlinecode"><span class="id" title="var">even</span></span> mamy konstruktor głoszący, że (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>).

<div class="paragraph"> </div>

    Być może w drugiej kolejności pomyślałeś o taktyce <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>: jeżeli
    sprawdzimy, w jaki sposób udowodniono <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, to przy okazji dowiemy
    się też, że <span class="inlinecode"><span class="id" title="var">n</span></span> może być jedynie postaci <span class="inlinecode">0</span> lub <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>. Dzięki
    temu powinniśmy uniknąć problemu z poprzedniej próby. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_sum_failed2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hn</span>, <span class="id" title="var">Hm</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety, taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> okazała się za słaba. Predykat <span class="inlinecode"><span class="id" title="var">even</span></span> jest
    induktywny, a zatem bez indukcji się nie obędzie. Rozwiązaniem naszych
    problemów nie będzie jednak indukcja po <span class="inlinecode"><span class="id" title="var">n</span></span> lub <span class="inlinecode"><span class="id" title="var">m</span></span>, lecz po dowodzie na
    to, że <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_sum</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">Hn</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">Hn'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja po dowodzie działa dokładnie tak samo, jak indukcja, z którą
    zetknęliśmy się dotychczas. Różni się od niej jedynie tym, że aż do
    teraz robiliśmy indukcję jedynie po termach, których typy były sortu
    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Indukcja po dowodzie to indukcja po termie, którego
    typ jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku użycie <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">Hn</span></span> ma następujący skutek:
<ul class="doclist">
<li> W pierwszym przypadku <span class="inlinecode"><span class="id" title="var">Hn</span></span> to po prostu konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>, a 
      zatem <span class="inlinecode"><span class="id" title="var">n</span></span> jest zerem.

</li>
<li> W drugim przypadku <span class="inlinecode"><span class="id" title="var">Hn</span></span> to <span class="inlinecode"><span class="id" title="var">evenSS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">Hn'</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> jest postaci
      <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, zaś <span class="inlinecode"><span class="id" title="var">Hn'</span></span> jest dowodem na to, że <span class="inlinecode"><span class="id" title="var">n'</span></span> jest parzyste. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab265"></a><h3 class="section">Taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span> i <span class="inlinecode"><span class="id" title="tactic">assert</span></span>.</h3>

<div class="paragraph"> </div>

 Przy następnych ćwiczeniach mogą przydać ci się taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">assert</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">stupid_example_replace</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">replace</span> (<span class="id" title="var">n</span> + 0) <span class="id" title="keyword">with</span> (0 + <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">plus_comm</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> pozwala nam zastąpić w celu każde
    wystąpienie termu <span class="inlinecode"><span class="id" title="var">t</span></span> termem <span class="inlinecode"><span class="id" title="var">t'</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span> nie ma w celu, to
    taktyka zawodzi, a w przeciwnym wypadku dodaje nam jeden podcel,
    w którym musimy udowodnić, że <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t'</span></span>. Można też zastosować ją
    w hipotezie, pisząc <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">stupid_example_assert</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + 0 + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">plus_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> dodaje do kontekstu term <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz
    generuje jeden dodatkowy podcel, w którym musimy skonstruować <span class="inlinecode"><span class="id" title="var">x</span></span>.
    Zawodzi ona, jeżeli nazwa <span class="inlinecode"><span class="id" title="var">x</span></span> jest już zajęta. 
<div class="paragraph"> </div>

<a id="lab266"></a><h4 class="section">Ćwiczenie (właściwości <span class="inlinecode"><span class="id" title="var">even</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenia. Zanim zaczniesz, zastanów się, po czym
    należy przeprowadzić indukcję: po wartości, czy po dowodzie? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">double_is_even</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> (2 * <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_is_double</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="tactic">exists</span> <span class="id" title="var">k</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 2 * <span class="id" title="var">k</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab267"></a><h2 class="section">Definicje stałych i spójników logicznych</h2>

<div class="paragraph"> </div>

 W rozdziale pierwszym dowiedzieliśmy się, że produkt zależny (typ,
    którego termami są funkcje zależne), a więc i implikacja, jest
    typem podstawowym/wbudowanym oraz że negacja jest zdefiniowana jako
    implikowanie fałszu. Teraz, gdy wiemy już co nieco o typach induktywnych,
    nadszedł czas by zapoznać się z definicjami spójników logicznych (i nie
    tylko). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyConnectives</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab268"></a><h3 class="section">Prawda i fałsz</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">False</span> : <span class="id" title="keyword">Prop</span> := .<br/>

<br/>
</div>

<div class="doc">
Fałsz nie ma żadnych konstruktorów, a zatem nie może zostać w żaden
    sposób skonstruowany, czyli udowodniony. Jego definicja jest bliźniaczo
    podobna do czegoś, co już kiedyś widzieliśmy — tym czymś był <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    czyli typ pusty. Nie jest to wcale przypadek. Natknęliśmy się (znowu) na
    przykład korespondencji Curry'ego-Howarda.

<div class="paragraph"> </div>

    Przypomnijmy, że głosi ona (w sporym uproszczeniu), iż sorty <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    i <span class="inlinecode"><span class="id" title="keyword">Set</span></span>/<span class="inlinecode"><span class="id" title="keyword">Type</span></span> są do siebie bardzo podobne. Jednym z tych podobieństw
    było to, że dowody implikacji są funkcjami. Kolejnym jest fakt, że
    <span class="inlinecode"><span class="id" title="var">False</span></span> jest odpowiednikiem <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, od którego różni się tym, że
    żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Ta definicja rzuca też trochę światła na sposób wnioskowania "ex falso
    quodlibet" (z fałszu wynika wszystko), który poznaliśmy w rozdziale
    pierwszym.

<div class="paragraph"> </div>

    Użycie taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> lub <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> na termie dowolnego typu
    induktywnego to sprawdzenie, którym konstruktorem term ten został
    zrobiony — generują one dokładnie tyle podcelów, ile jest możliwych
    konstruktorów. Użycie ich na termie typu <span class="inlinecode"><span class="id" title="var">False</span></span> generuje zero
    podcelów, co ma efekt natychmiastowego zakończenia dowodu. Dzięki
    temu mając dowód <span class="inlinecode"><span class="id" title="var">False</span></span> możemy udowodnić cokolwiek. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">True</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">I</span> : <span class="id" title="var">True</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">True</span></span> jest odpowiednikiem <span class="inlinecode"><span class="id" title="var">unit</span></span>, od którego różni się tym, że żyje
    w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Ma dokładnie jeden dowód, który w Coqu
    nazwano, z zupełnie nieznanych powodów (zapewne dla hecy), <span class="inlinecode"><span class="id" title="var">I</span></span>. 
<div class="paragraph"> </div>

<a id="lab269"></a><h3 class="section">Koniunkcja i dysjunkcja</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">and</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">conj</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód koniunkcji zdań <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> to para dowodów: pierwszy element
    pary jest dowodem <span class="inlinecode"><span class="id" title="var">P</span></span>, zaś drugi dowodem <span class="inlinecode"><span class="id" title="var">Q</span></span>. Koniunkcja jest
    odpowiednkiem produktu, od którego różni się tym, że żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    a nie w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">or</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> : <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód dysjunkcji zdań <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> to dowód <span class="inlinecode"><span class="id" title="var">P</span></span> albo dowód <span class="inlinecode"><span class="id" title="var">Q</span></span> wraz ze
    wskazaniem, którego zdania jest to dowód. Dysjunkcja jest odpowiednikiem
    sumy, od której różni się tym, że żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyConnectives</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab270"></a><h2 class="section">Równość</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyEq</span>.<br/>

<br/>
</div>

<div class="doc">
Czym jest równość? To pytanie stawiało sobie wielu filozofów,
    szczególnie politycznych, zaś wyjątkowo rzadko nad tą sprawą
    zastanawiali się sami bojownicy o równość, tak jakby wszystko
    dokładnie wiedzieli. Odpowiedź na nie jest jednym z największych
    osiągnięć matematyki w dziejach: równość to jeden z typów induktywnych,
    które możemy zdefiniować w Coqu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">eq</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">eq_refl</span> : <span class="id" title="var">eq</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Spróbujmy przeczytać tę definicję: dla danego typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz termu
    <span class="inlinecode"><span class="id" title="var">x</span></span> tego typu, <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> jest predykatem, który ma jeden konstruktor
    głoszący, że <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zachodzi. Choć definicja taka brzmi obco i
    dziwacznie, ma ona swoje uzasadnienie (które niestety poznamy
    dopiero w przyszłości). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_trivial</span> : <span class="id" title="var">eq</span> 42 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Poznane przez nas dotychczas taktyki potrafiące udowadniać proste
    równości, jak <span class="inlinecode"><span class="id" title="tactic">trivial</span></span> czy <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> działają w ten sposób,
    że po prostu aplikują na celu <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>. Nazwa <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> to skrót
    od ang. "reflexivity of equality", czyli "zwrotność równości" —
    jest to najważniejsza cecha równości, która oznacza, że każdy term
    jest równy samemu sobie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_nontrivial</span> : <span class="id" title="var">eq</span> (1 + 41) 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby wydawać się, że zwrotność nie wystarcza do udowadniania
    "nietrywialnych" równości pokroju <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">41</span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>, jednak tak nie jest.
    Dlaczego <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> odnosi na tym celu sukces skoro <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">41</span> oraz <span class="inlinecode">42</span>
    zdecydowanie różnią się postacią? Odpowiedź jest prosta: typ <span class="inlinecode"><span class="id" title="var">eq</span></span> w
    rzeczywistości owija jedynie równość pierwotną, wbudowaną w samo jądro
    Coqa, którą jest konwertowalność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_alpha</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">eq</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">change</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>) <span class="id" title="keyword">with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_beta</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">eq</span> ((<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">n</span> + <span class="id" title="var">n</span>) <span class="id" title="var">m</span>) (<span class="id" title="var">m</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ultimate_answer</span> : <span class="id" title="var">nat</span> := 42.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_delta</span> : <span class="id" title="var">eq</span> <span class="id" title="var">ultimate_answer</span> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ultimate_answer</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_iota</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">eq</span> 42 (<span class="id" title="keyword">match</span> 0 <span class="id" title="keyword">with</span> | 0 =&gt; 42 | <span class="id" title="var">_</span> =&gt; 13 <span class="id" title="keyword">end</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_zeta</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := 42 <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span> <span class="id" title="var">n</span> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, co już wiemy o redukcjach:
<ul class="doclist">
<li> konwersja alfa pozwala nam zmienić nazwę zmiennej związanej w
      funkcji anonimowej nową, jeżeli ta nie jest jeszcze używana.
      W naszym przykładzie zamieniamy <span class="inlinecode"><span class="id" title="var">x</span></span> w <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span>,
      otrzymując <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">y</span></span> — konwersja jest legalna. Jednak
      w funkcji <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">x</span></span> nie możemy użyć konwersji
      alfa, żeby zmienić nazwę <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span>, bo <span class="inlinecode"><span class="id" title="var">y</span></span> jest już używana
      (tak nazywa się drugi argument).

</li>
<li> Redukcja beta zastępuje argumentem każde wystąpienie zmiennej
      związanej w funkcji anonimowej. W naszym przypadku redukcja
      ta zamienia <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span> na <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> — w miejsce
      <span class="inlinecode"><span class="id" title="var">n</span></span> wstawiamy <span class="inlinecode"><span class="id" title="var">m</span></span>.

</li>
<li> Redukcja delta odwija definicje. W naszym przypadku zdefiniowaliśmy,
      że <span class="inlinecode"><span class="id" title="var">ultimate_answer</span></span> oznacza <span class="inlinecode">42</span>, więc redukcja delta w miejsce
      <span class="inlinecode"><span class="id" title="var">ultimate_answer</span></span> wstawia <span class="inlinecode">42</span>.

</li>
<li> Redukcja jota wykonuje dopasowanie do wzorca. W naszym przypadku <span class="inlinecode">0</span>
      jest termem, który postać jest znana (został on skonstruowany
      konstruktorem <span class="inlinecode">0</span>) i który pasuje do wzorca <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">42</span>, a zatem
      redukcja jota zamienia całe wyrażenie od <span class="inlinecode"><span class="id" title="keyword">match</span></span> aż do <span class="inlinecode"><span class="id" title="keyword">end</span></span>
      na <span class="inlinecode">42</span>.

</li>
<li> Redukcja zeta odwija lokalną definicję poczynioną za pomocą <span class="inlinecode"><span class="id" title="keyword">let</span></span>a 
</li>
</ul>

<div class="paragraph"> </div>

 Termy <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> są konwertowalne, gdy za pomocą serii konwersji alfa
    oraz redukcji beta, delta, jota i zeta oba redukują się do tego samego
    termu (który dzięki silnej normalizacji istnieje i jest w postaci
    kanonicznej).

<div class="paragraph"> </div>

    Uważny czytelnik zada sobie w tym momencie pytanie: skoro równość to
    konwertowalność, to jakim cudem równe są termy <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span>,
    gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> jest zmienną, które przecież nie są konwertowalne?

<div class="paragraph"> </div>

    Trzeba tutaj dokonać pewnego doprecyzowania. Termy <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> są
    konwertowalne dla każdego konkretnego <span class="inlinecode"><span class="id" title="var">n</span></span>, np. <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">42</span> i <span class="inlinecode">42</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> są
    konwertowalne. Konwertowalne nie są natomiast, gdy <span class="inlinecode"><span class="id" title="var">n</span></span> jest zmienną -
    jest tak dlatego, że nie możemy wykonać redukcji iota, bo nie wiemy, czy
    <span class="inlinecode"><span class="id" title="var">n</span></span> jest zerem czy następnikiem.

<div class="paragraph"> </div>

    Odpowiedzią na pytanie są reguły eliminacji, głównie dla typów
    induktywnych. Reguły te mają konkluzje postaci <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>,
    więc w szczególności możemy użyć ich dla <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> dla jakiegoś
    <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Dzięki nim przeprowadzaliśmy już wielokrotnie mniej więcej
    takie rozumowania: <span class="inlinecode"><span class="id" title="var">n</span></span> jest wprawdzie nie wiadomo czym, ale przez
    indukcję może to być albo <span class="inlinecode">0</span>, albo <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, gdzie dla <span class="inlinecode"><span class="id" title="var">n'</span></span> zachodzi
    odpowiednia hipoteza indukcyjna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyEq</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab271"></a><h2 class="section">Indukcja wzajemna</h2>

<div class="paragraph"> </div>

 Jest jeszcze jeden rodzaj indukcji, o którym dotychczas nie mówiliśmy:
    indukcja wzajemna (ang. mutual induction). Bez zbędnego teoretyzowania
    zbadajmy sprawę na przykładzie klasyków polskiej literatury: 
<div class="paragraph"> </div>

 <i>Smok to wysuszony zmok</i> 
<div class="paragraph"> </div>

 <i>Zmok to zmoczony smok</i> 
<div class="paragraph"> </div>

 Stanisław Lem 
<div class="paragraph"> </div>

 Idea stojąca za indukcją wzajemną jest prosta: chcemy przez indukcję
    zdefiniować jednocześnie dwa obiekty, które mogą się nawzajem do siebie
    odwoływać.

<div class="paragraph"> </div>

    W owym definiowaniu nie mamy rzecz jasna pełnej swobody — obowiązują te
    same kryteria co w przypadku zwykłych, "pojedynczych" definicji typów
    induktywnych. Wobec tego zauważyć należy, że definicja słowa "smok"
    podana przez Lema jest według Coqowych standardów nieakceptowalna, gdyż
    jeżeli w definicji <i>smoka</i> rozwiniemy definicję <i>zmoka</i>, to otrzymamy

<div class="paragraph"> </div>

    <i>Smok ty wysuszony zmoczony smok</i> 
<div class="paragraph"> </div>

 Widać gołym okiem, iż próba zredukowania (czyli obliczenia) obiektu
    <i>smok</i> nigdy się nie skończy. Jak już wiemy, niekończące się obliczenia
    w logice odpowiadają sprzeczności, a zatem ani <i>smoki</i>, ani <i>zmoki</i> w
    Coqowym świecie nie istnieją.

<div class="paragraph"> </div>

    Nie znaczy to bynajmniej, że wszystkie definicje przez indukcję
    wzajemną są w Coqu niepoprawne, choć należy przyznać, że są dość
    rzadko używane. Czas jednak abyśmy ujrzeli pierwszy prawdziwy przkład
    indukcji wzajemnej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MutInd</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">oddS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Aby zrozumieć tę definicję, zestawmy ją z naszą definicją parzystości
    z sekcji <i>Induktywne predykaty</i>.

<div class="paragraph"> </div>

    Zdefiniowaliśmy tam predykat bycia liczbą parzystą tak:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste

</li>
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> też jest parzyste 
</li>
</ul>

<div class="paragraph"> </div>

 Tym razem jednak nie definiujemy jedynie predykatu "jest liczbą parzystą".
    Definiujemy jednocześnie dwa predykaty: "jest liczbą parzystą" oraz
    "jest liczbą nieparzystą", które odwołują się do siebi nawzajm. Definicja
    brzmi tak:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste

</li>
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest nieparzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest parzyste

</li>
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest nieparzyste 
</li>
</ul>

<div class="paragraph"> </div>

 Czy definicja taka rzeczywiście ma sens? Sprawdźmy to:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste na mocy definicji

</li>
<li> jeżeli <span class="inlinecode">0</span> jest parzyste (a jest), to <span class="inlinecode">1</span> jest nieparzyste

</li>
<li> jeżeli <span class="inlinecode">1</span> jest nieparzyste (a jest), to <span class="inlinecode">2</span> jest parzyste

</li>
<li> i tak dalej, ad infinitum

</li>
</ul>

<div class="paragraph"> </div>

 Jak widać, za pomocą naszej wzajemnie induktywnej definicji <span class="inlinecode"><span class="id" title="var">even</span></span> można
    wygenerować wszystkie liczby parzyste (i tylko je), tak więc nowe <span class="inlinecode"><span class="id" title="var">even</span></span>
    jest równoważne staremu <span class="inlinecode"><span class="id" title="var">even</span></span> z sekcji <i>Induktywne predykaty</i>. Podobnie
    <span class="inlinecode"><span class="id" title="var">odd</span></span> może wygenerować wszystkie liczby nieparzyste i tylko je. 
<div class="paragraph"> </div>

<a id="lab272"></a><h4 class="section">Ćwiczenie (upewniające)</h4>

<div class="paragraph"> </div>

 Upewnij się, że powyższy akapit nie kłamie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_0</span> : <span class="id" title="var">even</span> 0.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">odd_1</span> : <span class="id" title="var">odd</span> 1.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_2</span> : <span class="id" title="var">even</span> 2.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_42</span> : <span class="id" title="var">even</span> 42.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">not_odd_0</span> : ~ <span class="id" title="var">odd</span> 0.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">not_even_1</span> : ~ <span class="id" title="var">even</span> 1.<br/>

<br/>
</div>

<div class="doc">
<a id="lab273"></a><h4 class="section">Ćwiczenie (właściwości <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij podstawowe właściwości <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_SS</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">odd_SS</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>

<br/>
</div>

<div class="doc">
Jeśli poległeś przy ostatnim zadaniu — nie przejmuj się. Specjalnie
    dobrałem złośliwy przykład.

<div class="paragraph"> </div>

    W tym momencie należy sobie zadać pytanie: jak dowodzić właściwości
    typów wzajemnie induktywnych? Aby udzielić odpowiedzi, spróbujmy
    udowodnić <span class="inlinecode"><span class="id" title="var">even_plus</span></span> za pomocą indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a potem prześledźmy,
    co poszło nie tak. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_plus_failed_1</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nasza indukcja po <span class="inlinecode"><span class="id" title="var">n</span></span> zawiodła, gdyż nasza hipoteza indukcyjna ma w
    konkluzji <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, podczas gdy nasz cel jest postaci
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. Zauważmy, że teoretycznie cel powinno dać się udowodnić,
    jako że mamy hipotezy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oraz <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, a suma liczby parzystej i
    nieparzystej jest nieparzysta.

<div class="paragraph"> </div>

    Nie zrażajmy się jednak i spróbujmy indukcji po dowodzie <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_plus_failed_2</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nasza indukcja po dowodzie hipotezy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> zawiodła, i to z kretesem,
    gdyż w kontekście nie mamy nawet żadnej hipotezy indukcyjnej! Co właściwie
    się stało? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">even_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, w naszej hipotezie "indukcyjnej" wygenerowanej przez Coqa w
    ogóle nie ma żadnej indukcji. Jest tam jedynie odwołanie do predykatu
    <span class="inlinecode"><span class="id" title="var">odd</span></span>...

<div class="paragraph"> </div>

    Zauważmy jednak, że naszym celem znów było <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, a hipotezy
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> sprawiają, że w teorii powinno dać się ten cel
    udowodnić, gdyż suma liczby parzystej i nieparzystej jest nieparzysta.

<div class="paragraph"> </div>

    Mogłoby się zdawać, że cierpimy na niedopasowanie (próba 1) lub brak
    (próba 2) hipotez indukcyjnych. Wydaje się też, że skoro w obydwu
    próbach zatrzymaliśmy się na celu <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, to pomocne mogłoby
    okazać się poniższe twierdzenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">odd_even_plus_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety — nie dla psa kiełbasa, gdyż natykamy się na problemy bliźniaczo
    podobne do tych, które napotkaliśmy w poprzednim twierdzeniu: nasza
    hipoteza indukcyjna ma w konkluzji <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, podczas gdy nasz cel
    jest postaci <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>.

<div class="paragraph"> </div>

    Próba przepchnięcia lematu za pomocą indukcji po dowodzie hipotezy
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> także nie zadziała, z tych samych powodów dla których indukcja
    po <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie pozwoliła nam udowodnić <span class="inlinecode"><span class="id" title="var">even_plus</span></span>. Zauważmy jednak, że
    cel jest udowadnialny, gdyż jako hipotezy mamy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    a suma dwóch liczb parzystych jest parzysta.

<div class="paragraph"> </div>

    Wydaje się, że wpadliśmy w błędne koło i jesteśmy w matni, bez wyjścia,
    bez nadziei, bez krzty szans na powodzenie: w dowodzie <span class="inlinecode"><span class="id" title="var">even_plus</span></span>
    potrzebujemy lematu <span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span>, ale nie możemy go udowodnić, gdyż
    w dowodzie <span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span> wymagane jest użycie lematu <span class="inlinecode"><span class="id" title="var">even_plus</span></span>.
    Ehhh, gdybyśmy tak mogli udowodnić oba te twierdzenia na raz...

<div class="paragraph"> </div>

    Eureka!

<div class="paragraph"> </div>

    Zauważ, że w naszych dotychczasowych dowodach przez indukcję posługiwaliśmy
    się zwykłą, "pojedynczą" indukcją. Była ona wystarczająca, gdyż mieliśmy do
    czynienia jedynie ze zwykłymi typami induktywnymi. Tym razem jednak jest
    inaczej: w ostatnich trzech dowodach chcieliśmy użyć "pojedynczej" indukcji
    do udowodnienia czegoś na temat predykatów wzajemnie induktywnych.

<div class="paragraph"> </div>

    Jest to ogromny zgrzyt. Do dowodzenia właściwości typów wzajemnie
    induktywnych powinniśmy użyć... o zgrozo, jak mogliśmy to przeoczyć,
    przecież to takie oczywiste... indukcji wzajemnej!

<div class="paragraph"> </div>

    Najprostszy sposób przeprowadzenia tego dowodu wygląda tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd_even_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">odd_even_plus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even_plus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Co tu się właściwie stało? Pierwsze dwie linijki są takie same jak
    poprzednio: stwierdzamy, że będziemy dowodzić twierdzenia o podanej
    nazwie i postaci. Następnie mamy słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">with</span></span>, które pełni
    tu rolę podobną jak w definicjach przez indukcję wzajemną: podając po
    nim nazwę i postać twierdzenia mówimy Coqowi, że chcemy dowodzić tego
    twierdzenia (<span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span>) jednocześnie z poprzednim (<span class="inlinecode"><span class="id" title="var">even_plus</span></span>).

<div class="paragraph"> </div>

    Dotychczas po rozpoczęciu dowodu ukazywał nam się jeden cel. Tym razem,
    jako że dowodzimy dwóch twierdzeń jednocześnie, mamy przed sobą dwa cele.
    W kontekście mamy też od razu dwie hipotezy indukcyjne. Musimy na nie
    bardzo uważać: dotychczas hipotezy indukcyjne pojawiały się dopiero w
    kroku indukcyjnym i sposób ich użycia był oczywisty. Tym razem jest
    inaczej — jako, że mamy je od samego początku, możemy natychmiast użyć
    ich do "udowodnienia" naszych twierdzeń.

<div class="paragraph"> </div>

    Niestety, takie "udowodnienie" odpowiada wywołaniu rekurencyjnemu na
    argumencie, który nie jest strukturalnie mniejszy (coś jak <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).
    Fakt ten obrazuje wiadomość o błędzie, jaką Coq daje nam po tej próbie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Error:&nbsp;Cannot&nbsp;guess&nbsp;decreasing&nbsp;argument&nbsp;of&nbsp;fix.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zaczynamy dowód od nowa, tym razem już bez oszukiwania. Musimy udowodnić
    każdy z naszych celów osobno, ale możemy korzystać z obydwu hipotez
    indukcyjnych. W obydwu celach zaczynamy od analizy przypadków, czyli
    rozbicia <span class="inlinecode"><span class="id" title="var">n</span></span>, i rozwiązania przypadku bazowego. Rozbicie <span class="inlinecode"><span class="id" title="var">n</span></span> dało nam
    <span class="inlinecode"><span class="id" title="var">n'</span></span>, które jest strukturalnie mniejsze od <span class="inlinecode"><span class="id" title="var">n</span></span>, a zatem możemy bez obaw
    użyć naszej hipotezy indukcyjnej. Reszta jest trywialna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_double</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> (2 * <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_O</span> <span class="id" title="tactic">in</span> *. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MutInd</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab274"></a><h1 class="section">Różne</h1>

<div class="paragraph"> </div>

<a id="lab275"></a><h2 class="section">Rodziny typów induktywnych</h2>

<div class="paragraph"> </div>

 Słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pozwala nam definiować nie tylko typy
    induktywne, ale także rodziny typów induktywnych — i to nawet na
    dwa sposoby. W tym podrozdziale przyjrzymy się obu z nich oraz
    różnicom między nimi, a także ich wadom i zaletom. Przyjrzyjmy się
    raz jeszcze typowi <span class="inlinecode"><span class="id" title="var">option</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">option</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;option&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;:&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> @<span class="id" title="var">None</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;@None&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Definiując rodzinę typów <span class="inlinecode"><span class="id" title="var">option</span></span>, umieściliśmy argument będący typem
    w nawiasach okrągłych tuż po nazwie definiowanego typu, a przed <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.
    Definiując konstruktory, nie napisaliśmy nigdzie <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">...</span>,
    a mimo tego komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> jasno pokazuje, że typy obydwu konstruktorów
    zaczynają się od takiej właśnie kwantyfikacji.

<div class="paragraph"> </div>

    (Przypomnijmy, że w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> argument <span class="inlinecode"><span class="id" title="var">A</span></span> jest domyślny, więc
    wyświetlenie pełnego typu tego konstruktora wymagało użycia symbolu <span class="inlinecode">@</span>,
    który oznacza "wyświetl wszystkie argumenty domyślne").

<div class="paragraph"> </div>

    W ogólności, definiowanie rodziny typów <span class="inlinecode"><span class="id" title="var">T</span></span> jako <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">(<span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">xN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">AN</span>)</span>
    ma następujący efekt:
<ul class="doclist">
<li> kwantyfikacja <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">xN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">AN</span>)</span> jest dodawana na
      początek każdego konstruktora

</li>
<li> w konkluzji konstruktora <span class="inlinecode"><span class="id" title="var">T</span></span> musi wystąpić zaaplikowany do tych
      argumentów, czyli jako <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xN</span></span> — wstawienie innych argumentów
      jest błędem 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">option'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option'</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">option'</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Próba zdefiniowania typu <span class="inlinecode"><span class="id" title="var">option'</span></span> kończy się następującym komunikatem
    o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:&nbsp;Last&nbsp;occurrence&nbsp;of&nbsp;"option'"&nbsp;must&nbsp;have&nbsp;"A"&nbsp;as&nbsp;1st&nbsp;argument&nbsp;in&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;B".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Drugi sposób zdefiniowania rodziny typów <span class="inlinecode"><span class="id" title="var">option</span></span> przedstawiono
    poniżej. Tym razem zamiast umieszczać argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> po
    nazwie definiowanego typu, deklarujemy, że typem <span class="inlinecode"><span class="id" title="var">option'</span></span> jest
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option'</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option'</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">option'</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Taki zabieg daje nam większą swobodę: w każdym konstruktorze
    z osobna musimy explicité umieścić kwantyfikację po argumencie
    sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, dzięki czemu różne konstruktory mogą w konkluzji
    mieć <span class="inlinecode"><span class="id" title="var">option'</span></span> zaaplikowany do różnych argumentów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some'&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option'&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">None'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None'&nbsp;:&nbsp;forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zauważmy jednak, że definicje <span class="inlinecode"><span class="id" title="var">option</span></span> i <span class="inlinecode"><span class="id" title="var">option'</span></span> są równoważne
    — typ konstruktora <span class="inlinecode"><span class="id" title="var">None'</span></span> różni się od typu <span class="inlinecode"><span class="id" title="var">None</span></span> jedynie nazwą
    argumentu (<span class="inlinecode"><span class="id" title="var">A</span></span> dla <span class="inlinecode"><span class="id" title="var">None</span></span>, <span class="inlinecode"><span class="id" title="var">B</span></span> dla <span class="inlinecode"><span class="id" title="var">None'</span></span>).

<div class="paragraph"> </div>

    Jak zatem rozstrzygnąć, który sposób definiowania jest "lepszy"?
    W naszym przypadku lepszy jest sposób pierwszy, odpowiadający
    typowi <span class="inlinecode"><span class="id" title="var">option</span></span>, gdyż jest bardziej zwięzły. Nie jest to jednak
    jedyne kryterium. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">option_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;option&nbsp;A&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;P&nbsp;(Some&nbsp;a))&nbsp;-&gt;&nbsp;P&nbsp;None&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;o&nbsp;:&nbsp;option&nbsp;A,&nbsp;P&nbsp;o&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">option'_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;forall&nbsp;T&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;T&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(a&nbsp;:&nbsp;A),&nbsp;P&nbsp;A&nbsp;(Some'&nbsp;A&nbsp;a))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;P&nbsp;B&nbsp;(None'&nbsp;B))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(T&nbsp;:&nbsp;Type)&nbsp;(o&nbsp;:&nbsp;option'&nbsp;T),&nbsp;P&nbsp;T&nbsp;o&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Dwa powyższe termy to reguły indukcyjne, wygenerowane automatycznie
    przez Coqa dla typów <span class="inlinecode"><span class="id" title="var">option</span></span> oraz <span class="inlinecode"><span class="id" title="var">option'</span></span>. Reguła dla <span class="inlinecode"><span class="id" title="var">option</span></span>
    jest wizualnie krótsza, co, jak dowiemy się w przyszłości, oznacza
    zapewne, że jest prostsza, zaś prostsza reguła indukcyjna oznacza
    łatwiejsze dowodzenie przez indukcję. Jest to w zasadzie najmocniejszy
    argument przemawiający za pierwszym sposobem zdefiniowania <span class="inlinecode"><span class="id" title="var">option</span></span>.

<div class="paragraph"> </div>

    Powyższe rozważania nie oznaczają jednak, że sposób pierwszy jest
    zawsze lepszy — sposób drugi jest bardziej ogólny i istnieją rodziny
    typów, których zdefiniowanie sposobem pierwszym jest niemożliwe.
    Klasycznym przykładem jest rodzina typów <span class="inlinecode"><span class="id" title="var">vec</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">vec</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">vnil</span> : <span class="id" title="var">vec</span> <span class="id" title="var">A</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">vcons</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">vec</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">vec</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Konstruktor <span class="inlinecode"><span class="id" title="var">vnil</span></span> reprezentuje listę pustą, której długość wynosi
    rzecz jasna <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">vcons</span></span> reprezentuje listę składająca się z
    głowy i ogona o długości <span class="inlinecode"><span class="id" title="var">n</span></span>, której długość wynosi oczywiście <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">vec</span></span> reprezetuje listy o długości znanej statycznie (tzn. Coq zna
    długość takiej listy już w trakcie sprawdzania typów), dzięki czemu
    możemy obliczać ich długość w czasie stałym (po prostu odczytując ją
    z typu danej listy).

<div class="paragraph"> </div>

    Zauważ, że w obu konstruktorach argumenty typu <span class="inlinecode"><span class="id" title="var">nat</span></span> są różne, a zatem
    zdefiniowanie tego typu jako <span class="inlinecode"><span class="id" title="var">vec</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">...</span> byłoby
    niemożliwe.

<div class="paragraph"> </div>

    Przykład ten pokazuje nam również, że przy definiowaniu rodzin typów
    możemy dowolnie mieszać sposoby pierwszy i drugi — w naszym przypadku
    argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest wspólny dla wszystkich konstruktorów, więc
    umieszczamy go przed ostatnim <span class="inlinecode">:</span>, zaś argument typu <span class="inlinecode"><span class="id" title="var">nat</span></span> różni się
    w zależności od konstruktora, a zatem umieszczamy go po ostatnim <span class="inlinecode">:</span>. 
<div class="paragraph"> </div>

<a id="lab276"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj następujące typy (zadbaj o to, żeby wygenerowana reguła
    indukcyjna była jak najkrótsza):
<ul class="doclist">
<li> typ drzew binarnych przechowujących elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> typ drzew binarnych przechowujących elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
      których wysokość jest znana statycznie

</li>
<li> typ heterogenicznych drzew binarnych (mogą one
      przechowywać elementy różnych typów)

</li>
<li> typ heterogenicznych drzew binarnych, których wysokość
      jest znana statycznie 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab277"></a><h2 class="section">Indukcja wzajemna a indeksowane rodziny typów</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MutualIndution_vs_InductiveFamilies</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja wzajemna nie jest zbyt użyteczna. Pierwszym, praktycznym,
    powodem jest to, że, jak pewnie zdążyłeś się już na własnej skórze
    przekonać, jej używanie jest dość upierdliwe. Drugi, teoretyczny,
    powód jest taki, że definicje przez indukcję wzajemną możemy łatwo
    zasymulować za pomocą indeksowanych rodzin typów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">oddS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Rzućmy jeszcze raz okiem na znaną nam już definicję predykatów <span class="inlinecode"><span class="id" title="var">even</span></span>
    i <span class="inlinecode"><span class="id" title="var">odd</span></span> przez indukcję wzajemną. Nie dzieje się tu nic niezwykłego, a
    najważniejszym spostrzeżeniem, jakie możemy poczynić, jest to, że
    <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span> to dwa byty - nie trzy, nie pięć, ale dwa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even_odd</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0'</span> : <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenS'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even_odd</span> <span class="id" title="var">false</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">oddS'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even_odd</span> <span class="id" title="var">false</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even'</span> := <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">odd'</span> := <span class="id" title="var">even_odd</span> <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
Co z tego wynika? Ano, zamiast definiować przez indukcję wzajemną dwóch
    predykatów <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span> możemy za jednym zamachem zdefiniować relację
    <span class="inlinecode"><span class="id" title="var">even_odd</span></span>, która jednocześnie odpowiada obu tym predykatom. Kluczem
    w tej sztuczce jest dodatkowy indeks, którym jest dwuelementowy typ
    <span class="inlinecode"><span class="id" title="var">bool</span></span>. Dzięki niemu możemy zakodować definicję <span class="inlinecode"><span class="id" title="var">even</span></span> za pomocą
    <span class="inlinecode"><span class="id" title="var">even_odd</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>, zaś <span class="inlinecode"><span class="id" title="var">odd</span></span> jako <span class="inlinecode"><span class="id" title="var">even_odd</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_even'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even'</span> <span class="id" title="var">n</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd_odd'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd'</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even'_even</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even'</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">n</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd'_odd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd'</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Obie definicje są, jak widać (ćwiczenie!), równoważne, choć pod względem
    estetycznym oczywiście dużo lepiej wypada indukcja wzajemna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MutualIndution_vs_InductiveFamilies</span>.<br/>

<br/>
</div>

<div class="doc">
Na koniec wypada jeszcze powiedzieć, że indeksowane typy induktywne są
    potężniejsze od typów wzajemnie induktywnych. Wynika to z tego prostego
    faktu, że przez wzajemną indukcję możemy zdefiniować na raz jedynie
    skończenie wiele typów, zaś indeksowane typy induktywne indeksowane
    mogą być typami nieskończonymi. 
<div class="paragraph"> </div>

<a id="lab278"></a><h2 class="section">Sumy zależne i podtypy</h2>

<div class="paragraph"> </div>

 W Coqu, w przeciwieństwie do wielu języków imperatywnych, nie ma
    mechanizmu podtypowania, a każde dwa typy są ze sobą rozłączne.
    Nie jest to problemem, gdyż podtypowanie możemy zasymulować za
    pomocą sum zależnych, a te zdefiniować możemy induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">sigma</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sigT</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">existT</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">sigT</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> reprezentuje sumę zależną, której elementami są pary zależne.
    Pierwszym elementem pary jest <span class="inlinecode"><span class="id" title="var">x</span></span>, który jest typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś drugim
    elementem pary jest term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Suma zależna jest wobec tego pewnym
    uogólnieniem produktu.

<div class="paragraph"> </div>

    Niech cię nie zmyli nazewnictwo:
<ul class="doclist">
<li> Suma jest reprezentowana przez typ <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jej elementami są
      elementy <span class="inlinecode"><span class="id" title="var">A</span></span> zawinięte w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span> oraz elementy <span class="inlinecode"><span class="id" title="var">B</span></span>
      zawinięte w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Reprezentuje ideę "lub/albo".
      Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie może zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Produkt jest reprezentowany przez typ <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      są pary elementów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. Reprezentuje on ideę "i/oraz". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> nie może zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Uogólnieniem produktu jest suma zależna. Jest ona reprezentowana
      przez typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jej elementami są pary zależne elementów
      <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pierwszym elementem pary.
      Reprezentuje ona ideę "i/oraz", gdzie typ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> może zależeć od
      elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Typ funkcji jest reprezentowany przez <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      są termy postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentują ideę "daj mi
      coś typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coś typu <span class="inlinecode"><span class="id" title="var">B</span></span>". Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie może
      zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Uogólnieniem typu funkcji jest produkt zależny <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
      Jego elementami są termu postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentuje
      on ideę "daj mi <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coś typu <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> może zależeć od typu elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">sigT</span></span> jest najogólniejszą postacią pary zależnej — <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem,
    a <span class="inlinecode"><span class="id" title="var">P</span></span> rodziną typów. Mimo swej ogólności jest używany dość rzadko,
    gdyż najbardziej przydatną postacią sumy zależnej jest typ <span class="inlinecode"><span class="id" title="var">sig</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sig</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">exist</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">sig</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">exist</span> {<span class="id" title="var">A</span> <span class="id" title="var">P</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> można interpretować jako typ składający się z tych
    elementów <span class="inlinecode"><span class="id" title="var">A</span></span>, które spełniają predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Formalnie jest to
    para zależna, której pierwszym elementem jest term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś
    drugim dowód na to, że spełnia on predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even_nat</span> : <span class="id" title="keyword">Type</span> := <span class="id" title="var">sig</span> <span class="id" title="var">nat</span> <span class="id" title="var">even</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even_four</span> : <span class="id" title="var">even_nat</span> := <span class="id" title="var">exist</span> 4 <span class="id" title="var">four_is_even</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">even_nat</span></span> reprezentuje parzyste liczby naturalne, zaś term
    <span class="inlinecode"><span class="id" title="var">even_four</span></span> to liczba <span class="inlinecode">4</span> wraz z załączonym dowodem faktu, że <span class="inlinecode">4</span>
    jest parzyste.

<div class="paragraph"> </div>

    Interpretacja typu <span class="inlinecode"><span class="id" title="var">sig</span></span> sprawia, że jest on wykorzystywany bardzo
    często do podawania specyfikacji programów — pozwala on dodać do
    wyniku zwracanego przez funkcję informację o jego właściwościach.
    W przypadku argumentów raczej nie jest używany, gdyż prościej jest
    po prostu wymagać dowodów żądanych właściwości w osobnych argumentach
    niż pakować je w <span class="inlinecode"><span class="id" title="var">sig</span></span> po to, żeby i tak zostały później odpakowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even_42</span> : <span class="id" title="var">sig</span> <span class="id" title="var">nat</span> <span class="id" title="var">even</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">exist</span> 42). <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definiowanie wartości typu <span class="inlinecode"><span class="id" title="var">sig</span></span> jest problematyczne, gdyż zawierają
    one dowody. Napisanie definicji "ręcznie", explicité podając proofterm,
    nie wchodzi w grę. Innym potencjalnym rozwiązaniem jest napisanie dowodu
    na boku, a następnie użycie go we właściwej definicji, ale jest ono
    dłuższe niż to konieczne.

<div class="paragraph"> </div>

    Przypomnijmy sobie, czym są taktyki. Dowody to termy, których typy są
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a taktyki służą do konstruowania tych dowodów. Ponieważ
    dowody nie różnią się (prawie) niczym od programów, taktyk można użyć
    także do pisania programów. Taktyki to metaprogramy (napisane w jęzku
    Ltac), które piszą programy (w jęzku termów Coqa, zwanym Gallina).

<div class="paragraph"> </div>

    Wobec tego trybu dowodzenia oraz taktyk możemy używać nie tylko do
    dowodzenia, ale także do definiowania i to właśnie uczyniliśmy w
    powyższym przykładzie. Skonstruowanie termu typu <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>,
    czyli parzystej liczby naturalnej, odbyło się w następujący sposób.

<div class="paragraph"> </div>

    Naszym celem jest początkowo <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>, czyli typ, którego
    element chcemy skonstrować. Używamy konstruktora <span class="inlinecode"><span class="id" title="var">exist</span></span>, który
    w naszym przypadku jest typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>.
    Wobec tego <span class="inlinecode"><span class="id" title="var">exist</span></span> <span class="inlinecode">42</span> jest typu <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">42</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>, a jego
    zaaplikowanie skutkować będzie zamianą naszego celu na <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">42</span>.
    Następnie dowodzimy tego faktu, co kończy proces definiowania. 
<div class="paragraph"> </div>

<a id="lab279"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj predykat <span class="inlinecode"><span class="id" title="var">sorted</span></span>, który jest spełniony, gdy jego argument
    jest listą posortowaną. Następnie zdefiniuj typ list liczb naturalnych
    posortowanych według relacji <span class="inlinecode">&lt;=</span> i skonstruuj term tego typu
    odpowiadający liście <span class="inlinecode">[42;</span> <span class="inlinecode">666;</span> <span class="inlinecode">1337]</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">sigma</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab280"></a><h2 class="section">Kwantyfikacja egzystencjalna</h2>

<div class="paragraph"> </div>

 Znamy już pary zależne i wiemy, że mogą służyć do reprezentowania
    podtypów, których w Coqu brak. Czas zatem uświadomić sobie kolejny
    fragment korespondencji Curry'ego-Howarda, a mianowicie definicję
    kwantyfikacji egzystencjalnej: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ex</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ex</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ex_intro</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">ex</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">ex</span></span> to kolejne wcielenie sumy zależnej. Porównaj dokładnie tę
    definicję z definicją <span class="inlinecode"><span class="id" title="var">sigT</span></span> oraz <span class="inlinecode"><span class="id" title="var">sig</span></span>. <span class="inlinecode"><span class="id" title="var">ex</span></span> jest niemal identyczne
    jak <span class="inlinecode"><span class="id" title="var">sig</span></span>: jest to para zależna, której pierwszym elementem jest
    term <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugim dowód na to, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zachodzi. <span class="inlinecode"><span class="id" title="var">ex</span></span> jednak,
    w przeciwieństwie do <span class="inlinecode"><span class="id" title="var">sig</span></span>, żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, czyli jest zdaniem — nie
    liczą się konkretne postaci jego termów ani ich ilość, a jedynie
    fakt ich istnienia. To sprawia, że <span class="inlinecode"><span class="id" title="var">ex</span></span> jest doskonałym kandydatem
    do reprezentowania kwantyfikacji egzystencjalnej. 
<div class="paragraph"> </div>

<a id="lab281"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że dla każdej liczby naturalnej n istnieje liczba od niej
    większa. Następnie zastanów się, jak działa taktyka <span class="inlinecode"><span class="id" title="tactic">exists</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">exists_greater</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ex</span> <span class="id" title="var">nat</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">k</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">n</span> &lt; <span class="id" title="var">k</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ex</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab282"></a><h1 class="section">Wyższe czary</h1>

<div class="paragraph"> </div>

 Najwyższy czas nauczyć się czegoś tak zaawansowanego, że nawet w Coqu
    (pełnym przecież dziwnych rzeczy) tego nie ma i nie zapowiada się na
    to, że będzie. Mam tu na myśli mechanizmy takie jak indukcja-indukcja,
    indukcja-rekursja oraz indukcja-indukcja-rekursja (jak widać, w świecie
    poważnych uczonych, podobnie jak świecie Goebbelsa, im więcej razy
    powtórzy się dane słowo, tym więcej płynie z niego mocy). 
<div class="paragraph"> </div>

<a id="lab283"></a><h2 class="section">Przypomnienie</h2>

<div class="paragraph"> </div>

 Zanim jednak wyjaśnimy, co to za stwory, przypomnijmy sobie różne, coraz
    bardziej innowacyjne sposoby definiowania przez indukcję oraz dowiedzmy
    się, jak sformułować i udowodnić wynikające z nich reguły rekursji oraz
    indukcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Elimination</span> <span class="id" title="var">Schemes</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższa komenda mówi Coqowi, żeby nie generował automatycznie reguł
    indukcji. Przyda nam się ona, by uniknąć konfliktów nazw z regułami,
    które będziemy pisać ręcznie. 
<div class="paragraph"> </div>

<a id="lab284"></a><h3 class="section">Enumeracje</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">enum</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
Najprymitywniejszymi z typów induktywnych są enumeracje. Definiując je,
    wymieniamy po prostu wszystkie ich elementy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">I</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Reguła definiowania przez przypadki jest banalnie prosta: jeżeli w
    jakimś inny typie <span class="inlinecode"><span class="id" title="var">P</span></span> uda nam się znaleźć po jednym elemencie dla każdego
    z elementów naszego typu <span class="inlinecode"><span class="id" title="var">I</span></span>, to możemy zrobić funkcję <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span> : <span class="id" title="var">I_case_nondep_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> <span class="id" title="var">c1'</span> <span class="id" title="var">c2'</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> =&gt; <span class="id" title="var">c0'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> =&gt; <span class="id" title="var">c1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> =&gt; <span class="id" title="var">c2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Regułę zdefiniować możemy za pomocą dopasowania do wzorca. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c0</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c1</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
Zależną regułę definiowania przez przypadki możemy uzyskać z poprzedniej
    uzależniając przeciwdziedzinę <span class="inlinecode"><span class="id" title="var">P</span></span> od dziedziny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span> : <span class="id" title="var">I_case_dep_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c0</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c1</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c2</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> =&gt; <span class="id" title="var">c0'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> =&gt; <span class="id" title="var">c1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> =&gt; <span class="id" title="var">c2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja, jak widać, jest taka sama jak poprzednio, więc obliczeniowo
    obie reguły zachowują się tak samo. Różnica leży jedynie w typach -
    druga reguła jest ogólniejsza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">enum</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab285"></a><h3 class="section">Konstruktory rekurencjne</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">rec</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">D</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
Typy induktywne stają się naprawdę induktywne, gdy konstruktory mogą
    brać argumenty typu, który właśnie definiujemy. Dzięki temu możemy
    tworzyć type, które mają nieskończenie wiele elementów, z których
    każdy ma kształt takiego czy innego drzewa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_rec_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>,  (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">I</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ reguły rekursji (czyli rekursora) tworzymy tak jak dla enumeracji:
    jeżeli w typie <span class="inlinecode"><span class="id" title="var">P</span></span> znajdziemy rzeczy o takim samym kształcie jak
    konstruktory typu <span class="inlinecode"><span class="id" title="var">I</span></span>, to możemy zrobić funkcję <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. W naszym
    przypadku oba konstruktory mają kształt <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">I</span></span>, więc do zdefiniowania
    naszej funkcji musimy znaleźć odpowiadające im rzeczy typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">I_rec</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x'</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">D'</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">x'</span> (<span class="id" title="var">I_rec</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">D</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">D'</span> (<span class="id" title="var">I_rec</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja rekursora jest prosta. Jeżeli wyobrazimy sobie <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> jako
    drzewo, to węzły z etykietką <span class="inlinecode"><span class="id" title="var">x</span></span> zastępujemy wywołaniem funkcji <span class="inlinecode"><span class="id" title="var">x'</span></span>,
    a węzły z etykietką <span class="inlinecode"><span class="id" title="var">D</span></span> zastępujemy wywołaniami funkcji <span class="inlinecode"><span class="id" title="var">D</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_ind_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">D'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">D</span> <span class="id" title="var">i</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
Reguła indukcji (czyli induktor - cóż za piękna nazwa!) powstaje z
    reguły rekursji przez uzależnienie przeciwdziedziny <span class="inlinecode"><span class="id" title="var">P</span></span> od dziedziny
    <span class="inlinecode"><span class="id" title="var">I</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">I_ind</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">x'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>)) (<span class="id" title="var">D'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">D</span> <span class="id" title="var">i</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) : <span class="id" title="var">P</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">x'</span> <span class="id" title="var">i'</span> (<span class="id" title="var">I_ind</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">D</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">D'</span> <span class="id" title="var">i'</span> (<span class="id" title="var">I_ind</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, implementacja reguły indukcji jest identyczna
    jak rekursora, jedynie typy są bardziej ogólnej.

<div class="paragraph"> </div>

    Uwaga: nazywam reguły nieco inaczej niż te autogenerowane przez Coqa.
    Dla Coqa reguła indukcji dla <span class="inlinecode"><span class="id" title="var">I</span></span> to nasze <span class="inlinecode"><span class="id" title="var">I_ind</span></span> z <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    zastąpionym przez <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, zaś Coqowe <span class="inlinecode"><span class="id" title="var">I_rec</span></span> odpowiadałoby
    naszemu <span class="inlinecode"><span class="id" title="var">I_ind</span></span> dla <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Jeżeli smuci cię burdel nazewniczy, to nie przejmuj się - kiedyś będzie
    lepiej. Klasyfikacja reguł jest prosta:
<ul class="doclist">
<li> reguły mogą być zależne lub nie, w zależności od tego czy <span class="inlinecode"><span class="id" title="var">P</span></span> zależy
      od <span class="inlinecode"><span class="id" title="var">I</span></span>

</li>
<li> reguły mogą być rekurencyjne lub nie

</li>
<li> reguły mogą być dla sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> albo nawet <span class="inlinecode"><span class="id" title="keyword">Set</span></span> 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="keyword">rec</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab286"></a><h3 class="section">Parametry</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">param</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">c0</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">c1</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">c2</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną innowacją są parametry, których głównym zastosowaniem jest
    polimorfizm. Dzięki parametrom możemy za jednym zamachem (tylko bez
    skojarzeń z Islamem!) zdefiniować nieskończenie wiele typów, po jednym
    dla każdego parametru. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ rekursora jest oczywisty: jeżeli znajdziemy rzeczy o kształtach
    takich jak konstruktory <span class="inlinecode"><span class="id" title="var">I</span></span> z <span class="inlinecode"><span class="id" title="var">I</span></span> zastąpionym przez <span class="inlinecode"><span class="id" title="var">P</span></span>, to możemy
    zrobić funkcję <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jako, że parametry są zawsze takie samo,
    możemy skwantyfikować je na samym początku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c1'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c2'</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c1'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c1</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c2'</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> (<span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
A regułę indukcję uzyskujemy przez uzależnienie <span class="inlinecode"><span class="id" title="var">P</span></span> od <span class="inlinecode"><span class="id" title="var">I</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c1'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c1</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c2'</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> (<span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">P</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c1'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c2'</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">param</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab287"></a><h3 class="section">Indukcja wzajemna</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">mutual</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Smok</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">Smok</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Zmok</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">Zmok</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja wzajemna pozwala definiować na raz wiele typów, które mogą
    odwoływać się do siebie nawzajem. Cytując klasyków: smok to wysuszony
    zmok, zmok to zmoczony smok. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">S</span>) -&gt; <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">S</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">Z</span>) -&gt; <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">Z</span>.<br/>

<br/>
</div>

<div class="doc">
Reguła niezależnej analizy przypadków dla <span class="inlinecode"><span class="id" title="var">Smok</span></span>a wygląda banalnie:
    jeżeli ze <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a potrafimy wyprodukować <span class="inlinecode"><span class="id" title="var">S</span></span>, to ze <span class="inlinecode"><span class="id" title="var">Smok</span></span>a też.
    Dla <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a jest analogicznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Wy</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">S</span>) (<span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>) : <span class="id" title="var">S</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">smok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span> =&gt; <span class="id" title="var">Wy</span> <span class="id" title="var">zmok</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Zm</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">Z</span>) (<span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>) : <span class="id" title="var">Z</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">zmok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span> =&gt; <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_rec_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) -&gt; (<span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) -&gt; <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">S</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_rec_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) -&gt; (<span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) -&gt; <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">Z</span>.<br/>

<br/>
</div>

<div class="doc">
Typ rekursora jest jednak nieco bardziej zaawansowany. Żeby zdefiniować
    funkcję typu <span class="inlinecode"><span class="id" title="var">Smok</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span>, musimy mieć nie tylko rzeczy w kształcie
    konstruktorów <span class="inlinecode"><span class="id" title="var">Smok</span></span>a, ale także w kształcie konstruktorów <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a,
    gdyż rekurencyjna struktura obu typów jest ze sobą nierozerwalnie
    związana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">Smok_rec</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Wy</span> : <span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) (<span class="id" title="var">Zm</span> : <span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) (<span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>) : <span class="id" title="var">S</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">smok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span> =&gt; <span class="id" title="var">Wy</span> (<span class="id" title="var">Zmok_rec</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">zmok</span>)<br/>
<span class="id" title="keyword">end</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Zmok_rec</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Wy</span> : <span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) (<span class="id" title="var">Zm</span> : <span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) (<span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>) : <span class="id" title="var">Z</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">zmok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span> =&gt; <span class="id" title="var">Zm</span> (<span class="id" title="var">Smok_rec</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja wymaga rekursji wzajemnej, ale poza nie jest jakoś
    wybitnie groźna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_ind_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_ind_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">Smok_ind</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>) : <span class="id" title="var">S</span> <span class="id" title="var">smok</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">smok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span> =&gt; <span class="id" title="var">Wy</span> <span class="id" title="var">zmok</span> (<span class="id" title="var">Zmok_ind</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">zmok</span>)<br/>
<span class="id" title="keyword">end</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Zmok_ind</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>) : <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">zmok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span> =&gt; <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span> (<span class="id" title="var">Smok_ind</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Mając rekursor, napisanie typu reguły indukcji jest banalne, podobnie
    jak jego implementacja. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">mutual</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab288"></a><h3 class="section">Indeksy</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">index</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">I</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">I</span> 42.<br/>

<br/>
</div>

<div class="doc">
Ostatnią poznaną przez nas innowacją są typy indeksowane. Tutaj również
    definiujemy za jednym zamachem (ekhem...) dużo typów, ale nie są one
    niezależne jak w przypadku parametrów, lecz mogą od siebie wzajemnie
    zależeć. Słowem, tak naprawdę definiujemy przez indukcję funkcję
    typu <span class="inlinecode"><span class="id" title="var">A_1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A_n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>/<span class="id" title="keyword">Prop</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A_i</span></span> to indeksy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_very_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_very_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;{<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">c42'</span> <span class="id" title="var">n</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Możliwych reguł analizy przypadków mamy tutaj trochę więcej niż w
    przypadku parametrów. W powyższej regule <span class="inlinecode"><span class="id" title="var">P</span></span> nie zależy od indeksu
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span> 0) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span> 42),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span> 0) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span> 42)<br/>
&nbsp;&nbsp;{<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">c42'</span> <span class="id" title="var">n</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
... a w powyższej tak. Jako, że indeksy zmieniają się pomiędzy
    konstruktorami, każdy z nich musi kwantyfikować je osobno (co akurat
    nie jest potrzebne w naszym przykładzie, gdyż jest zbyt prosty). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> 0 (<span class="id" title="var">c0</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c42'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> 42 (<span class="id" title="var">c42</span> <span class="id" title="var">n</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>), <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">i</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> 0 (<span class="id" title="var">c0</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c42'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> 42 (<span class="id" title="var">c42</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">c42'</span> <span class="id" title="var">n</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Ogólnie reguła jest taka: reguła niezależna (pierwsza) nie zależy od
    niczego, a zależna (trzecia) zależy od wszystkiego. Reguła druga jest
    pośrednia - ot, take ciepłe kluchy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">index</span>.<br/>

<br/>
</div>

<div class="doc">
Nie zapomnijmy ponownie nakazać Coqowi generowania reguł indukcji. 
</div>
<div class="code">
<span class="id" title="keyword">Set</span> <span class="id" title="var">Elimination</span> <span class="id" title="var">Schemes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab289"></a><h2 class="section">Indukcja-indukcja</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ind_ind</span>.<br/>

<br/>
</div>

<div class="doc">
Po powtórce nadszedł czas nowości. Zacznijmy od nazwy, która jest iście
    kretyńska: indukcja-indukcja. Każdy rozsądny człowiek zgodzi się,
    że dużo lepszą nazwą byłoby coś w stylu "indukcja wzajemna indeksowana".

<div class="paragraph"> </div>

    Ta alternatywna nazwa rzuca sporo światła: indukcja-indukcja to połączenie
    i uogólnienie mechanizmów definiowania typów wzajemnie induktywnych oraz
    indeksowanych typów induktywnych.

<div class="paragraph"> </div>

    Typy wzajemnie induktywne mogą odnosić się do siebie nawzajem, ale co
    to dokładnie znaczy? Ano to, że konstruktory każdego typu mogą brać
    argumenty wszystkch innych typów definiowanych jednocześnie z nim. To
    jest clou całej sprawy: konstruktory.

<div class="paragraph"> </div>

    A co to ma do typów indeksowanych? Ano, zastanówmy się, co by się stało,
    gdybyśmy chcieli zdefiniować przez wzajemną indukcję typ <span class="inlinecode"><span class="id" title="var">A</span></span> oraz rodzinę
    typów <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Otóż nie da się: konstruktory <span class="inlinecode"><span class="id" title="var">A</span></span> mogą odnosić
    się do <span class="inlinecode"><span class="id" title="var">B</span></span> i vice-versa, ale <span class="inlinecode"><span class="id" title="var">A</span></span> nie może być indeksem <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Indukcja-indukcja to coś, co... tam taram tam tam... pozwala właśnie na
    to: możemy jednocześnie zdefiniować typ i indeksowaną nim rodzinę typów.
    I wszystko to ukryte pod taką smutną nazwą... lobby teoriotypowe nie
    chciało, żebyś się o tym dowiedział.

<div class="paragraph"> </div>

    Czas na przykład! 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span><br/>
<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">slist</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">snil</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">scons</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">A</span>), <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">A</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">ok</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ok_snil</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">ok</span> <span class="id" title="var">x</span> <span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> -&gt; <span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>).<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;reference&nbsp;slist&nbsp;was&nbsp;not&nbsp;found&nbsp;in&nbsp;the&nbsp;current&nbsp;environment.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jako się już wcześniej rzekło, indukcja-indukcja nie jest wspierana
    przez Coqa - powyższa definicja kończy się informacją o błędzie: Coq
    nie widzi <span class="inlinecode"><span class="id" title="var">slist</span></span> kiedy czyta indeksy <span class="inlinecode"><span class="id" title="var">ok</span></span> właśnie dlatego, że nie
    dopuszcza on możliwości jednoczesnego definiowania rodziny (w tym
    wypadku relacji) <span class="inlinecode"><span class="id" title="var">ok</span></span> wraz z jednym z jej indeksów, <span class="inlinecode"><span class="id" title="var">slist</span></span>.

<div class="paragraph"> </div>

    Będziemy zatem musieli poradzić sobie z przykładem jakoś inaczej -
    po prostu damy go sobie za pomocą aksjomatów. Zanim jednak to zrobimy,
    omówimy go dokładniej, gdyż deklarowanie aksjomatów jest niebezpieczne
    i nie chcemy się pomylić.

<div class="paragraph"> </div>

    Zamysłem powyższego przykładu było zdefiniowanie typu list posortowanych
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> pełni rolę relacji porządku, jednocześnie z relacją
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> wyraża, że dostawienie <span class="inlinecode"><span class="id" title="var">x</span></span>
    na początek listy posortowanej <span class="inlinecode"><span class="id" title="var">l</span></span> daje listę posortowaną.

<div class="paragraph"> </div>

    Przykład jest oczywiście dość bezsensowny, bo dokładnie to samo można
    osiągnąć bez używania indukcji-indukcji - wystarczy najpierw zdefiniować
    listy, a potem relację bycia listą posortowaną, a na koniec zapakować
    wszystko razem. Nie będziemy się tym jednak przejmować.

<div class="paragraph"> </div>

    Definicja <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> jest następująca:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">snil</span></span> to lista pusta

</li>
<li> <span class="inlinecode"><span class="id" title="var">scons</span></span> robi posortowaną listę z głowy <span class="inlinecode"><span class="id" title="var">h</span></span> i ogona <span class="inlinecode"><span class="id" title="var">t</span></span> pod warunkiem, że
      dostanie też dowód zdania <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> mówiącego, że można dostawić <span class="inlinecode"><span class="id" title="var">h</span></span> na
      początek listy <span class="inlinecode"><span class="id" title="var">t</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Definicja <span class="inlinecode"><span class="id" title="var">ok</span></span> też jest banalna:
<ul class="doclist">
<li> każdy <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> może być dostawiony do pustej listy

</li>
<li> jeżeli mamy listę <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> oraz element <span class="inlinecode"><span class="id" title="var">x</span></span>, o którym wiemy,
      że jest mniejszy od <span class="inlinecode"><span class="id" title="var">h</span></span>, tzn. <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, to <span class="inlinecode"><span class="id" title="var">x</span></span> może zostać dostawiony
      do listy <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Jak powinny wyglądać reguły rekursji oraz indukcji? Na szczęście wciąż
    działają schematy, które wypracowaliśmy dotychczas.

<div class="paragraph"> </div>

    Reguła rekursji mówi, że jeżeli znajdziemy w typie <span class="inlinecode"><span class="id" title="var">P</span></span> coś o kształcie
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a w relacji <span class="inlinecode"><span class="id" title="var">Q</span></span> coś o kształcie <span class="inlinecode"><span class="id" title="var">ok</span></span>, to możemy zdefiniować
    funkcję <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>),</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>.

<div class="paragraph"> </div>

    Regułe indukcji można uzyskać dodając tyle zależności, ile tylko zdołamy
    unieść.

<div class="paragraph"> </div>

    Zobaczmy więc, jak zrealizować to wszystko za pomocą aksjomatów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">slist</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Prop</span>).<br/>

<br/>
</div>

<div class="doc">
Najpierw musimy zadeklarować <span class="inlinecode"><span class="id" title="var">slist</span></span>, gdyż wymaga tego typ <span class="inlinecode"><span class="id" title="var">ok</span></span>. Obie
    definicje wyglądają dokładnie tak, jak nagłówki w powyższej definicji
    odrzuconej przez Coqa.

<div class="paragraph"> </div>

    Widać też, że gdybyśmy chcieli zdefiniować rodziny <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>, które są
    nawzajem swoimi indeksami, to nie moglibyśmy tego zrobić nawet za pomocą
    aksjomatów. Rodzi to pytanie o to, które dokładnie definicje przez
    indukcję-indukcję są legalne. Odpowiedź brzmi: nie wiem, ale może kiedyś
    się dowiem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">snil</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}, <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">ok</span> <span class="id" title="var">x</span> (@<span class="id" title="var">snil</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> -&gt; <span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)).<br/>

<br/>
</div>

<div class="doc">
Następnie definiujemy konstruktory: najpierw konstruktory <span class="inlinecode"><span class="id" title="var">slist</span></span>, a
    potem <span class="inlinecode"><span class="id" title="var">ok</span></span>. Musimy to zrobić w tej kolejności, bo konstruktor <span class="inlinecode"><span class="id" title="var">ok_snil</span></span>
    odnosi się do <span class="inlinecode"><span class="id" title="var">snil</span></span>, a <span class="inlinecode"><span class="id" title="var">ok_scons</span></span> do <span class="inlinecode"><span class="id" title="var">scons</span></span>.

<div class="paragraph"> </div>

    Znowu widzimy, że gdyby konstruktory obu typów odnosiły się do siebie
    nawzajem, to nie moglibyśmy zdefiniować takiego typu aksjomatycznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Q</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>), <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Psnil</span> : <span class="id" title="var">P</span> <span class="id" title="var">snil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pscons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">Q</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Qok_snil</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">Q</span> <span class="id" title="var">x</span> <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Qok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">Q</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> -&gt; <span class="id" title="var">Q</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) (<span class="id" title="var">ok_scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span>) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">g</span> : (<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>), <span class="id" title="var">Q</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">Psnil</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">Pscons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>) (<span class="id" title="var">g</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">x</span> <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> <span class="id" title="var">x</span>) = <span class="id" title="var">Qok_snil</span> <span class="id" title="var">x</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) (<span class="id" title="var">ok_scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Qok_scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>) (<span class="id" title="var">g</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}}).<br/>

<br/>
</div>

<div class="doc">
Ugh, co za potfur. Spróbujmy rozłożyć go na czynniki pierwsze.

<div class="paragraph"> </div>

    Przede wszystkim, żeby za dużo nie pisać, zobaczymy tylko regułę indukcji.
    Teoretycznie powinny to być dwie reguły (tak jak w przypadku <span class="inlinecode"><span class="id" title="var">Smok</span></span>a i
    <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a) - jedna dla <span class="inlinecode"><span class="id" title="var">slist</span></span> i jedna dla <span class="inlinecode"><span class="id" title="var">ok</span></span>, ale żeby za dużo nie
    pisać, możemy zapisać je razem.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">A</span></span> i relacja <span class="inlinecode"><span class="id" title="var">R</span></span> są parametrami obu definicji, więc skwantyfikowane
    są na samym początku. Nasza reguła pozwala nam zdefiniować przez wzajemną
    rekursję dwie funkcje, <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>)</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>),</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Tak więc <span class="inlinecode"><span class="id" title="var">P</span></span>
    to kodziedzina <span class="inlinecode"><span class="id" title="var">f</span></span>, a <span class="inlinecode"><span class="id" title="var">Q</span></span> - <span class="inlinecode"><span class="id" title="var">g</span></span>.

<div class="paragraph"> </div>

    Teraz potrzebujemy rozważyć wszystkie możliwe przypadki - tak jak przy
    dopasowaniu do wzorca. Przypadek <span class="inlinecode"><span class="id" title="var">snil</span></span> jest dość banalny. Przypadek
    <span class="inlinecode"><span class="id" title="var">scons</span></span> jest trochę cięższy. Przede wszystkim chcemy, żeby konkluzja
    była postaci <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span>, ale jak powinny wyglądać hipotezy
    indukcyjne?

<div class="paragraph"> </div>

    Jedyna słuszna odpowiedź brzmi: odpowiadają one typom wszystkich możliwych
    wywołań rekurencyjnych <span class="inlinecode"><span class="id" title="var">f</span></span> i <span class="inlinecode"><span class="id" title="var">g</span></span> na strukturalnych podtermach
    <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Jedynymi typami spełniającymi te warunki są <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, więc dajemy je sobie jako hipotezy indukcyjne.

<div class="paragraph"> </div>

    Przypadki dla <span class="inlinecode"><span class="id" title="var">Q</span></span> wyglądają podobnie: <span class="inlinecode"><span class="id" title="var">ok_snil</span></span> jest banalne, a dla
    <span class="inlinecode"><span class="id" title="var">ok_scons</span></span> konkluzja musi być jedynej słusznej postaci, a hipotezami
    indukcyjnymi jest wszystko, co pasuje.

<div class="paragraph"> </div>

    W efekcie otrzymujemy dwie funkcje, <span class="inlinecode"><span class="id" title="var">f</span></span> i <span class="inlinecode"><span class="id" title="var">g</span></span>. Tym razem następuje jednak
    mały twist: ponieważ nasza definicja jest aksjomatyczna, zagwarantować
    musimy sobie także reguły obliczania, które dotychczas były zamilaczne,
    bo wynikały z definicji przez dopasowanie do wzorca. Teraz wszystkie te
    "dopasowania" musimy napisać ręcznie w postaci odpowiednio
    skwantyfikowanych równań. Widzimy więc, że <span class="inlinecode"><span class="id" title="var">Psnil</span></span>, <span class="inlinecode"><span class="id" title="var">Pscons</span></span>, <span class="inlinecode"><span class="id" title="var">Qok_snil</span></span>
    i <span class="inlinecode"><span class="id" title="var">Qok_scons</span></span> odpowiadają klauzulom w dopasowaniu do wzorca.

<div class="paragraph"> </div>

    Ufff... udało się. Tak spreparowaną definicją aksjomatyczną możemy się
    jako-tako posługiwać: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">rec'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">snil'</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">scons'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">P</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">snil'</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">scons'</span> <span class="id" title="var">h</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span><br/>
&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">A</span> <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">P</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">True</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">t</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">scons'</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">I</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">I</span>)<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">g</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span> &amp; <span class="id" title="var">H3</span> &amp; <span class="id" title="var">H4</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H2</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Możemy na przykład dość łatwo zdefiniować niezależny rekursor tylko dla
    <span class="inlinecode"><span class="id" title="var">slist</span></span>, nie odnoszący się w żaden sposób do <span class="inlinecode"><span class="id" title="var">ok</span></span>. Widzimy jednak, że
    "programowanie" w taki aksjomatyczny sposób jest dość ciężkie - zamiast
    eleganckich dopasowań do wzorca musimy ręcznie wpisywać argumenty do
    reguły indukcyjnej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = [] /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">h</span> :: <span class="id" title="var">f</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">rec'</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) [] <span class="id" title="var">cons</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">proj1_sig</span> <span class="id" title="var">toList'</span>.<br/>

<br/>
</div>

<div class="doc">
Używanie takiego rekursora jest już dużo prostsze, co ilustruje powyższy
    przykład funkcji, która zapomina o tym, że lista jest posortowana i daje
    nam zwykłą listę.

<div class="paragraph"> </div>

    Przykładowe posortowane listy wyglądają tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">le</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">scons</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> 1 <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> 1) 0 (<span class="id" title="var">le_S</span> 0 0 (<span class="id" title="var">le_n</span> 0))).<br/>

<br/>
</div>

<div class="doc">
Niezbyt piękna, prawda? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span>.<br/>

<br/>
</div>

<div class="doc">
Utrapieniem jest też to, że nasza funkcja się nie oblicza. Jest tak, bo
    została zdefiniowana za pomocą reguły indukcji, która jest aksjomatem.
    Aksjomaty zaś, jak wiadomo, nie obliczają się.

<div class="paragraph"> </div>

    Wyniku powyższego wywołania nie będę nawet wklejał, gdyż jest naprawdę
    ohydny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">toList_slist_01_result</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span> = [0; 1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">toList</span>, <span class="id" title="var">slist_01</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">toList'</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">H2</span>, <span class="id" title="var">H1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Najlepsze, co możemy osiągnąć, mając taką definicję, to udowodnienie, że
    jej wynik faktycznie jest taki, jak się spodziewamy. 
<div class="paragraph"> </div>

<a id="lab290"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj dla list posortowanych funkcję <span class="inlinecode"><span class="id" title="var">slen</span></span>, która liczy ich długość.
    Udowodnij oczywiste twierdzenie wiążące ze sobą <span class="inlinecode"><span class="id" title="var">slen</span></span>, <span class="inlinecode"><span class="id" title="var">toList</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">length</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab291"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że przykład faktycznie jest bez sensu: zdefiniuje relację
    <span class="inlinecode"><span class="id" title="var">sorted</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">sorted</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>
    oznacza, że lista <span class="inlinecode"><span class="id" title="var">l</span></span> jest posortowana według porządku <span class="inlinecode"><span class="id" title="var">R</span></span>. Używając
    <span class="inlinecode"><span class="id" title="var">sorted</span></span> zdefiniuj typ list posortowanych <span class="inlinecode"><span class="id" title="var">slist'</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a następnie znajdź
    dwie funkcje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">slist'</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist'</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>,
    które są swoimi odwrotnościami. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab292"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Żeby przekonać się, że przykład był naprawdę bezsensowny, zdefiniuj
    rodzinę typów <span class="inlinecode"><span class="id" title="var">blist</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, gdzie elementami
    <span class="inlinecode"><span class="id" title="var">blist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> są listy posortowane, których elementy są <span class="inlinecode"><span class="id" title="var">R</span></span>-większe od <span class="inlinecode"><span class="id" title="var">x</span></span>.
    Użyj <span class="inlinecode"><span class="id" title="var">blist</span></span> do zdefiniowania typu <span class="inlinecode"><span class="id" title="var">slist''</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a następnie udowodnij,
    że <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">slist''</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> są sobie równoważne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ind_ind</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab293"></a><h4 class="section"> </h4>

<div class="paragraph"> </div>

 Na koniec wypadałoby jeszcze wspomnieć, do czego tak naprawdę można w
    praktyce użyć indukcji-indukcji (definiowanie list posortowanych nie
    jest jedną z tych rzeczy, o czym przekonałeś się w ćwiczeniach). Otóż
    najciekawszym przykładem wydaje się być formalizacja teorii typów, czyli,
    parafrazując, implementacja Coqa w Coqu.

<div class="paragraph"> </div>

    Żeby się za to zabrać, musimy zdefiniować konteksty, typy i termy, a
    także relacje konwertowalności dla typów i termów. Są tutaj możliwe dwa
    podejścia:
<ul class="doclist">
<li> Curry'ego (ang. Curry style lub mądrzej extrinsic style) - staramy
      się definiować wszystko osobno, a potem zdefiniować relacje "term x
      jest typu A w kontekście Γ", "typ A jest poprawnie sformowany w
      kontekście Γ" etc. Najważniejszą cechą tego sposobu jest to, że
      możemy tworzyć termy, którym nie da się przypisać żadnego typu oraz
      typy, które nie są poprawnie sformowane w żadnym kontekście.

</li>
<li> Churcha (ang. Church style lub mądrzej intrinsic style) - definiujemy
      wszystko na raz w jednej wielkiej wzajemnej indukcji. Zamiastów
      typów definiujemy od razu predykat "typ A jest poprawnie sformowany
      w kontekście Γ", a zamiast termów definiujemy od razu relację
      "term x ma typ A w kontekście Γ". Parafrazując - wszystkie termy,
      które jesteśmy w stanie skonstruować, są poprawnie typowane (a
      wszystkie typy poprawnie sformowane w swoich kontekstach). 
</li>
</ul>

<div class="paragraph"> </div>

 Zamiast tyle gadać zobaczmy, jak mogłoby to wyglądać w Coqu. Oczywiście
    będą to same nagłówki, bo podanie tutaj pełnej definicji byłoby mocno
    zaciemniającym przegięciem. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;Ctx&nbsp;:&nbsp;Type&nbsp;:=&nbsp;...<br/>
<br/>
with&nbsp;Ty&nbsp;:&nbsp;Ctx&nbsp;-&gt;&nbsp;Type&nbsp;:=&nbsp;...<br/>
<br/>
with&nbsp;Term&nbsp;:&nbsp;forall&nbsp;Γ&nbsp;:&nbsp;Ctx,&nbsp;Ty&nbsp;Γ&nbsp;-&gt;&nbsp;Type&nbsp;:=&nbsp;...<br/>
<br/>
with&nbsp;TyConv&nbsp;:&nbsp;forall&nbsp;Γ&nbsp;:&nbsp;Ctx,&nbsp;Ty&nbsp;Γ&nbsp;-&gt;&nbsp;Ty&nbsp;Γ&nbsp;-&gt;&nbsp;Prop&nbsp;:=&nbsp;...<br/>
<br/>
with<br/>
&nbsp;&nbsp;TermConv&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(Γ&nbsp;:&nbsp;Ctx)&nbsp;(A&nbsp;:&nbsp;Ty&nbsp;Γ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Term&nbsp;Γ&nbsp;A&nbsp;-&gt;&nbsp;Term&nbsp;Γ&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=&nbsp;...<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Nagłówki w tej definicji powinniśmy interpretować tak:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">Ctx</span></span> to typ reprezentujący konteksty.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Ty</span></span> ma reprezentować typy, ale nie jest to typ, lecz rodzina typów
      indeksowana kontekstami - każdy typ jest typem w jakimś kontekście,
      np. <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem w kontekście zawierającym <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, ale
      nie jest typem w pustym kontekście.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Term</span></span> ma reprezentować termy, ale nie jest to typ, lecz rodzina typów
      indeksowana kontekstami i typami - każdy term ma jakiś typ, a typy,
      jak już się rzekło, zawsze są typami w jakimś kontekście. Przykład:
      jeżeli <span class="inlinecode"><span class="id" title="var">x</span></span> jest zmienną, to <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">nil</span></span> jest typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> w
      kontekście, w którym <span class="inlinecode"><span class="id" title="var">x</span></span> jest typu <span class="inlinecode"><span class="id" title="var">A</span></span>, ale nie ma żadnego typu (i nie
      jest nawet poprawnym termem) w kontekście pustym ani w żadnym, w którym
      nie występuje <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">TyConv</span></span> <span class="inlinecode"><span class="id" title="var">Γ</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> zachodzi, gdy typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> są konwertowalne, czyli
      obliczają się do tego samego (relacja taka jest potrzebna, gdyż w Coqu
      i ogólnie w teorii typów występować mogą takie typy jak <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span>
      <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, który jest konwertowalny z <span class="inlinecode"><span class="id" title="var">nat</span></span>). Jako się rzekło,
      typy zawsze występują w kontekście, więc konwertowalne mogą być też
      tylko w kontekście.

</li>
<li> <span class="inlinecode"><span class="id" title="var">TermConv</span></span> <span class="inlinecode"><span class="id" title="var">Γ</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> znaczy, że termy <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> są konwertowalne,
      np. <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode">0</span> jest konwertowalne z <span class="inlinecode">42</span>. Ponieważ każdy
      term ciągnie za sobą swój typ, <span class="inlinecode"><span class="id" title="var">TermConv</span></span> ma jako indeks typ <span class="inlinecode"><span class="id" title="var">A</span></span>, a
      ponieważ typ ciągnie za sobą kontekst, indeksem <span class="inlinecode"><span class="id" title="var">TermConv</span></span> jest także
      <span class="inlinecode"><span class="id" title="var">Γ</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Jak widać, indukcji-indukcji jest w powyższym przykładzie na pęczki -
    jest ona wręcz teleskopowa, gdyż <span class="inlinecode"><span class="id" title="var">Ctx</span></span> jest indeksem <span class="inlinecode"><span class="id" title="var">Ty</span></span>, <span class="inlinecode"><span class="id" title="var">Ctx</span></span> i <span class="inlinecode"><span class="id" title="var">Ty</span></span>
    są indeksami <span class="inlinecode"><span class="id" title="var">Term</span></span>, a <span class="inlinecode"><span class="id" title="var">Ctx</span></span>, <span class="inlinecode"><span class="id" title="var">Ty</span></span> i <span class="inlinecode"><span class="id" title="var">Term</span></span> są indeksami <span class="inlinecode"><span class="id" title="var">TermConv</span></span>.

<div class="paragraph"> </div>

    Cóż, to by było na tyle w tym temacie. Ława oburzonych wyraża w tym
    momencie swoje najwyższe oburzenie na brak indukcji-indukcji w Coqu:
    https://www.sadistic.pl/lawa-oburzonych-vt22270.htm

<div class="paragraph"> </div>

    Jednak uszy do góry - istnieją już języki, które jakoś sobie radzą z
    indukcją-indukcją. Jednym z nich jest wspomniana we wstępie Agda,
    którą można znaleźć tu:
    https://agda.readthedocs.io/en/latest/ 
<div class="paragraph"> </div>

<a id="lab294"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Typ stert binarnych <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest relacją
    porządku, składa się z drzew, które mogą być albo puste, albo być węzłem
    przechowującym wartość <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wraz z dwoma poddrzewami <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>,
    przy czym <span class="inlinecode"><span class="id" title="var">v</span></span> musi być <span class="inlinecode"><span class="id" title="var">R</span></span>-większe od wszystkich elementów <span class="inlinecode"><span class="id" title="var">l</span></span> oraz <span class="inlinecode"><span class="id" title="var">r</span></span>.

<div class="paragraph"> </div>

    Użyj indukcji-indukcji, żeby zdefiniować jednocześnie typ <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> oraz
    relację <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> zachodzi, gdy <span class="inlinecode"><span class="id" title="var">v</span></span> jest <span class="inlinecode"><span class="id" title="var">R</span></span>-większe od
    wszystkich elementów <span class="inlinecode"><span class="id" title="var">h</span></span>.

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicję, a potem przetłumacz ją na odpowiedni
    zestaw aksjomatów.

<div class="paragraph"> </div>

    Następnie użyj swojej aksjomatycznej definicji, aby zdefiniować funkcję
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, która tworzy lustrzane odbicie sterty <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. Wskazówka:
    prawdopodobnie nie uda ci się zdefiniować <span class="inlinecode"><span class="id" title="var">mirror</span></span>. Zastanów się,
    dlaczego jest tak trudno. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab295"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Typ drzew wyszukiwań binarnych <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest
    relacją porządku, składa się z drzew, które mogą być albo puste, albo być
    węzłem przechowującym wartość <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wraz z dwoma poddrzewami
    <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, przy czym <span class="inlinecode"><span class="id" title="var">v</span></span> musi być <span class="inlinecode"><span class="id" title="var">R</span></span>-większe od wszystkich elemtnów
    <span class="inlinecode"><span class="id" title="var">l</span></span> oraz <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejsze od wszystkich elementów <span class="inlinecode"><span class="id" title="var">r</span></span>.

<div class="paragraph"> </div>

    Użyj indukcji-indukcji, żeby zdefiniować jednocześnie typ <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> wraz
    z odpowiednimi relacjami zapewniającymi poprawność konstrukcji węzła.
    Wypróbuj trzy podejścia:
<ul class="doclist">
<li> jest jedna relacja, <span class="inlinecode"><span class="id" title="var">oklr</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">oklr</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> oznacza, że z <span class="inlinecode"><span class="id" title="var">v</span></span>, <span class="inlinecode"><span class="id" title="var">l</span></span> i
      <span class="inlinecode"><span class="id" title="var">r</span></span> można zrobić węzeł

</li>
<li> są dwie relacje, <span class="inlinecode"><span class="id" title="var">okl</span></span> i <span class="inlinecode"><span class="id" title="var">okr</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">okl</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> oznacza, że <span class="inlinecode"><span class="id" title="var">v</span></span> jest
      <span class="inlinecode"><span class="id" title="var">R</span></span>-większe od wszystkich elementów <span class="inlinecode"><span class="id" title="var">l</span></span>, zaś <span class="inlinecode"><span class="id" title="var">okr</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>, że <span class="inlinecode"><span class="id" title="var">v</span></span> jest
      <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejsze od wszystkich elementów <span class="inlinecode"><span class="id" title="var">r</span></span>

</li>
<li> jest jedna relacja, <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> oznacza, że <span class="inlinecode"><span class="id" title="var">v</span></span> jest
      <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejsze od wszystkich elementów <span class="inlinecode"><span class="id" title="var">t</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Najpierw napisz pseudodefinicję, a potem przetłumacz ją na odpowiedni
    zestaw aksjomatów.

<div class="paragraph"> </div>

    Następnie użyj swojej aksjomatycznej definicji, aby zdefiniować funkcję
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, która tworzy lustrzane odbicie drzewa <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. Wskazówka:
    dość możliwe, że ci się nie uda. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab296"></a><h2 class="section">Indukcja-rekursja</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ind_rec</span>.<br/>

<br/>
</div>

<div class="doc">
A oto kolejny potfur do naszej kolekcji: indukcja-rekursja. Nazwa, choć
    brzmi tak głupio, jak "indukcja-indukcja", niesie ze sobą jednak dużo
    więcej wyobraźni: indukcja-rekursja pozwala nam jednocześnie definiować
    typy induktywne oraz operujące na nich funkcje rekurencyjne.

<div class="paragraph"> </div>

    Co to dokładnie znaczy? Dotychczas nasz modus operandi wyglądał tak, że
    najpierw definiowaliśmy jakiś typ induktywny, a potem przez rekursję
    definiowaliśmy operujące na nim funkcje, np:
<ul class="doclist">
<li> najpierw zdefiniowaliśmy typ <span class="inlinecode"><span class="id" title="var">nat</span></span>, a potem dodawanie, mnożenie etc.

</li>
<li> najpierw zdefiniowaliśmy typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a potem <span class="inlinecode"><span class="id" title="var">app</span></span>, <span class="inlinecode"><span class="id" title="var">rev</span></span> etc. 
</li>
</ul>

<div class="paragraph"> </div>

 Dlaczego mielibyśmy chcieć definiować typ i funkcję jednocześnie? Dla
    tego samego, co zawsze, czyli zależności - indukcja-rekursja pozwala,
    żeby definicja typu odnosiła się do funkcji, która to z kolei jest
    zdefiniowana przez rekursję strukturalną po argumencie o tym typie.

<div class="paragraph"> </div>

    Zobaczmy dobrze nam już znany bezsensowny przykład, czyli listy
    posortowane, tym razem zaimplementowane za pomocą indukcji-rekursji. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;slist&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;bool)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;snil&nbsp;:&nbsp;slist&nbsp;R<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;scons&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(h&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;slist&nbsp;R),&nbsp;ok&nbsp;h&nbsp;t&nbsp;=&nbsp;true&nbsp;-&gt;&nbsp;slist&nbsp;R<br/>
<br/>
with<br/>
<br/>
Definition&nbsp;ok<br/>
&nbsp;&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;{R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;bool}&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;slist&nbsp;R)&nbsp;:&nbsp;bool&nbsp;:=<br/>
match&nbsp;t&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;snil&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;scons&nbsp;h&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;R&nbsp;x&nbsp;h<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Coq niestety nie wspiera indukcji-rekursji, a próba napisania powyższej
    definicji kończy się błędem składni, przy którym nie pomaga nawet komenda
    <span class="inlinecode"><span class="id" title="var">Fail</span></span>. Podobnie jak poprzednio, pomożemy sobie za pomocą aksjomatów,
    jednak najpierw prześledźmy definicję.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> działa następująco:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> to jakiś porządek. Zauważ, że tym razem <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a
      więc porządek jest reprezentowany przez funkcję, która go rozstrzyga

</li>
<li> <span class="inlinecode"><span class="id" title="var">snil</span></span> to lista pusta

</li>
<li> <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> to lista z głową <span class="inlinecode"><span class="id" title="var">h</span></span> i ogonem <span class="inlinecode"><span class="id" title="var">t</span></span>, zaś <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>
      to dowód na to, że dostawienie <span class="inlinecode"><span class="id" title="var">h</span></span> przed <span class="inlinecode"><span class="id" title="var">t</span></span> daje listę posortowaną. 
</li>
</ul>

<div class="paragraph"> </div>

 Tym razem jednak <span class="inlinecode"><span class="id" title="var">ok</span></span> nie jest relacją, lecz funkcją zwracającą <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    która działa następująco:
<ul class="doclist">
<li> dla <span class="inlinecode"><span class="id" title="var">snil</span></span> zwróć <span class="inlinecode"><span class="id" title="var">true</span></span> - każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> można dostawić do listy pustej

</li>
<li> dla <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> zwróć wynik porównania <span class="inlinecode"><span class="id" title="var">x</span></span> z <span class="inlinecode"><span class="id" title="var">h</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Istotą mechanizmu indukcji-rekursji w tym przykładzie jest to, że <span class="inlinecode"><span class="id" title="var">scons</span></span>
    wymaga dowodu na to, że funkcja <span class="inlinecode"><span class="id" title="var">ok</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span>, podczas gdy funkcja
    ta jest zdefiniowana przez rekursję strukturalną po argumencie typu
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Użycie indukkcji-rekursji do zaimplementowania <span class="inlinecode"><span class="id" title="var">slist</span></span> ma swoje zalety:
    dla konkretnych list (złożonych ze stałych, a nie ze zmiennych) dowody
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> będą postaci <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>, bo <span class="inlinecode"><span class="id" title="var">ok</span></span> po prostu obliczy się
    do <span class="inlinecode"><span class="id" title="var">true</span></span>. W przypadku indukcji-indukcji dowody na <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> były całkiem
    sporych rozmiarów drzewami. Innymi słowy, udało nam się zastąpić część
    termu obliczeniami. Ten intrygujący motyw jeszcze się w przyszłości
    pojawi, gdy omawiać będziemy dowód przez reflekcję.

<div class="paragraph"> </div>

    Dosyć gadania! Zobaczmy, jak zakodować powyższą definicję za pomocą
    aksjomatów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">slist</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}, <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">x</span> (@<span class="id" title="var">snil</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span>) = <span class="id" title="var">true</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> <span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>).<br/>

<br/>
</div>

<div class="doc">
Najpierw musimy zadeklarować <span class="inlinecode"><span class="id" title="var">slist</span></span>, a następnie <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdyż typ <span class="inlinecode"><span class="id" title="var">ok</span></span>
    zależy od <span class="inlinecode"><span class="id" title="var">slist</span></span>. Następnym krokiem jest zadeklarowanie konstruktorów
    <span class="inlinecode"><span class="id" title="var">slist</span></span>, a później równań definiujących funkcję <span class="inlinecode"><span class="id" title="var">ok</span></span> - koniecznie w tej
    kolejności, gdyż równania zależą od konstruktorów.

<div class="paragraph"> </div>

    Jak widać, aksjomaty są bardzo proste i sprowadzają się do przepisania
    powyższej definicji odrzuconej przez Coqa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Psnil</span> : <span class="id" title="var">P</span> <span class="id" title="var">snil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pscons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">Psnil</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">Pscons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>))}.<br/>

<br/>
</div>

<div class="doc">
Innym zyskiem z użycia indukcji-rekursji jest postać reguły indukcyjnej.
    Jest ona dużo prostsza, niż w przypadku indukcji-indukcji, gdyż teraz
    definiujemy tylko jeden typ, zaś towarzysząca mu funkcja nie wymaga w
    regule niczego specjalnego - po prostu pojawia się w niej tam, gdzie
    spodziewamy się jej po definicji <span class="inlinecode"><span class="id" title="var">slist</span></span>, ale nie robi niczego
    ponad to. Może to sugerować, że zamiast indukcji-indukcji, o ile to
    możliwe, lepiej jest używać indukcji-rekursji, a predykaty i relacje
    definiować przez rekursję.

<div class="paragraph"> </div>

    Powyższą regułę możemy odczytać następująco:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> to parametry <span class="inlinecode"><span class="id" title="var">slist</span></span>, więc muszą się
      pojawić

</li>
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> to przeciwdziedzina funkcji definiowanej za
      pomocą reguły

</li>
<li> <span class="inlinecode"><span class="id" title="var">Psnil</span></span> to wynik funkcji dla <span class="inlinecode"><span class="id" title="var">snil</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">Pscons</span></span> produkuje wynik funkcji dla <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> z hipotezy
      indukcyjnej/wywołania rekurencyjnego dla <span class="inlinecode"><span class="id" title="var">t</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> to funkcja zdefiniowana przez regułę,
      zaś równania formalizują to, co zostało napisane powyżej o <span class="inlinecode"><span class="id" title="var">Psnil</span></span>
      i <span class="inlinecode"><span class="id" title="var">Pscons</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Termy induktywno-rekurencyjnego <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> wyglądają następująco
    (najpierw definiujemy sobie funkcję rozstrzygającą standardowy
    porządek na liczbach naturalnych): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">leb</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, 0 =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">leb</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">leb</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">scons</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> 0 1 <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> 1)).<br/>

<br/>
</div>

<div class="doc">
Nie wygląda wiele lepiej od poprzedniej, induktywno-induktywnej wersji,
    prawda? Ta rażąca kiepskość nie jest jednak zasługą indukcji-rekursji,
    lecz kodowania za pomocą aksjomatów - funkcja <span class="inlinecode"><span class="id" title="var">ok</span></span> się nie oblicza,
    więc zamiast <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> musimy używać aksjomatów <span class="inlinecode"><span class="id" title="var">ok_snil</span></span> i <span class="inlinecode"><span class="id" title="var">ok_scons</span></span>.

<div class="paragraph"> </div>

    W tym momencie znów wkracza ława oburzonych i wyraża swoje oburzenie na
    fakt, że Coq nie wspiera indukcji-rekursji (ale Agda już tak). Gdyby
    <span class="inlinecode"><span class="id" title="var">Coq</span></span> wspierał indukcję-rekursję, to ten term wyglądałby tak: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">leb</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0 (<span class="id" title="var">scons</span> 1 <span class="id" title="var">snil</span> <span class="id" title="var">eq_refl</span>) <span class="id" title="var">eq_refl</span>.<br/>

<br/>
</div>

<div class="doc">
Dużo lepiej, prawda? Na koniec zobaczmy, jak zdefiniować funkcję
    zapominającą o fakcie, że lista jest posortowana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = [] /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">h</span> :: <span class="id" title="var">f</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ind</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>) [] (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> =&gt; <span class="id" title="var">h</span> :: <span class="id" title="var">r</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">proj1_sig</span> <span class="id" title="var">toList'</span>.<br/>

<br/>
</div>

<div class="doc">
Ponownie jest to dużo prostsze, niż w przypadku indukcji-indukcji -
    wprawdzie wciąż musimy ręcznie wpisywać termy do reguły indukcji,
    ale dzięki prostocie reguły jest to znacznie łatwiejsze. Alternatywnie:
    udało nam się zaoszczędzić trochę czasu na definiowaniu reguły rekursji,
    co w przypadku indukcji-indukcji było niemal konieczne, żeby nie
    zwariować. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">toList_slist_01_result</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span> = [0; 1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">toList</span>, <span class="id" title="var">slist_01</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">toList'</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">H2</span>, <span class="id" title="var">H1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Udowodnienie, że nasza funkcja daje taki wynik jak chcieliśmy, jest
    równie proste jak poprzednio. 
<div class="paragraph"> </div>

<a id="lab297"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj dla list posortowanych funkcję <span class="inlinecode"><span class="id" title="var">slen</span></span>, która liczy ich długość.
    Udowodnij oczywiste twierdzenie wiążące ze sobą <span class="inlinecode"><span class="id" title="var">slen</span></span>, <span class="inlinecode"><span class="id" title="var">toList</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">length</span></span>. Czy było łatwiej, niż w przypadku indukcji-indukcji? 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ind_rec</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab298"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 No cóż, jeszcze raz to samo. Zdefiniuj za pomocą indukcji-rekursji
    jednocześnie typ stert binarnych <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    rozstrzyga porządek, i funkcję <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy stertę <span class="inlinecode"><span class="id" title="var">h</span></span> można podczepić pod element <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicję, a potem przetłumacz ją na odpowiedni
    zestaw aksjomatów.

<div class="paragraph"> </div>

    Następnie użyj swojej aksjomatycznej definicji, aby zdefiniować funkcję
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, która tworzy lustrzane odbicie sterty <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. Wskazówka:
    tym razem powinno ci się udać.

<div class="paragraph"> </div>

    Porównaj induktywno-rekurencyjną implementację <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">ok</span></span> z
    implementacją przez indukcję-indukcję. Która jest bardziej ogólna?
    Która jest "lżejsza"? Która jest lepsza? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab299"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 No cóż, jeszcze raz to samo. Zdefiniuj za pomocą indukcji-rekursji
    jednocześnie typ drzew wyszukiwań binarnych <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> rozstrzyga porządek, oraz funkcje
    <span class="inlinecode"><span class="id" title="var">oklr</span></span>/<span class="inlinecode"><span class="id" title="var">okl</span></span> i <span class="inlinecode"><span class="id" title="var">okr</span></span>/<span class="inlinecode"><span class="id" title="var">ok</span></span>, które dbają o odpowiednie warunki (wybierz
    tylko jeden wariant z trzech, które testowałeś w tamtym zadaniu).

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicję, a potem przetłumacz ją na odpowiedni
    zestaw aksjomatów.

<div class="paragraph"> </div>

    Następnie użyj swojej aksjomatycznej definicji, aby zdefiniować funkcję
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, która tworzy lustrzane odbicie drzewa <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. Wskazówka:
    tym razem powinno ci się udać.

<div class="paragraph"> </div>

    Porównaj induktywno-rekurencyjną implementację <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> z implementacją
    przez indukcję-indukcję. Która jest bardziej ogólna? Która jest
    "lżejsza"? Która jest lepsza? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, pojawia się pytanie: do czego w praktyce
    można użyć indukcji-rekursji (poza rzecz jasna głupimi strukturami
    danych, jak listy posortowane)? W świerszczykach dla bystrzaków
    (czyli tzw. "literaturze naukowej") przewija się głównie jeden (ale
    jakże użyteczny) pomysł: uniwersa.

<div class="paragraph"> </div>

    Czym są uniwersa i co mają wspólnego z indukcją-rekursją? Najlepiej
    będzie przekonać się na przykładzie programowania generycznego: 
<div class="paragraph"> </div>

<a id="lab300"></a><h4 class="section">Ćwiczenie (zdecydowanie za trudne)</h4>

<div class="paragraph"> </div>

 Zaimplementuj generyczną funkcję <span class="inlinecode"><span class="id" title="var">flatten</span></span>, która spłaszcza dowolnie
    zagnieżdżone listy list do jednej, płaskiej listy.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">5</span> <span class="inlinecode">=</span> <span class="inlinecode">[5]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[[1];</span> <span class="inlinecode">[2];</span> <span class="inlinecode">[3]]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[[[1;</span> <span class="inlinecode">2]];</span> <span class="inlinecode">[[3]];</span> <span class="inlinecode">[[4;</span> <span class="inlinecode">5];</span> <span class="inlinecode">[6]]]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6]</span> 
<div class="paragraph"> </div>

 Trudne, prawda? Ale robialne, a robi się to tak.

<div class="paragraph"> </div>

    W typach argumentów <span class="inlinecode"><span class="id" title="var">flatten</span></span> na powyższym przykładzie widać pewien
    wzorzec: są to kolejno <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>,
    <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>))</span> i tak dalej. Możemy ten "wzorzec" bez problemu
    opisać za pomocą następującego typu: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">FlattenType</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> : <span class="id" title="var">FlattenType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">List</span> : <span class="id" title="var">FlattenType</span> -&gt; <span class="id" title="var">FlattenType</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby było śmieszniej, <span class="inlinecode"><span class="id" title="var">FlattenType</span></span> to dokładnie to samo co <span class="inlinecode"><span class="id" title="var">nat</span></span>, ale
    przemilczmy to. Co dalej? Możemy myśleć o elementach <span class="inlinecode"><span class="id" title="var">FlattenType</span></span> jak
    o kodach prawdziwych typów, a skoro są to kody, to można też napisać
    funkcję dekodującą: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">decode</span> (<span class="id" title="var">t</span> : <span class="id" title="var">FlattenType</span>) : <span class="id" title="keyword">Type</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> =&gt; <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">List</span> <span class="id" title="var">t'</span> =&gt; <span class="id" title="var">list</span> (<span class="id" title="var">decode</span> <span class="id" title="var">t'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">decode</span></span> każdemu kodowi przyporządkowuje odpowiadający mu typ. O
    kodach możemy myśleć jak o nazwach - <span class="inlinecode"><span class="id" title="var">Nat</span></span> to nazwa <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaś
    <span class="inlinecode"><span class="id" title="var">List</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> to nazwa typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">decode</span></span> <span class="inlinecode"><span class="id" title="var">t'</span>)</span>, np. <span class="inlinecode"><span class="id" title="var">List</span></span> <span class="inlinecode">(<span class="id" title="var">List</span></span> <span class="inlinecode"><span class="id" title="var">Nat</span>)</span>
    to nazwa typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>.

<div class="paragraph"> </div>

    Para <span class="inlinecode">(<span class="id" title="var">FlattenType</span>,</span> <span class="inlinecode"><span class="id" title="var">decode</span>)</span> jest przykładem uniwersum.

<div class="paragraph"> </div>

    Uniwersum to, najprościej pisząc, worek, który zawiera jakieś typy.
    Formalnie uniwersum składa się z typu kodów (czyli "nazw" typów) oraz
    funkcji dekodującej, która przyporządkowuje kodom prawdziwe typy.

<div class="paragraph"> </div>

    Programowanie generyczne to programowanie funkcji, które operują na
    kolekcjach typów o dowolnych kształtach, czyli na uniwersach właśnie.
    Generyczność od polimorfizmu różni się tym, że funkcja polimorficzna
    działa dla dowolnego typu, zaś generyczna - tylko dla typu o pasującym
    kształcie.

<div class="paragraph"> </div>

    Jak dokończyć implementację funkcji <span class="inlinecode"><span class="id" title="var">flatten</span></span>? Kluczowe jest zauważenie,
    że możemy zdefiniować <span class="inlinecode"><span class="id" title="var">flatten</span></span> przez rekursję strutkuralną po argumencie
    domyślnym typu <span class="inlinecode"><span class="id" title="var">FlattenType</span></span>. Ostatni problem to jak zrobić, żeby Coq sam
    zgadywał kod danego typu - dowiemy się tego w rozdziale o klasach.

<div class="paragraph"> </div>

    Co to wszystko ma wspólnego z uniwersami? Ano, jeżeli chcemy definiować
    bardzo zaawansowane funkcje generyczne, musimy mieć do dyspozycji bardzo
    potężne uniwersa i to właśnie je zapewnia nam indukcja-rekursja. Ponieważ
    w powyższym przykładzie generyczność nie była zbyt wyrafinowana, nie było
    potrzeby używania indukcji-rekursji, jednak uszy do góry: przykład nieco
    bardziej skomplikowanego uniwersum pojawi się jeszcze w tym rozdziale. 
<div class="paragraph"> </div>

<a id="lab301"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Nieco podchwytliwe zadanie: zdefiniuj uniwersum funkcji <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>, <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> i tak dalej, dowolnie zagnieżdżonych.

<div class="paragraph"> </div>

    Zagadka: czy potrzebna jest nam indukcja-rekursja? 
<div class="paragraph"> </div>

<a id="lab302"></a><h2 class="section">Indeksowana indukcja-rekursja</h2>

<div class="paragraph"> </div>

 Za siedmioma górami, za siedmioma lasami, za siedmioma rzekami, za
    siedmioma budkami telefonicznymi, nawet za indukcją-rekursją (choć
    tylko o kroczek) leży indeksowana indukcja-rekursja, czyli połączenie
    indukcji-rekursji oraz indeksowanych rodzin typów.

<div class="paragraph"> </div>

    Jako, że w porównaniu do zwykłej indukcji-rekursji nie ma tu za wiele
    innowacyjności, przejdźmy od razu do przykładu przydatnej techniki,
    którą nasza tytułowa bohaterka umożliwia, a zwie się on metodą
    induktywnej dziedziny.

<div class="paragraph"> </div>

    Pod tą nazwą kryje się sposób definiowania funkcji, pozwalający oddzielić
    samą definicję od dowodu jej terminacji. Jeżeli ten opis nic ci nie mówi,
    nie martw się: dotychczas definiowaliśmy tylko tak prymitywne funkcje, że
    tego typu fikołki nie były nam potrzebne.

<div class="paragraph"> </div>

    Metoda induktywnej dziedziny polega na tym, żeby zamiast funkcji
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, która nie jest strukturalnie rekurencyjna (na co Coq
    nie pozwala) napisać funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest "predykatem dziedziny", który sprawia, że dziwna
    rekursja z oryginalnej definicji <span class="inlinecode"><span class="id" title="var">f</span></span> staje się rekursją strukturalną
    po dowodzie <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Żeby zdefiniować oryginalne <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wystarczy
    udowodnić, że każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> spełnia predykat dziedziny.

<div class="paragraph"> </div>

    Co to wszystko ma wspólnego z indeksowaną indukcją-rekursją? Już piszę.
    Otóż metoda ta nie wymaga w ogólności indukcji-rekursji - ta staje się
    potrzebna dopiero, gdy walczymy z bardzo złośliwymi funkcjami, czyli
    takimi, w których rekursja jest zagnieżdżona, tzn. robimy wywołanie
    rekurencyjne na wyniku poprzedniego wywołania rekurencyjnego.

<div class="paragraph"> </div>

    Predykat dziedziny dla takiej funkcji musi zawierać konstruktor w stylu
    "jeżeli wynik wywołania rekurencyjnego na x należy do dziedziny, to x też
    należy do dziedziny".To właśnie tu ujawnia się indukcja-rekursja: żeby
    zdefiniować predykat dziedziny, musimy odwołać się do funkcji (żeby móc
    powiedzieć coś o wyniku wywołania rekurencyjnego), a żeby zdefiniować
    funkcję, musimy mieć predykat dziedziny.

<div class="paragraph"> </div>

    Brzmi skomplikowanie? Jeżeli czegoś nie rozumiesz, to jesteś debi...
    a nie, czekaj. Jeżeli czegoś nie rozumiesz, to nie martw się: powyższy
    przykład miał na celu jedynie zilustrować jakieś praktyczne zastosowanie
    indeksowanej indukcji-rekursji. Do metody induktywnej dziedziny powrócimy
    w kolejnym rozdziale. Pokażemy, jak wyeliminować z niej indukcję-rekursję,
    tak żeby uzyskane za jej pomocą definicje można było odpalać w Coqu.
    Zobaczymy też, jakimi sposobami dowodzić, że każdy element dziedziny
    spełnia predykat dziedziny, co pozwoli nam odzyskać oryginalną definicję
    funkcji, a także dowiemy się, jak z "predykatu" o typie <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    zrobić prawdziwy predykat <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
<div class="paragraph"> </div>

<a id="lab303"></a><h2 class="section">Indukcja-indukcja-rekursja</h2>

<div class="paragraph"> </div>

 Ufff... przebrnęliśmy przez indukcję-indukcję i (indeksowaną)
    indukcję-rekursję. Czy mogą istnieć jeszcze potężniejsze i bardziej
    innowacyjne sposoby definiowania typów przez indukcję?

<div class="paragraph"> </div>

    Ależ oczywiście. Jest nim... uwaga uwaga, niespodzianka...
    indukcja-indukcja-rekursja, która jest nie tylko strasznym
    potfurem, ale też powinna dostać Oskara za najlepszą nazwę.

<div class="paragraph"> </div>

    Chodzi tu oczywiście o połączenie indukcji-indukcji i indukcji-rekursji:
    możemy jednocześnie zdefiniować jakiś typ <span class="inlinecode"><span class="id" title="var">A</span></span>, rodzinę typów <span class="inlinecode"><span class="id" title="var">B</span></span>
    indeksowaną przez <span class="inlinecode"><span class="id" title="var">A</span></span> oraz operujące na nich funkcje, do których
    konstruktory <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> mogą się odwoływać.

<div class="paragraph"> </div>

    Nie ma tu jakiejś wielkiej filozofii: wszystkiego, co powinieneś wiedzieć
    o indukcji-indukcji-rekursji, dowiedziałeś się już z dwóch poprzednich
    podrozdziałów. Nie muszę chyba dodawać, że ława oburzonych jest oburzona
    faktem, że Coq nie wspiera indukcji-indukcji-rekursji.

<div class="paragraph"> </div>

    Rodzi się jednak to samo super poważne pytanie co zawsze, czyli do czego
    można tego tałatajstwa użyć? Przez całkiem długi czas nie miałem pomysłu,
    ale okazuje się, że jest jedno takie zastosowanie i w sumie narzuca się
    ono samo.

<div class="paragraph"> </div>

    Przypomnij sobie metodę induktywno-rekurencyjnej dziedziny, czyli jedno
    ze sztandarowych zastosowań indeksowanej indukcji-rekursji. Zaczynamy od
    typu <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, na którym chcemy zdefiniować funkcję o niestandardowym
    kształcie rekursji. W tym celu definiujemy dziedzinę <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    wraz z funkcją <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span>,</span> <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Zauważmy, jaki jest związek typu <span class="inlinecode"><span class="id" title="var">I</span></span> z funkcją <span class="inlinecode"><span class="id" title="var">f</span></span>: najpierw jest typ,
    potem funkcja. Co jednak, gdy musimy <span class="inlinecode"><span class="id" title="var">I</span></span> oraz <span class="inlinecode"><span class="id" title="var">f</span></span> zdefiniować razem za
    pomocą indukcji-rekursji? Wtedy <span class="inlinecode"><span class="id" title="var">f</span></span> może być zdefiniowane jedynie za
    pomocą rekursji strukturalnej po <span class="inlinecode"><span class="id" title="var">I</span></span>, co wyklucza rekursję o fikuśnym
    kształcie...

<div class="paragraph"> </div>

    I tu wchodzi indukcja-indukcja-rekursja, cała na biało. Możemy użyć
    jej w taki sposób, że definiujemy jednocześnie:
<ul class="doclist">
<li> typ <span class="inlinecode"><span class="id" title="var">I</span></span>, który odnosi się do funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>

</li>
<li> predykat dziedziny <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, który jest indeksowany przez <span class="inlinecode"><span class="id" title="var">I</span></span>

</li>
<li> funkcję <span class="inlinecode"><span class="id" title="var">f</span></span>, która zdefiniowana jest przez rekursję strukturalną po
      dowodzie należenia do dziedziny

</li>
</ul>

<div class="paragraph"> </div>

    Jak widać, typ zależy od funkcji, funkcja od predykatu, a predykat od
    typu i koło się zamyka.

<div class="paragraph"> </div>

    Następuje jednak skądinąd uzasadnione pytanie: czy faktycznie istnieje
    jakaś sytuacja, w której powyższy schemat działania jest tym słusznym?
    Odpowiedź póki co może być tylko jedna: nie wiem, ale się domyślam. 
<div class="paragraph"> </div>

<a id="lab304"></a><h2 class="section">Najstraszniejszy potfur</h2>

<div class="paragraph"> </div>

 Na koniec dodam jeszcze na zachętę (albo zniechętę, zależy jakie kto
    ma podejście), że istnieje jeszcze jeden potfur, straszniejszy nawet
    niż indukcja-indukcja-rekursja, ale jest on zbyt straszny jak na ten
    rozdział i być może w ogóle zbyt straszny jak na tę książkę - panie
    boże, daj odwagę na omówienie go! 
<div class="paragraph"> </div>

<a id="lab305"></a><h1 class="section">Dobre, złe i podejrzane typy induktywne</h1>

<div class="paragraph"> </div>

 Poznana przez nas dotychczas definicja typów induktywnych (oraz wszelkich
    ich ulepszeń, jak indukcja-indukcja, indukcja-rekursja etc.) jest
    niepełna. Tak jak świat pełen jest złoczyńców oszukujących starszych
    ludzi metodą "na wnuczka", tak nie każdy typ podający się za induktywny
    faktycznie jest praworządnym obywatelem krainy typów induktywnych.

<div class="paragraph"> </div>

    Na szczęście typy induktywne to istoty bardzo prostolinijne, zaś te złe
    można odróżnić od tych dobrych gołym okiem, za pomocą bardzo prostego
    kryterium: złe typy induktywne to te, które nie są ściśle pozytywne.
    Zanim jednak dowiemy się, jak rozpoznawać złe typy induktywne, poznajmy
    najpierw dwa powody, przez które złe typy induktywne są złe.

<div class="paragraph"> </div>

    Przyjrzyjmy się poniższemu typowemu przypadkowi negatywnego typu
    induktywnego (co dokładnie znaczy w tym kontekście słowo "negatywny"
    i jak takie typy rozpoznawać zobaczymy później): 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;"(wut&nbsp;A&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;wut&nbsp;A".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Uwaga: poprzedzenie komendą <span class="inlinecode"><span class="id" title="var">Fail</span></span> innej komendy oznajmia Coqowi, że
    spodziewamy się, iż komenda zawiedzie. Coq akceptuje komendę <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>,
    jeżeli komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zawodzi, i wypisuje jej komunikat o błędzie. Jeżeli
    komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zakończy się sukcesem, komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> zwróci błąd.
    Komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> jest przydatna w sytuacjach takich jak obecna, gdy
    chcemy zilustrować fakt, że jakaś komenda zawodzi.

<div class="paragraph"> </div>

    W naszym przypadku komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> kończy się sukcesem, a zatem próba
    zdefiniowania powyższego typu induktywnego się nie powiodła. Wiadomość
    o błędzie podaje nam, jak na tacy, powód tej sytuacji: typ konstruktora
    <span class="inlinecode"><span class="id" title="var">C</span></span> zawiera nie-ściśle-pozytywne wystąpienie definiowanego typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> ma też jednak pewne wady: poza poświadczeniem rezultatu
    wykonania komendy <span class="inlinecode"><span class="id" title="var">c</span></span>, nie ma ona żadnych innych skutków. To sprawia, że
    użycie <span class="inlinecode"><span class="id" title="var">Fail</span></span> zmusiłoby nas, w dalszej części podrozdziału, do zaledwie
    udawania, że mamy jakiś typ i coś z nim robimy. To zaś jest bardzo złe,
    bo bez czujnego Coqowego oka bardzo łatwo jest napisać coś głupiego lub
    popełnić jakiś inny błąd. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">wut</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Na szczęście jest sposób na to, byśmy mogli pobawić się nie-ściśle-pozytywnymi
    typami induktywnymi pod czujnym okiem Coqa: posługując się komendą <span class="inlinecode"><span class="id" title="keyword">Unset</span></span>
    <span class="inlinecode"><span class="id" title="var">Positivity</span></span> <span class="inlinecode"><span class="id" title="var">Checking</span></span> możemy wyłączyć positivity checker (czyli po polsku
    "sprawdzacz pozytywności"), co sprawi, że Coq zaakceptuje definicję typu <span class="inlinecode"><span class="id" title="var">wut</span></span>.
    Dzięki temu będziemy mogli posługiwać się tym typem jak gdyby nigdy nic.

<div class="paragraph"> </div>

    Oczywiście takie rozwiązanie również niesie za sobą negatywne konsekwencje:
    jak za chwilę zobaczymy, z istnienia typu <span class="inlinecode"><span class="id" title="var">wut</span></span> można wywnioskować dowód
    fałszu, a zatem od teraz możemy udowodnić w Coqu dosłownie wszystko, więc
    teoretycznie wszystkie nasze dowody stają się bezwartościowe. W praktyce
    rzecz jasna nie będziemy tej sprzeczności wykorzystywać w niecnych celach,
    a istnienie typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dopuszczamy tylko w celach ilustracyjnych. 
<div class="paragraph"> </div>

<a id="lab306"></a><h2 class="section">Nieterminacja jako źródło zła na świecie</h2>

<div class="paragraph"> </div>

 Pierwszym powodem nielegalności nie-ściśle-pozytywnych typów induktywnych
    jest to, że unieważniają one filozoficzną interpretację teorii typów i
    pozwalają łamać reguły dzięki którym to co robimy w Coqu ma jakikolwiek
    sens (co jednak tylko czasami prowadzi do sprzeczności bezpośrednio).
    Przyjrzyjmy się poniższemu programowi: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> (<span class="id" title="var">w</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">w</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> <span class="id" title="var">_</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">g</span> <span class="id" title="var">w</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">in</span> <span class="id" title="var">f</span> (<span class="id" title="var">C</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
Już sam typ tego programu wygląda złowrogo: dla każdego typu <span class="inlinecode"><span class="id" title="var">A</span></span> program
    zwraca element typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Nie dziwota więc, że możemy uzyskać z niego dowód
    fałszu wstawiając <span class="inlinecode"><span class="id" title="var">False</span></span> za <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">santa_is_a_pedophile</span> : <span class="id" title="var">False</span> := <span class="id" title="var">loop</span> <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
Paradoksalnie jednak to nie ta rażąca sprzeczność jest naszym największym
    problemem - nie z każdego złego typu induktywnego da się tak łatwo dostać
    sprzeczność (systematyczny sposób dostawania sprzeczności z istnienia
    takich typów zobaczymy później). W rzeczywistości jest nim nieterminacja.

<div class="paragraph"> </div>

    Nieterminacja (ang. nontermination) lub kolokwialniej zapętlenie to sytuacja,
    w której program nigdy nie skończy się wykonywać. Ta właśnie bolączka jest
    przypadłością <span class="inlinecode"><span class="id" title="var">loop</span></span>, czego nietrudno domyślić się po nazwie.

<div class="paragraph"> </div>

    Dlaczego <span class="inlinecode"><span class="id" title="var">loop</span></span> nie terminuje? Przyjrzyjmy się definicji: za pomocą <span class="inlinecode"><span class="id" title="keyword">let</span></span>a
    definiujemy funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, która odpakowuje swój argument <span class="inlinecode"><span class="id" title="var">w</span></span>,
    wyciąga z niego funkcję <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> i aplikuje <span class="inlinecode"><span class="id" title="var">g</span></span> do <span class="inlinecode"><span class="id" title="var">w</span></span>, czyli do
    oryginalnego argumentu <span class="inlinecode"><span class="id" title="var">f</span></span>. Wynikiem całego programu jest <span class="inlinecode"><span class="id" title="var">f</span></span> zaaplikowane
    do siebie samego zawiniętego w konstruktor <span class="inlinecode"><span class="id" title="var">C</span></span> (żeby typy się zgadzały).

<div class="paragraph"> </div>

    Ta aplikacja czegoś do samego siebie to kolejny sygnał ostrzegawczy, który
    powinien wzbudzić naszą czujność. Ogólniej sytuacja, w której coś odnosi
    się samo do siebie, nazywa się autoreferencją i często prowadzi do różnych
    wesołych paradoksów.

<div class="paragraph"> </div>

    Żeby jeszcze lepiej zrozumieć nieterminację <span class="inlinecode"><span class="id" title="var">loop</span></span>, spróbujmy interaktywnie
    prześledzić, w jaki sposób program ten się oblicza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">loop</span> <span class="id" title="var">unit</span> = <span class="id" title="var">tt</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> [<span class="id" title="var">loop</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">zeta</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>. <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>. <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>; <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli jesteś leniwy i nie masz włączonego CoqIDE, sprowadza się to do czegoś
    w tym stylu:

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span>

<div class="paragraph"> </div>

    i tak dalej.

<div class="paragraph"> </div>

    To natomiast, co powinno nas tu zdziwić, to fakt, że <span class="inlinecode"><span class="id" title="var">loop</span></span> jest funkcją
    w pewnym sensie rekurencyjną (bo funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> wywołuje sama siebie), mimo
    że przecież nie użyliśmy komendy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>!

<div class="paragraph"> </div>

    To jest właśnie jeden z przejawów zamętu, jaki wprowadzają negatywny typy
    induktywne - zmieniają reguły gry. Dotychczas <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (i <span class="inlinecode"><span class="id" title="keyword">fix</span></span>) dawały
    nam możliwość użycia rekursji (a w praktyce oznaczały, że rekursji faktycznie
    użyliśmy), zaś <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> (i <span class="inlinecode"><span class="id" title="keyword">fun</span></span>) świadczyło o tym, że funkcja nie jest
    rekurencyjna. Od kiedy tylko Coq zaakceptował definicję typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, regułę
    tę można bez przeszkód łamać, z opłakanymi konsekwencjami.

<div class="paragraph"> </div>

    Przyjrzyjmy się teraz problemom filozoficznym powodowanym przez
    nieterminację. W skrócie: zmienia ona fundamentalne właściwości
    obliczeń, co prowadzi do zmiany interpretacji pojęcia typu, zaś
    to pociąga za sobą kolejne przykre skutki, takie jak np. to, że
    reguły eliminacji tracą swoje uzasadnienie. Brzmi mega groźnie,
    prawda?

<div class="paragraph"> </div>

    Na szczęście tak naprawdę, to sprawa jest prosta. W Coqu wymagamy,
    aby każde obliczenie się kończyło. Końcowe wyniki obliczeń (zwane też
    wartościami, postaciami kanonicznymi lub postaciami normalnymi) możemy
    utożsamiać z elementami danego typu. Dla przykładu wynikami obliczania
    termów typu <span class="inlinecode"><span class="id" title="var">bool</span></span> są <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>, więc możemy myśleć, że są to
    elementy typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> składa się tylko z nich. To z kolei daje
    nam uzasadnienie reguły eliminacji (czyli indukcji) dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span>:
    żeby udowodnić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> dla każdego <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, wystarczy
    udowodnić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>, gdyż <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span> są jedynymi
    elementami typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    Nieterminacja obraca tę jakże piękną filozoficzną wizję w perzynę:
    nie każde obliczenie się kończy, a przez to powstają nowe, "dziwne"
    elementy różnych typów. <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> nigdy nie obliczy się do <span class="inlinecode"><span class="id" title="var">true</span></span> ani
    do <span class="inlinecode"><span class="id" title="var">false</span></span>, więc możemy traktować je jako nowy element typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. To
    sprawia, że <span class="inlinecode"><span class="id" title="var">bool</span></span>, typ z założenia dwuelementowy, ma teraz co najmniej
    trzy elementy - <span class="inlinecode"><span class="id" title="var">true</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Z tego też powodu reguła
    eliminacji przestaje obowiązywać, bo wymaga ona dowodów jedynie dla
    <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>, ale milczy na temat <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Moglibyśmy próbować
    naiwnie ją załatać, uwzględniając ten dodatkowy przypadek, ale tak po
    prawdzie, to nie wiadomo nawet za bardzo jakie jeszcze paskudztwa
    rozpanoszyły się w typie <span class="inlinecode"><span class="id" title="var">bool</span></span> z powodu nieterminacji.

<div class="paragraph"> </div>

    Morał jest prosty: nieterminacja to wynalazek szatana, a negatywne
    typy induktywne to też wynalazek szatana. 
<div class="paragraph"> </div>

<a id="lab307"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Użyj typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> żeby zdefiniować nieskończoną liczbę naturalną <span class="inlinecode"><span class="id" title="tactic">omega</span></span>
    (jeżeli szukasz inspiracji, zerknij na definicję <span class="inlinecode"><span class="id" title="var">loop</span></span>). Następnie udowodnij,
    że <span class="inlinecode"><span class="id" title="tactic">omega</span></span> jest większa od każdej innej liczby naturalnej. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">lt_n_omega</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="tactic">omega</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab308"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Jakie elementy ma typ <span class="inlinecode"><span class="id" title="var">nat</span></span>? Wypisz kilka początkowych, a potem opisz
    ogólną zasadę ich powstawania.

<div class="paragraph"> </div>

    Napisz jakiś term <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, który nie jest wartością, ale terminuje.
    Jaki jest wynik obliczenia tego termu?

<div class="paragraph"> </div>

    Następnie przyjrzyj się termowi <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Czy term ten terminuje?
    Pobaw się nim w trybie dowodzenia, żeby się przekonać (że nie, bo
    niby czego innego się spodziewałeś?).

<div class="paragraph"> </div>

    Przypomnij sobie regułę indukcji dla <span class="inlinecode"><span class="id" title="var">nat</span></span>. Gdyby udowodnić przez
    indukcję <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, jak wygląda dowód <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">t</span></span>
    to term, który napisałeś powyżej? A jak wygląda dowód <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>? 
<div class="paragraph"> </div>

<a id="lab309"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Spróbujmy lepiej zrozumieć, o co chodzi z tym, że reguły eliminacji "tracą
    swoje uzasadnienie": udowodnij, że dla każdej liczby naturalnej istnieje
    liczba od niej większa (zdaje się, że już to przerabialiśmy). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">no_greatest</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Jak to możliwe, że udało nam się udowodnić to twierdzenie, skoro przecież
    w poprzedinm ćwiczeniu udowodniliśmy, że największą liczbą naturalną jest
    <span class="inlinecode"><span class="id" title="tactic">omega</span></span>?

<div class="paragraph"> </div>

    Ano, <span class="inlinecode"><span class="id" title="tactic">omega</span></span> jest niestandardową liczbą naturalną - pomiotem szatana
    powstałym w wyniku nieterminacji - i w związku z tym indukcja milczy
    na jej temat. Parafrazując: żeby udowodnić coś dla wszystkich liczb
    naturalnych przez indukcję, w ogóle nie musimy przejmować się omegą.
    Chyba nie trzeba dodawać, że to kolejna droga prowadząca prosto do
    sprzeczności? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">yes_and_no</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">no_greatest</span> <span class="id" title="tactic">omega</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">H1</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H2</span> := <span class="id" title="var">lt_n_omega</span> <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Nat.lt_asymm</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">wut</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby przez przypadek nie użyć żadnej ze sprzeczności, które daje nam typ
    <span class="inlinecode"><span class="id" title="var">wut</span></span>, schowaliśmy je w osobnym module, też nazwanym <span class="inlinecode"><span class="id" title="var">wut</span></span>. Oczywiście
    wciąż mamy do nich dostęp, ale teraz ciężej będzie nam się pomylić. 
<div class="paragraph"> </div>

<a id="lab310"></a><h2 class="section">Twierdzenie Cantora</h2>

<div class="paragraph"> </div>

 Zanim zaczniemy ten podrozdział na poważnie, mam dla ciebie wesoły
    łamaniec językowy:

<div class="paragraph"> </div>

    Cantor - kanciarz, który skradł zza kurtyny kantoru z Kantonu kontury
    kartonu Koranicznemu kanarowi, który czasem karał karczystych kafarów
    czarami za karę za kantowanie i za zakatowanie zza kontuaru konarem
    kontrkulturowych kuluarowych karłów.

<div class="paragraph"> </div>

    Dobra, wystarczy. Reszta tego podrozdziału będzie śmiertelnie poważna,
    a przyjrzymy się w niej jednemu z mega klasycznych twierdzeń z końca
    XIX w. głoszącemu mniej więcej, że "zbiór potęgowy zbioru liczb
    naturalnych ma większą moc od zbioru liczb naturalnych".

<div class="paragraph"> </div>

    Co za bełkot, pomyślisz zapewne. Ten podrozdział poświęcimy właśnie temu,
    żeby ów bełkot nieco wyklarować. Jeżeli zaś zastanawiasz się, po co nam
    to, to odpowiedź jest prosta - na (uogólnionym) twierdzeniu Cantora
    opierać się będzie nasza systematyczna metoda dowodzenia nielegalności
    negatywnych typów induktywnych.

<div class="paragraph"> </div>

    Oczywiście oryginalne sformułowanie twierdzenia powstało na długo przed
    powstaniem teorii typów czy Coqa, co objawia się np. w tym, że mówi ono
    o <i>zbiorze</i> liczb naturalnych, podczas gdy my dysponujemy <i>typem</i> liczb
    naturalnych. Musimy więc oryginalne sformułowanie lekko przeformułować,
    a także wprowadzić wszystkie niezbędne nam pojęcia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">surjective</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">a</span> = <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszym niezbędnym pojęciem jest pojęcie surjekcji. Powyższa definicja
    głosi, że funkcja jest surjektywna, gdy każdy element przeciwdziedziny
    jest wynikiem funkcji dla pewnego elementu dziedziny. Surjekcja to
    funkcja, która jest surjektywna.

<div class="paragraph"> </div>

    O co chodzi w tej definicji? Samo słowo "surjekcja" pochodzi od fr.
    "sur" - "na" oraz łac. "iacere" - "rzucać". Ubogim tłumaczeniem na
    polski może być słowo "narzut".

<div class="paragraph"> </div>

    Idea jest taka, że surjekcja <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> "narzuca" swoją dziedzinę
    <span class="inlinecode"><span class="id" title="var">A</span></span> na przeciwdziedzinę <span class="inlinecode"><span class="id" title="var">B</span></span> tak, że <span class="inlinecode"><span class="id" title="var">A</span></span> "pokrywa" całe <span class="inlinecode"><span class="id" title="var">B</span></span>. Innymi
    słowy, każdy element <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest pokryty przez jakiś element <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    co wyraża równość <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>. Oczywiście to <span class="inlinecode"><span class="id" title="var">a</span></span> nie musi być unikalne -
    <span class="inlinecode"><span class="id" title="var">b</span></span> może być pokrywane przez dużo różnych <span class="inlinecode"><span class="id" title="var">a</span></span>. Jak widać, dokładnie to
    jest napisane w powyższej definicji.

<div class="paragraph"> </div>

    Mówiąc jeszcze prościej: jeżeli <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest surjekcją, to typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> jest większy (a precyzyjniej mówiący, nie mniejszy) niż typ <span class="inlinecode"><span class="id" title="var">B</span></span>.
    Oczywiście nie znaczy to, że jeżeli <span class="inlinecode"><span class="id" title="var">f</span></span> nie jest surjekcją, to typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> jest mniejszy niż <span class="inlinecode"><span class="id" title="var">B</span></span> - mogą przecież istnieć inne surjekcje.
    Powiemy, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest mniejszy od <span class="inlinecode"><span class="id" title="var">B</span></span>, jeżeli nie istnieje żadna
    surjekcja między nimi.

<div class="paragraph"> </div>

    Spróbujmy rozrysować to niczym Jacek Gmoch... albo nie, bo nie umiem
    jeszcze rysować, więc zamiast tego będzie przykład i ćwiczenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isZero</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_isZero</span> : <span class="id" title="var">surjective</span> <span class="id" title="var">isZero</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 42. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">isZero</span></span>, która sprawdza, czy jej argument jest zerem, jest
    surjekcją, bo każdy element typu <span class="inlinecode"><span class="id" title="var">bool</span></span> może być jej wynikiem -
    <span class="inlinecode"><span class="id" title="var">true</span></span> jest wynikiem dla <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">false</span></span> jest jej wynikiem dla
    wszystkich innych argumentów. Wobec tego możemy skonkludować, że
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span> jest większy niż typ <span class="inlinecode"><span class="id" title="var">bool</span></span> i w rzeczywistości faktycznie
    tak jest: <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dwa elementy, a <span class="inlinecode"><span class="id" title="var">nat</span></span> nieskończenie wiele.

<div class="paragraph"> </div>

    Do kwestii tego, który typ ma ile elementów wrócimy jeszcze w rozdziale
    o typach i funkcjach. Tam też zapoznamy się lepiej z surjekcjami i
    innymi rodzajami funkcji. Tymczasem: 
<div class="paragraph"> </div>

<a id="lab311"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Czy funkcja <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">5</span> jest surjekcją? A funkcja <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">minus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">5</span>?
    Sprawdź swoje odpowiedzi w Coqu. Na koniec filozoficznie zinterpretuj
    otrzymany wynik.

<div class="paragraph"> </div>

    Wskazówka: <span class="inlinecode"><span class="id" title="var">minus</span></span> to funkcja z biblioteki standardowej, która
    implementuje odejmowanie liczb naturalnych z obcięciem, czyli np.
    <span class="inlinecode">2</span> <span class="inlinecode">-</span> <span class="inlinecode">5</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. Użyj <span class="inlinecode"><span class="id" title="keyword">Print</span></span>a, żeby dokładnie zbadać jej definicję. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Pozostaje jeszcze kwestia tego, czym jest "zbiór potęgowy zbioru liczb
    naturalnych". Mimo groźnej nazwy sprawa jest prosta: jest to archaiczne
    określenie na typ funkcji <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Każdą funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    możemy interpretować jako pewną kolekcję (czyli właśnie zbiór) elementów
    typu <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaś <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, czyli wynik <span class="inlinecode"><span class="id" title="var">f</span></span> na konkretnym <span class="inlinecode"><span class="id" title="var">n</span></span>, mówi nam, czy
    <span class="inlinecode"><span class="id" title="var">n</span></span> znajduje się w tej kolekcji, czy nie.

<div class="paragraph"> </div>

    To w zasadzie wyczerpuje zestaw pojęć potrzebnych nam do sformułowania
    twierdzenia. Pojawiająca się w oryginalnej wersji "większa moc" to po
    prostu synonim określenia "większy", które potrafimy już wyrażać za
    pomocą pojęcia surjekcji. Tak więc nowszą (czyli bardziej postępową)
    wersję twierdzenia Cantora możemy sformułować następująco: nie istnieje
    surjekcja z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Lub jeszcze bardziej obrazowo: <span class="inlinecode"><span class="id" title="var">nat</span></span>
    jest mniejsze niż <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Cantor</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <span class="id" title="var">nat</span> -&gt; (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">bool</span>), ~ <span class="id" title="var">surjective</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">Hf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">diagonal</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">negb</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hf</span> <span class="id" title="var">diagonal</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">Hn</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">bool</span> =&gt; <span class="id" title="var">h</span> <span class="id" title="var">n</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">diagonal</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">inversion</span> <span class="id" title="var">Hn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Dowód twierdzenia jest równie legendarny jak samo twierdzenie, a na
    dodatek bajecznie prosty i niesamowicie użyteczny - jeżeli będziesz
    zajmował się w życiu matematyką i informatyką, spotkasz go w jeszcze
    wielu odsłonach. Metoda stojąca za dowodem nazywana bywa argumentem
    przekątniowym - choć nazwa ta może się wydawać dziwna, to za chwilę
    stanie się zupełnia jasna.

<div class="paragraph"> </div>

    O co więc chodzi w powyższym dowodzie? Po pierwsze zauważmy, że
    mamy do czynienia z funkcją <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>, czyli
    funkcją, która bierze liczbę naturalną i zwraca funkcję z liczb
    naturalnych w <span class="inlinecode"><span class="id" title="var">bool</span></span>. Pamiętajmy jednak, że <span class="inlinecode">-&gt;</span> łączy w prawo
    i wobec tego typ <span class="inlinecode"><span class="id" title="var">f</span></span> możemy zapisać też jako <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    Tak więc <span class="inlinecode"><span class="id" title="var">f</span></span> jest funkcją, która bierze dwie liczby naturalne i
    zwraca element typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    Dzięki temu zabiegowi możemy wyobrażać sobie <span class="inlinecode"><span class="id" title="var">f</span></span> jako dwuwymiarową
    tabelkę, której wiersze i kolumny są indeksowane liczbami naturalnymi,
    a komórki w tabelce wypełnione są wartościami typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. Przyjmijmy,
    że pierwszy argument <span class="inlinecode"><span class="id" title="var">f</span></span> to indeks wiersza, zaś drugi to indeks kolumny.
    W takim układzie <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> to wartość <span class="inlinecode"><span class="id" title="var">n</span></span>-tej funkcji na argumencie <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Wobec tego twierdzenie możemy sparafrazować mówiąc, że każda funkcja
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> znajduje się w którymś wierszu tabelki.

<div class="paragraph"> </div>

    To tyle wyobraźni - możemy już udowodnić twierdzenie. Na początku
    oczywiście bierzemy dowolne <span class="inlinecode"><span class="id" title="var">f</span></span> oraz zakładamy, że jest surjekcją,
    uprzednio odwijając definicję bycia surjekcją.

<div class="paragraph"> </div>

    Teraz musimy jakoś wyciągnąć sprzeczność z hipotezy <span class="inlinecode"><span class="id" title="var">Hf</span></span>, czyli,
    używając naszej tabelkowej parafrazy, znaleźć funkcję z <span class="inlinecode"><span class="id" title="var">nat</span></span> w
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, która nie znajduje się w tabelce. A nie znajdować się w
    tabelce, panie Ferdku, to znaczy: różnić się od każdej funkcji z
    tabelki na jakimś argumencie.

<div class="paragraph"> </div>

    Zamiast jednak szukać takiej funkcji po omacku, skonstruujmy ją
    z tego, co mamy pod ręką - czyli z naszej tabelki. Jak przerobić
    funkcje z tabelki na nową, której w nie ma w tabelce? Tu właśnie
    ujawnia się geniuszalność Cantora: użyjemy metody przekątniowej,
    czyli spojrzymy na przekątną naszej tabelki.

<div class="paragraph"> </div>

    Definiujemy więc nową funkcję <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> następująco:
    dla argumentu <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> bierzemy funkcję z <span class="inlinecode"><span class="id" title="var">n</span></span>-tego wiersza w tabelce,
    patrzymy na <span class="inlinecode"><span class="id" title="var">n</span></span>-tą kolumnę, czyli na wartość funkcji na argumencie
    <span class="inlinecode"><span class="id" title="var">n</span></span>, i zwracamy negację tego, co tam znajdziemy. Czujesz sprzeczność?

<div class="paragraph"> </div>

    Nasze założenie mówi, że <span class="inlinecode"><span class="id" title="var">diagonal</span></span> znajduje się w którymś wierszu
    tabelki - niech ma on numer <span class="inlinecode"><span class="id" title="var">n</span></span>. Wiemy jednak, że <span class="inlinecode"><span class="id" title="var">diagonal</span></span> różni
    się od <span class="inlinecode"><span class="id" title="var">n</span></span>-tej funkcji z tabelki na argumencie <span class="inlinecode"><span class="id" title="var">n</span></span>, gdyż zdefiniowaliśmy
    <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> jako negację tej właśnie komórki w tabelce. Dostajemy stąd
    równość <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, co po analizie przypadków daje
    ostatecznie <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span> lub <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>.

<div class="paragraph"> </div>

    Voilà! Sprzeczność osiągnięta, a zatem początkowe założenie było
    błędne i nie istnieje żadna surjekcja z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
<div class="paragraph"> </div>

<a id="lab312"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że nie ma surjekcji z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Czy jest surjekcja
    z <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>? A w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>? 
<div class="paragraph"> </div>

 Poznawszy twierdzenie Cantora, możemy powrócić do ścisłej pozytywności,
    czyż nie? Otóż nie, bo twierdzenie Cantora jest biedne. Żeby móc czerpać
    z niego niebotyczne profity, musimy najpierw uogólnić je na dowolne
    dwa typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> znajdując kryterium mówiące, kiedy nie istnieje
    surjekcja z <span class="inlinecode"><span class="id" title="var">A</span></span> w <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Cantor'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">modify</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">modify</span> <span class="id" title="var">b</span> &lt;&gt; <span class="id" title="var">b</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id" title="var">surjective</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">modify</span> <span class="id" title="var">H</span> <span class="id" title="var">Hf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">modify</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hf</span> <span class="id" title="var">g</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">Hx</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> =&gt; <span class="id" title="var">h</span> <span class="id" title="var">x</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">H</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Uogólnienie jest dość banalne. Najpierw zastępujemy <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> przez
    dowolne typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. W oryginalnym twierdzeniu nie użyliśmy żadnej
    właściwości liczb naturalnych, więc nie musimy szukać żadnych kryteriów
    dla typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Nasza tabelka może równie dobrze być indeksowana elementami
    dowolnego typu - dalej jest to tabelka i dalej ma przekątną.

<div class="paragraph"> </div>

    Twierdzenie było jednak zależne od pewnej właściwości <span class="inlinecode"><span class="id" title="var">bool</span></span>, mianowicie
    funkcja <span class="inlinecode"><span class="id" title="var">diagonal</span></span> była zdefiniowana jako negacja przekątnej. Było nam
    jednak potrzeba po prostu funkcji, która dla każdego elementu z przekątnej
    zwraca element <span class="inlinecode"><span class="id" title="var">bool</span></span> od niego różny. Ponieważ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dokładnie dwa
    elementy, to negacja jest jedyną taką funkcją.

<div class="paragraph"> </div>

    Jednak w ogólnym przypadku dobra będzie dowolna <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja bez
    punktów stałych. Ha! Nagły atak żargonu bezzębnych ryb, co? Zróbmy
    krótką przerwę, żeby zbadać sposób komunikacji tych czarodziejskich
    zwierząt pływających po uczelnianych korytarzach.

<div class="paragraph"> </div>

    Endofunkcja to funkcja, która ma taką samą dziedzinę i przeciwdziedzinę.
    Można się zatem domyślać, że <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja to funkcja o typie <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.
    Punkt stały zaś to takie <span class="inlinecode"><span class="id" title="var">x</span></span>, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Jest to więc dokładnie ta
    własność, której chcemy, żeby pożądana przez nas funkcja nie miała dla
    żadnego <span class="inlinecode"><span class="id" title="var">x</span></span>. Jak widać, żargon bezzębnych ryb jest równie zwięzły jak
    niepenetrowalny dla zwykłych śmiertelników.

<div class="paragraph"> </div>

    Podsumowując: w uogólnionym twierdzeniu Cantora nie wymagamy niczego od
    <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś od <span class="inlinecode"><span class="id" title="var">B</span></span> wymagamy tylko, żeby istniała funkcja <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>,
    która spełnia <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">b</span></span>. Dowód twierdzenia jest taki
    jak poprzednio, przy czym zastępujemy użycie <span class="inlinecode"><span class="id" title="var">negb</span></span> przez <span class="inlinecode"><span class="id" title="var">modify</span></span>. 
<div class="paragraph"> </div>

<a id="lab313"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Znajdź jedyny słuszny typ <span class="inlinecode"><span class="id" title="var">B</span></span>, dla którego nie istnieje żadna
    <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja bez punktów stałych.

<div class="paragraph"> </div>

    Podpowiedź: to zadanie jest naprawdę proste i naprawdę istnieje jedyny
    słuszny typ o tej właściwości.

<div class="paragraph"> </div>

    Pytanie (bardzo trudne): czy da się udowodnić w Coqu, że istnieje
    dokładnie jeden taki typ? Jeżeli tak, to w jakim sensie typ ten
    jest unikalny i jakich aksjomatów potrzeba do przepchnięcia dowodu? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab314"></a><h2 class="section">Twierdzenie Cantora jako młot na negatywność</h2>

<div class="paragraph"> </div>

 Z Cantorem po naszej stronie możemy wreszcie kupić ruble... ekhem,
    możemy wreszcie zaprezentować ogólną metodę dowodzenia, że negatywne
    typy induktywne prowadzą do sprzeczności. Mimo szumnej nazwy ogólna
    metoda nie jest aż taka ogólna i czasem będziemy musieli się bonusowo
    napracować. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Example1</span>.<br/>

<br/>
</div>

<div class="doc">
Otworzymy sobie nowy moduł, żeby nie zaśmiecać globalnej przestrzeni
    nazw - wszystkie nasze złe typy będą się nazywały <span class="inlinecode"><span class="id" title="var">wut</span></span>. Przy okazji,
    zdecydowanie powinieneś nabrać podejrzeń do tej nazwy - jeżeli coś w
    tej książce nazywa się <span class="inlinecode"><span class="id" title="var">wut</span></span>, to musi to być złowrogie, podejrzane
    paskudztwo. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">C</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, żeby Coq pozwolił nam zdefiniować <span class="inlinecode"><span class="id" title="var">wut</span></span> musimy
    na czas definicji wyłączyć sprawdzanie kryterium ścisłej pozytywności.
    Dlaczego bez wykonania tego zabiegu typ <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest nielegalny, a jego
    definicja zostałaby przez Coqao drzucona? Poza wspomnianymi w poprzednim
    podrozdziale problemami filozoficznymi wynikającymi z nieterminacji,
    jest też drugi, bardziej namacalny powód: istnienie typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest
    sprzeczne z (uogólnionym) twierdzeniem Cantora. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">w</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span>) : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">w</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Powód tej sprzeczności jest dość prozaiczny: za pomocą konstruktora <span class="inlinecode"><span class="id" title="var">C</span></span>
    możemy z dowolnej funkcji <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> zrobić element <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a skoro
    tak, to dowolny element typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> możemy odpakować i wyjąć z niego
    funkcję o typie <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">surjective</span> (@<span class="id" title="var">extract</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">C</span> <span class="id" title="var">f</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro możemy włożyć dowolną funkcję, to znaczy, że dla każdej funkcji
    istnieje element, z którego możemy ją wyjąć, a zatem mamy do czynienia
    z surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> (@<span class="id" title="var">extract</span> <span class="id" title="var">bool</span>) <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W połączeniu zaś z twierdzeniem Cantora surjekcja <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>
    prowadzi do sprzeczności - wystarczy za <span class="inlinecode"><span class="id" title="var">A</span></span> wstawić <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Example1</span>.<br/>

<br/>
</div>

<div class="doc">
Przykład może ci się jednak wydać niezadowalający - typ <span class="inlinecode"><span class="id" title="var">wut</span></span> jest
    przecież dość nietypowy, bo ma tylko jeden konstruktor. A co, gdy
    konstruktorów jest więcej?

<div class="paragraph"> </div>

    Początkowo miałem opisać kilka przypadków z większą liczbą konstruktorów,
    ale stwierdziłem, że jednak mi się nie chce. W ćwiczeniach zobaczymy, czy
    będziesz w stanie sam wykombinować, jak się z nimi uporać (wskazówka: jest
    to bardzo łatwe, wystarczy chcieć i nie być leniwym jak ja). 
<div class="paragraph"> </div>

<a id="lab315"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższe paskudztwo łamie prawo ścisłej pozytywności nie jednym, lecz
    aż dwoma swoimi konstruktorami. Udowodnij, że jego istnienie prowadzi
    do sprzeczności. Metoda jest podobna jak w naszym przykładzie, ale
    trzeba ją troszkę dostosować do zastanej sytuacji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise1</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C0</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">wut</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C1</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise1</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab316"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższe paskudztwo ma jeden konstruktor negatywny, a drugi pozytywny,
    niczym typowa panienka z borderlajnem...

<div class="paragraph"> </div>

    Polecenie jak w poprzednim ćwiczeniu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise2</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C0</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">wut</span>) -&gt; <span class="id" title="var">wut</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise2</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab317"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższy typ reprezentuje termy beztypowego rachunku lambda, gdzie <span class="inlinecode"><span class="id" title="var">V</span></span>
    to typ reprezentujący zmienne. Co to za zwierzątko ten rachunek lambda
    to my się jeszcze przekonamy... chyba, oby.

<div class="paragraph"> </div>

    Taki sposób reprezentowania rachunku lambda (i ogólnie składni języków
    programowania) nazywa się HOAS, co jest skrótem od ang. Higher Order
    Abstract Syntax. W wielu językach funkcyjnych jest to popularna technika,
    ale w Coqu, jak zaraz udowodnisz, jest ona nielegalna. Ława oburzonych
    jest rzecz jasna oburzona! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise3</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Term</span> (<span class="id" title="var">V</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Var</span> : <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Lam</span> : (<span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span>) -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">App</span> : <span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Var</span> {<span class="id" title="var">V</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Lam</span> {<span class="id" title="var">V</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">App</span> {<span class="id" title="var">V</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Term_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise3</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab318"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższe bydle jeszcze do niedawna wydawało mi się całkiem trudne i problematyczne,
    ale oczywiście jest bardzo proste. Uszy do góry i do dzieła! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise4</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">wut</span>) -&gt; <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise4</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab319"></a><h2 class="section">Poradnik rozpoznawania negatywnych typów induktywnych</h2>

<div class="paragraph"> </div>

 Skoro już wiemy, że negatywne typy induktywne są wynalazkiem szatana,
    to czas podać proste kryterium na ich rozpoznawanie. Jeżeli jesteś
    sprytny, to pewnie sam zdążyłeś już zauważyć ogólną regułę. Jednak aby
    nie dyskryminować osób mało sprytnych, trzeba napisać ją wprost.

<div class="paragraph"> </div>

    Kryterium jest banalne. Mając dany typ <span class="inlinecode"><span class="id" title="var">T</span></span> musimy rzucić okiem na jego
    konstruktory, a konkretniej na ich argumenty. Argumenty nieindukcyjne
    (czyli o typach, w których nie występuje <span class="inlinecode"><span class="id" title="var">T</span></span>) są zupełnie niegroźne i
    wobec tego powinniśmy je zignorować. Interesować nas będą wyłącznie
    argumenty indukcyjne, czyli takie, w których występuje typ <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Najbardziej podstawowy typ argumentu indukcyjnego, czyli samo <span class="inlinecode"><span class="id" title="var">T</span></span>, jest
    rzecz jasna niegroźny. To samo dotyczy argumentu indukcyjnego o typie
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Wprawdzie jest on typu funkcyjnego, co, jak się zaraz przekonamy,
    jest groźne, ale <span class="inlinecode"><span class="id" title="var">T</span></span> występuje po prawej stronie strzałki, więc wszystko jest
    w porządku. W ogólności w porządku są też argumenty typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest znanym typem niezależącym od <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Niektóre typy argumentów indukcyjnych również są niegroźne, np. <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> albo <span class="inlinecode">{<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>}</span>, ale ich użycie sprawia, że Coq nie
    potrafi wygenerować dla definiowanego typu odpowiedniej reguły indukcji,
    więc generuje jedynie regułę analizy przypadków. Te typy argumentów nie
    prowadzą do sprzeczności, ale powinniśmy ich unikać, bo są upierdliwe i
    każde takie wystąpienie argumentu indukcyjnego można łatwo zrefaktoryzować.

<div class="paragraph"> </div>

    Argument typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span> można zastąpić dwoma argumentami typu <span class="inlinecode"><span class="id" title="var">T</span></span>
    i podobnie dla <span class="inlinecode">{<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>}</span>. Konstruktor z argumentem typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    możemy rozbić na dwa konstruktory (i powinniśmy, bo jest to bardziej
    czytelne). Konstruktor z wystąpieniem <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> możemy przerobić na
    definicję przez indukcję wzajemną (ćwiczenie: sprawdź jak), ale lepiej
    chyba po prostu zaimplementować regułę indukcji ręcznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T0</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c3</span> : <span class="id" title="var">nat</span> * <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c4</span> : <span class="id" title="var">T0</span> * <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c5</span> : <span class="id" title="var">T0</span> + <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c6</span> : <span class="id" title="var">list</span> <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c7</span> : (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">T0</span>) -&gt; <span class="id" title="var">T0</span>.<br/>

<br/>
</div>

<div class="doc">
Rodzaje nieszkodliwych typów argumentów widać na powyższym przykładzie.
    Konstruktory <span class="inlinecode"><span class="id" title="var">c0</span></span> i <span class="inlinecode"><span class="id" title="var">c1</span></span> są nieindukcyjne, więc są ok. Konstruktor <span class="inlinecode"><span class="id" title="var">c2</span></span>
    jest indukcyjny - jest jeden argument typu <span class="inlinecode"><span class="id" title="var">T0</span></span>. Zauważ, że typem
    konstruktora <span class="inlinecode"><span class="id" title="var">c2</span></span> jest <span class="inlinecode"><span class="id" title="var">T0</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T0</span></span>, ale nie oznacza to, że <span class="inlinecode"><span class="id" title="var">T0</span></span>
    występuje po lewej stronie strzałki!

<div class="paragraph"> </div>

    Jest tak, gdyż ostatnie wystąpienie <span class="inlinecode"><span class="id" title="var">T0</span></span> jest konkluzją konstruktora
    <span class="inlinecode"><span class="id" title="var">c2</span></span>. Ważne są tylko wystąpienia po lewej stronie strzałki w argumentach
    (gdyby konstruktor <span class="inlinecode"><span class="id" title="var">c2</span></span> nie był legalny, to jedynymi legalnymi typami
    induktywnymi byłyby enumeracje).

<div class="paragraph"> </div>

    Konstruktory <span class="inlinecode"><span class="id" title="var">c3</span></span>, <span class="inlinecode"><span class="id" title="var">c4</span></span>, <span class="inlinecode"><span class="id" title="var">c5</span></span> i <span class="inlinecode"><span class="id" title="var">c6</span></span> są induktywne i również w pełni
    legalne, ale są one powodem tego, że Coq nie generuje dla <span class="inlinecode"><span class="id" title="var">T0</span></span> reguły
    indukcji, a jedynie regułę analizy przypadków (choć nazywa się ona
    <span class="inlinecode"><span class="id" title="var">T0_ind</span></span>). Konstruktor <span class="inlinecode"><span class="id" title="var">c7</span></span> również jest w pełni legalny. 
<div class="paragraph"> </div>

<a id="lab320"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zrefaktoryzuj powyższy upośledzony typ. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Problem pojawia się dopiero wtedy, gdy typ <span class="inlinecode"><span class="id" title="var">T</span></span> występuje po lewej
    stronie strzałki, np. <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, lub
    gdy jest skwantyfikowany uniwersalnie, np. <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> (typ
    <span class="inlinecode"><span class="id" title="var">T</span></span> jest dziedziną kwantyfikacji) lub <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>),</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span>
    (tym razem <span class="inlinecode"><span class="id" title="var">T</span></span> jest dziedziną dziedziny kwantyfikacji).

<div class="paragraph"> </div>

    W trzech poprzednich podrozdziałach mierzyliśmy się z sytuacjami, gdy
    typ <span class="inlinecode"><span class="id" title="var">T</span></span> występował bezpośrednio na lewo od strzałki, ale oczywiście
    może on być dowolnie zagnieżdżony. Dla każdego wystąpienia <span class="inlinecode"><span class="id" title="var">T</span></span> w
    argumentach możemy policzyć, na lewo od ilu strzałek się ono znajduje
    (czyli jak mocno zagnieżdżona jest dziedzina kwantyfikacji). Liczbę tę
    nazywać będziemy niedobrością. W zależności od niedobrości,
    wystąpienie nazywamy:
<ul class="doclist">
<li> 0 - wystąpienie ściśle pozytywne

</li>
<li> liczba nieparzysta - wystąpienie negatywne

</li>
<li> liczba parzysta (poza 0) - wystąpienie pozytywne

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli w definicji mamy wystąpienie negatywne, to typ możemy nazywać
    negatywnym typem induktywnym (choć oczywiście nie jest to legalny typ
    induktywny). Jeżeli nie ma wystąpień negatywnych, ale są wystąpienia
    pozytywne, to typ nazywamy pozytywnym typem induktywnym (lub
    nie-ściśle-pozytywnym typem induktywnym), choć oczywiście również nie
    jest to legalny typ induktywny. Jeżeli wszystkie wystąpienia są ściśle
    pozytywne, to mamy do czynienia po prostu z typem induktywnym.
    Parafrazując: każdy typ induktywny jest ściśle pozytywny.

<div class="paragraph"> </div>

    Podobne nazewnictwo możemy sobie wprowadzić dla konstruktorów
    (konstruktory negatywne, pozytywne i ściśle pozytywne), ale nie
    ma sensu, bo za tydzień i tak zapomnisz o tych mało istotnych detalach.
    Ważne, żebyś zapamiętał najważniejsze, czyli ideę. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;T1&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T1_0&nbsp;:&nbsp;T1&nbsp;-&gt;&nbsp;T1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T1_1&nbsp;:&nbsp;(T1&nbsp;-&gt;&nbsp;T1)&nbsp;-&gt;&nbsp;T1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T1_2&nbsp;:&nbsp;((T1&nbsp;-&gt;&nbsp;T1)&nbsp;-&gt;&nbsp;T1)&nbsp;-&gt;&nbsp;T1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T1_3&nbsp;:&nbsp;forall&nbsp;(t&nbsp;:&nbsp;T1)&nbsp;(P&nbsp;:&nbsp;T1&nbsp;-&gt;&nbsp;Prop),&nbsp;P&nbsp;t&nbsp;-&gt;&nbsp;T1.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
W powyższym przykładzie wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w pierwszym argumencie
    <span class="inlinecode"><span class="id" title="var">T1_0</span></span> jest ściśle pozytywne (na lewo od 0 strzałek). Pierwsze
    wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w <span class="inlinecode"><span class="id" title="var">T1_1</span></span> jest negatywne (na lewo od 1 strzałki),
    a drugie ściśle pozytywne (na lewo od 0 strzałek). Pierwsze
    wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w <span class="inlinecode"><span class="id" title="var">T1_2</span></span> jest pozytywne (na lewo od 2 strzałek),
    drugie negatywne (na lewo od 1 strzałki), trzecie zaś ściśle
    pozytywne (na lewo od 0 strzałek). Pierwsze wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w
    <span class="inlinecode"><span class="id" title="var">T1_3</span></span> jest negatywne (dziedzina kwantyfikacji), drugie zaś
    pozytywne (na lewo od jednej strzałki, ale ta strzałka jest w
    typie, po którym kwantyfikujemy).

<div class="paragraph"> </div>

    Konstruktor <span class="inlinecode"><span class="id" title="var">T1_0</span></span> jest ściśle pozytywny, zaś konstruktory <span class="inlinecode"><span class="id" title="var">T1_1</span></span>,
    <span class="inlinecode"><span class="id" title="var">T1_2</span></span> oraz <span class="inlinecode"><span class="id" title="var">T1_3</span></span> są negatywne. Wobec tego typ <span class="inlinecode"><span class="id" title="var">T1</span></span> jest negatywnym
    typem induktywnym (czyli nie jest legalnym typem induktywnym i dlatego
    właśnie Coq odrzuca jego definicję). 
<div class="paragraph"> </div>

<a id="lab321"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;T2&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T2_0&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;f&nbsp;:&nbsp;(forall&nbsp;g&nbsp;:&nbsp;(forall&nbsp;t&nbsp;:&nbsp;T2,&nbsp;nat),&nbsp;Prop),&nbsp;T2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T2_1&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((((T2&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;T2_2&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;T2&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;t&nbsp;:&nbsp;T2,&nbsp;nat))&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2&nbsp;-&gt;&nbsp;T2&nbsp;-&gt;&nbsp;T2.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Policz niedobrość każdego wystąpienia <span class="inlinecode"><span class="id" title="var">T2</span></span> w powyższej definicji.
    Sklasyfikuj konstruktory jako negatywne, pozytywne lub ściśle
    pozytywne. Następnie sklasyfikuj sam typ jako negatywny, pozytywny
    lub ściśle pozytywny. 
<div class="paragraph"> </div>

<a id="lab322"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Inductive&nbsp;T&nbsp;:&nbsp;Type&nbsp;:=&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Rozstrzygnij, czy następujące konstruktory spełniają kryterium ścisłej
    pozytywności. Jeżeli tak, narysuj wesołego jeża. Jeżeli nie, napisz
    zapętlającą się funkcję podobną do <span class="inlinecode"><span class="id" title="var">loop</span></span> (zakładamy, że typ <span class="inlinecode"><span class="id" title="var">T</span></span> ma
    tylko ten jeden konstruktor). Następnie sprawdź w Coqu, czy udzieliłeś
    poprawnej odpowiedzi.
<ul class="doclist">
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C3</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C4</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C5</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C6</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C7</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C8</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C9</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C10</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>),</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C11</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span>
                  <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab323"></a><h2 class="section">Kilka bonusowych pułapek</h2>

<div class="paragraph"> </div>

 Wiemy już, że niektóre typy argumentów indukcyjnych są ok (<span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>),
    inne problematyczne (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>), a jeszcze inne nielegalne (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">...</span>). Uważny i żądny wiedzy czytelnik (daj boże, żeby tacy
    istnieli) zeche zapewne postawić sobie pytanie: które dokładnie typy argumentów
    indukcyjnych są ok, a które są wynalazkiem szatana? 
<div class="paragraph"> </div>

<a id="lab324"></a><h3 class="section">Zabawy z parametrami</h3>

<div class="paragraph"> </div>

 Najprościej będzie sprawę zbadać empirycznie, czyli na przykładzie.
    Żeby zaś przykład był reprezentatywny, niech parametrem definicji
    będzie dowolna funkcja <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">wut_0</span> : <span class="id" title="var">F</span> (<span class="id" title="var">wut</span> <span class="id" title="var">F</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">F</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"F&nbsp;(wut&nbsp;F)&nbsp;-&gt;&nbsp;wut&nbsp;F".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, jeżeli zaaplikujemy <span class="inlinecode"><span class="id" title="var">F</span></span> do argumentu indukcyjnego, to Coq
    krzyczy, że to wystąpienie nie jest ściśle pozytywne. Dlaczego tak
    jest, skoro <span class="inlinecode"><span class="id" title="var">F</span></span> nie jest ani strzałką, ani kwantyfikatorem uniwersalnym?
    Dlatego, że choć nie jest nimi, to może nimi zostać. Jeżeli zdefiniujemy
    sobie gdzieś na boku <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, to wtedy
    <span class="inlinecode"><span class="id" title="var">wut_0</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span>, a z takim diabelstwem już się
    mierzyliśmy i wiemy, że nie wróży ono niczego dobrego.

<div class="paragraph"> </div>

    Morał z tej historii jest dość banalny: gdy definiujemy typ induktywny
    <span class="inlinecode"><span class="id" title="var">T</span></span>, jedynymi prawilnymi typami dla argumentu indukcyjnego są <span class="inlinecode"><span class="id" title="var">T</span></span> oraz
    typy funkcji, które mają <span class="inlinecode"><span class="id" title="var">T</span></span> jako konkluzję (<span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    etc.). Wszystkie inne albo rodzą problemy z automatyczną generacją
    reguł indukcji (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>), albo prowadzą do sprzeczności
    (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">...</span>), albo mogą prowadzić do sprzeczności,
    jeżeli wstawi się za nie coś niedobrego (<span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>). 
<div class="paragraph"> </div>

<a id="lab325"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj rodzinę typów z powyższego przykładu (wyłączając sprawdzanie
    kryterium ścisłej pozytywności) i udowodnij, że jej istnienie prowadzi
    do sprzeczności. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab326"></a><h3 class="section">Pułapki dla indukcji wzajemnej</h3>

<div class="paragraph"> </div>

 To jeszcze nie koniec wrażeń na dziś - póki co omówiliśmy wszakże
    kryterium ścisłej pozytywności jedynie dla bardzo prostych typów
    induktywnych. Słowem nie zająknęliśmy się nawet na temat typów
    wzajemnie induktywnych czy indeksowanych typów induktywnych. Nie
    trudno będzie nam jednak uzupełnić naszą wiedzę, gdyż w przypadku
    oby tych mechanizmów kryterium ścisłej pozytywności wygląda podobnie
    jak w znanych nam już przypadkach (choć jest kilka kruczków, na które
    trzeba uważać). Spójrzmy na poniższy przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">X0</span> : <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">X1</span> : (<span class="id" title="var">Y</span> -&gt; <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Y</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Y0</span> : <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Y1</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">Y</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"Y"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;"(Y&nbsp;-&gt;&nbsp;X)&nbsp;-&gt;&nbsp;X".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, powyższa definicja <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> przez wzajemną indukcję jest
    nielegalna, gdyż jedyny argument konstruktora <span class="inlinecode"><span class="id" title="var">X1</span></span> ma typ <span class="inlinecode"><span class="id" title="var">Y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span>.
    Mogłoby wydawać się, że wszystko jest w porządku, wszakże <span class="inlinecode"><span class="id" title="var">X</span></span> występuje
    tutaj na pozycji ściśle pozytywnej. Jednak ponieważ jest to definicja
    przez indukcję wzajemną, kryterium ścisłej pozytywności stosuje się nie
    tylko do wystąpień <span class="inlinecode"><span class="id" title="var">X</span></span>, ale także do wystąpień <span class="inlinecode"><span class="id" title="var">Y</span></span> - wszystkie wystąpienia
    <span class="inlinecode"><span class="id" title="var">X</span></span> oraz <span class="inlinecode"><span class="id" title="var">Y</span></span> muszą być ściśle pozytywne zarówno w konstruktorach typu <span class="inlinecode"><span class="id" title="var">X</span></span>,
    jak i w konstruktorach typu <span class="inlinecode"><span class="id" title="var">Y</span></span>. 
<div class="paragraph"> </div>

<a id="lab327"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj typy <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> wyłączając positivity checker. Udowodnij za
    pomocą twierdzenia Cantora, że typy <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> są nielegalne. Zdefiniuj
    też nieterminujące elementy <span class="inlinecode"><span class="id" title="var">loopx</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span> oraz <span class="inlinecode"><span class="id" title="var">loopy</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Y</span></span> i pobaw się
    nimi w trybie dowodzenia, żeby upewnić się, że faktyzcnie nie terminują.
    Pytanie bonusowe: czy do zdefiniowania <span class="inlinecode"><span class="id" title="var">loopx</span></span> i <span class="inlinecode"><span class="id" title="var">loopy</span></span> konieczna jest
    rekursja wzajemna? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab328"></a><h2 class="section">Jeszcze więcej pułapek</h2>

<div class="paragraph"> </div>

 To już prawie koniec naszej wędrówki przez świat nielegalnych typów
    "induktywnych". Dowiedzieliśmy się, że negatywne typy induktywne
    prowadzą do nieterminacji i nauczyliśmy się wykorzystywać twierdzenie
    Cantora do dowodzenia nielegalności takich typów.

<div class="paragraph"> </div>

    Poznaliśmy też jednak klasyfikację typów wyglądających na induktywne
    (ściśle pozytywne, pozytywne, negatywne), a w szczególności pojęcie
    "niedobrości" indukcyjnego wystąpienia definiowanego typu w konstruktorze
    (upraszczając, na lewo od ilu strzałek znajduje się to wystąpienie).

<div class="paragraph"> </div>

    Piszę "jednak", gdyż z jej powodu możemy czuć pewien niedosyt - wszystkie
    dotychczasowe przykłady były typami negatywnymi o niedobrości równej 1.
    Podczas naszej intelektualnej wędrówki zwiedziliśmy mniej miejscówek,
    niż moglibyśmy chcieć. W tym podrozdziale spróbujemy ten przykry niedosyt
    załatać, rozważając (nie ściśle) pozytywne typy induktywne. Zobaczymy
    formalny dowód na to, że nie są one legalne (lub, precyzyjniej pisząc,
    dowód na to, że conajmniej jeden z nich nie jest legalny). Zanim jednak
    to się stanie, zobaczmy, czy wypracowane przez nas techniki działają na
    negatywne typy induktywne o niedobrości innej niż 1. 
<div class="paragraph"> </div>

<a id="lab329"></a><h3 class="section">Większa niedobrość</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T3</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T3</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T3_0</span> : (((<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">T3</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy się powyższej definicji. Występienie indukcyjne typu <span class="inlinecode"><span class="id" title="var">T3</span></span>
    ma współczynnik niedobrości równy 3, gdyż znajduje się na lewo od 3
    strzałek. Prawe strony wszystkich z nich to <span class="inlinecode"><span class="id" title="var">bool</span></span>. Zanim zobaczymy,
    jak pokazać nielegalność tego typu metodą Cantora, przypomnijmy sobie
    pewien kluczowy fakt dotyczący negacji i jego banalne uogólnienie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_negation</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ ~ ~ <span class="id" title="var">P</span> -&gt; ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_arrow</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, (((<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>).<br/>

<br/>
</div>

<div class="doc">
Fakt ten przypomina nam, że jeżeli chodzi o spamowanie negacją, to
    są w zasadzie tylko trzy sytuacje:
<ul class="doclist">
<li> brak negacji

</li>
<li> pojedyncza negacja

</li>
<li> podwójna negacja

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli mamy do czynienia z większą liczbą negacji, to możemy zdejmować
    po dwie aż dojdziemy do któregoś z powyższych przypadków. Ponieważ
    negacja to tylko implikacja, której kodziedziną jest <span class="inlinecode"><span class="id" title="var">False</span></span>, a nie
    korzystamy w dowodzie z żadnych specjalnych właściwości <span class="inlinecode"><span class="id" title="var">False</span></span>,
    analogiczna właściwość zachodzi także dla dowolnego innego <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T3</span>) : <span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T3_0</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">T3</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">g</span> <span class="id" title="var">y</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Wobec powyższych rozważań definicja funkcji <span class="inlinecode"><span class="id" title="var">extract</span></span> zupełnie nie powinna
    cię zaskakiwać (a jeżeli cię zaskakuje, to sprawdź jak wygląda term, który
    skonstruowałeś dowodząc <span class="inlinecode"><span class="id" title="var">triple_arrow</span></span> - jeżeli zrobiłeś to dobrze, to
    powinien wyglądać podobnie do definicji <span class="inlinecode"><span class="id" title="var">extract</span></span>). Szczerze pisząc, reszta
    dowodu również nie jest jakoś specjalnie wymagająca czy oświecająca. 
<div class="paragraph"> </div>

<a id="lab330"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Dokończ dowód. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">T3_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab331"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisanie zapętlającej się funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T3</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> też nie
    jest jakoś wybitnie trudne. Napisz ją i pobaw się nią w trybie
    dowodzenia, żeby przekonać się, że faktycznie nie terminuje
    (dla jakiegoś argumentu <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T3</span></span>, który musisz sam wymyślić -
    to również nie jest specjalnie trudne). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T3</span>.<br/>

<br/>
</div>

<div class="doc">
Morał z powyższych rozważań jest prosty: nasze techniki działają także
    na negatywne typy induktywne o niedobrości równej 3. Myślę, że jesteś
    całkiem skłonny uwierzyć też, że zadziałają na te o niedobrości równej
    5, 7 i tak dalej. 
<div class="paragraph"> </div>

<a id="lab332"></a><h3 class="section">Upierdliwe kodziedziny</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
</div>

<div class="doc">
To wszystko jest prawdą jednak tylko wtedy, gdy wszystkie typy po prawych
    stronach strzałek będą takie same. A co, gdy będą różne? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T4</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T4</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T4</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższy przykład jest podobny do poprzedniego, ale tym razem zamiast
    trzech wystąpień <span class="inlinecode"><span class="id" title="var">bool</span></span> mamy <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">Color</span></span> (to ostatnie
    to typ, który zdefiniowaliśmy na samym początku tego rozdziału, gdy
    uczyliśmy się o enumeracjach). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T4</span>) : <span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Nasz modus operandi będzie taki jak poprzednio: spróbujemy wyjąć z
    elementu <span class="inlinecode"><span class="id" title="var">T4</span></span> funkcję typu <span class="inlinecode"><span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. W tym celu rozbijamy <span class="inlinecode"><span class="id" title="var">x</span></span>
    i wprowadzamy <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T4</span></span> do kontekstu.

<div class="paragraph"> </div>

    Tym razem nie możemy jednak bezpośrednio zaaplikować <span class="inlinecode"><span class="id" title="var">f</span></span>, gdyż jej
    kodziedziną jest <span class="inlinecode"><span class="id" title="var">Color</span></span>, a my musimy skonstruować coś typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    Możemy temu jednak zaradzić aplikując do celu skonstruowaną naprędce
    funkcję typu <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Ta funkcja powinna być surjekcją (jeśli
    nie wierzysz, sprawdź, co się stanie, jeżeli zamienimy ją na funckję
    stałą albo inną nie-surjekcję).

<div class="paragraph"> </div>

    Możemy już zaaplikować <span class="inlinecode"><span class="id" title="var">f</span></span> i wprowadzić <span class="inlinecode"><span class="id" title="var">g</span></span> do kontekstu. Chcielibyśmy
    teraz zaaplikować <span class="inlinecode"><span class="id" title="var">g</span></span>, ale nie możemy, bo typy się nie zgadzają - <span class="inlinecode"><span class="id" title="var">g</span></span>
    zwraca <span class="inlinecode"><span class="id" title="var">bool</span></span>, a my musimy skonstruować liczbę naturalną. Robimy tutaj
    to samo co poprzednio - aplikujemy do celu jakąś funkcję <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>.
    Tym razem nie musi ona być surjekcją (nie jest to nawet możliwe, gdyż
    nie ma surjekcji z <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span>). Dzięki temu możemy zaaplikować <span class="inlinecode"><span class="id" title="var">g</span></span>
    i zakończyć, używając <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

    Żeby pokazać, że <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, będziemy potrzebować aksjomatu
    ekstensjonalności dla funkcji (ang. functional extensionality axiom,
    w skrócie funext). Głosi on, że dwie funkcje <span class="inlinecode"><span class="id" title="var">f</span>,</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> są równe,
    jeżeli uda nam się pokazać, że dają równe wyniki dla każdego argumentu
    (czyli <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).

<div class="paragraph"> </div>

    Importując moduł <span class="inlinecode"><span class="id" title="var">FunctionalExtensionality</span></span> zakładamy prawdziwość tego
    aksjomatu oraz uzyskujemy dostęp do taktyki <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span>, która ułatwia
    dowody wymagające użycia ekstensjonalności. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód jest prawie taki jak zawsze: odwijamy definicję surjektywności i
    wprowadzamy hipotezy do kontekstu, a następnie odwijamy definicję <span class="inlinecode"><span class="id" title="var">extract</span></span>
    i rozbijamy ją dla czytelności na właściwą funkcję <span class="inlinecode"><span class="id" title="var">extract</span></span> oraz równanie
    <span class="inlinecode"><span class="id" title="var">eq</span></span>.

<div class="paragraph"> </div>

    Następnie musimy znaleźć <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T4</span></span>, które <span class="inlinecode"><span class="id" title="var">extract</span></span> mapuje na <span class="inlinecode"><span class="id" title="var">f</span></span>. Zaczynamy
    od <span class="inlinecode"><span class="id" title="var">c0</span></span>, bo jest to jedyny konstruktor <span class="inlinecode"><span class="id" title="var">T4</span></span>. Bierze on jako argument
    funkcję typu <span class="inlinecode">((<span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span></span>. Żeby ją wyprodukować,
    bierzemy na wejściu funkcję <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> i musimy zrobić
    coś typu <span class="inlinecode"><span class="id" title="var">Color</span></span>.

<div class="paragraph"> </div>

    Nie może to być jednak byle co - musimy użyć <span class="inlinecode"><span class="id" title="var">f</span></span>, a jedynym sensownym
    sposobem, żeby to zrobić, jest zaaplikować <span class="inlinecode"><span class="id" title="var">g</span></span> do <span class="inlinecode"><span class="id" title="var">f</span></span>. Musimy zadbać
    też o to, żeby odwrócić funkcje konwertujące <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, których użyliśmy w definicji <span class="inlinecode"><span class="id" title="var">extract</span></span>. Pierwsza z nich
    konwertowała <span class="inlinecode"><span class="id" title="var">R</span></span> (czyli kolor czerwony) na <span class="inlinecode"><span class="id" title="var">true</span></span>, a inne kolory na
    <span class="inlinecode"><span class="id" title="var">false</span></span>, zaś druga konwertowała <span class="inlinecode"><span class="id" title="var">true</span></span> na <span class="inlinecode">0</span>, a <span class="inlinecode"><span class="id" title="var">false</span></span> na <span class="inlinecode">1</span>.
    Wobec tego dopasowując <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> musimy przekonwertować <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">R</span></span>,
    zaś <span class="inlinecode">1</span> na coś innego niż <span class="inlinecode"><span class="id" title="var">R</span></span>, np. na <span class="inlinecode"><span class="id" title="var">G</span></span> (czyli kolor zielony).

<div class="paragraph"> </div>

    Znalazłszy odpowiedni argument, możemy przepisać równanie definiujące
    <span class="inlinecode"><span class="id" title="var">extract</span></span>. To już prawie koniec, ale próba użycia taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> w
    tym momencie skończyłaby się porażką. Na ratunek przychodzi nam
    aksjomat ekstensjonalności, którego używamy pisząc <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.
    Dzięki temu pozostaje nam pokazać jedynie, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> jest równe tej
    drugie funkcji dla argumentu <span class="inlinecode"><span class="id" title="var">y</span></span>. W tym celu rozbijamy <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a oba
    wyrażenia okazują się być konwertowalne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">T4_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> <span class="id" title="var">extract</span> <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro mamy surjekcję z <span class="inlinecode"><span class="id" title="var">T4</span></span> w <span class="inlinecode"><span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, katastrofy nie da się
    uniknąć.

<div class="paragraph"> </div>

    Moglibyśmy się też zastanowić nad napisaniem zapętlającej się funkcji
    <span class="inlinecode"><span class="id" title="var">loop</span></span>, ale coś czuję, że ty coś czujesz, że byłoby to babranie się
    w niepotrzebnym problemie. Wobec tego (oczywiście o ile dotychczas
    się nie skapnąłeś) poczuj się oświecony! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T4</span>) : <span class="id" title="var">bool</span> := <span class="id" title="var">extract</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Ha! Tak tak, <span class="inlinecode"><span class="id" title="var">loop</span></span> nie jest niczym innym niż lekko rozmnożoną wersją
    <span class="inlinecode"><span class="id" title="var">extract</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract_c0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extract</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">g</span> <span class="id" title="var">y</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">loop</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">loop</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 5!<span class="id" title="var">extract_c0</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
A skoro <span class="inlinecode"><span class="id" title="var">loop</span></span> to tylko inne <span class="inlinecode"><span class="id" title="var">extract</span></span>, to nie powinno cię też wcale a
    wcale zdziwić, że najbardziej oczywisty argument, dla którego <span class="inlinecode"><span class="id" title="var">loop</span></span>
    się zapętla, jest żywcem wzięty z dowodu <span class="inlinecode"><span class="id" title="var">surjective_extract</span></span> (choć
    oczywiście musimy zastąpić <span class="inlinecode"><span class="id" title="var">f</span></span> przez <span class="inlinecode"><span class="id" title="var">loop</span></span>).

<div class="paragraph"> </div>

    Oczywiście niemożliwe jest, żeby formalnie udowodnić w Coqu, że coś
    się zapętla. Powyższy lemat ma być jedynie demonstracją - ręczne
    rozpisanie tego przykładu byłoby zbyt karkołomne. Jak widać z dowodu,
    przepisywanie równania definiującego <span class="inlinecode"><span class="id" title="var">extract</span></span> tworzy wesołą piramidkę
    zrobioną z <span class="inlinecode"><span class="id" title="keyword">match</span></span>ów i <span class="inlinecode"><span class="id" title="keyword">if</span></span>ów. Jeżeli chcesz poczuć pełnię zapętlenia,
    wypbróuj taktykę <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">!<span class="id" title="var">eq</span></span> - zapętli się ona, gdyż równanie <span class="inlinecode"><span class="id" title="var">eq</span></span>
    można przepisywać w nieskończoność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T4</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby się wydawać, że teraz to już na pewno nasze metody działają na
    wszystkie możliwe negatywne typy induktywne. Cytując Tadeusza Sznuka:
    "Nic bardziej mylnego!". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T5</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T5</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T5</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Rzućmy okiem na powyższy typ. Wygląda podobnie do poprzedniego, ale jest
    nieco inny - typy <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> zamieniły się miejscami. Jakie rodzi to
    konsekwencje? Sprawdźmy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span>] <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">G</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">B</span> =&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isZero</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja <span class="inlinecode"><span class="id" title="var">extract</span></span> jest podobna jak poprzednio, ale tym razem konwertujemy
    <span class="inlinecode"><span class="id" title="var">Color</span></span> na <span class="inlinecode"><span class="id" title="var">nat</span></span> za pomocą funkcji, która nie jest surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód również przebiega podobnie jak poprzednio. Załamuje się on dopiero,
    gdy na samym końcu rozbijamy wyrażenie <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> i upraszczamy używając <span class="inlinecode"><span class="id" title="var">cbn</span></span>.
    W pierwszym podcelu <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> jeszcze jakoś udaje się nam udowodnić, ale w
    drugim naszym oczom ukazuje się cel <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Problem polega na tym, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> może być dowolną liczbą naturalną, ale
    zastosowana przez nas funkcja konwertująca <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> może zwracać
    jedynie <span class="inlinecode">0</span>, <span class="inlinecode">1</span> lub <span class="inlinecode">2</span>. Teraz widzimy jak na dłoni, skąd wziął się
    wymóg, by funkcja konwertująca była surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T5</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">extract</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">f</span> : ((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">T5</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extract</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>) <span class="id" title="var">y</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">isZero</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">G</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">B</span> =&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;42 = <span class="id" title="var">loop</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">loop</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">extract_eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">extract_eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Co ciekawe, mimo że nie jesteśmy w stanie pokazać surjektywności <span class="inlinecode"><span class="id" title="var">extract</span></span>,
    to wciąż możemy użyć tej funkcji do zdefiniowania zapętlającej się
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>, zupełnie jak w poprzednim przykładzie.

<div class="paragraph"> </div>

    Niesmak jednak pozostaje, gdyż szczytem naszych ambicji nie powinno być
    ograniczanie się do zdefiniowania <span class="inlinecode"><span class="id" title="var">loop</span></span>, lecz do formalnego udowodnienia
    nielegalności <span class="inlinecode"><span class="id" title="var">T5</span></span>. Czy wszystko stracone? Czy umrzemy? Tu dramatyczna
    pauza.

<div class="paragraph"> </div>

    Nie (w sensie że nie stracone, chociaż oczywiście umrzemy jak każdy).

<div class="paragraph"> </div>

    Okazuje się, że jest pewien trikowy sposób na rozwiązanie tego problemu,
    a mianowicie: zamiast próbować wyjąć z <span class="inlinecode"><span class="id" title="var">T5</span></span> funkcję <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, wyjmiemy
    stamtąd po prostu funckję <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> i to mimo tego, że jej tam nie ma! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract'</span> : <span class="id" title="var">T5</span> -&gt; (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span>] <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isZero</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
W kluczowych momentach najpierw konwertujemy <span class="inlinecode"><span class="id" title="var">Color</span></span> na <span class="inlinecode"><span class="id" title="var">bool</span></span> tak jak
    w jednym z poprzednich przykładów, a potem konwertujemy <span class="inlinecode"><span class="id" title="var">nat</span></span> na <span class="inlinecode"><span class="id" title="var">bool</span></span>
    za pomocą funkcji <span class="inlinecode"><span class="id" title="var">isZero</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> : <span class="id" title="var">T5</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">f</span> <span class="id" title="var">t</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">then</span> <span class="id" title="var">R</span> <span class="id" title="keyword">else</span> <span class="id" title="var">G</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>); <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Ponieważ obydwie nasze funkcję konwertujące były surjekcjami, możemy je
    teraz odwrócić i wykazać ponad wszelką wątpliwość, że <span class="inlinecode"><span class="id" title="var">extract'</span></span> faktycznie
    jest surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">T5_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> <span class="id" title="var">extract'</span> <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Spróbujmy podsumować, co tak naprawdę stało się w tym przykładzie.

<div class="paragraph"> </div>

    Tym razem, mimo że do <span class="inlinecode"><span class="id" title="var">T5</span></span> możemy włożyć dowolną funkcję <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    to nie możemy jej potem wyjąć, uzyskując surjekcję, gdyż zawadzają
    nam w tym typy po prawych stronach strzałek (<span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">Color</span></span>), które
    mają za mało elementów, żeby móc surjektywnie przekonwertować je na
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    Jednak jeżeli mamy wszystkie możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, to
    możemy przerobić je (w locie, podczas "wyciągania") na wszystkie
    możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, składając je z odpowiednią
    surjekcją (np. <span class="inlinecode"><span class="id" title="var">isZero</span></span>). Ponieważ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">Color</span></span> jesteśmy
    w stanie surjektywnie przekonwertować na <span class="inlinecode"><span class="id" title="var">bool</span></span>, reszta procesu
    działa podobnie jak w poprzednich przykładach. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop'</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T5</span>) : <span class="id" title="var">bool</span> := <span class="id" title="var">extract'</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract'_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">f</span> : ((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">T5</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extract'</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>) <span class="id" title="var">y</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">isZero</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">loop'</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> : <span class="id" title="var">T5</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">loop'</span> <span class="id" title="var">t</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 3!<span class="id" title="var">extract'_eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Takie trikowe <span class="inlinecode"><span class="id" title="var">extract'</span></span> wciąż pozwala nam bez większych przeszkód
    zdefiniować zapętlającą się funkcję <span class="inlinecode"><span class="id" title="var">loop'</span></span>. Osiągnęliśmy więc
    pełen sukces.

<div class="paragraph"> </div>

    W ogólności nasz trik możnaby sformułować tak: jeżeli mamy konstruktor
    negatywny typu <span class="inlinecode"><span class="id" title="var">T</span></span>, to możemy wyjąć z niego funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest najmniejszym z typów występujących po prawych stronach strzałek. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T5</span>.<br/>

<br/>
</div>

<div class="doc">
No, teraz to już na pewno mamy obcykane wszystkie przypadki, prawda?
    Tadeuszu Sznuku przybywaj: "Otóż nie tym razem!". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T6</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T6</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T6</span> -&gt; <span class="id" title="var">unit</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T6</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejnym upierdliwym przypadkiem, burzącym nawet nasz ostateczny
    trik, jest sytuacja, w której po prawej stronie strzałki wystąpi
    typ <span class="inlinecode"><span class="id" title="var">unit</span></span>. Oczywiście zgodnie z trikiem możemy z <span class="inlinecode"><span class="id" title="var">T6</span></span> wyciągnąć
    surjekcję <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, ale jest ona oczywiście bezużyteczna, bo
    taką samą możemy zrobić za darmo, stale zwracając po prostu <span class="inlinecode"><span class="id" title="var">tt</span></span>.
    Surjekcja z <span class="inlinecode"><span class="id" title="var">T6</span></span> w <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> nie wystarczy rzecz jasna, żeby
    odpalić twierdzenie Cantora.

<div class="paragraph"> </div>

    Tym razem jednak nie powinniśmy spodziewać się, że upierdliwość tę
    będzie dało się jakoś obejść. Typ <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> jest jednoelementowy
    (jedynym elementem jest <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">tt</span></span>) podobnie jak <span class="inlinecode"><span class="id" title="var">unit</span></span>. Bardziej
    poetycko możemy powiedzieć, że <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> i <span class="inlinecode"><span class="id" title="var">unit</span></span> są izomorficzne,
    czyli możemy bez żadnych strat konwertować elementy jednego z tych
    typów na elementy drugiego i z powrotem.

<div class="paragraph"> </div>

    Skoro tak, to typ konstruktora <span class="inlinecode"><span class="id" title="var">c0</span></span>, czyli
    <span class="inlinecode">(((<span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span>)</span>, możemy równie dobrze
    zapisać jako <span class="inlinecode">((<span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span>)</span>. Zauważmy teraz,
    że <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> jest izomorficzne z <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdyż ma tylko dwa
    elementy, a mianowicie <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">false</span></span>.
    Tak więc typ <span class="inlinecode"><span class="id" title="var">c0</span></span> możemy jeszcze prościej zapisać jako
    <span class="inlinecode">(<span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span></span>, a to oznacza, że typ <span class="inlinecode"><span class="id" title="var">T6</span></span> jest jedynie
    owijką na funkcje typu <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span></span>. Twierdzenie Cantora nie
    pozwala tutaj uzyskać sprzeczności.

<div class="paragraph"> </div>

    Czy zatem typy takie jak <span class="inlinecode"><span class="id" title="var">T6</span></span> sa legalne? Syntaktycznie nie - Coq
    odrzuca je podobnie jak wszystkie inne negatywne typy induktywne.
    Semantycznie również nie - o ile nie możemy tutaj uzyskać jawnej
    sprzeczności, to nasze rozważania o nieterminacji wciąż są w mocy.

<div class="paragraph"> </div>

    Przypomnij sobie poprzedni przykład i nieudaną próbę wyłuskania z
    <span class="inlinecode"><span class="id" title="var">T5</span></span> surjekcji <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Udało nam się zaimplementować funkcję
    <span class="inlinecode"><span class="id" title="var">extract</span></span>, której surjektywności nie potrafiliśmy pokazać, ale pomimo
    tego bez problemu udało nam się użyć jej do napisania funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>.
    W obecnym przykładzie jest podobnie i nieterminacja to najlepsze, na
    co możemy liczyć. 
<div class="paragraph"> </div>

<a id="lab333"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">extract</span></span>, a następnie użyj jej do zdefiniowania
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Zademonstruj w sposób podobny jak poprzednio, że
    <span class="inlinecode"><span class="id" title="var">loop</span></span> się zapętla. Wskazówka: wszystko działa tak samo jak w
    poprzednim przykładzie. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T6</span>.<br/>

<br/>
</div>

<div class="doc">
No, teraz to już na pewno wiemy wszystko... 
<div class="paragraph"> </div>

<a id="lab334"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Otóż nie do końca. Ostatnim hamulcowym, groźniejszym nawet niż <span class="inlinecode"><span class="id" title="var">unit</span></span>,
    jest wystąpienie po prawej stronie strzałki typu (czy raczej zdania)
    <span class="inlinecode"><span class="id" title="var">False</span></span>. W tym przypadku nie tylko nie pomaga nam Cantor, ale nie
    pomaga też nieterminacja, gdyż najzwyczajniej w świecie nie da się
    zdefiniować żadnej funkcji.

<div class="paragraph"> </div>

    Jako, że za cholerę nie wiem, co z tym fantem zrobić, zostawiam go tobie
    jako ćwiczenie: wymyśl metodę pokazywania nielegalności negatywnych typów
    induktywnych, w których po prawej stronie strzałki jest co najmniej
    jedno wystąpienie <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T7</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T7</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T7</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">False</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T7</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T7</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab335"></a><h2 class="section">Promocja 2 w 1 czyli paradoksy Russella i Girarda</h2>

<div class="paragraph"> </div>

 <i>Istnieje teoria, że jeśli kiedyś ktoś się dowie, dlaczego powstało i
    czemu służy uniwersum, to zniknie ono i zostanie zastąpione czymś
    znacznie dziwaczniejszym i jeszcze bardziej pozbawionym sensu</i>. 
<div class="paragraph"> </div>

 <i>Istnieje także teoria, że dawno już tak się stało</i>. 
<div class="paragraph"> </div>

 Douglas Adams, <i>Restauracja na końcu wszechświata</i> 
<div class="paragraph"> </div>

 W poprzednich podrozdziałach poznaliśmy twierdzenie Cantora oraz
    nauczyliśmy się używać go jako młota na negatywne typy induktywne.

<div class="paragraph"> </div>

    W tym podrozdziale zapoznamy się z dwoma paradoksami (a precyzyjniej
    pisząc, z dwoma wersjami tego samego paradoksu), które okażą się być
    ściśle powiązane z twierdzeniem Cantora, a które będą służyć nam gdy
    staniemy w szranki z negatwynymi typami induktywno-rekurencyjnymi
    (czyli tymi, które definiuje się przez indukcję-rekursję). O tak: w
    tym podrozdziale, niczym Thanos, staniemy do walki przeciw uniwersum! 
<div class="paragraph"> </div>

<a id="lab336"></a><h3 class="section">Paradoks Russella</h3>

<div class="paragraph"> </div>

 Zacznijmy od paradoksu Russella. Jest to bardzo stary paradoks, odkryty
    w roku 1901 przez... zgadnij kogo... gdy ów człek szukał dziury w całym
    w naiwnej teorii zbiorów (która to teoria, dzięki temu właśnie odkryciu,
    jest już od bardzo dawna dość mocno martwa).

<div class="paragraph"> </div>

    Sformułowanie paradoksu brzmi następująco: niech V będzie zbiorem
    wszystkich zbiorów, które nie należą same do siebie. Pytanie: czy
    V należy do V?

<div class="paragraph"> </div>

    Gdzie tu paradoks? Otóż jeżeli V należy do V, to na mocy definicji V,
    V nie należy do V. Jeżeli zaś V nie należy do V, to na mocy definicji V,
    V należy do V. Nie trzeba chyba dodawać, że jednoczesne należenie i
    nienależenie prowadzi do sprzeczności.

<div class="paragraph"> </div>

    Na czym tak naprawdę polega paradoks? Jakiś mądry (czyli przemądrzały)
    filozof mógłby rzec, że na nadużyciu pojęcia zbioru... albo czymś
    równie absurdalnym. Otóż nie! Paradoks Russella polega na tym samym,
    co cała masa innych paradoksów, czyli na autoreferencji.

<div class="paragraph"> </div>

    Z autoreferencją spotkaliśmy się już co najmniej raz, w rozdziale
    pierwszym. Przypomnij sobie, że golibroda goli tych i tylko tych,
    którzy sami siebie nie golą. Czy golibroda goli sam siebie? Takie
    postawienie sprawy daje paradoks. Podobnie z Russellem: V zawiera
    te i tylko te zbiory, które nie zawierają same siebie. Czy V zawiera
    V? Wot, paradoks. Żeby lepiej wczuć się w ten klimat, czas na więcej
    ćwiczeń. 
<div class="paragraph"> </div>

<a id="lab337"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 To genialne ćwiczenie wymyśliłem dzięki zabłądzeniu na esperanckiej
    Wikipedii (ha! nikt nie spodziewał się esperanckiej Wikipedii w
    ćwiczeniu dotyczącym paradoksu Russella). Ćwiczenie brzmi tak:

<div class="paragraph"> </div>

    W Wikipedii niektóre artykuły są listami (nie, nie w sensie typu
    induktywnego :)), np. lista krajów według PKB per capita. Pytanie:
    czy można stworzyć w Wikipedii listę wszystkich list? Czy na liście
    wszystkich list ona sama jest wymieniona? Czy można w Wikipedii
    stworzyć listę wszystkich list, które nie wymieniają same siebie? 
<div class="paragraph"> </div>

<a id="lab338"></a><h3 class="section">Paradoks Girarda</h3>

<div class="paragraph"> </div>

 Dobra, wystarczy już tych paradoksów... a nie, czekaj. Przecież został
    nam do omówienia jeszcze paradoks Girarda. Jednak poznawszy już tajniki
    autoreferencji, powinno pójść jak z płatka.

<div class="paragraph"> </div>

    Paradoks Girarda to paradoks, który może zaistnieć w wielu systemach
    formalnych, takich jak teorie typów, języki programowania, logiki i
    inne takie. Źródłem całego zła jest zazwyczaj stwierdzenie w stylu
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
O nie! Czyżbyśmy właśnie zostali zaatakowani przez paradoks Girarda?
    W tym miejscu należy przypomnieć (albo obwieścić - niestety nie pamiętam,
    czy już o tym wspominałem), że <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest w Coqu jedynie synonimem dla
    czegoś w stylu <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">i</span></span> jest "poziomem" sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, zaś
    każde <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span> żyje tak naprawdę w jakimś <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">j</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">j</span></span> jest
    większe od <span class="inlinecode"><span class="id" title="var">i</span></span> - typy niższego poziomu żyją w typach wyższego poziomu.
    Będziesz mógł ów fakt ujrzeć na własne oczy, gdy w CoqIDE zaznaczysz
    opcję <span class="inlinecode"><span class="id" title="var">View</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode"><span class="id" title="var">Display</span></span> <span class="inlinecode"><span class="id" title="var">universe</span></span> <span class="inlinecode"><span class="id" title="var">levels</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type@{Top.590}&nbsp;:&nbsp;Type@{Top.590+1}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, jest mniej więcej tak jak napisałem wyżej. Nie przejmuj się
    tym tajemniczym <span class="inlinecode"><span class="id" title="var">Top</span></span> - to tylko nic nieznaczący bibelocik. W twoim
    przypadku również poziom uniwersum może być inny niż <span class="inlinecode">590</span>. Co więcej,
    poziom ten będzie się zwiększał wraz z każdym odpaleniem komendy <span class="inlinecode"><span class="id" title="keyword">Check</span></span>
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> (czyżbyś pomyślał właśnie o doliczeniu w ten sposób do zyliona?).

<div class="paragraph"> </div>

    Skoro już wiemy, że NIE zostaliśmy zaatakowani przez paradoks Girarda,
    to w czym problem z tym całym <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>? Jakiś przemądrzały (czyli
    mądry) adept informatyki teoretycznej mógłby odpowiedzieć, że to zależy
    od konkretnego systemu formalnego albo coś w tym stylu. Otóż niet! Jak
    zawsze, chodzi oczywiście o autoreferencję.

<div class="paragraph"> </div>

    Gdyby ktoś był zainteresowany, to najlepsze dotychczas sformułowanie
    paradoksu znalazłem (zupełnie przez przypadek, wcale nie szukając) w
    pracy "An intuitionistic theory of types" Martina-Löfa (swoją drogą,
    ten koleś wymyślił podstawy dużej części wszystkiego, czym się tutaj
    zajmujemy). Można ją przeczytać tu (paradoks Girarda jest pod koniec
    pierwszej sekcji):
    archive-pml.github.io/martin-lof/pdfs/An-Intuitionistic-Theory-of-Types-1972.pdf

<div class="paragraph"> </div>

    Nasze sformułowanie paradoksu będzie podobne do tego z powyższej pracy
    (co jest w sumie ciekawe, bo wymyśliłem je samodzielnie i to przez
    przypadek), ale dowód sprzeczności będzie inny - na szczęście dużo
    prostszy (albo i nie...).

<div class="paragraph"> </div>

    Dobra, koniec tego ględzenia. Czas na konkrety. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Fail&nbsp;Inductive&nbsp;U&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;:&nbsp;U<br/>
<br/>
with&nbsp;El&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;Type&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;forall&nbsp;x&nbsp;:&nbsp;El&nbsp;A,&nbsp;B&nbsp;x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa induktywno-rekurencyjna definicja typu <span class="inlinecode"><span class="id" title="var">U</span></span> (i interpretującej
    go funkcji <span class="inlinecode"><span class="id" title="var">El</span></span>), którą Coq rzecz jasna odrzuca (uczcijmy ławę oburzonych
    minutą oburzenia) to definicja pewnego uniwersum.

<div class="paragraph"> </div>

    W tym miejscu wypadałoby wytłumaczyć, czym są uniwersa. Otóż odpowiedź
    jest dość prosta: uniwersum składa się z typu <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> oraz funkcji
    <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Intuicja w tym wszystkim jest taka, że elementami
    typu <span class="inlinecode"><span class="id" title="var">U</span></span> są nazwy typów (czyli bytów sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), zaś fukncja <span class="inlinecode"><span class="id" title="var">El</span></span>
    zwraca typ, którego nazwę dostanie.

<div class="paragraph"> </div>

    Choć z definicji widać to na pierwszy rzut oka, to zaskakujący może
    wydać ci się fakt, że w zasadzie każdy typ można zinterpretować jako
    uniwersum i to zazwyczaj na bardzo wiele różnych sposobów (tyle ile
    różnych interpretacji <span class="inlinecode"><span class="id" title="var">El</span></span> jesteśmy w stanie wymyślić). Najlepiej
    będzie, jeżeli przemyślisz to wszystko w ramach ćwiczenia. 
<div class="paragraph"> </div>

<a id="lab339"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Ćwiczenie będzie konceptualne, a składa się na nie kilka łamigłówek:
<ul class="doclist">
<li> zinterpretuj <span class="inlinecode"><span class="id" title="var">False</span></span> jako uniwersum

</li>
<li> zinterpretuj <span class="inlinecode"><span class="id" title="var">unit</span></span> jako uniwersum (ile jest możliwych sposobów?)

</li>
<li> czy istnieje uniwersum, które zawiera nazwę samego siebie? Uwaga:
      to nie jest tak proste, jak może się wydawać na pierwszy rzut oka.

</li>
<li> wymyśl ideologicznie słuszną interpretację typu <span class="inlinecode"><span class="id" title="var">nat</span></span> jako uniwersum
      (tak, jest taka). Następnie wymyśl jakąś głupią interpretację <span class="inlinecode"><span class="id" title="var">nat</span></span>
      jako uniwersum. Dlaczego ta interpretacja jest głupia?

</li>
<li> zdefiniuj uniwersum, którego elementami są nazwy typów funkcji z
      n-krotek liczb naturalnych w liczby naturalne. Uwaga: rozwiązanie
      jest bardzo eleganckie i możesz się go nie spodziewać.

</li>
<li> czy istnieje uniwersum, którego interpretacja jest surjekcją? Czy
      da się w Coqu udowodnić, że tak jest albo nie jest? Uwaga: tak
      bardzo podchwytliwe, że aż sam się złapałem. 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Skoro wiemy już, czym są uniwersa, przyjrzyjmy się temu, które właśnie
    zdefiniowaliśmy. Żebyś nie musiał w rozpaczy przewijać do góry, tak
    wygląda aksjomatyczne kodowanie tego uniwersum: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">PoorUniverse</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">U</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">El</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">Pi</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>), <span class="id" title="var">U</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">UU</span> : <span class="id" title="var">U</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">El_Pi</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">El</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) = <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span>), <span class="id" title="var">El</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">El_UU</span> : <span class="id" title="var">El</span> <span class="id" title="var">UU</span> = <span class="id" title="var">U</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PPi</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">A</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PUU</span> : <span class="id" title="var">P</span> <span class="id" title="var">UU</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span>, <span class="id" title="var">P</span> <span class="id" title="var">u</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">PPi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> <span class="id" title="var">A</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>))) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> <span class="id" title="var">UU</span> = <span class="id" title="var">PUU</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">U</span></span> to typ, którego elementami są nazwy typów, zaś <span class="inlinecode"><span class="id" title="var">El</span></span> jest jego
    interpretacją. Nazwy możemy tworzyć tylko na dwa sposoby: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    jest nazwą typu, zaś <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> jest rodziną nazw typów indeksowaną
    przez elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>, to <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest nazwą typu
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span>. Drugim konstruktorem jest <span class="inlinecode"><span class="id" title="var">UU</span></span>, które
    oznacza nazwę samego uniwersum, tzn. <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>.

<div class="paragraph"> </div>

    Reguła indukcji jest dość prosta: jeżeli <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest rodziną
    typów (tych prawdziwych) indeksowaną przez <span class="inlinecode"><span class="id" title="var">U</span></span> (czyli nazwy typów), to
    żeby zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> musimy mieć dwie rzeczy:
    po pierwsze, musimy pokazać, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> zachodzi, gdy zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> dla każdego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Po drugie, musi zachodzić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>.

<div class="paragraph"> </div>

    Mimo, że uniwersum wydaje się biedne, jest ono śmiertelnie sprzeczne,
    gdyż zawiera nazwę samego siebie. Jeżeli rozwiązałeś (poprawnie, a nie
    na odwal!) ostatnie ćwiczenie, to powinieneś wiedzieć, że niektóre
    uniwersa mogą zawierać nazwy samego siebie i wcale to a wcale nie daje
    to żadnych problemów.

<div class="paragraph"> </div>

    Dlaczego więc w tym przypadku jest inaczej? Skoro <span class="inlinecode"><span class="id" title="var">UU</span></span> nie jest złe samo
    w sobie, to problem musi leżeć w <span class="inlinecode"><span class="id" title="var">Pi</span></span>, bo niby gdzie indziej? Zobaczmy
    więc, gdzie kryje się sprzeczność. W tym celu posłużymy się twierdzeniem
    Cantora: najpierw zdefiniujemy surjekcję <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span>)</span>, a potem pokażemy,
    za pomocą metody przekątniowej, że taka surjekcja nie może istnieć. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Definition&nbsp;extract&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;UU&nbsp;B&nbsp;=&gt;&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;fun&nbsp;u&nbsp;:&nbsp;U&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Jeżeli dostajemy <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span> to <span class="inlinecode"><span class="id" title="var">UU</span></span>, to wtedy <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    tak naprawdę jest typu <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> (bo <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>). W innych przypadkach
    wystarczy po prostu zwrócić funkcję identycznościową. Niestety Coq nie
    wspiera indukcji-rekursji (ława oburzonych), więc funkcję <span class="inlinecode"><span class="id" title="var">extract</span></span> musimy
    zdefiniować ręcznie: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> : <span class="id" title="var">U</span> -&gt; (<span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. <span class="id" title="var">revert</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> : <span class="id" title="var">U</span> =&gt; (<span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>) -&gt; (<span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">El_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span> =&gt; <span class="id" title="var">u</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższa definicja za pomocą taktyk działa dokładnie tak samo jak
    nieformalna definicja <span class="inlinecode"><span class="id" title="var">extract</span></span> za pomocą dopasowania do wzorca. Jedyna
    różnica jest taka, że <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> nie jest definicyjnie równe <span class="inlinecode"><span class="id" title="var">U</span></span>, lecz
    są one jedynie zdaniowo równe na mocy aksjomatu <span class="inlinecode"><span class="id" title="var">El_UU</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>.
    Musimy więc przepisać go w <span class="inlinecode"><span class="id" title="var">B</span></span>, żeby typy się zgadzały.

<div class="paragraph"> </div>

    Zanim będziemy mogli pokazać, że <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, czeka nas kilka
    niemiłych detali technicznych (gdyby <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> i <span class="inlinecode"><span class="id" title="var">U</span></span> były definicyjnie
    równe, wszystkie te problemy by zniknęły). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">eq_rect</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">eq_rect_r</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;y&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">eq_rect</span></span> oraz <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> to groźnie wyglądające lematy, ale sprawa tak
    na prawdę jest dość prosta: to one wykonują całą pracę za każdym razem,
    kiedy używasz taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. Jeżeli cel jest postaci <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> i użyjemy
    na nim <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, to <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> zamienia cel na
    <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">cel</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, które jest już typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> działa
    podobnie, ale tym razem równość jest postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> (czyli obrócona).

<div class="paragraph"> </div>

    Ponieważ w definicji <span class="inlinecode"><span class="id" title="var">extract</span></span> używaliśmy <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>'a, to przy dowodzeniu,
    że <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, będziemy musieli zmierzyć się właśnie z
    <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> i <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span>. Stąd poniższy lemat, który mówi mniej więcej,
    że jeżeli przepiszemy z prawa na lewo, a potem z lewa na prawo, to tak,
    jakby nic się nie stało. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">right_to_left_to_right</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">y</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_rect</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> (@<span class="id" title="var">eq_rect_r</span> <span class="id" title="var">A</span> <span class="id" title="var">y</span> <span class="id" title="var">P</span> <span class="id" title="var">u</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>) <span class="id" title="var">y</span> <span class="id" title="var">p</span> = <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód jest banalny. Ponieważ <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> i <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> są zdefiniowane
    przez dopasowanie do wzorca <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, to wystarczy <span class="inlinecode"><span class="id" title="var">p</span></span> potraktować
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>em, a dalej wszystko już ładnie się oblicza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">extract</span> [<span class="id" title="var">extract_Pi</span> <span class="id" title="var">extract_UU</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">extract'</span> [<span class="id" title="var">extract'_Pi</span> <span class="id" title="var">extract'_UU</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">f'</span> := <span class="id" title="var">eq_rect_r</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span> =&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="var">U</span>) <span class="id" title="var">f</span> <span class="id" title="var">El_UU</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">UU</span> <span class="id" title="var">f'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">f'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">extract_Pi</span>, <span class="id" title="var">extract'_UU</span>, <span class="id" title="var">right_to_left_to_right</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dlaczego <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją? Intuicyjnie pisząc, każdą funkcję
    <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> możemy włożyć do konstruktora <span class="inlinecode"><span class="id" title="var">Pi</span></span> jako jego drugi argument,
    jeżeli tylko zamienimy pierwsze <span class="inlinecode"><span class="id" title="var">U</span></span> na <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>. Skoro każdą możemy
    tam włożyć, to każdą możemy wyjąć. Ot i cały sekret.

<div class="paragraph"> </div>

    Technicznie dowód realizujemy tak: odwijamy definicje i wprowadzamy do
    kontekstu funkcję <span class="inlinecode"><span class="id" title="var">f</span></span>. Następnie rozbijamy <span class="inlinecode"><span class="id" title="var">ind</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> pochodzące z definicji
    <span class="inlinecode"><span class="id" title="var">extract</span></span>, rozkładając w ten sposób definicję <span class="inlinecode"><span class="id" title="var">extract</span></span> na właściwe
    <span class="inlinecode"><span class="id" title="var">extract</span></span> (sama funkcja), <span class="inlinecode"><span class="id" title="var">extract'</span></span> (wewnętrzna funkcja pomocnicza) oraz
    równania dla <span class="inlinecode"><span class="id" title="var">extract</span></span> i <span class="inlinecode"><span class="id" title="var">extract'</span></span> dla poszczególnych przypadków.

<div class="paragraph"> </div>

    Następnie musimy znaleźć takie <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>, że <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span>. Robimy to, co
    zasugerowałem wyżej, czyli w <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> pierwsze <span class="inlinecode"><span class="id" title="var">U</span></span> zamieniamy na
    <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>, uzyskując w ten sposób <span class="inlinecode"><span class="id" title="var">f'</span></span>. Temu właśnie służy użycie
    <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> (nie używamy <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, bo potrzeba nam większej precyzji).

<div class="paragraph"> </div>

    Wobec tego szukanym przez nas elementem <span class="inlinecode"><span class="id" title="var">U</span></span>, któremu <span class="inlinecode"><span class="id" title="var">extract</span></span> przyporządkuje
    <span class="inlinecode"><span class="id" title="var">f</span></span>, jest <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode"><span class="id" title="var">f'</span></span>. Możemy w tym miejscu odwinąć definicję <span class="inlinecode"><span class="id" title="var">f'</span></span>. Gdyby
    Coq wspierał indukcję-rekursję, to w tym miejscu wystarczyłoby użyć tylko
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> - <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode"><span class="id" title="var">f'</span>)</span> obliczyłoby się do <span class="inlinecode"><span class="id" title="var">f</span></span> na mocy definicji
    <span class="inlinecode"><span class="id" title="var">extract</span></span> oraz dzięki temu, że <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> obliczyłoby się do <span class="inlinecode"><span class="id" title="var">U</span></span>. Niestety Coq
    nie wspiera indukcji rekursji (ława oburzonych), więc musimy wszystkie
    te trzy kroki obliczeń wykonać ręcznie za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    Ufff, udało się! Jeżeli przeraża cię ten dowód - nie martw się. Chodzi
    w nim o to samo, o co chodziło w poprzednich dowodach bycia surjekcją.
    Ten jest po prostu trochę bardziej skomplikowany, bo indukcja-rekursja
    jest nieco bardziej skomplikowana do użycia w Coqu niż prymitywniejsze
    formy indukcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">modify</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">UU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">UU</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">UU</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz czas udowodnić, że <span class="inlinecode"><span class="id" title="var">extract</span></span> nie jest surjekcją. Zrobimy to metodą
    przekątniową, a w tym celu potrzebować będziemy funkcji <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>, która
    dla każdego argumentu zwraca coś, co jest od niego różne.

<div class="paragraph"> </div>

    Na szczęście sprawa jest prosta: jeżeli argumentem jest <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, to
    zwracamy <span class="inlinecode"><span class="id" title="var">UU</span></span>, zaś jeżeli <span class="inlinecode"><span class="id" title="var">UU</span></span>, to zwracamy <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">UU</span>)</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">discern</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">true</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Przydałaby się też funkcja, która pozwoli nam rozróżnić konstruktory
    typu <span class="inlinecode"><span class="id" title="var">U</span></span>. Normalnie użylibyśmy do tego taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, ale
    używamy kodowania aksjomatycznego, więc <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> nie zadziała i
    musimy ręcznie zaimplementować sobie coś w jej stylu.

<div class="paragraph"> </div>

    Nasza funkcja dla <span class="inlinecode"><span class="id" title="var">Pi</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span>, a dla <span class="inlinecode"><span class="id" title="var">UU</span></span> daje <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">modify_neq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span>, <span class="id" title="var">modify</span> <span class="id" title="var">u</span> &lt;&gt; <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">H1</span> <span class="id" title="var">H2</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">discern</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">modify</span>, <span class="id" title="var">discern</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">d</span> [<span class="id" title="var">d_Pi</span> <span class="id" title="var">d_UU</span>]],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">ch</span> [<span class="id" title="var">ch_Pi</span> <span class="id" title="var">ch_UU</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">d_Pi</span>, <span class="id" title="var">ch_Pi</span>, <span class="id" title="var">d_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">discern</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">modify</span>, <span class="id" title="var">discern</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">d</span> [<span class="id" title="var">d_Pi</span> <span class="id" title="var">d_UU</span>]],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">ch</span> [<span class="id" title="var">ch_Pi</span> <span class="id" title="var">ch_UU</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">ch_UU</span>, <span class="id" title="var">d_Pi</span>, <span class="id" title="var">d_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">eq</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Wypadałoby też pokazać, ża nasza funkcja działa tak, jak sobie tego
    życzymy. Dowód jest bardzo prosty, ale aksjomatyczne kodowanie znacznie
    go zaciemnia.

<div class="paragraph"> </div>

    Zaczynamy od indukcji po <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>. W pierwszym przypadku mamy hipotezę
    <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, a skoro tak, to po zaaplikowaniu
    <span class="inlinecode"><span class="id" title="var">discern</span></span> musi być także <span class="inlinecode"><span class="id" title="var">discern</span></span> <span class="inlinecode">(<span class="id" title="var">modify</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">discern</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span>.

<div class="paragraph"> </div>

    Następnie rozkładamy definicje <span class="inlinecode"><span class="id" title="var">modify</span></span> i <span class="inlinecode"><span class="id" title="var">discern</span></span> na atomy (<span class="inlinecode"><span class="id" title="var">modify</span></span>
    nazywa się teraz <span class="inlinecode"><span class="id" title="var">ch</span></span>, a <span class="inlinecode"><span class="id" title="var">discern</span></span> nazywa się <span class="inlinecode"><span class="id" title="var">d</span></span>). Przepisujemy
    odpowiednie równania w hipotezie <span class="inlinecode"><span class="id" title="var">eq</span></span>, dzięki czemu uzyskujemy
    <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, co jest sprzeczne. Drugi przypadek jest analogiczny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract_not_sur</span> :<br/>
&nbsp;&nbsp;~ <span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">H</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span> =&gt; <span class="id" title="var">modify</span> (<span class="id" title="var">extract</span> <span class="id" title="var">u</span> <span class="id" title="var">u</span>))) <span class="id" title="keyword">as</span> [<span class="id" title="var">u</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">u</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">modify_neq</span> (<span class="id" title="var">extract</span> <span class="id" title="var">u</span> <span class="id" title="var">u</span>)). <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz możemy już pokazać, że <span class="inlinecode"><span class="id" title="var">extract</span></span> nie jest surjekcją. W tym celu
    wyobraźmy sobie <span class="inlinecode"><span class="id" title="var">extract</span></span> jako kwadratową tabelkę, której wiersze i
    kolumny są indeksowane przez <span class="inlinecode"><span class="id" title="var">U</span></span>. Tworzymy nową funkcję <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    biorąc elementy z przekątnej i modyfikując je za pomocą <span class="inlinecode"><span class="id" title="var">modify</span></span>.

<div class="paragraph"> </div>

    Skoro <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, to ta nowa funkcja musi być postaci
    <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> dla jakiegoś <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>. Aplikując obie strony jeszcze raz
    do <span class="inlinecode"><span class="id" title="var">u</span></span> dostajemy równanie <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">(<span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">u</span>)</span>, które
    jest sprzeczne na mocy lematu <span class="inlinecode"><span class="id" title="var">modify_neq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">U_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">extract_not_sur</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Ponieważ <span class="inlinecode"><span class="id" title="var">extract</span></span> jednocześnie jest i nie jest surjekcją, nastepuje nagły
    atak sprzeczności. Definicja uniwersum <span class="inlinecode"><span class="id" title="var">U</span></span> przez indukcję-rekursję jest
    nielegalna. Tak właśnie prezentuje się paradoks Girarda w Coqowym wydaniu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PoorUniverse</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab340"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Tak naprawdę, to w tym podrozdziale byliśmy co najwyżej bieda-Thanosem,
    gdyż uniwersum, z którym się ścieraliśmy, samo było biedne. W niniejszym
    ćwiczeniu zmierzysz się z uniwersum, które zawiera też nazwy typu pustego,
    typu <span class="inlinecode"><span class="id" title="var">unit</span></span> i liczb naturalnych, nazwy produktów, sum i funkcji, a także
    sum zależnych.

<div class="paragraph"> </div>

    Mówiąc wprost: zakoduj aksjomatycznie poniższą definicję uniwersum <span class="inlinecode"><span class="id" title="var">U</span></span>,
    a następnie udowodnij, że jest ona nielegalna. Nie powinno to być
    trudne - metoda jest podobna jak w przypadku biednego uniwersum. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NonPoorUniverse</span>.<br/>

<br/>
<span class="comment">(*<br/>
Fail&nbsp;Inductive&nbsp;U&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Empty&nbsp;:&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Unit&nbsp;:&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Nat&nbsp;:&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Prod&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sum&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Arr&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sigma:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;:&nbsp;U<br/>
<br/>
with&nbsp;El&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;Type&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Empty&nbsp;=&gt;&nbsp;Empty_set<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Unit&nbsp;=&gt;&nbsp;unit<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Nat&nbsp;=&gt;&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Prod&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;*&nbsp;El&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sum&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;+&nbsp;El&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Arr&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;El&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;forall&nbsp;x&nbsp;:&nbsp;El&nbsp;A,&nbsp;B&nbsp;x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sigma&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;{x&nbsp;:&nbsp;El&nbsp;A&nbsp;&amp;&nbsp;El&nbsp;(B&nbsp;x)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">U_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NonPoorUniverse</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab341"></a><h2 class="section">Pozytywne typy induktywne</h2>

<div class="paragraph"> </div>

 Na koniec rozprawimy się z pozytywnymi typami "induktywnymi" (ale tylko
    do pewnego stopnia; tak po prawdzie, to raczej one rozprawią się z
    nami). 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Pos0</span> : ((<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Pos</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"Pos"&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"((Pos&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;Pos".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coq odrzuca powyższą definicję typu <span class="inlinecode"><span class="id" title="var">Pos</span></span>, gdyż pierwsze wystąpienie <span class="inlinecode"><span class="id" title="var">Pos</span></span>
    w typie konstruktora <span class="inlinecode"><span class="id" title="var">Pos0</span></span> nie jest ściśle pozytywne. I faktycznie - gdy
    policzymy niedobrość tego wystąpienia zgodnie z naszym wzorem, to wyjdzie,
    że wynosi ona 2, gdyż <span class="inlinecode"><span class="id" title="var">Pos</span></span> występuje na lewo od dwóch strzałek (pamiętaj,
    że najbardziej zewnętrzna strzałka, czyli ta, na prawo od której też jest
    <span class="inlinecode"><span class="id" title="var">Pos</span></span>, nie liczy się - wzór dotyczy tylko argumentów konstruktora, a nie
    całego konstruktora). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Pos0</span> : ((<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Pos</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Spróbujmy zawalczyć z typem <span class="inlinecode"><span class="id" title="var">Pos</span></span> naszą metodą opartą o twierdzenie
    Cantora. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> (<span class="id" title="var">p</span> : <span class="id" title="var">Pos</span>) : <span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f</span>]. <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;ad&nbsp;infinitum&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby się wydawać, że wyciągnięcie z <span class="inlinecode"><span class="id" title="var">Pos</span></span> funkcji <span class="inlinecode"><span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    nie może być trudniejsze, niż zabranie dziecku cukierka. Niestety
    jednak nie jest tak, gdyż w <span class="inlinecode"><span class="id" title="var">Pos</span></span> tak naprawdę nie ma żadnej takiej
    funkcji - jest funkcja <span class="inlinecode">(<span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a to już zupełnie
    coś innego.

<div class="paragraph"> </div>

    Żeby lepiej zrozumieć tę materię, musimy metaforycznie zinterpretować
    znany nam już współczynnik niedobrości i wynikający z niego podział
    na wystąpienia ściśle pozytywne, pozytywne i negatywne. Dzięki tej
    interpretacji dowiemy się też, dlaczego nieparzysta niedobrość jest
    negatywna, a niezerowa parzysta jest pozytywna.

<div class="paragraph"> </div>

    Najprościej jest zinterpretować wystąpienia ściśle pozytywne, gdyż
    mieliśmy już z nimi sporo do czynienia. Weźmy konstruktor
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Jest tutaj jedno ściśle pozytywne
    wystąpienie typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, które możemy interpretować tak: gdy
    używamy dopasowania do wzorca i dopasuje się <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, to "mamy"
    element <span class="inlinecode"><span class="id" title="var">t</span></span> typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Ot i cała filozofia.

<div class="paragraph"> </div>

    Załóżmy teraz na chwilę, że Coq akceptuje negatywne i pozytywne
    typy induktywne. Co by było, gdybyśmy dopasowali konstruktor postaci
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>? Tym razem nie mamy elementu typu <span class="inlinecode"><span class="id" title="var">T</span></span>, lecz
    funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Parafrazując: musimy "dać" funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>
    element typu <span class="inlinecode"><span class="id" title="var">T</span></span>, żeby dostać <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    A co by było, gdybyśmy dopasowali konstruktor postaci
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode">((<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>? Tym razem również nie mamy żadnego
    elementu typu <span class="inlinecode"><span class="id" title="var">T</span></span>, lecz funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode">((<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>.
    Parafrazując: musimy dać funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> jakąś funkcję typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    żeby dostać <span class="inlinecode"><span class="id" title="var">bool</span></span>. Ale gdy konstruujemy funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, to na
    wejściu dostajemy <span class="inlinecode"><span class="id" title="var">T</span></span>. Tak więc początkowo nie mamy żadnego <span class="inlinecode"><span class="id" title="var">T</span></span>, ale
    gdy o nie poprosimy, to możemy je dostać. Ba! Jak pokazuje przykład,
    możemy dostać bardzo dużo <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Taka właśnie jest różnica między ścisłą pozytywnością (mamy coś),
    negatywnością (musimy coś dać) i pozytywnością (możemy coś dostać,
    i to nawet w dużej liczbie sztuk). Zauważmy, że jedynie w przypadku
    negatywnym możemy wyjąć z <span class="inlinecode"><span class="id" title="var">T</span></span> funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">co</span>ś</span> (chyba, że zawadza
    nam <span class="inlinecode"><span class="id" title="var">unit</span></span> lub <span class="inlinecode"><span class="id" title="var">False</span></span>), bo to jedyny przypadek, gdy żądają od nas
    <span class="inlinecode"><span class="id" title="var">T</span></span> (a skoro żądają <span class="inlinecode"><span class="id" title="var">T</span></span>, to muszą mieć funkcję, która coś z tym <span class="inlinecode"><span class="id" title="var">T</span></span>
    zrobi). W przypadku pozytywnym nie ma żadnej takiej funkcji - to my
    dostajemy <span class="inlinecode"><span class="id" title="var">T</span></span> i musimy coś z niego wyprodukować, więc to my jesteśmy
    tą funkcją!

<div class="paragraph"> </div>

    Ufff... mam nadzieję, że powyższa bajeczka jest sformułowana zrozumiale,
    bo lepszego wytłumaczenia nie udało mi się wymyślić.

<div class="paragraph"> </div>

    Moglibyśmy w tym miejscu zastanowić się, czy nie uda nam się pokazać
    sprzeczności choć na metapoziomie, poprzez napisanie nieterminującej
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Szczerze pisząc, to niezbyt w to wierzę. Przypomnij
    sobie, że okazało się, że funkcja <span class="inlinecode"><span class="id" title="var">loop</span></span> jest bardzo ściśle powiązana
    z funkcją <span class="inlinecode"><span class="id" title="var">extract</span></span>, zaś esencja nieterminacji polegała na przekazaniu
    do <span class="inlinecode"><span class="id" title="var">loop</span></span> jako argument czegoś, co zawierało <span class="inlinecode"><span class="id" title="var">loop</span></span> jako podterm
    (jeżeli nie zauważyłeś, to wszystkie nasze nieterminujące funkcje
    udało nam się zdefiniować bez użycia rekursji!). To daje nam jako taką
    podstawę by wierzyć, że nawet nieterminacja nie jest w tym przypadku
    osiągalna. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W tym momencie należy sobie zadać zasadnicze pytanie: dlaczego w ogóle
    pozytywne typy induktywne są nielegalne? Przecież odróżnienie wystąpienia
    pozytywnego od negatywnego nie jest czymś trudnym, więc Coq nie może ich
    od tak po prostu nie rozróżniać - musi mieć jakiś powód!

<div class="paragraph"> </div>

    I faktycznie, powód jest. Nie ma on jednak wiele wspólnego z mechanizmem
    (pozytywnych) typów induktywnych samym w sobie, a z impredykatywnością
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Trudne słowo, co? Nie pamiętam, czy już to wyjaśniałem,
    więc wyjaśnię jeszcze raz.

<div class="paragraph"> </div>

    Impredykatywność (lub też impredykatywizm) to pewna forma autoreferencji,
    która czasem jest nieszkodliwa, a czasem bardzo mordercza. Przyjrzyjmy
    się następującej definicji: "wujek Janusz to najbardziej wąsata osoba w
    tym pokoju". Definicja ta jest impredykatywna, gdyż definiuje ona wujka
    Janusza poprzez wyróżnienie go z pewnej kolekcji osób, ale definicja tej
    kolekcji osób musi odwoływać się do wujka Janusza ("w pokoju są wujek
    Janusz, ciocia Grażynka, Sebastianek i Karynka"). W Coqu impredykatywny
    jest sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, co ilustruje przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja zdania <span class="inlinecode"><span class="id" title="var">X</span></span> jest impredykatywna, gdyż kwantyfikujemy w niej po
    wszystkich zdaniach (<span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), a zatem kwantyfikujemy także
    po zdaniu <span class="inlinecode"><span class="id" title="var">X</span></span>, które właśnie definiujemy.

<div class="paragraph"> </div>

    Impredykatywność sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest niegroźna (no chyba, że pragniemy
    pozytywnych typów induktywnych, to wtedy jest), ale impredykatywność
    dla <span class="inlinecode"><span class="id" title="keyword">Type</span></span> byłaby zabójcza, co zresztą powinien nam był uświadomić
    paradoks Russella.

<div class="paragraph"> </div>

    Dobra, koniec gadania. Poniższy przykład pośrednio pochodzi z sekcji
    3.1 pracy "Inductively defined types", której autorami są Thierry
    Coquand oraz Christine Paulin-Mohring, zaś bezpośrednio jest przeróbką
    kodu wziętego z
    vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Pos'0</span> : ((<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="var">Pos'</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać, podejrzanym typem jest <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, bliźniaczo podobne do <span class="inlinecode"><span class="id" title="var">Pos</span></span>,
    ale zamiast <span class="inlinecode"><span class="id" title="var">bool</span></span> występuje tutaj <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    Tym razem jednak dowód sprzeczności będzie przebiegał nieco inaczej niż
    dotychczas. Poprzednio nasze plany sprowadzały się do tego, żeby wyjąć
    z nielegalnego typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> jakąś funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, co daje nam
    surjekcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, a to jest sprzeczne z twierdzeniem Cantora.

<div class="paragraph"> </div>

    Intuicja zaś stojąca za tym twierdzeniem (przynajmniej dla <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>)
    była taka, że funkcje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> są zbiorami elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span> i
    jest ich przez to "więcej" niż elementów <span class="inlinecode"><span class="id" title="var">T</span></span>, czyli <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> jest
    większa niż <span class="inlinecode"><span class="id" title="var">T</span></span>. Surjekcją z <span class="inlinecode"><span class="id" title="var">T</span></span> w <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> oznacza jednak, że to
    <span class="inlinecode"><span class="id" title="var">T</span></span> jest większe niż <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, co prowadzi do sprzeczności.

<div class="paragraph"> </div>

    Tym razem nie jesteśmy w stanie zrobić żadnej surjekcji, ale możemy za
    to zrobić injekcję. Intuicyjnie injekcja z <span class="inlinecode"><span class="id" title="var">A</span></span> w <span class="inlinecode"><span class="id" title="var">B</span></span> oznacza, że każdemu
    elementowi <span class="inlinecode"><span class="id" title="var">A</span></span> można przypisać unikalny element <span class="inlinecode"><span class="id" title="var">B</span></span>. Jeszcze intuicyjniej:
    typ <span class="inlinecode"><span class="id" title="var">A</span></span> jest w jakimś sensie "mniejszy" niż typ <span class="inlinecode"><span class="id" title="var">B</span></span>, czyli jeszcze inaczej
    pisząc, typ <span class="inlinecode"><span class="id" title="var">A</span></span> można "włożyć" lub "wstrzyknąć" (i stąd nazwa) do typu <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Nasz plan polega więc na tym, żeby zdefiniować injekcję
    <span class="inlinecode">(<span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, co powinno jakoś prowadzić do sprzeczności:
    istnienie takiej injekcji oznacza, że <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest "mniejszy"
    niż <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, ale z twierdzenia Cantora powinniśmy intuicyjnie czyć, że
    <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest większe niż <span class="inlinecode"><span class="id" title="var">Pos'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">Pos'</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">Pos'0</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">Q</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span> =&gt; <span class="id" title="var">P</span> = <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">injective_f</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">P</span> = <span class="id" title="var">f</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span> = <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">Q</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja naszej injekcji jest dość prosta. Żeby przerobić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    na <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, używamy konstruktora <span class="inlinecode"><span class="id" title="var">Pos'0</span></span>, a jego argumentem jest po prostu
    funkcja, która porównuje swój argument do <span class="inlinecode"><span class="id" title="var">P</span></span> używając relacji równości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wut</span> (<span class="id" title="var">x</span> : <span class="id" title="var">Pos'</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>, <span class="id" title="var">f</span> <span class="id" title="var">P</span> = <span class="id" title="var">x</span> /\ ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Tutaj następują czary, które używają impredykatywności.

<div class="paragraph"> </div>

    Definiujemy predykat <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, który głosi, że funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> jest
    surjekcją (czyli <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">P</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>), która ma dodatkowo tę właściwość, że
    predykat <span class="inlinecode"><span class="id" title="var">P</span></span>, któremu <span class="inlinecode"><span class="id" title="var">f</span></span> przyporządkowuje <span class="inlinecode"><span class="id" title="var">x</span></span>, nie jest spełniony przez <span class="inlinecode"><span class="id" title="var">x</span></span>
    (czyli <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).

<div class="paragraph"> </div>

    Parafrazując: <span class="inlinecode"><span class="id" title="var">wut</span></span> to coś w stylu zbioru wszystkich <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, które nie
    należą same same do siebie. Paradoks Russella jak malowany! Wielka zła
    autoreferencja czai się tuż za rogiem - ciekawe co by się stało, gdybyśmy
    rozważyli zdanie <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">paradox</span> : <span class="id" title="var">wut</span> (<span class="id" title="var">f</span> <span class="id" title="var">wut</span>) &lt;-&gt; ~ <span class="id" title="var">wut</span> (<span class="id" title="var">f</span> <span class="id" title="var">wut</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> (<span class="id" title="var">P</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>). <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">injective_f</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">red</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">wut</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Ano, wszystko wybucha. Z lewa na prawo rozbijamy dowód <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span> i
    dostajemy predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Wiemy, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span>, ale <span class="inlinecode"><span class="id" title="var">f</span></span> jest injekcją,
    więc <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">wut</span></span>. To jednak kończy się sprzecznością, bo z jednej strony
    <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>, ale z drugiej strony <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span>, czyli <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>.

<div class="paragraph"> </div>

    Z prawa na lewo jest łatwiej. Mamy <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span> i musimy udowodnić
    <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>. Wystarczy, że istnieje pewien predykat <span class="inlinecode"><span class="id" title="var">P</span></span>, który spełnia
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> i <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>. Na <span class="inlinecode"><span class="id" title="var">P</span></span> wybieramy oczywiście <span class="inlinecode"><span class="id" title="var">wut</span></span>. Równość
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> zachodzi trywialnie, zaś <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span> zachodzi na mocy
    założenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Pos'_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">paradox</span>. <span class="id" title="tactic">firstorder</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
No i bum. Jak widać, pozytywne typy induktywne prowadzą do sprzeczności,
    ale nie ma to z nimi wiele wspólnego, za to ma wiele wspólnego z sortem
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i jego impredykatywnością. 
<div class="paragraph"> </div>

<a id="lab342"></a><h1 class="section">"Paradoksy" indukcji (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab343"></a><h1 class="section">Indukcja matematyczna a indukcja w nauce (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab344"></a><h1 class="section">Podsumowanie</h1>

<div class="paragraph"> </div>

 To już koniec naszej przydługiej podróży przez mechanizmy definiowania
    typów przez indukcję. W jej trakcie nauczyliśmy się bardzo wielu rzeczy.

<div class="paragraph"> </div>

    Zaczęliśmy od definiowania prostych enumeracji, operujących na nich
    funkcji definiowanych za pomocą dopasowania do wzorca oraz omówienia
    mechanizmu obliczania wyniku funkcji.

<div class="paragraph"> </div>

    Następnie poznaliśmy różne rozszerzenia tego podstawowego pomysłu
    definiowania typu za pomocą konstruktorów reprezentujących możliwe
    wartości:
<ul class="doclist">
<li> rekurencję, dzięki której możemy definiować typy, których
      termy mają najprzeróżniejsze drzewiaste kształty

</li>
<li> parametryzowane typy induktywne, których głównym zastosowaniem
      jest definiowanie kontenerów o takich samych kształtach, ale
      różnych przechowywanych typach

</li>
<li> indukcję wzajemną, w praktyce niezbyt użyteczną, dzięki której
      możemy na raz zdefiniować wiele typów odnoszących się do siebie
      nawzajem

</li>
<li> indeksowane rodziny typów induktywnych, dzięki którym możemy
      przez indukcję definiować predykaty oraz relacje

</li>
<li> indukcję-indukcję, dzięki której możemy jednocześnie zdefiniować
      typ oraz indeksowaną nim rodzinę typów

</li>
<li> indukcję-rekursję, dzięki której możemy jednoczesnie zdefiniować
      typ oraz funkcję operującą na tym typie 
</li>
</ul>

<div class="paragraph"> </div>

 Nauczyliśmy się definiować funkcje przez rekursję oraz dowodzić ich
    właściwości przez indukcję. Poznaliśmy definicje poznanych w pierwszym
    rozdziale spójników logicznych oraz odpowiadających im konstrukcji na
    typach, a także definicję bardzo ważnej rodziny typów, czyli równości.

<div class="paragraph"> </div>

    Poznaliśmy podstawowe obiekty, którymi musi potrafić posługiwać
    się każdy programista, informatyk czy matematyk, a mianowicie
    wartości boolowskie, liczby naturalne oraz listy.

<div class="paragraph"> </div>

    Nauczyliśmy się formułować i implementować reguły indukcyjne (TODO:
    opisać to w głównym tekście, a nie dopiero w przypomnieniu), a także,
    co powiązane, programować listy przy pomocy foldów i unfoldów.

<div class="paragraph"> </div>

    Na końcu poznaliśmy kryterium ścisłej pozytywności, które obowiązuje
    wszystkie definicje typów induktywnych. Dowiedzieliśmy się, że negatywne
    typy induktywne prowadzą do nieterminacji, która jest złem wcielonym.
    Poznaliśmy pojęcie surjekcji oraz twierdzenie Cantora, które również
    zabrania negatywnym typom induktywnym istnienia.

<div class="paragraph"> </div>

    Poznaliśmy też paradoks Russella/Girarda i jego związek z twierdzeniem
    Cantora, autoreferencją oraz ideą uniwersum zdefiniowanego za pomocą
    indukcji-rekursji.

<div class="paragraph"> </div>

    Ostatecznie dowiedzieliśmy się, że pozytywne typy induktywne także są
    nielegalne, choć jesteśmy wobec nich raczej bezsilni, no chyba że
    chodzi o impredykatywny (tego słowa też się nauczyliśmy) sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    Całkiem sporo, prawda? Nie? No to w kolejnych rozdziałach będzie jeszcze
    wincyj. </div>
<div class="code">
</div>
