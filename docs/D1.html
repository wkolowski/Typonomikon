<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
</head>
<h1 class="libtitle">D1: Indukcja i rekursja</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 W poprzednim rozdziale dowiedzieliÅ›my siÄ™ juÅ¼ co nieco o typach, a
    takÅ¼e spotkaliÅ›my kilka z nich oraz kilka sposobÃ³w tworzenia nowych
    typÃ³w ze starych (takich jak np. koniunkcja; pamiÄ™taj, Å¼e zdania sÄ…
    typami). W tym rozdziale dowiemy siÄ™, jak definiowaÄ‡ nowe typy przy
    pomocy indukcji oraz jak uÅ¼yÄ‡ rekursji do definiowania funkcji, ktÃ³re
    operujÄ… na tych typach. 
<div class="paragraph"> </div>

<a name="lab86"></a><h1 class="section">Typy induktywne</h1>

<div class="paragraph"> </div>

 W Coqu sÄ… trzy gÅ‚Ã³wne rodzaje typÃ³w: produkt zaleÅ¼ny, typy induktywne
    i typy koinduktywne. Z pierwszym z nich juÅ¼ siÄ™ zetknÄ™liÅ›my, drugi
    poznamy w tym rozdziale, trzeci na razie pominiemy.

<div class="paragraph"> </div>

    Typ induktywny definiuje siÄ™ przy pomocy zbioru konstruktorÃ³w, ktÃ³re
    sÅ‚uÅ¼Ä…, jak sama nazwa wskazuje, do budowania termÃ³w tego typu.
    Konstruktory te sÄ… funkcjami (byÄ‡ moÅ¼e zaleÅ¼nymi), ktÃ³rych
    przeciwdziedzinÄ… jest definiowany typ, ale niczego nie
    obliczajÄ… â€” nadajÄ… jedynie termom ich "ksztaÅ‚t". W szczegÃ³lnoÅ›ci, nie
    majÄ… nic wspÃ³lnego z konstruktorami w takich jÄ™zykach jak C++ lub Java
    â€” nie mogÄ… przetwarzaÄ‡ swoich argumentÃ³w, alokowaÄ‡ pamiÄ™ci, dokonywaÄ‡
    operacji wejÅ›cia/wyjÅ›cia etc.

<div class="paragraph"> </div>

    Tym, co jest waÅ¼ne w przypadku konstruktorÃ³w, jest ich iloÅ›Ä‡, nazwy
    oraz iloÅ›Ä‡ i typy przyjmowanych argumentÃ³w. To te cztery rzeczy decydujÄ…
    o tym, jakie "ksztaÅ‚ty" bÄ™dÄ… miaÅ‚y termy danego typu, a wiÄ™c i czym
    bÄ™dzie sam typ. W ogolnoÅ›ci kaÅ¼dy term jest skoÅ„czonym, ukorzenionym
    drzewem, ktÃ³rego ksztaÅ‚t zaleÅ¼y od charakterystyki konstruktorÃ³w tak:
<ul class="doclist">
<li> kaÅ¼dy konstruktor to inny rodzaj wÄ™zÅ‚a (nazwa konstruktora to nazwa
      wÄ™zÅ‚a)

</li>
<li> konstruktory nierekurencyjne to liÅ›cie, a rekurencyjne â€” wÄ™zÅ‚y
      wewnÄ™trzne

</li>
<li> argumenty konstruktorÃ³w to dane przechowywane w danym wÄ™Åºle 
</li>
</ul>

<div class="paragraph"> </div>

 Typ induktywny moÅ¼na wyobraÅ¼aÄ‡ sobie jako przestrzeÅ„ zawierajÄ…cÄ…
    te i tylko te drzewa, ktÃ³re moÅ¼na zrobiÄ‡ przy pomocy jego
    konstruktorÃ³w. Nie przejmuj siÄ™, jeÅ¼eli opis ten wydaje ci siÄ™
    dziwny â€” sposÃ³b definiowania typÃ³w induktywnych i ich wartoÅ›ci
    w Coqu jest diametralnie rÃ³Å¼ny od sposobu definiowania klas i
    obiektÃ³w w jÄ™zykach imperatywnych i wymaga przyzwyczajenia siÄ™
    do niego. Zobaczmy, jak powyÅ¼szy opis ma siÄ™ do konkretnych
    przykÅ‚adÃ³w. 
<div class="paragraph"> </div>

<a name="lab87"></a><h2 class="section">Enumeracje</h2>

<div class="paragraph"> </div>

 Najprostszym rodzajem typÃ³w induktywnych sÄ… enumeracje, czyli typy,
    ktÃ³rych wszystkie konstruktory sÄ… staÅ‚ymi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> : <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja typu induktywnego ma nastÄ™pujÄ…cÄ… postaÄ‡: najpierw wystÄ™puje
    sÅ‚owo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, nastÄ™pnie nazwa typu, a po dwukropku sort
    (<span class="inlinecode"><span class="id" title="keyword">Set</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>). NastÄ™pnie wymieniamy konstruktory typu â€”
    dla czytelnoÅ›ci kaÅ¼dy w osobnej linii. MajÄ… one swoje unikalne nazwy i
    sÄ… funkcjami, ktÃ³rych przeciwdziedzinÄ… jest definiowany typ. W naszym
    przypadku mamy 2 konstruktory, zwane <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="var">false</span></span>, ktÃ³re sÄ…
    funkcjami zeroargumentowymi.

<div class="paragraph"> </div>

    DefinicjÄ™ tÄ™ moÅ¼emy udczytaÄ‡ nastÄ™pujÄ…co: "<span class="inlinecode"><span class="id" title="var">true</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    <span class="inlinecode"><span class="id" title="var">false</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i nie ma Å¼adnych wiÄ™cej wartoÅ›ci typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span>".

<div class="paragraph"> </div>

    Uwaga: naleÅ¼y odrÃ³Å¼niÄ‡ symbole <span class="inlinecode">:=</span> oraz <span class="inlinecode">=</span>. Pierwszy z nich sÅ‚uÅ¼y
    do definiowania, a drugi do zapisywania rÃ³wnoÅ›ci.

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">term</span></span> oznacza "niech od teraz <span class="inlinecode"><span class="id" title="var">name</span></span> bÄ™dzie innÄ… nazwÄ…
    dla <span class="inlinecode"><span class="id" title="var">term</span></span>". Jest to komenda, a nie zdanie logiczne. Od teraz jeÅ¼eli
    natkniemy siÄ™ na nazwÄ™ <span class="inlinecode"><span class="id" title="var">name</span></span>, bÄ™dziemy mogli odwinÄ…Ä‡ jej definicjÄ™ i
    wstawiÄ‡ w jej miejsce <span class="inlinecode"><span class="id" title="var">term</span></span>. PrzykÅ‚ad: <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span>.
    AntyprzykÅ‚ad: <span class="inlinecode">2</span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span> (bÅ‚Ä…d skÅ‚adni).

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> oznacza "<span class="inlinecode"><span class="id" title="var">a</span></span> jest rÃ³wne <span class="inlinecode"><span class="id" title="var">b</span></span>". Jest to zdanie logiczne,
    a nie komenda. Zdanie to rzecz jasna nie musi byÄ‡ prawdziwe. PrzykÅ‚ad:
    <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>. AntyprzykÅ‚ad: <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> (jeÅ¼eli <span class="inlinecode"><span class="id" title="var">five</span></span> nie jest zdefiniowane,
    to dostajemy komunikat w stylu "nie znaleziono nazwy <span class="inlinecode"><span class="id" title="var">five</span></span>"). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji wyglÄ…da tak: najpierw mamy sÅ‚owo kluczowe <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>
    (jeÅ¼eli funkcja nie jest rekurencyjna), nastÄ™pnie argumenty funkcji
    w postaci <span class="inlinecode">(<span class="id" title="var">name</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>; po dwukropku przeciwdziedzina, a po symbolu
    <span class="inlinecode">:=</span> ciaÅ‚o funkcji.

<div class="paragraph"> </div>

    Podstawowym narzÄ™dziem sÅ‚uÅ¼Ä…cym do definiowania funkcji jest
    dopasowanie do wzorca (ang. pattern matching). Pozwala ono sprawdziÄ‡,
    ktÃ³rego konstruktora uÅ¼yto do zrobienia dopasowywanej wartoÅ›ci.
    Podobnym tworem wystÄ™pujÄ…cym w jÄ™zykach imperatywnych jest instrukcja
    switch, ale dopasowanie do wzorca jest od niej duÅ¼o potÄ™Å¼niejsze.

<div class="paragraph"> </div>

    Nasza funkcja dziaÅ‚a nastÄ™pujÄ…co: sprawdzamy, ktÃ³rym konstruktorem
    zrobiono argument <span class="inlinecode"><span class="id" title="var">b</span></span> â€” jeÅ¼eli byÅ‚o to <span class="inlinecode"><span class="id" title="var">true</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">false</span></span>, a
    gdy byÅ‚o to <span class="inlinecode"><span class="id" title="var">false</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a name="lab88"></a><h4 class="section">Ä†wiczenie (<span class="inlinecode"><span class="id" title="var">andb</span></span> i <span class="inlinecode"><span class="id" title="var">orb</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">andb</span></span> (koniunkcja boolowska) i <span class="inlinecode"><span class="id" title="var">orb</span></span> (alternatywa
    boolowska). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zanim odpalimy naszÄ… funkcjÄ™, powinniÅ›my zadaÄ‡ sobie pytanie: w jaki
    sposÃ³b programy sÄ… wykonywane? W celu lepszego zrozumienia tego
    zagadnienia porÃ³wnamy ewaluacjÄ™ programÃ³w napisanych w jÄ™zykach
    imperatywnych oraz funkcyjnych.

<div class="paragraph"> </div>

    RozwaÅ¼my bardzo uproszczony model: interpreter wykonuje program,
    ktÃ³ry nie dokonuje operacji wejÅ›cia/wyjÅ›cia, napisany w jakimÅ›
    jÄ™zyku imperatywnym. W tej sytuacji dziaÅ‚anie interpretera
    sprowadza siÄ™ do tego, Å¼e czyta on kod programu instrukcja po
    instrukcji, a nastÄ™pnie w zaleÅ¼noÅ›ci od przeczytanej instrukcji
    odpowiednio zmienia swÃ³j stan.

<div class="paragraph"> </div>

    W jÄ™zyku czysto funkcyjnym taki model ewaluacji jest niemoÅ¼liwy,
    gdyÅ¼ nie dysponujemy globalnym stanem. Zamiast tego, w Coqu
    wykonanie programu polega na jego redukcji. O co chodzi?
    Przypomnijmy najpierw, Å¼e program to term, ktÃ³rego typem jest
    specyfikacja, czyli typ sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Termy mogÄ… byÄ‡ redukowane,
    czyli zamieniane na rÃ³wnowaÅ¼ne, ale prostsze, przy uÅ¼yciu
    reguÅ‚ redukcji. PrzeÅ›ledÅºmy wykonanie programu <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    krok po kroku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;(fun&nbsp;b&nbsp;:&nbsp;bool&nbsp;=&gt;&nbsp;match&nbsp;b&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja delta odwija definicje. Å»eby uÅ¼yÄ‡ jakiejÅ› redukcji, uÅ¼ywamy
    komendy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> <span class="inlinecode"><span class="id" title="var">redukcje</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">term</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;match&nbsp;true&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja beta podstawia argument do funkcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">iota</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja jota dopasowuje term do wzorca i zamienia go na term
    znajdujÄ…cy siÄ™ po prawej stronie <span class="inlinecode">=&gt;</span> dla dopasowanego przypadku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Å»eby zredukowaÄ‡ term za jednym zamachem, moÅ¼emy pominÄ…Ä‡ nazwy
    redukcji wystÄ™pujÄ…ce po <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> â€” w taki wypadku zostanÄ… zaaplikowane
    wszystkie moÅ¼liwe redukcje, czyli program zostanie wykonany. Do jego
    wykonania moÅ¼emy teÅ¼ uÅ¼yÄ‡ komend <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (a
    takÅ¼e <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ale taktyka <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> jest przestarzaÅ‚a, wiÄ™c nie
    polecam). 
<div class="paragraph"> </div>

<a name="lab89"></a><h4 class="section">Ä†wiczenie (redukcja)</h4>

<div class="paragraph"> </div>

 Zredukuj "rÄ™cznie" programy <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> oraz <span class="inlinecode"><span class="id" title="var">orb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 Jak widaÄ‡, wykonanie programu w Coqu jest doÅ›Ä‡ toporne. Wynika to
    z faktu, Å¼e Coq nie zostaÅ‚ stworzony do wykonywania programÃ³w, a
    jedynie do ich definiowania i dowodzenia ich poprawnoÅ›ci. Aby uÅ¼yÄ‡
    programu napisanego w Coqu w Å›wiecie rzeczywistym, stosuje siÄ™
    zazwyczaj mechanizm ekstrakcji, ktÃ³ry pozwala z programu napisanego
    w Coqu automatycznie uzyskaÄ‡ program w Scheme, OCamlu lub Haskellu,
    ktÃ³re sÄ… od Coqa duÅ¼o szybsze i duÅ¼o powszechniej uÅ¼ywane. My jednak
    nie bÄ™dziemy siÄ™ tym przejmowaÄ‡. 

<div class="paragraph"> </div>

    Zdefiniowawszy naszÄ… funkcjÄ™, moÅ¼emy zadaÄ‡ sobie pytanie:
    czy definicja jest poprawna? GdybyÅ›my pisali w jednym z
    jÄ™zykÃ³w imperatywnych, moglibyÅ›my napisaÄ‡ dla niej testy
    jednostkowe, polegajÄ…ce np. na tym, Å¼e generujemy losowo
    wejÅ›cie funkcji i sprawdzamy, czy wynik posiada Å¼Ä…danÄ… przez
    nas wÅ‚aÅ›ciwoÅ›Ä‡. Coq umoÅ¼liwia nam coÅ› duÅ¼o silniejszego:
    moÅ¼emy wyraziÄ‡ przy pomocy twierdzenia, Å¼e funkcja posiada
    interesujÄ…cÄ… nas wÅ‚asnoÅ›Ä‡, a nastÄ™pnie sprÃ³bowaÄ‡ je udowodniÄ‡.
    JeÅ¼eli nam siÄ™ powiedzie, mamy caÅ‚kowitÄ… pewnoÅ›Ä‡, Å¼e funkcja
    rzeczywiÅ›cie posiada Å¼Ä…danÄ… wÅ‚asnoÅ›Ä‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_involutive</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie gÅ‚osi, Å¼e funkcja <span class="inlinecode"><span class="id" title="var">negb</span></span> jest inwolucjÄ…,
    tzn. Å¼e dwukrotne jej zaaplikowanie do danego argumentu
    nie zmienia go, lub teÅ¼, innymi sÅ‚owy, Å¼e <span class="inlinecode"><span class="id" title="var">negb</span></span> jest
    swojÄ… wÅ‚asnÄ… odwrotnoÅ›ciÄ….

<div class="paragraph"> </div>

    DowÃ³d przebiega w nastÄ™pujÄ…cy sposÃ³b: taktykÄ… <span class="inlinecode"><span class="id" title="tactic">intro</span></span>
    wprowadzamy zmiennÄ… <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu, a nastÄ™pnie
    uÅ¼ywamy taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, aby sprawdziÄ‡, ktÃ³rym
    konstruktorem zostaÅ‚a zrobiona. PoniewaÅ¼ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma
    dwa konstruktory, taktyka ta generuje nam dwa podcele:
    musimy udowodniÄ‡ twierdzenie osobno dla przypadku, gdy
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz dla <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. Potem przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> redukujemy (czyli wykonujemy) programy
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span>. ZauwaÅ¼, Å¼e
    byÅ‚oby to niemoÅ¼liwe, gdyby argument byÅ‚ postaci <span class="inlinecode"><span class="id" title="var">b</span></span>
    (nie moÅ¼na wtedy zaaplikowaÄ‡ Å¼adnej redukcji), ale jest
    jak najbardziej moÅ¼liwe, gdy jest on postaci <span class="inlinecode"><span class="id" title="var">true</span></span> albo
    <span class="inlinecode"><span class="id" title="var">false</span></span> (wtedy redukcja przebiega jak w przykÅ‚adzie). Na
    koniec uÅ¼ywamy taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, ktÃ³ra potrafi udowodniÄ‡
    cel postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> jest taktykowym odpowiednikiem dopasowania do wzorca
    i bardzo czÄ™sto jest uÅ¼ywany, gdy mamy do czynienia z czymÅ›,
    co zostaÅ‚o za jego pomocÄ… zdefiniowane.

<div class="paragraph"> </div>

    ByÄ‡ moÅ¼e poczuÅ‚eÅ› dyskomfort spowodowany tym, Å¼e cel postaci
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> moÅ¼na udowodniÄ‡ dwoma rÃ³Å¼nymi taktykami (<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>) albo Å¼e termy moÅ¼na redukowaÄ‡ na cztery rÃ³Å¼ne
    sposoby (<span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>).
    Niestety, bÄ™dziesz musiaÅ‚ siÄ™ do tego przyzwyczaiÄ‡ â€” jÄ™zyk
    taktyka Coqa jest strasznie zabaÅ‚aganiony i niesie ze sobÄ…
    spory bagaÅ¼ swej mrocznej przeszÅ‚oÅ›ci. Na szczÄ™Å›cie od niedawna
    trwajÄ… prace nad jego ucywilizowaniem, czego pierwsze efekty
    widaÄ‡ juÅ¼ od wersji 8.5. W chwilach desperacji uratowaÄ‡ moÅ¼e
    ciÄ™ jedynie dokumentacja:
<ul class="doclist">
<li> https://coq.inria.fr/refman/coq-tacindex.html

</li>
<li> https://coq.inria.fr/refman/proof-engine/ltac.html 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_involutive'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
ZauwaÅ¼my, Å¼e nie musimy uÅ¼ywaÄ‡ taktyki <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, Å¼eby wprowadziÄ‡
    <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu: taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sama jest w stanie wykryÄ‡,
    Å¼e nie ma go w kontekÅ›cie i wprowadziÄ‡ je tam przed rozbiciem
    go na konstruktory. ZauwaÅ¼my teÅ¼, Å¼e oba podcele rozwiÄ…zaliÅ›my
    w ten sam sposÃ³b, wiÄ™c moÅ¼emy uÅ¼yÄ‡ kombinatora <span class="inlinecode">;</span> (Å›rednika),
    Å¼eby rozwiÄ…zaÄ‡ je oba za jednym zamachem. 
<div class="paragraph"> </div>

<a name="lab90"></a><h4 class="section">Ä†wiczenie (logika boolowska)</h4>

<div class="paragraph"> </div>

 Udowodnij poniÅ¼sze twierdzenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">andb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">orb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">orb</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">orb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">b1</span> = <span class="id" title="var">true</span> /\ <span class="id" title="var">b2</span> = <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab91"></a><h4 class="section">Ä†wiczenie (rÃ³Å¼a kierunkÃ³w)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj typ opisujÄ…cy kierunki podstawowe (pÃ³Å‚noc, poÅ‚udnie, wschÃ³d,
    zachÃ³d - dodatkowe punkty za nadanie im sensownych nazw). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>, ktÃ³re reprezentujÄ… obrÃ³t o 90
    stopni przeciwnie/zgodnie z ruchem wskazÃ³wek zegara. SformuÅ‚uj i
    udowodnij twierdzenia mÃ³wiÄ…ce, Å¼e:
<ul class="doclist">
<li> obrÃ³t cztery razy w lewo/prawo niczego nie zmienia

</li>
<li> obrÃ³t trzy razy w prawo to tak naprawdÄ™ obrÃ³t w lewo (jest to tzw.
      pierwsze twierdzenie korwinizmu)

</li>
<li> obrÃ³t trzy razy w lewo to obrÃ³t w prawo (jest to tzw. drugie
      twierdzenie korwinizmu)

</li>
<li> obrÃ³t w prawo, a potem w lewo niczego nie zmienia

</li>
<li> obrÃ³t w lewo, a potem w prawo niczego nie zmienia

</li>
<li> kaÅ¼dy kierunek to pÃ³Å‚noc, poÅ‚udnie, wschÃ³d lub zachÃ³d (tzn. nie ma
      innych kierunkÃ³w) 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcjÄ™ <span class="inlinecode"><span class="id" title="var">opposite</span></span>, ktÃ³re danemu kierunkowi przyporzÄ…dkowuje
    kierunek do niego przeciwny (czyli pÃ³Å‚nocy przyporzÄ…dkowuje poÅ‚udnie
    etc.). WymyÅ›l i udowodnij jakÄ…Å› ciekawÄ™ specyfikacjÄ™ dla tej funkcji
    (wskazÃ³wka: powiÄ…Å¼ jÄ… z <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcjÄ™ <span class="inlinecode"><span class="id" title="var">is_opposite</span></span>, ktÃ³ra bierze dwa kierunki i zwraca
    <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy sÄ… one przeciwne oraz <span class="inlinecode"><span class="id" title="var">false</span></span> w przeciwnym wypadku. WymyÅ›l
    i udowodnij jakÄ…Å› specyfikacjÄ™ dla tej funkcji. WskazÃ³wka: jakie sÄ… jej
    zwiÄ…zku z <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> i <span class="inlinecode"><span class="id" title="var">opposite</span></span>? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
PokaÅ¼, Å¼e funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> oraz <span class="inlinecode"><span class="id" title="var">opposite</span></span> sÄ… injekcjami i
    surjekcjami (co to dokÅ‚adnie znacz, dowiemy siÄ™ pÃ³Åºniej). Uwaga: to
    zadanie wymaga uÅ¼yci taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, ktÃ³ra jest opisana w
    podrozdziale o polimorfizmie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnL</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnR</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">opposite</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab92"></a><h4 class="section">Ä†wiczenie (rÃ³Å¼ne enumeracje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj typy induktywne reprezentujÄ…ce:
<ul class="doclist">
<li> dni tygodnia

</li>
<li> miesiÄ…ce

</li>
<li> kolory podstawowe systemu RGB 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
WymyÅ›l do nich jakieÅ› ciekawe funkcje i twierdzenia. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab93"></a><h2 class="section">Konstruktory rekurencyjne</h2>

<div class="paragraph"> </div>

 PowiedzieliÅ›my, Å¼e termy typÃ³w induktywnych sÄ… drzewami. W przypadku
    enumeracji jest to sÅ‚abo widoczne, gdyÅ¼ drzewa te sÄ… zdegenerowane â€”
    sÄ… to po prostu punkciki oznaczone nazwami konstruktorÃ³w. Efekt
    rozgaÅ‚Ä™zienia moÅ¼emy uzyskaÄ‡, gdy jeden z konstruktorÃ³w bÄ™dzie
    rekurencyjny, tzn. gdy jako argument bÄ™dzie przyjmowaÅ‚ term typu,
    ktÃ³ry wÅ‚aÅ›nie definiujemy. Naszym przykÅ‚adem bÄ™dÄ… liczby naturalne
    (choÄ‡ i tutaj rozgaÅ‚Ä™zienie bÄ™dzie nieco zdegenerowane  ­- kaÅ¼dy term
    bÄ™dzie mÃ³gÅ‚ mieÄ‡ co najwyÅ¼ej jedno). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatDef</span>.<br/>

<br/>
</div>

<div class="doc">
Mechanizm moduÅ‚Ã³w jest podobny do mechanizmu sekcji i na razie nie
    bÄ™dzie nas interesowaÅ‚ â€” uÅ¼yjemy go, Å¼eby nie zaÅ›miecaÄ‡ gÅ‚Ã³wnej
    przestrzeni nazw (mechanizm sekcji w tym przypadku by nie pomÃ³gÅ‚). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;0" := <span class="id" title="var">O</span>.<br/>

<br/>
</div>

<div class="doc">
Uwaga: nazwa pierwszego konstruktora to duÅ¼a litera O, a nie cyfra 0
    â€” cyfry nie mogÄ… byÄ‡ nazwami. Å»eby obejÅ›Ä‡ tÄ™ niedogodnoÅ›Ä‡, musimy
    posÅ‚uÅ¼yÄ‡ siÄ™ mechanizmem notacji â€” dziÄ™ki temu bÄ™dziemy mogli pisaÄ‡
    0 zamiast O.

<div class="paragraph"> </div>

    DefinicjÄ™ tÄ™ moÅ¼emy odczytaÄ‡ w nastÄ™pujÄ…cy sposÃ³b: "<span class="inlinecode">0</span> jest liczbÄ…
    naturalnÄ…; jeÅ¼eli <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbÄ… naturalnÄ…, to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> rÃ³wnieÅ¼ jest
    liczbÄ… naturalnÄ…". Konstruktor <span class="inlinecode"><span class="id" title="var">S</span></span> odpowiada tutaj dodawaniu jedynki:
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> to 1, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span> to 2, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0))</span> to 3 i tak dalej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0))).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;S&nbsp;(S&nbsp;(S&nbsp;0))&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatDef</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;3&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
RÄ™czne liczenie iloÅ›ci <span class="inlinecode"><span class="id" title="var">S</span></span> w kaÅ¼dej liczbie szybko staje siÄ™ trudne
    nawet dla maÅ‚ych liczb. Na szczÄ™Å›cie standardowa biblioteka Coqa
    udostÄ™pnia notacje, ktÃ³re pozwalajÄ… nam zapisywaÄ‡ liczby naturalne
    przy pomocy dobrze znanych nam cyfr arabskich. Å»eby uzyskaÄ‡ do nich
    dostÄ™p, musimy opuÅ›ciÄ‡ zdefiniowany przez nas moduÅ‚ <span class="inlinecode"><span class="id" title="var">NatDef</span></span>, Å¼eby
    nasza definicja <span class="inlinecode"><span class="id" title="var">nat</span></span> nie przysÅ‚aniaÅ‚a tej bibliotecznej. Zaczniemy
    za to nowy moduÅ‚, Å¼ebyÅ›my mogli swobodnie zredefiniowaÄ‡ dziaÅ‚ania
    na liczbach naturalnych z biblioteki standardowej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatOps</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
W zapisie unarnym liczby naturalne moÅ¼emy wyobraÅ¼aÄ‡ sobie jako kupki
    <span class="inlinecode"><span class="id" title="var">S</span></span>-Ã³w, wiÄ™c dodawanie dwÃ³ch liczb sprowadza siÄ™ do przerzucenia <span class="inlinecode"><span class="id" title="var">S</span></span>-Ã³w
    z jednej kupki na drugÄ….

<div class="paragraph"> </div>

    Definiowanie funkcji dla typÃ³w z konstruktorami rekurencyjnymi
    wyglÄ…da podobnie jak dla enumeracji, ale wystÄ™pujÄ… drobne rÃ³Å¼nice:
    jeÅ¼eli bÄ™dziemy uÅ¼ywaÄ‡ rekurencji, musimy zaznaczyÄ‡ to za pomocÄ…
    sÅ‚owa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (zamiast wczeÅ›niejszego <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>).
    ZauwaÅ¼my teÅ¼, Å¼e jeÅ¼eli funkcja ma wiele argumentÃ³w tego samego typu,
    moÅ¼emy napisaÄ‡ <span class="inlinecode">(<span class="id" title="var">arg1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">argN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span> zamiast dÅ‚uÅ¼szego <span class="inlinecode">(<span class="id" title="var">arg1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>
    <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">argN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>.

<div class="paragraph"> </div>

    JeÅ¼eli konstruktor typu induktywnego bierze jakieÅ› argumenty, to wzorce,
    ktÃ³re go dopasowujÄ…, stajÄ… siÄ™ nieco bardziej skomplikowane: poza nazwÄ…
    konstruktora muszÄ… teÅ¼ dopasowywaÄ‡ argumenty â€” w naszym przypadku uÅ¼ywamy
    zmiennej o nazwie <span class="inlinecode"><span class="id" title="var">n'</span></span>, ktÃ³ra istnieje tylko lokalnie (tylko we wzorcu
    dopasowania oraz po prawej stronie strzaÅ‚ki <span class="inlinecode">=&gt;</span>).

<div class="paragraph"> </div>

    NaszÄ… funkcjÄ™ zdefiniowaliÅ›my przy pomocy najbardziej elementarnego
    rodzaju rekursji, jaki jest dostÄ™pny w Coqu: rekursji strukturalnej.
    W przypadku takiej rekursji wywoÅ‚ania rekurencyjne mogÄ… odbywaÄ‡ siÄ™
    jedynie na termach strukturalnie mniejszych, niÅ¼ obecny argument
    gÅ‚Ã³wny rekurencji. W naszym przypadku argumentem gÅ‚Ã³wnym jest <span class="inlinecode"><span class="id" title="var">n</span></span>
    (bo on jest dopasowywany), zaÅ› rekurencyjnych wywoÅ‚aÅ„ dokonujemy na
    <span class="inlinecode"><span class="id" title="var">n'</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. <span class="inlinecode"><span class="id" title="var">n'</span></span> jest strukturalnie mniejszy od <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>,
    gdyÅ¼ skÅ‚ada siÄ™ z jednego <span class="inlinecode"><span class="id" title="var">S</span></span> mniej. JeÅ¼eli wyobrazimy sobie nasze
    liczby jako kupki <span class="inlinecode"><span class="id" title="var">S</span></span>-Ã³w, to wywoÅ‚ania rekurencyjne moÅ¼emy robiÄ‡
    jedynie po zdjÄ™ciu z kupki co najmniej jednego <span class="inlinecode"><span class="id" title="var">S</span></span>. 
<div class="paragraph"> </div>

<a name="lab94"></a><h4 class="section">Ä†wiczenie (rekursja niestrukturalna)</h4>

<div class="paragraph"> </div>

 WymyÅ›l funkcjÄ™ z liczb naturalnych w liczby naturalne,
    ktÃ³ra jest rekurencyjna, ale nie jest strukturalnie rekurencyjna.
    Precyzyjniej piszÄ…c: pÃ³Åºniej okaÅ¼e siÄ™, Å¼e wszystkie formy
    rekurencji to tak naprawdÄ™ rekursja strukturalna pod przykrywkÄ….
    WymyÅ›l takÄ… definicjÄ™, ktÃ³ra na pierwszy rzut oka nie jest
    strukturalnie rekurencyjna. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Podobnie jak w przypadku funkcji <span class="inlinecode"><span class="id" title="var">negb</span></span>, tak i tym razem w celu
    sprawdzenia poprawnoÅ›ci naszej definicji sprÃ³bujemy udowodniÄ‡, Å¼e
    posiada ona wÅ‚aÅ›ciwoÅ›ci, ktÃ³rych siÄ™ spodziewamy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_O_n</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> 0 <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Tak prosty dowÃ³d nie powinien nas dziwiÄ‡ â€” wszakÅ¼e twierdzenie to
    wynika wprost z definicji (sprÃ³buj zredukowaÄ‡ "rÄ™cznie" wyraÅ¼enie
    <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O_try1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">f_equal</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem nie jest juÅ¼ tak prosto â€” <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie wynika z definicji
    przez prostÄ… redukcjÄ™, gdyÅ¼ argumentem gÅ‚Ã³wnym funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> jest
    jej pierwszy argument, czyli <span class="inlinecode"><span class="id" title="var">n</span></span>. Å»eby mÃ³c zredukowaÄ‡ to wyraÅ¼enie,
    musimy rozbiÄ‡ <span class="inlinecode"><span class="id" title="var">n</span></span>. Pokazanie, Å¼e <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> jest trywialne, ale
    drugi przypadek jest juÅ¼ beznadziejny. PoniewaÅ¼ funkcje zachowujÄ…
    rÃ³wnoÅ›Ä‡ (czyli <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> implikuje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>), to aby pokazaÄ‡, Å¼e
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, wystarczyÄ‡ pokazaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> â€” w ten wÅ‚aÅ›nie sposÃ³b
    dziaÅ‚a taktyka <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>. Nie pomogÅ‚a nam ona jednak â€” po jej
    uÅ¼yciu mamy do pokazania to samo, co na poczÄ…tku, czyli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Do udowodnienia tego twierdzenia musimy posÅ‚uÅ¼yÄ‡ siÄ™ indukcjÄ….
    Indukcja jest sposobem dowodzenia wÅ‚aÅ›ciwoÅ›ci typÃ³w induktywnych
    i funkcji rekurencyjnych, ktÃ³ry dziaÅ‚a mniej wiÄ™cej tak: Å¼eby
    udowodniÄ‡, Å¼e kaÅ¼dy term typu <span class="inlinecode"><span class="id" title="var">A</span></span> posiada wÅ‚asnoÅ›Ä‡ <span class="inlinecode"><span class="id" title="var">P</span></span>, pokazujemy
    najpierw, Å¼e konstruktory nierekurencyjne posiadajÄ… tÄ™ wÅ‚asnoÅ›Ä‡
    dla dowolnych argumentÃ³w, a nastÄ™pnie, Å¼e konstruktory rekurencyjne
    zachowujÄ… tÄ™ wÅ‚asnoÅ›Ä‡.

<div class="paragraph"> </div>

    W przypadku liczb naturalnych indukcja wyglÄ…da tak: Å¼eby pokazaÄ‡,
    Å¼e kaÅ¼da liczba naturalna ma wÅ‚asnoÅ›Ä‡ <span class="inlinecode"><span class="id" title="var">P</span></span>, najpierw naleÅ¼y
    pokazaÄ‡, Å¼e zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">0</span>, a nastÄ™pnie, Å¼e jeÅ¼eli zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    to zachodzi takÅ¼e <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. Z tych dwÃ³ch reguÅ‚ moÅ¼emy zbudowaÄ‡
    dowÃ³d na to, Å¼e <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> zachodzi dla dowolnego <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Ten sposÃ³b rozumowania moÅ¼emy zrealizowaÄ‡ w Coqu przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. DziaÅ‚a ona podobnie do <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, czyli
    rozbija podany term na konstruktory, ale w przypadku konstruktorÃ³w
    rekurencyjnych robi coÅ› jeszcze â€” daje nam zaÅ‚oÅ¼enie indukcyjne,
    ktÃ³re mÃ³wi, Å¼e dowodzone przez nas twierdzenie zachodzi dla
    rekurencyjnych argumentÃ³w konstruktora. WÅ‚aÅ›nie tego byÅ‚o nam
    trzeba: zaÅ‚oÅ¼enie indukcyjne pozwala nam dokoÅ„czyÄ‡ dowÃ³d. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">plus</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm'</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pojedyncza indukcja nie zawsze wystarcza, co obrazuje powyÅ¼szy przypadek.
    ZauwaÅ¼my, Å¼e przed uÅ¼yciem <span class="inlinecode"><span class="id" title="tactic">induction</span></span> nie musimy wprowadzaÄ‡ zmiennych
    do kontekstu â€” taktyka ta robi to sama, podobnie jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>.
    RÃ³wnieÅ¼ podobnie jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, moÅ¼emy przekazaÄ‡ jej wzorzec, ktÃ³rym
    nadajemy nazwy argumentom konstruktorÃ³w, na ktÃ³re rozbijany jest term.

<div class="paragraph"> </div>

    W ogÃ³lnoÅ›ci wzorzec ma postaÄ‡ <span class="inlinecode">[<span class="id" title="var">a11</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">a1n</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">am1</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">amk</span>]</span>. Pionowa
    kreska oddziela argumenty poszczegÃ³lnych konstruktorÃ³w: <span class="inlinecode"><span class="id" title="var">a11</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">a1n</span></span>
    to argumenty pierwszego konstruktora, zaÅ› <span class="inlinecode"><span class="id" title="var">am1</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">amk</span></span> to argumenty
    m-tego konstruktora. <span class="inlinecode"><span class="id" title="var">nat</span></span> ma dwa konstruktory, z czego pierwszy nie
    bierze argumentÃ³w, a drugi bierze jeden, wiÄ™c nasz wzorzec ma postaÄ‡
    <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">n'</span>]</span>. DziÄ™ki temu nie musimy polegaÄ‡ na domyÅ›lnych nazwach nadawanych
    argumentom przez Coqa, ktÃ³re czÄ™sto wprowadzajÄ… zamÄ™t.

<div class="paragraph"> </div>

    JeÅ¼eli damy taktyce <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> nazwÄ™ hipotezy lub twierdzenia, ktÃ³rego
    konkluzjÄ… jest <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, to zamienia ona w obecnym podcelu wszystkie
    wystÄ…pienia <span class="inlinecode"><span class="id" title="var">a</span></span> na <span class="inlinecode"><span class="id" title="var">b</span></span> oraz generuje tyle podcelÃ³w, ile przesÅ‚anek ma
    uÅ¼yta hipoteza lub twierdzenie. W naszym przypadku uÅ¼yliÅ›my udowodnionego
    uprzednio twierdzenia <span class="inlinecode"><span class="id" title="var">plus_n_O</span></span>, ktÃ³re nie ma przesÅ‚anek, czego efektem
    byÅ‚o po prostu przepisanie <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    PrzepisywaÄ‡ moÅ¼emy teÅ¼ w drugÄ… stronÄ™ piszÄ…c <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>. Wtedy jeÅ¼eli
    konkluzjÄ… danego <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> twierdzenia lub hipotezy jest <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, to
    w celu wszystkie <span class="inlinecode"><span class="id" title="var">b</span></span> zostanÄ… zastÄ…pione przez <span class="inlinecode"><span class="id" title="var">a</span></span>. 
<div class="paragraph"> </div>

<a name="lab95"></a><h4 class="section">Ä†wiczenie (mnoÅ¼enie)</h4>

<div class="paragraph"> </div>

 Zdefiniuj mnoÅ¼enie i udowodnij jego wÅ‚aÅ›ciwoÅ›ci. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> 0 <span class="id" title="var">n</span> = 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> <span class="id" title="var">n</span> 0 = 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_1_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> 1 <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_1_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">mult</span> <span class="id" title="var">n</span> 1 = <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
JeÅ¼eli Ä‡wiczenie byÅ‚o za proste i czytaÅ‚eÅ› podrozdziaÅ‚ o kombinatorach
    taktyk, to sprÃ³buj udowodniÄ‡:
<ul class="doclist">
<li> dwa pierwsze twierdzenia uÅ¼ywajÄ…c nie wiÄ™cej niÅ¼ 2 taktyk

</li>
<li> trzecie bez uÅ¼ycia indukcji, uÅ¼ywajÄ…c nie wiÄ™cej niÅ¼ 4 taktyk

</li>
<li> czwarte uÅ¼ywajÄ…c nie wiÄ™cej niÅ¼ 4 taktyk 
</li>
</ul>

<div class="paragraph"> </div>

 Wszystkie dowody powinny byÄ‡ nie dÅ‚uÅ¼sze niÅ¼ pÃ³Å‚ linijki. 
<div class="paragraph"> </div>

<a name="lab96"></a><h4 class="section">Ä†wiczenie (inne dodawanie)</h4>

<div class="paragraph"> </div>

 Dodawanie moÅ¼na alternatywnie zdefiniowaÄ‡ takÅ¼e w sposÃ³b przedstawiony
    poniÅ¼ej. Udowodnij, Å¼e ta definicja jest rÃ³wnowaÅ¼na poprzedniej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">plus'</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_n_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_S</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">m</span> = <span class="id" title="var">S</span> (<span class="id" title="var">plus'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_0_n</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> 0 <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">plus'</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus'_is_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatOps</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab97"></a><h2 class="section">Typy polimorficzne i wÅ‚aÅ›ciwoÅ›ci konstruktorÃ³w</h2>

<div class="paragraph"> </div>

 Przy pomocy komendy <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> moÅ¼emy definiowaÄ‡ nie tylko typy
    induktywne, ale takÅ¼e rodziny typÃ³w induktywnych. JeÅ¼eli taka
    rodzina parametryzowana jest typem, to mamy do czynienia z
    polimorfizmem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">option</span></span> jest rodzinÄ… typÃ³w, zaÅ› samo <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dla ustalonego <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest typem, ktÃ³ry reprezentuje moÅ¼liwoÅ›Ä‡ istnienia wartoÅ›ci typu <span class="inlinecode"><span class="id" title="var">A</span></span>
    (konstruktor <span class="inlinecode"><span class="id" title="var">Some</span></span>) albo i nie (konstruktor <span class="inlinecode"><span class="id" title="var">None</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span> <span class="id" title="var">nat</span> 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;nat&nbsp;5&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">None</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Some</span> [<span class="id" title="var">A</span>] <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">None</span> [<span class="id" title="var">A</span>].<br/>

<br/>
</div>

<div class="doc">
Jak widaÄ‡ typ <span class="inlinecode"><span class="id" title="var">A</span></span>, bÄ™dÄ…cy parametrem <span class="inlinecode"><span class="id" title="var">option</span></span>, jest teÅ¼ pierwszym
    argumentem kaÅ¼dego z konstruktorÃ³w.
    Pisanie go bywa uciÄ…Å¼liwe, ale na szczÄ™Å›cie Coq moÅ¼e sam wywnioskowaÄ‡
    jego wartoÅ›Ä‡, jeÅ¼eli mu kaÅ¼emy. Komenda <span class="inlinecode"><span class="id" title="var">Arguments</span></span> pozwala nam
    okreÅ›liÄ‡, ktÃ³re argumenty majÄ… byÄ‡ domyÅ›lne â€” chcemy, aby argument <span class="inlinecode"><span class="id" title="var">A</span></span>
    byÅ‚ domyÅ›lny, gdyÅ¼ w przypadku konstruktura <span class="inlinecode"><span class="id" title="var">Some</span></span> moÅ¼e byÄ‡ wywnioskowany
    z drugiego argumentu, a w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> â€” zazwyczaj z kontekstu.

<div class="paragraph"> </div>

    Konstruktory typÃ³w induktywnych majÄ… kilka wÅ‚aÅ›ciwoÅ›ci, o ktÃ³rch
    warto wiedzieÄ‡. Po pierwsze, wartoÅ›ci zrobione za pomocÄ… rÃ³Å¼nych
    konstruktorÃ³w sÄ… rÃ³Å¼ne. Jest to konieczne, gdyÅ¼ za pomocÄ… dopasowania
    do wzorca moÅ¼emy rozrÃ³Å¼niÄ‡ rÃ³Å¼ne konstruktory â€” gdyby byÅ‚y one
    rÃ³wne, uzyskalibyÅ›my sprzecznoÅ›Ä‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isSome</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">a</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">False</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Pomocnicza funkcja <span class="inlinecode"><span class="id" title="var">isSome</span></span> ma za zadanie sprawdziÄ‡, ktÃ³rym
    konstruktorem zrobiono wartoÅ›Ä‡ typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span>
    oznacza, Å¼e <span class="inlinecode"><span class="id" title="var">A</span></span> jest argumentem domyÅ›lnym funkcji â€” Coq moÅ¼e go
    wywnioskowaÄ‡, gdyÅ¼ zna typ argumentu <span class="inlinecode"><span class="id" title="var">a</span></span> (jest nim <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).
    ZauwaÅ¼ teÅ¼, Å¼e funkcja ta zwraca zdania logiczne, a nie wartoÅ›ci
    boolowskie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_not_none</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">change</span> <span class="id" title="var">False</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">isSome</span> (@<span class="id" title="var">None</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
MoÅ¼emy uÅ¼yÄ‡ tej pomocniczej funkcji, aby udowodniÄ‡, Å¼e konstruktory
    <span class="inlinecode"><span class="id" title="var">Some</span></span> i <span class="inlinecode"><span class="id" title="var">None</span></span> tworzÄ… rÃ³Å¼ne wartoÅ›ci. Taktyka <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span>
    pozwala nam zamieniÄ‡ term <span class="inlinecode"><span class="id" title="var">t1</span></span> na <span class="inlinecode"><span class="id" title="var">t2</span></span> pod warunkiem, Å¼e sÄ… one
    konwertowalne (czyli jeden z nich redukuje siÄ™ do drugiego). W naszym
    wypadku chcemy zastÄ…piÄ‡ <span class="inlinecode"><span class="id" title="var">False</span></span> przez <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(@<span class="id" title="var">None</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, ktÃ³ry
    redukuje siÄ™ do <span class="inlinecode"><span class="id" title="var">False</span></span> (sprÃ³buj zredukowaÄ‡ to wyraÅ¼enie rÄ™cznie).

<div class="paragraph"> </div>

    UÅ¼ycie symbolu <span class="inlinecode">@</span> pozwala nam dla danego wyraÅ¼enia zrezygnowaÄ‡ z
    prÃ³by automatycznego wywnioskowania argumentÃ³w domyÅ›lnych â€” w tym
    przypadku Coq nie potrafiÅ‚by wywnioskowaÄ‡ argumentu dla konstruktora
    <span class="inlinecode"><span class="id" title="var">None</span></span>, wiÄ™c musimy podaÄ‡ ten argument rÄ™cznie. 

<div class="paragraph"> </div>

    NastÄ™pnie moÅ¼emy skorzystaÄ‡ z rÃ³wnania <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>, Å¼eby
    uzyskaÄ‡ cel postaci <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(<span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>. Cel ten redukuje siÄ™
    do <span class="inlinecode"><span class="id" title="var">True</span></span>, ktÃ³rego udowodnienie jest trywialne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_not_none'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">inversion</span> 1. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
CaÅ‚a procedura jest doÅ›Ä‡ skomplikowana â€” w szczegÃ³lnoÅ›ci wymaga
    napisania funkcji pomocniczej. Na szczÄ™Å›cie Coq jest w stanie
    sam wywnioskowaÄ‡, Å¼e konstruktory sÄ… rÃ³Å¼ne. MoÅ¼emy zrobiÄ‡ to
    przy pomocy znanej nam z poprzedniego rozdziaÅ‚u taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Zapis <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> oznacza: wprowadÅº zmienne zwiÄ…zane przez
    kwantyfikacjÄ™ uniwersanÄ… do kontekstu i uÅ¼yj taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    na pierwszej przesÅ‚ance implikacji. W naszym przypadku implikacja
    jest ukryta w definicji negacji: <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">None</span></span> to tak naprawdÄ™
    <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
KolejnÄ… wÅ‚aÅ›ciwoÅ›ciÄ… konstruktorÃ³w jest fakt, Å¼e sÄ… one injekcjami,
    tzn. jeÅ¼eli dwa termy zrobione tymi samymi konstruktorami sÄ… rÃ³wne,
    to argumenty tych konstruktorÃ³w teÅ¼ sÄ… rÃ³wne.

<div class="paragraph"> </div>

    Aby skorzystaÄ‡ z tej wÅ‚aÅ›ciwoÅ›ci w dowodzie, moÅ¼emy uÅ¼yÄ‡ taktyki
    <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, podajÄ…c jej jako argument nazwÄ™ hipotezy. JeÅ¼eli
    hipoteza jest postaci <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">yn</span></span>, to nasz cel <span class="inlinecode"><span class="id" title="var">G</span></span>
    zostanie zastÄ…piony przez implikacjÄ™ <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">yn</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>.
    Po wprowadzeniu hipotez do kontekstu moÅ¼emy uÅ¼yÄ‡ ich do udowodnienia
    <span class="inlinecode"><span class="id" title="var">G</span></span>, zazwyczaj przy pomocy taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">H</span></span> miaÅ‚o postaÄ‡ <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a cel <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    wiÄ™c <span class="inlinecode"><span class="id" title="tactic">injection</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> przeksztaÅ‚ciÅ‚o cel do postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    ktÃ³ry jest trywialny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_inj'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> moÅ¼e nam pomÃ³c rÃ³wnieÅ¼ wtedy, kiedy chcemy skorzystaÄ‡
    z injektywnoÅ›ci konstruktorÃ³w. W zasadzie jest ona nawet bardziej
    przydatna â€” dziaÅ‚a ona tak jak <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, ale zamiast zostawiaÄ‡ cel w
    postaci <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>, wprowadza ona wygenerowane hipotezy do
    kontekstu, a nastÄ™pnie przepisuje w celu wszystkie, ktÃ³rych przepisanie
    jest moÅ¼liwe. W ten sposÃ³b oszczÄ™dza nam ona nieco pisania.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">inverson</span></span> <span class="inlinecode">1</span> dodaÅ‚a do kontekstu hipotezÄ™ <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    a nastÄ™pnie przepisaÅ‚a jÄ… w celu (ktÃ³ry miaÅ‚ postaÄ‡ <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>), dajÄ…c
    cel postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">some_inj''</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">injection</span> 1. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
TaktykÄ… uÅ‚atwiajÄ…cÄ… pracÄ™ z <span class="inlinecode"><span class="id" title="tactic">injection</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> jest <span class="inlinecode"><span class="id" title="tactic">subst</span></span>.
    Taktyka ta wyszukuje w kontekÅ›cie hipotezy postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>,
    przepisuje je we wszystkich hipotezach w kontekÅ›cie i celu, w ktÃ³rych
    jest to moÅ¼liwe, a nastÄ™pnie usuwa. SzczegÃ³lnie czÄ™sto spotykana
    jest kombinacja <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, gdyÅ¼ <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> czÄ™sto
    generuje sporÄ… iloÅ›Ä‡ hipotez postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, ktÃ³re <span class="inlinecode"><span class="id" title="tactic">subst</span></span> nastÄ™pnie
    "sprzÄ…ta".

<div class="paragraph"> </div>

    W naszym przypadku hipoteza <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> zostaÅ‚a przepisana nie tylko
    w celu, dajÄ…c <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, ale takÅ¼e w hipotezie <span class="inlinecode"><span class="id" title="var">H</span></span>, dajÄ…c
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
<div class="paragraph"> </div>

<a name="lab98"></a><h4 class="section">Ä†wiczenie (zero i jeden)</h4>

<div class="paragraph"> </div>

 Udowodnij poniÅ¼sze twierdzenie bez uÅ¼ywania taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Å»eby byÅ‚o trudniej, nie pisz osobnej funkcji pomocniczej â€” zdefiniuj
    swojÄ… funkcjÄ™ bezpoÅ›rednio w miejscu, w ktÃ³rym chcesz jej uÅ¼yÄ‡.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_not_one</span> : 0 &lt;&gt; 1.<br/>

<br/>
</div>

<div class="doc">
Dwie opisane wÅ‚aÅ›ciwoÅ›ci, choÄ‡ pozornie niewinne, a nawet przydatne,
    majÄ… bardzo istotne i daleko idÄ…ce konsekwencje. PowodujÄ™ one na
    przykÅ‚ad, Å¼e nie istniejÄ… typy ilorazowe. DokÅ‚adne znaczenie tego
    faktu omÃ³wimy pÃ³Åºniej, zaÅ› teraz musimy zadowoliÄ‡ siÄ™ jedynie
    prostym przykÅ‚adem w formie Ä‡wiczenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">rational</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mk_rational</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">sign</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">numerator</span> <span class="id" title="var">denominator</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">denominator</span> &lt;&gt; 0 -&gt; <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">rational_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> <span class="id" title="var">p'</span> <span class="id" title="var">q</span> <span class="id" title="var">q'</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="var">q</span> &lt;&gt; 0) (<span class="id" title="var">H'</span> : <span class="id" title="var">q'</span> &lt;&gt; 0), <span class="id" title="var">p</span> * <span class="id" title="var">q'</span> = <span class="id" title="var">p'</span> * <span class="id" title="var">q</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mk_rational</span> <span class="id" title="var">s</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">H</span> = <span class="id" title="var">mk_rational</span> <span class="id" title="var">s'</span> <span class="id" title="var">p'</span> <span class="id" title="var">q'</span> <span class="id" title="var">H'</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">rational</span></span> ma reprezentowaÄ‡ liczby wymierne. Znak jest typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span> â€” moÅ¼emy interpretowaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">true</span></span> oznacza obecnoÅ›Ä‡ znaku
    minus, a <span class="inlinecode"><span class="id" title="var">false</span></span> brak znaku. Dwie liczby naturalne bÄ™dÄ… oznaczaÄ‡
    kolejno licznik i mianownik, a na koÅ„cu Å¼Ä…damy jeszcze dowodu na
    to, Å¼e mianownik nie jest zerem.

<div class="paragraph"> </div>

    OczywiÅ›cie typ ten sam w sobie niewiele ma wspÃ³lnego z liczbami
    wymiernymi â€” jest to po prostu trÃ³jka elementÃ³w o typach <span class="inlinecode"><span class="id" title="var">bool</span>,</span>
    <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, z ktÃ³rych ostatni nie jest zerem. Å»eby rzeczywiÅ›cie
    reprezentowaÅ‚ liczby wymierne musimy zapewniÄ‡, Å¼e termy, ktÃ³re
    reprezentujÄ… te same wartoÅ›ci, sÄ… rÃ³wne, np. 1/2 musi byÄ‡ rÃ³wna
    2/4.

<div class="paragraph"> </div>

    W tym celu postulujemy aksjomat, ktÃ³ry zapewni nam poÅ¼Ä…dane
    wÅ‚aÅ›ciwoÅ›ci relacji rÃ³wnoÅ›ci. Komenda <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> pozwala nam
    wymusiÄ‡ istnienie termu poÅ¼Ä…danego typu i nadaÄ‡ mu nazwÄ™,
    jednak jest szalenie niebezpieczna â€” jeÅ¼eli zapostulujemy
    aksjomat, ktÃ³ry jest sprzeczny, jesteÅ›my zgubieni.

<div class="paragraph"> </div>

    W takiej sytuacji caÅ‚e nasze dowodzenie idzie na marne, gdyÅ¼
    ze sprzecznego aksjomatu moÅ¼emy wywnioskowaÄ‡ <span class="inlinecode"><span class="id" title="var">False</span></span>, z
    <span class="inlinecode"><span class="id" title="var">False</span></span> zaÅ› moÅ¼emy wywnioskowaÄ‡ cokolwiek, o czym przekonaliÅ›my
    siÄ™ w rozdziale pierwszym. Tak teÅ¼ jest w tym przypadku â€”
    aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny, gdyÅ¼ Å‚amie zasadÄ™
    injektywnoÅ›ci konstruktorÃ³w. 
<div class="paragraph"> </div>

<a name="lab99"></a><h4 class="section">Ä†wiczenie (niedobry aksjomat)</h4>

<div class="paragraph"> </div>

 Udowodnij, Å¼e aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny. WskazÃ³wka: znajdÅº
    dwie liczby wymierne, ktÃ³re sÄ… rÃ³wne na mocy tego aksjomatu, ale ktÃ³re
    moÅ¼na rozrÃ³Å¼niÄ‡ za pomocÄ… dopasowania do wzorca. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rational_eq_inconsistent</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">rational</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab100"></a><h2 class="section">Listy, czyli parametry + rekursja</h2>

<div class="paragraph"> </div>

 PoÅ‚Ä…czenie funkcji zaleÅ¼nych, konstruktorÃ³w rekurencyjnych i
    polimorfizmu pozwala nam na opisywanie (prawie) dowolnych typÃ³w.
    Jednym z najbardziej podstawowych i najbardziej przydatnych
    narzÄ™dzi w programowaniu funkcyjnym (i w ogÃ³le w Å¼yciu) sÄ… listy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyList</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Lista przechowuje wartoÅ›ci pewnego ustalonego typu <span class="inlinecode"><span class="id" title="var">A</span></span> (a wiÄ™c nie
    moÅ¼na np. trzymaÄ‡ w jednej liÅ›cie jednoczeÅ›nie wartoÅ›ci typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i
    <span class="inlinecode"><span class="id" title="var">nat</span></span>) i moÅ¼e mieÄ‡ jednÄ… z dwÃ³ch postaci: moÅ¼e byÄ‡ pusta (konstruktor
    <span class="inlinecode"><span class="id" title="var">nil</span></span>) albo skÅ‚adaÄ‡ siÄ™ z gÅ‚owy i ogona (konstruktor <span class="inlinecode"><span class="id" title="var">cons</span></span>). GÅ‚owa
    listy to wartoÅ›Ä‡ typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaÅ› jej ogon to inna lista przechowujÄ…ca
    wartoÅ›ci typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nil</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nil&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">cons</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;cons&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">nil</span> [<span class="id" title="var">A</span>].<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">cons</span> [<span class="id" title="var">A</span>] <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Jak juÅ¼ wspomnieliÅ›my, jeÅ¼eli typ induktywny ma argument (w naszym
    przypadku <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), to argument ten jest teÅ¼ pierwszym argumentem
    kaÅ¼dego z konstruktorÃ³w. W przypadku konstruktora <span class="inlinecode"><span class="id" title="var">cons</span></span> podawanie
    argumentu <span class="inlinecode"><span class="id" title="var">A</span></span> jest zbÄ™dne, gdyÅ¼ kolejnym jego argumentem jest wartoÅ›Ä‡
    tego typu. Wobec tego Coq moÅ¼e sam go wywnioskowaÄ‡, jeÅ¼eli mu kaÅ¼emy.

<div class="paragraph"> </div>

    Robimy to za pomocÄ… komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span> <span class="inlinecode"><span class="id" title="var">konstruktor</span></span> <span class="inlinecode"><span class="id" title="var">argumenty</span></span>.
    Argumenty w nawiasach kwadratowych Coq bÄ™dzie traktowaÅ‚ jako domyÅ›lne,
    a te oznaczone podkreÅ›lnikiem trzeba bÄ™dzie zawsze podawaÄ‡ rÄ™cznie.
    Nazwa argumentu domyÅ›lnego musi byÄ‡ taka sama jak w definicji typu
    (w naszym przypadku w definicji <span class="inlinecode"><span class="id" title="var">list</span></span> argument nazywaÅ‚ siÄ™ <span class="inlinecode"><span class="id" title="var">A</span></span>,
    wiÄ™c tak teÅ¼ musimy go nazwaÄ‡ uÅ¼ywajÄ…c komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span>). Musimy
    wypisaÄ‡ wszystkie argumenty danego konstruktora â€” ich iloÅ›Ä‡ moÅ¼emy
    sprawdziÄ‡ np. komendÄ… <span class="inlinecode"><span class="id" title="keyword">Check</span></span>.

<div class="paragraph"> </div>

    Warto w tym momencie zauwaÅ¼yÄ‡, Å¼e Coq zna typy wszystkich termÃ³w,
    ktÃ³re zostaÅ‚y skonstruowane â€” gdyby tak nie byÅ‚o, nie mÃ³gÅ‚by
    sam uzupeÅ‚niaÄ‡ argumentÃ³w domyÅ›lnych, a komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> nie mogÅ‚aby
    dziaÅ‚aÄ‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;[]" := <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Infix</span> &quot;::" := (<span class="id" title="var">cons</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span> ).<br/>

<br/>
<span class="id" title="keyword">Check</span> [].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[]</span>&nbsp;:&nbsp;list&nbsp;?254&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> 0 :: 1 :: 2 :: <span class="id" title="var">nil</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[0;</span> <span class="inlinecode">1;</span> <span class="inlinecode">2]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Nazwy <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span> sÄ… zdecydowanie za dÅ‚ugie w porÃ³wnaniu do swej
    czÄ™stoÅ›ci wystÄ™powania. DziÄ™ki powyÅ¼szym eleganckim notacjom
    zaoszczÄ™dzimy sobie trochÄ™ pisania. JeÅ¼eli jednak notacje utrudniajÄ…
    nam np. odczytanie celu, ktÃ³ry mamy udowodniÄ‡, moÅ¼emy je wyÅ‚Ä…czyÄ‡
    odznaczajÄ…c w CoqIDE View &gt; Display Notations.

<div class="paragraph"> </div>

    Wynik <span class="inlinecode">[]</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">?254</span> (lub podobny) wyÅ›wietlony przez Coqa dla <span class="inlinecode">[]</span>
    mÃ³wi nam, Å¼e <span class="inlinecode">[]</span> jest listÄ… pewnego ustalonego typu, ale Coq jeszcze
    nie wie, jakiego (bo ma za maÅ‚o informacji, bo wywnioskowaÄ‡ argument
    domyÅ›lny konstruktora <span class="inlinecode"><span class="id" title="var">nil</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ]" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">nil</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ; y ; .. ; z ]" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cons</span> <span class="id" title="var">x</span> (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> .. (<span class="id" title="var">cons</span> <span class="id" title="var">z</span> <span class="id" title="var">nil</span>) .. )).<br/>

<br/>
<span class="id" title="keyword">Check</span> [5].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[5]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> [0; 1; 2; 3].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[0;</span> <span class="inlinecode">1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
ZauwaÅ¼, Å¼e system notacji Coqa jest bardzo silny â€” ostatnia notacja
    (ta zawierajÄ…ca <span class="inlinecode">..</span>) jest rekurencyjna. W innych jÄ™zykach tego typu
    notacje sÄ… zazwyczaj wbudowane w jÄ™zyk i ograniczajÄ… siÄ™ do podstawowych
    typÃ³w, takich jak listy wÅ‚aÅ›nie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> =&gt; <span class="id" title="var">h</span> :: <span class="id" title="var">app</span> <span class="id" title="var">t</span> <span class="id" title="var">l2</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;l1 ++ l2" := (<span class="id" title="var">app</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
</div>

<div class="doc">
Funkcje na listach moÅ¼emy definiowaÄ‡ analogicznie do funkcji na
    liczbach naturalnych. Zaczniemy od sÅ‚owa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>,
    gdyÅ¼ bÄ™dziemy potrzebowaÄ‡ rekurencji. Pierwszym argumentem naszej
    funkcji bÄ™dzie typ <span class="inlinecode"><span class="id" title="var">A</span></span> â€” musimy go wymieniÄ‡, bo inaczej nie bÄ™dziemy
    mogli mieÄ‡ argumentÃ³w typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> (pamiÄ™taj, Å¼e samo <span class="inlinecode"><span class="id" title="var">list</span></span>
    jest rodzinÄ… typÃ³w, a nie typem). Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span> oznacza,
    Å¼e Coq ma traktowaÄ‡ <span class="inlinecode"><span class="id" title="var">A</span></span> jako argument domyÅ›lny â€” jest to szybszy
    sposÃ³b, niÅ¼ uÅ¼ycie komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span>.

<div class="paragraph"> </div>

    Nasz funkcja ma za zadanie dokleiÄ‡ na koÅ„cu (ang. append) pierwszej
    listy drugÄ… listÄ™. Definicja jest doÅ›Ä‡ intuicyjna: doklejenie jakiejÅ›
    listy na koniec listy pustej daje pierwszÄ… listÄ™, a doklejenie listy
    na koniec listy majÄ…cej gÅ‚owÄ™ i ogon jest doklejeniem jej na koniec
    ogona. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> [1; 2; 3] ++ [4; 5; 6].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Wynik dziaÅ‚ania naszej funkcji wyglÄ…da poprawnie, ale niech ciÄ™
    nie zwiodÄ… Å‚adne oczka â€” jedynym sposobem ustalenia poprawnoÅ›ci
    naszego kodu jest udowodnienie, Å¼e posiada on poÅ¼Ä…dane przez
    nas wÅ‚aÅ›ciwoÅ›ci. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), [] ++ <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">l</span> ++ [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHt</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Sposoby dowodzenia sÄ… analogiczne jak w przypadku liczb naturalnych.
    Pierwsze twierdzenie zachodzi na mocy samej definicji funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>
    i dowÃ³d sprowadza siÄ™ do wykonania programu za pomocÄ… taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span>.
    Drugie jest analogiczne do twierdzenia <span class="inlinecode"><span class="id" title="var">plus_n_0</span></span>, z tÄ… rÃ³Å¼nicÄ…, Å¼e
    w drugim celu zamiast <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> posÅ‚uÅ¼yliÅ›my siÄ™ taktykÄ… <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    ZauwaÅ¼ teÅ¼, Å¼e zmianie ulegÅ‚a postaÄ‡ wzorca przekazanego taktyce
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> â€” teraz ma on postaÄ‡ <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>]</span>, gdyÅ¼ <span class="inlinecode"><span class="id" title="var">list</span></span> ma 2
    konstruktory, z ktÃ³rych pierwszy, <span class="inlinecode"><span class="id" title="var">nil</span></span>, nie bierze argumentÃ³w
    (argumenty domyÅ›lne nie sÄ… wymieniane we wzorcach), zaÅ› drugi, <span class="inlinecode"><span class="id" title="var">cons</span></span>,
    ma dwa argumenty â€” gÅ‚owÄ™, tutaj nazwanÄ… <span class="inlinecode"><span class="id" title="var">h</span></span> (jako skrÃ³t od ang. head)
    oraz ogon, tutaj nazwany <span class="inlinecode"><span class="id" title="var">t</span></span> (jako skrÃ³t od ang. tail). 
<div class="paragraph"> </div>

<a name="lab101"></a><h4 class="section">Ä†wiczenie (wÅ‚aÅ›ciwoÅ›ci funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij poniÅ¼sze wÅ‚aÅ›ciwoÅ›ci funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>. WskazÃ³wka: moÅ¼e ci siÄ™
    przydaÄ‡ taktyka <span class="inlinecode"><span class="id" title="tactic">specialize</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ <span class="id" title="var">l3</span>) = (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_not_comm</span> :<br/>
&nbsp;&nbsp;~ <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span> = <span class="id" title="var">l2</span> ++ <span class="id" title="var">l1</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab102"></a><h4 class="section">Ä†wiczenie (<span class="inlinecode"><span class="id" title="var">length</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcjÄ™ <span class="inlinecode"><span class="id" title="var">length</span></span>, ktÃ³ra oblicza dÅ‚ugoÅ›Ä‡ listy, a nastÄ™pnie
    udowodnij poprawnoÅ›Ä‡ swojej implementacji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_nil</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">length</span> (@<span class="id" title="var">nil</span> <span class="id" title="var">A</span>) = 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_cons</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">length</span> (<span class="id" title="var">h</span> :: <span class="id" title="var">t</span>) &lt;&gt; 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_app</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l1</span> + <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyList</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab103"></a><h2 class="section">Przydatne komendy</h2>

<div class="paragraph"> </div>

 Czas, aby opisaÄ‡ kilka przydatnych komend. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;unit&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, Å¼e komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> wyÅ›wietla typ danego jej termu,
    a <span class="inlinecode"><span class="id" title="keyword">Print</span></span> wypisuje jego definicjÄ™. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Search</span></span> wyÅ›wietla wszystkie obiekty, ktÃ³re zawierajÄ… podanÄ… nazwÄ™.
    W naszym przypadku pokazaÅ‚y siÄ™ wszystkie funkcje, w ktÃ³rych
    sygnaturze wystÄ™puje typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">SearchAbout</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> wyÅ›wietla wszystkie obiekty, ktÃ³re majÄ… jakiÅ› zwiÄ…zek
    z danÄ… nazwÄ…. Zazwyczaj wskaÅ¼e on nam duÅ¼o wiÄ™cej obiektÃ³w, niÅ¼ zwykÅ‚e
    <span class="inlinecode"><span class="id" title="keyword">Search</span></span>, np. poza funkcjami, w ktÃ³rych sygnaturze wystÄ™puje <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    pokazuje teÅ¼ twierdzenia dotyczÄ…ce ich wÅ‚aÅ›ciwoÅ›ci. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span><span class="id" title="var">Pattern</span> (<span class="id" title="var">_</span> + <span class="id" title="var">_</span> = <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchPattern</span></span> jako argument bierze wzorzec i wyÅ›wietla wszystkie
    obiekty, ktÃ³re zawierajÄ… podterm pasujÄ…cy do danego wzorca. W naszym
    przypadku pokazaÅ‚y siÄ™ twierdzenia, w ktÃ³rych wystÄ™puje podterm
    majÄ…cy po lewej dodawanie, a po prawej cokolwiek.

<div class="paragraph"> </div>

    DokÅ‚adny opis wszystkich komend znajdziesz tutaj:
    https://coq.inria.fr/refman/coq-cmdindex.html 
<div class="paragraph"> </div>

<a name="lab104"></a><h2 class="section">WaÅ¼ne typy induktywne</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab105"></a><h3 class="section">Typ pusty</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty_set</span> : <span class="id" title="keyword">Set</span> := .<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Empty_set</span></span> jest, jak sama nazwa wskazuje, typem pustym. Å»aden term
    nie jest tego typu. Innymi sÅ‚owy: jeÅ¼eli jakiÅ› term jest typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    to mamy sprzecznoÅ›Ä‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">create</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
JeÅ¼eli mamy term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, to moÅ¼emy w sposÃ³b niemal magiczny
    wyczarowaÄ‡ term dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span>, uÅ¼ywajÄ…c dopasowania do wzorca z
    pustym wzorcem. 
<div class="paragraph"> </div>

<a name="lab106"></a><h4 class="section">Ä†wiczenie (<span class="inlinecode"><span class="id" title="var">create_unique</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij, Å¼e powyÅ¼sza funkcja jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">create_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">Empty_set</span> -&gt; <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>, <span class="id" title="var">create</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab107"></a><h4 class="section">Ä†wiczenie (<span class="inlinecode"><span class="id" title="var">no_fun_from_nonempty_to_empty</span></span>)</h4>

<div class="paragraph"> </div>

 PokaÅ¼, Å¼e nie istniejÄ… funkcje z typu niepustego w pusty. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">no_fun_from_nonempty_to_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>), <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab108"></a><h3 class="section">Singleton</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">unit</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tt</span> : <span class="id" title="var">unit</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">unit</span></span> jest typem, ktÃ³ry ma tylko jeden term, zwany <span class="inlinecode"><span class="id" title="var">tt</span></span> (nazwa ta
    jest wziÄ™ta z sufitu). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">delete</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">unit</span> := <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest w pewien sposÃ³b "dualna" do napotkanej przez
    nas wczeÅ›niej funkcji <span class="inlinecode"><span class="id" title="var">create</span></span>. MajÄ…c term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span> mogliÅ›my
    stworzyÄ‡ term dowolnego innego typu, zaÅ› majÄ…c term dowolnego typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>, moÅ¼emy "zapomnieÄ‡ o nim" albo "skasowaÄ‡ go", wysyÅ‚ajÄ…c go
    funkcjÄ… <span class="inlinecode"><span class="id" title="var">delete</span></span> w jedyny term typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, czyli <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

    Uwaga: okreÅ›lenie "skasowaÄ‡" nie ma nic wspÃ³lnego z fizycznym
    niszczeniem albo dealokacjÄ… pamiÄ™ci. Jest to tylko metafora. 
<div class="paragraph"> </div>

<a name="lab109"></a><h4 class="section">Ä†wiczenie (<span class="inlinecode"><span class="id" title="var">delete_unique</span></span>)</h4>
 PokaÅ¼, Å¼e funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">delete_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">unit</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">delete</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab110"></a><h3 class="section">Produkt</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">prod</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">pair</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">pair</span> [<span class="id" title="var">A</span>] [<span class="id" title="var">B</span>] <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Produkt typÃ³w <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, ktÃ³rego termami sÄ… pary. Pierwszy
    element pary to term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugi to term typu <span class="inlinecode"><span class="id" title="var">B</span></span>. Tym, co
    charakteryzuje produkt, sÄ… projekcje:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">fst</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wyciÄ…ga z pary jej
      pierwszy element

</li>
<li> <span class="inlinecode"><span class="id" title="var">snd</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wyciÄ…ga z pary jej
      drugi element 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab111"></a><h4 class="section">Ä†wiczenie (projekcje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj projekcje i udowodnij poprawnoÅ›Ä‡ swoich definicji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">proj_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> = <span class="id" title="var">pair</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab112"></a><h3 class="section">Suma</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sum</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inl</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inr</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">inl</span> [<span class="id" title="var">A</span>] [<span class="id" title="var">B</span>] <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">inr</span> [<span class="id" title="var">A</span>] [<span class="id" title="var">B</span>] <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Suma <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, ktÃ³rego termy sÄ… albo termami typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    zawiniÄ™tymi w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span>, albo termami typu <span class="inlinecode"><span class="id" title="var">B</span></span>, zawiniÄ™tymi
    w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Suma, w przeciwieÅ„stwie do produktu, zdecydowanie
    nie ma projekcji. 
<div class="paragraph"> </div>

<a name="lab113"></a><h4 class="section">Ä†wiczenie (sumy bez projekcji)</h4>

<div class="paragraph"> </div>

 PokaÅ¼, Å¼e suma nie ma projekcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">sum_no_fst</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">sum_no_snd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab114"></a><h2 class="section">Kiedy typ induktywny jest pusty?</h2>

<div class="paragraph"> </div>

 Typy puste to typy, ktÃ³re nie majÄ… Å¼adnych elementÃ³w. Z jednym z nich
    juÅ¼ siÄ™ spotkaliÅ›my â€” byÅ‚ to <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, ktÃ³ry jest pusty, gdyÅ¼ nie
    ma Å¼adnych konstruktorÃ³w. Czy wszystkie typy puste to typy, ktÃ³re
    nie majÄ… konstruktorÃ³w? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c</span> : <span class="id" title="var">Empty_set</span> -&gt; <span class="id" title="var">Empty</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Empty_is_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">empty</span> : <span class="id" title="var">Empty</span>, <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">empty</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Okazuje siÄ™, Å¼e nie. PustoÅ›Ä‡ i niepustoÅ›Ä‡ jest kwestiÄ… czegoÅ› wiÄ™cej,
    niÅ¼ tylko iloÅ›ci konstruktorÃ³w. PowyÅ¼szy przykÅ‚ad pokazuje dobitnie,
    Å¼e waÅ¼ne sÄ… teÅ¼ typy argumentÃ³w konstruktorÃ³w. JeÅ¼eli typ ktÃ³regoÅ› z
    argumentÃ³w konstruktora jest pusty, to nie moÅ¼na uÅ¼yÄ‡ go do zrobienia
    Å¼adnego termu. JeÅ¼eli kaÅ¼dy konstruktor typu <span class="inlinecode"><span class="id" title="var">T</span></span> ma argument, ktÃ³rego
    typ jest pusty, to sam typ <span class="inlinecode"><span class="id" title="var">T</span></span> rÃ³wnieÅ¼ jest pusty.

<div class="paragraph"> </div>

    Wobec powyÅ¼szych rozwaÅ¼aÅ„ moÅ¼emy sformuÅ‚owaÄ‡ nastÄ™pujÄ…ce kryterium:
    typ <span class="inlinecode"><span class="id" title="var">T</span></span> jest niepusty, jeÅ¼eli ma co najmniej jeden konstruktor, ktÃ³ry
    nie bierze argumentÃ³w, ktÃ³rych typy sÄ… puste. Jakkolwiek jest to bardzo
    dobre kryterium, to jednak nie rozwiewa ono niestety wszystkich moÅ¼liwych
    wÄ…tpliwoÅ›ci. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">InfiniteList</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">InfiniteCons</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">InfiniteList</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">InfiniteList</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Czy typ <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest niepusty? Skorzystajmy z naszego kryterium:
    ma on jeden konstruktor biorÄ…cy dwa argumenty, jeden typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz drugi
    typu <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. W zaleÅ¼noÅ›ci od tego, czym jest <span class="inlinecode"><span class="id" title="var">A</span></span>, moÅ¼e on byÄ‡
    pusty lub nie â€” przyjmijmy, Å¼e <span class="inlinecode"><span class="id" title="var">A</span></span> jest niepusty. W przypadku drugiego
    argumentu napotykamy jednak na problem: to, czy <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest
    niepusty zaleÅ¼y od tego, czy typ argumentu jego konstruktora, rÃ³wnieÅ¼
    <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, jest niepusty. Sytuacja jest wiÄ™c beznadziejna â€” mamy
    bÅ‚Ä™dne koÅ‚o.

<div class="paragraph"> </div>

    PowyÅ¼szy przykÅ‚ad pokazuje, Å¼e nasze kryterium moÅ¼e nie poradziÄ‡ sobie
    z rekurencjÄ…. Jak zatem rozstrzygnÄ…Ä‡, czy typ ten jest niepusty? Musimy
    odwoÅ‚aÄ‡ siÄ™ bezpoÅ›rednio do definicji i zastanowiÄ‡ siÄ™, czy moÅ¼liwe jest
    skonstruowanie jakichÅ› jego termÃ³w. W tym celu przypomnijmy, czym sÄ… typy
    induktywne:
<ul class="doclist">
<li> Typ induktywny to rodzaj planu, ktÃ³ry pokazuje, w jaki sposÃ³b moÅ¼na
      konstruowaÄ‡ jego termy, ktÃ³re sÄ… drzewami.

</li>
<li> Konstruktory to wÄ™zÅ‚y drzewa. Ich nazwy oraz iloÅ›Ä‡ i typy argumentÃ³w
      nadajÄ… drzewu ksztaÅ‚t i znaczenie.

</li>
<li> Konstruktory nierekurencyjne to liÅ›cie drzewa.

</li>
<li> Konstruktory rekurencyjne to wÄ™zÅ‚y wewnÄ™trzne drzewa. 
</li>
</ul>

<div class="paragraph"> </div>

 Kluczowym faktem jest rozmiar termÃ³w: o ile rozgaÅ‚Ä™zienia mogÄ… byÄ‡
    potencjalnie nieskoÅ„czone, o tyle wszystkie gaÅ‚Ä™zie muszÄ… mieÄ‡
    skoÅ„czonÄ… dÅ‚ugoÅ›Ä‡. PociÄ…ga to za sobÄ… bardzo istotny fakt: typy
    majÄ…ce jedynie konstruktory rekurencyjne sÄ… puste, gdyÅ¼ bez uÅ¼ycia
    konstruktorÃ³w nierekurencyjnych moÅ¼emy konstruowaÄ‡ jedynie drzewa
    nieskoÅ„czone (i to tylko przy nierealnym zaÅ‚oÅ¼eniu, Å¼e moÅ¼liwe jest
    zakoÅ„czenie konstrukcji liczÄ…cej sobie nieskoÅ„czonoÅ›Ä‡ krokÃ³w). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">InfiniteList_is_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">InfiniteList</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span> <span class="id" title="var">t</span>]. <span class="id" title="tactic">exact</span> <span class="id" title="var">IHt</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pokazanie, Å¼e <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, jest bardzo proste â€”
    wystarczy posÅ‚uÅ¼yÄ‡ siÄ™ indukcjÄ…. Indukcja po <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    daje nam hipotezÄ™ indukcyjnÄ… <span class="inlinecode"><span class="id" title="var">IHt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, ktÃ³rej moÅ¼emy uÅ¼yÄ‡,
    aby natychmiast zakoÅ„czyÄ‡ dowÃ³d.

<div class="paragraph"> </div>

    Zaraz, co wÅ‚aÅ›ciwie siÄ™ staÅ‚o? Dlaczego dostaliÅ›my zupeÅ‚nie za darmo
    hipotezÄ™ <span class="inlinecode"><span class="id" title="var">IHt</span></span>, ktÃ³ra jest szukanym przez nas dowodem? W ten wÅ‚aÅ›nie
    sposÃ³b przeprowadza siÄ™ dowody indukcyjne: zakÅ‚adamy, Å¼e hipoteza <span class="inlinecode"><span class="id" title="var">P</span></span>
    zachodzi dla termu <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a nastÄ™pnie musimy pokazaÄ‡,
    Å¼e <span class="inlinecode"><span class="id" title="var">P</span></span> zachodzi takÅ¼e dla termu <span class="inlinecode"><span class="id" title="var">InfiniteCons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. Zazwyczaj <span class="inlinecode"><span class="id" title="var">P</span></span> jest
    predykatem i wykonanie kroku indukcyjnego jest nietrywialne, w naszym
    przypadku jest jednak inaczej â€” postaÄ‡ <span class="inlinecode"><span class="id" title="var">P</span></span> jest taka sama dla <span class="inlinecode"><span class="id" title="var">t</span></span> oraz
    dla <span class="inlinecode"><span class="id" title="var">InfiniteCons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> i jest niÄ… <span class="inlinecode"><span class="id" title="var">False</span></span>.

<div class="paragraph"> </div>

    Czy ten konfundujÄ…cy fakt nie oznacza jednak, Å¼e <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, czyli typ
    zwykÅ‚ych list, rÃ³wnieÅ¼ jest pusty? SprÃ³bujmy pokazaÄ‡, Å¼e tak jest. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">list_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Focus</span> 2. <span class="id" title="tactic">exact</span> <span class="id" title="var">IHt</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pokazanie, Å¼e typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, jest rzecz jasna niemoÅ¼liwe,
    gdyÅ¼ typ ten zdecydowanie pusty nie jest â€” w jego definicji stoi
    jak byk napisane, Å¼e dla dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span> istnieje lista termÃ³w
    typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Jest niÄ… oczywiÅ›cie <span class="inlinecode">@<span class="id" title="var">nil</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Przyjrzyjmy siÄ™ naszej prÃ³bie dowodu. PrÃ³bujemy posÅ‚uÅ¼yÄ‡ siÄ™ indukcjÄ…
    w ten sam sposÃ³b co poprzednio. Taktyka <span class="inlinecode"><span class="id" title="tactic">induction</span></span> generuje nam dwa
    podcele, gdyÅ¼ <span class="inlinecode"><span class="id" title="var">list</span></span> ma dwa konstruktory â€” pierwszy podcel dla <span class="inlinecode"><span class="id" title="var">nil</span></span>,
    a drugi dla <span class="inlinecode"><span class="id" title="var">cons</span></span>. Komenda <span class="inlinecode"><span class="id" title="var">Focus</span></span> pozwala nam przeÅ‚Ä…czyÄ‡ siÄ™ do
    wybranego celu, w tym przypadku celu nr 2, czyli gdy <span class="inlinecode"><span class="id" title="var">l</span></span> jest postaci
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    Sprawa wyglÄ…da identycznie jak poprzednio â€” za darmo dostajemy hipotezÄ™
    <span class="inlinecode"><span class="id" title="var">IHt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, ktÃ³rej uÅ¼ywamy do natychmiastowego rozwiÄ…zania naszego
    celu. Tym, co stanowi przeszkodÄ™ nie do pokonania, jest cel nr 1, czyli
    gdy <span class="inlinecode"><span class="id" title="var">l</span></span> zrobiono za pomocÄ… konstruktora <span class="inlinecode"><span class="id" title="var">nil</span></span>. Ten konstruktor nie jest
    rekurencyjny, wiÄ™c nie dostajemy Å¼adnej hipotezy indukcyjnej. Lista <span class="inlinecode"><span class="id" title="var">l</span></span>
    zostaje w kaÅ¼dym miejscu, w ktÃ³rym wystÄ™puje, zastÄ…piona przez <span class="inlinecode">[]</span>, a
    poniewaÅ¼ nie wystÄ™puje nigdzie â€” znika. Musimy teraz udowodniÄ‡ faÅ‚sz
    wiedzÄ…c jedynie, Å¼e <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem, co jest niemoÅ¼liwe. 
<div class="paragraph"> </div>

<a name="lab115"></a><h1 class="section">Induktywne zdania i predykaty</h1>

<div class="paragraph"> </div>

 Wiemy, Å¼e sÅ‚owo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pozwala nam definiowaÄ‡ nowe typy
    (a nawet rodziny typÃ³w, jak w przypadku <span class="inlinecode"><span class="id" title="var">option</span></span>). Wiemy teÅ¼, Å¼e zdania
    sÄ… typami. Wobec tego nie powinno nas dziwiÄ‡, Å¼e induktywnie moÅ¼emy
    definiowaÄ‡ takÅ¼e zdania, spÃ³jniki logiczne, predykaty oraz relacje. 
<div class="paragraph"> </div>

<a name="lab116"></a><h2 class="section">Induktywne zdania</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">false_prop</span> : <span class="id" title="keyword">Prop</span> := .<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">true_prop</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">obvious_proof</span> : <span class="id" title="var">true_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tricky_proof</span> : <span class="id" title="var">true_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">weird_proof</span> : <span class="id" title="var">true_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">magical_proof</span> : <span class="id" title="var">true_prop</span>.<br/>

<br/>
</div>

<div class="doc">
Induktywne definicje zdaÅ„ nie sÄ… zbyt ciekawe, gdyÅ¼ pozwalajÄ… definiowaÄ‡
    jedynie zdania faÅ‚szywe (zero konstruktorÃ³w) lub prawdziwe (jeden lub
    wiÄ™cej konstruktorÃ³w). Pierwsze z naszych zdaÅ„ jest faÅ‚szywe (a wiÄ™c
    rÃ³nowaÅ¼ne z <span class="inlinecode"><span class="id" title="var">False</span></span>), drugie zaÅ› jest prawdziwe (czyli rÃ³wnowaÅ¼ne z <span class="inlinecode"><span class="id" title="var">True</span></span>)
    i to na cztery sposoby! 
<div class="paragraph"> </div>

<a name="lab117"></a><h4 class="section">Ä†wiczenie (induktywne zdania)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">false_prop_iff_False</span> : <span class="id" title="var">false_prop</span> &lt;-&gt; <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">true_prop_iff_True</span> : <span class="id" title="var">true_prop</span> &lt;-&gt; <span class="id" title="var">True</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab118"></a><h2 class="section">Induktywne predykaty</h2>

<div class="paragraph"> </div>

 Przypomnijmy, Å¼e predykaty to funkcje, ktÃ³rych przeciwdziedzinÄ… jest
    sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, czyli funkcje zwracajÄ…ce zdania logiczne. Predykat
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> moÅ¼na rozumieÄ‡ jako wÅ‚aÅ›ciwoÅ›Ä‡, ktÃ³rÄ… mogÄ… posiadaÄ‡
    termy typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaÅ› dla konkretnego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> zapis <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> interpretowaÄ‡
    moÅ¼na "term <span class="inlinecode"><span class="id" title="var">x</span></span> posiada wÅ‚aÅ›ciwÃ³Å›Ä‡ <span class="inlinecode"><span class="id" title="var">P</span></span>".

<div class="paragraph"> </div>

    O ile istniejÄ… tylko dwa rodzaje induktwynych zdaÅ„ (prawdziwe i faÅ‚szywe),
    o tyle induktywnie zdefiniowane predykaty sÄ… duÅ¼o bardziej ciekawe i
    uÅ¼yteczne, gdyÅ¼ dla jednych termÃ³w mogÄ… byÄ‡ prawdziwe, a dla innych nie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenSS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
Predykat <span class="inlinecode"><span class="id" title="var">even</span></span> ma oznaczaÄ‡ wÅ‚aÅ›ciwoÅ›Ä‡ "bycia liczbÄ… parzystÄ…". Jego
    definicjÄ™ moÅ¼na zinterpretowaÄ‡ tak:
<ul class="doclist">
<li> "<span class="inlinecode">0</span> jest liczbÄ… przystÄ…"

</li>
<li> "jeÅ¼eli <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbÄ… parzystÄ…, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> rÃ³wnieÅ¼ jest
       liczbÄ… parzystÄ…" 
</li>
</ul>

<div class="paragraph"> </div>

 Jak widaÄ‡, induktywna definicja parzystoÅ›ci rÃ³Å¼ni siÄ™ od powszechnie
    uÅ¼ywanej definicji, ktÃ³ra gÅ‚osi, Å¼e "liczba jest parzysta, gdy
    dzieli siÄ™ bez reszty przez 2". RÃ³Å¼nica jest natury filozoficznej:
    definicja induktywna mÃ³wi, jak konstruowaÄ‡ liczby parzyste, podczas
    gdy druga, "klasyczna" definicja mÃ³wi, jak sprawdziÄ‡, czy liczba
    jest parzysta.

<div class="paragraph"> </div>

    Przez wzglÄ…d na swÄ… konstruktywnoÅ›Ä‡, w Coqu induktywne definicje
    predykatÃ³w czy relacji sÄ… czÄ™sto duÅ¼o bardziej uÅ¼yteczne od tych
    nieinduktywnych, choÄ‡ nie wszystko moÅ¼na zdefiniowaÄ‡ induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_is_even</span> : <span class="id" title="var">even</span> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">even0</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak moÅ¼emy udowodniÄ‡, Å¼e <span class="inlinecode">0</span> jest liczbÄ… parzystÄ…? PosÅ‚uÅ¼y nam
    do tego konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>, ktÃ³ry wprost gÅ‚osi, Å¼e <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>.
    Nie daj siÄ™ zwieÅ›Ä‡: <span class="inlinecode"><span class="id" title="var">even0</span></span>, pisane bez spacji, jest nazwÄ…
    konstruktora, podczas gdy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>, ze spacjÄ…, jest zdaniem
    (czyli termem typu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), ktÃ³re moÅ¼na interpretowaÄ‡ jako
    "<span class="inlinecode">0</span> jest liczbÄ… parzystÄ…". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">two_is_even</span> : <span class="id" title="var">even</span> 2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">evenSS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even0</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak moÅ¼emy udowodniÄ‡, Å¼e <span class="inlinecode">2</span> jest parzyste? Konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>
    nam nie pomoÅ¼e, gdyÅ¼ jego postaÄ‡ (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>) nie pasuje do postaci
    naszego twierdzenia (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">2</span>). Pozostaje nam jednak konstruktor
    <span class="inlinecode"><span class="id" title="var">evenSS</span></span>.

<div class="paragraph"> </div>

    JeÅ¼eli przypomnimy sobie, Å¼e <span class="inlinecode">2</span> to tak naprawdÄ™ <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>,
    natychmiast dostrzeÅ¼emy, Å¼e jego konkluzja pasuje do postaci naszego
    twierdzenia. MoÅ¼emy go wiÄ™c zaaplikowaÄ‡ (pamiÄ™taj, Å¼e konstruktory sÄ…
    jak zwykÅ‚e funkcje, tylko Å¼e niczego nie obliczajÄ… â€” nadajÄ… one typom
    ich ksztaÅ‚ty). Teraz wystarczy pokazaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span> zachodzi, co juÅ¼
    potrafimy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">four_is_even</span> : <span class="id" title="var">even</span> 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak pokazaÄ‡, Å¼e <span class="inlinecode">4</span> jest parzyste? TÄ… samÄ… metodÄ…, ktÃ³ra pokazaliÅ›my,
    Å¼e <span class="inlinecode">2</span> jest parzyste. <span class="inlinecode">4</span> to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span>, wiÄ™c moÅ¼emy uÅ¼yÄ‡
    konstruktora <span class="inlinecode"><span class="id" title="var">evenSS</span></span>. Zamiast jednak pisaÄ‡ <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, moÅ¼emy
    uÅ¼yÄ‡ taktyki <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>. Taktyka ta dziaÅ‚a na celach, w ktÃ³rych
    chcemy skonstruowaÄ‡ wartoÅ›Ä‡ jakiegoÅ› typu induktywnego (a wiÄ™c takÅ¼e
    gdy dowodzimy twierdzeÅ„ o induktywnych predykatach). Szuka ona
    konstruktora, ktÃ³ry moÅ¼e zaaplikowaÄ‡ na celu, i jeÅ¼eli znajdzie, to
    aplikuje go, a gdy nie â€” zawodzi.

<div class="paragraph"> </div>

    W naszym przypadku pierwsze dwa uÅ¼ycia <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> aplikujÄ…
    konstruktor <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, a trzecie â€” konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">the_answer_is_even</span> : <span class="id" title="var">even</span> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A co, gdy chcemy pokazaÄ‡, Å¼e <span class="inlinecode">42</span> jest parzyste? Czy musimy 22 razy
    napisaÄ‡ <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>? Na szczÄ™Å›cie nie â€” wystarczy posÅ‚uÅ¼yÄ‡ siÄ™
    kombinatorem <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> (jeÅ¼eli nie pamiÄ™tasz, jak dziaÅ‚a, zajrzyj do
    rozdziaÅ‚u 1). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">one_not_even_failed</span> : ~ <span class="id" title="var">even</span> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">one_not_even</span> : ~ <span class="id" title="var">even</span> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A jak pokazaÄ‡, Å¼e <span class="inlinecode">1</span> nie jest parzyste? MajÄ…c w kontekÅ›cie dowÃ³d
    na to, Å¼e <span class="inlinecode">1</span> jest parzyste (<span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span>), moÅ¼emy zastantowiÄ‡ siÄ™,
    w jaki sposÃ³b dowÃ³d ten zostaÅ‚ zrobiony. Nie mÃ³gÅ‚ zostaÄ‡ zrobiony
    konstruktorem <span class="inlinecode"><span class="id" title="var">even0</span></span>, gdyÅ¼ ten dowodzi, Å¼e <span class="inlinecode">0</span> jest parzyste, a
    przecieÅ¼ przekonaliÅ›my siÄ™ juÅ¼, Å¼e <span class="inlinecode">0</span> to nie <span class="inlinecode">1</span>. Nie mÃ³gÅ‚ teÅ¼
    zostaÄ‡ zrobiony konstruktorem <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyÅ¼ ten ma w konkluzji
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>, podczas gdy <span class="inlinecode">1</span> jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> â€” nie pasuje
    on do konkluzji <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyÅ¼ "ma za maÅ‚o <span class="inlinecode"><span class="id" title="var">S</span></span>Ã³w".

<div class="paragraph"> </div>

    Nasze rozumowanie prowadzi do wniosku, Å¼e za pomocÄ… <span class="inlinecode"><span class="id" title="var">even0</span></span> i <span class="inlinecode"><span class="id" title="var">evenSS</span></span>,
    ktÃ³re sÄ… jedynymi konstruktorami <span class="inlinecode"><span class="id" title="var">even</span></span>, nie moÅ¼na skonstruowaÄ‡ <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span>,
    wiÄ™c <span class="inlinecode">1</span> nie moÅ¼e byÄ‡ parzyste. Na podstawie wczeÅ›niejszych doÅ›wiadczeÅ„
    mogÅ‚oby siÄ™ nam wydawaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> zaÅ‚atwi sprawÄ™, jednak tak nie
    jest â€” taktyka ta jest w tym przypadku upoÅ›ledzona i nie potrafi nam
    pomÃ³c. Zamiast tego moÅ¼emy siÄ™ posÅ‚uÅ¼yÄ‡ taktykÄ… <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>. DziaÅ‚a ona
    dokÅ‚adnie w sposÃ³b opisany w poprzednim akapicie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">three_not_even</span> : ~ <span class="id" title="var">even</span> 3.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak pokazaÄ‡, Å¼e <span class="inlinecode">3</span> nie jest parzyste? PomoÅ¼e nam w tym, jak poprzednio,
    inwersja. Tym razem jednak nie zaÅ‚atwia ona sprawy od razu. JeÅ¼eli
    zastanowimy siÄ™, jak moÅ¼na pokazaÄ‡ <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">3</span>, to dojdziemy do wniosku,
    Å¼e moÅ¼na to zrobiÄ‡ konstruktorem <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyÅ¼ <span class="inlinecode">3</span> to tak naprawdÄ™
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">1)</span>. To wÅ‚aÅ›nie robi pierwsza inwersja: mÃ³wi nam, Å¼e <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">3</span>
    moÅ¼na uzyskaÄ‡ z zaaplikowania <span class="inlinecode"><span class="id" title="var">evenSS</span></span> do <span class="inlinecode">1</span>, jeÅ¼eli tylko mamy dowÃ³d
    <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span> na to, Å¼e <span class="inlinecode">1</span> jest parzyste. Jak pokazaÄ‡, Å¼e <span class="inlinecode">1</span> nie
    jest parzyste, juÅ¼ wiemy. 
<div class="paragraph"> </div>

<a name="lab119"></a><h4 class="section">Ä†wiczenie (odd)</h4>

<div class="paragraph"> </div>

 Zdefiniuj induktywny predykat <span class="inlinecode"><span class="id" title="var">odd</span></span>, ktÃ³ry ma oznaczaÄ‡ "bycie liczbÄ…
    nieparzystÄ…" i udowodnij, Å¼e zachowuje siÄ™ on jak naleÅ¼y. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">one_odd</span> : <span class="id" title="var">odd</span> 1.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">seven_odd</span> : <span class="id" title="var">odd</span> 7.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_not_odd</span> : ~ <span class="id" title="var">odd</span> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">two_not_odd</span> : ~ <span class="id" title="var">odd</span> 2.<br/>

<br/>
</div>

<div class="doc">
<a name="lab120"></a><h2 class="section">Indukcja po dowodzie</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
</div>

<div class="doc">
Biblioteka <span class="inlinecode"><span class="id" title="var">Arith</span></span> zawiera rÃ³Å¼ne definicje i twierdzenia dotyczÄ…ce
    arytmetyki. BÄ™dzie nam ona potrzebna w tym podrozdziale.

<div class="paragraph"> </div>

    Jak udowodniÄ‡, Å¼e suma liczb parzystych jest parzysta? ByÄ‡ moÅ¼e
    wÅ‚aÅ›nie pomyÅ›laÅ‚eÅ› o indukcji. SprÃ³bujmy zatem: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_sum_failed1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
PrÃ³bujÄ…c jednak indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a potem po <span class="inlinecode"><span class="id" title="var">m</span></span>, docieramy do martwego
    punktu. Musimy udowodniÄ‡ <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, podczas gdy zachodzi <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>
    (czyli <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest faÅ‚szywe). Wynika to z faktu, Å¼e przy indukcji
    <span class="inlinecode"><span class="id" title="var">n</span></span> zwiÄ™ksza siÄ™ o 1 (<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>), podczas gdy w definicji
    <span class="inlinecode"><span class="id" title="var">even</span></span> mamy konstruktor gÅ‚oszÄ…cy, Å¼e (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>).

<div class="paragraph"> </div>

    ByÄ‡ moÅ¼e w drugiej kolejnoÅ›ci pomyÅ›laÅ‚eÅ› o taktyce <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>: jeÅ¼eli
    sprawdzimy, w jaki sposÃ³b udowodniono <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, to przy okazji dowiemy
    siÄ™ teÅ¼, Å¼e <span class="inlinecode"><span class="id" title="var">n</span></span> moÅ¼e byÄ‡ jedynie postaci <span class="inlinecode">0</span> lub <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>. DziÄ™ki
    temu powinniÅ›my uniknÄ…Ä‡ problemu z poprzedniej prÃ³by. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_sum_failed2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hn</span>, <span class="id" title="var">Hm</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety, taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> okazaÅ‚a siÄ™ za sÅ‚aba. Predykat <span class="inlinecode"><span class="id" title="var">even</span></span> jest
    induktywny, a zatem bez indukcji siÄ™ nie obÄ™dzie. RozwiÄ…zaniem naszych
    problemÃ³w nie bÄ™dzie jednak indukcja po <span class="inlinecode"><span class="id" title="var">n</span></span> lub <span class="inlinecode"><span class="id" title="var">m</span></span>, lecz po dowodzie na
    to, Å¼e <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_sum</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">Hn</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">Hn'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja po dowodzie dziaÅ‚a dokÅ‚adnie tak samo, jak indukcja, z ktÃ³rÄ…
    zetknÄ™liÅ›my siÄ™ dotychczas. RÃ³Å¼ni siÄ™ od niej jedynie tym, Å¼e aÅ¼ do
    teraz robiliÅ›my indukcjÄ™ jedynie po termach, ktÃ³rych typy byÅ‚y sortu
    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Indukcja po dowodzie to indukcja po termie, ktÃ³rego
    typ jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku uÅ¼ycie <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">Hn</span></span> ma nastÄ™pujÄ…cy skutek:
<ul class="doclist">
<li> W pierwszym przypadku <span class="inlinecode"><span class="id" title="var">Hn</span></span> to po prostu konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>, a 
      zatem <span class="inlinecode"><span class="id" title="var">n</span></span> jest zerem.

</li>
<li> W drugim przypadku <span class="inlinecode"><span class="id" title="var">Hn</span></span> to <span class="inlinecode"><span class="id" title="var">evenSS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">Hn'</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> jest postaci
      <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, zaÅ› <span class="inlinecode"><span class="id" title="var">Hn'</span></span> jest dowodem na to, Å¼e <span class="inlinecode"><span class="id" title="var">n'</span></span> jest parzyste. 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab121"></a><h3 class="section">Taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span> i <span class="inlinecode"><span class="id" title="tactic">assert</span></span>.</h3>

<div class="paragraph"> </div>

 Przy nastÄ™pnych Ä‡wiczeniach mogÄ… przydaÄ‡ ci siÄ™ taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">assert</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">stupid_example_replace</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">replace</span> (<span class="id" title="var">n</span> + 0) <span class="id" title="keyword">with</span> (0 + <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">plus_comm</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> pozwala nam zastÄ…piÄ‡ w celu kaÅ¼de
    wystÄ…pienie termu <span class="inlinecode"><span class="id" title="var">t</span></span> termem <span class="inlinecode"><span class="id" title="var">t'</span></span>. JeÅ¼eli <span class="inlinecode"><span class="id" title="var">t</span></span> nie ma w celu, to
    taktyka zawodzi, a w przeciwnym wypadku dodaje nam jeden podcel,
    w ktÃ³rym musimy udowodniÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t'</span></span>. MoÅ¼na teÅ¼ zastosowaÄ‡ jÄ…
    w hipotezie, piszÄ…c <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">stupid_example_assert</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + 0 + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">plus_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> dodaje do kontekstu term <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz
    generuje jeden dodatkowy podcel, w ktÃ³rym musimy skonstruowaÄ‡ <span class="inlinecode"><span class="id" title="var">x</span></span>.
    Zawodzi ona, jeÅ¼eli nazwa <span class="inlinecode"><span class="id" title="var">x</span></span> jest juÅ¼ zajÄ™ta. 
<div class="paragraph"> </div>

<a name="lab122"></a><h4 class="section">Ä†wiczenie (wÅ‚aÅ›ciwoÅ›ci <span class="inlinecode"><span class="id" title="var">even</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij poniÅ¼sze twierdzenia. Zanim zaczniesz, zastanÃ³w siÄ™, po czym
    naleÅ¼y przeprowadziÄ‡ indukcjÄ™: po wartoÅ›ci, czy po dowodzie? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">double_is_even</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> (2 * <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_is_double</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="tactic">exists</span> <span class="id" title="var">k</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 2 * <span class="id" title="var">k</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab123"></a><h2 class="section">Definicje staÅ‚ych i spÃ³jnikÃ³w logicznych</h2>

<div class="paragraph"> </div>

 W rozdziale pierwszym dowiedzieliÅ›my siÄ™, Å¼e produkt zaleÅ¼ny (typ,
    ktÃ³rego termami sÄ… funkcje zaleÅ¼ne), a wiÄ™c i implikacja, jest
    typem podstawowym/wbudowanym oraz Å¼e negacja jest zdefiniowana jako
    implikowanie faÅ‚szu. Teraz, gdy wiemy juÅ¼ co nieco o typach induktywnych,
    nadszedÅ‚ czas by zapoznaÄ‡ siÄ™ z definicjami spÃ³jnikÃ³w logicznych (i nie
    tylko). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyConnectives</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab124"></a><h3 class="section">Prawda i faÅ‚sz</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">False</span> : <span class="id" title="keyword">Prop</span> := .<br/>

<br/>
</div>

<div class="doc">
FaÅ‚sz nie ma Å¼adnych konstruktorÃ³w, a zatem nie moÅ¼e zostaÄ‡ w Å¼aden
    sposÃ³b skonstruowany, czyli udowodniony. Jego definicja jest bliÅºniaczo
    podobna do czegoÅ›, co juÅ¼ kiedyÅ› widzieliÅ›my â€” tym czymÅ› byÅ‚ <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    czyli typ pusty. Nie jest to wcale przypadek. NatknÄ™liÅ›my siÄ™ (znowu) na
    przykÅ‚ad korespondencji Curry'ego-Howarda.

<div class="paragraph"> </div>

    Przypomnijmy, Å¼e gÅ‚osi ona (w sporym uproszczeniu), iÅ¼ sorty <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    i <span class="inlinecode"><span class="id" title="keyword">Set</span></span>/<span class="inlinecode"><span class="id" title="keyword">Type</span></span> sÄ… do siebie bardzo podobne. Jednym z tych podobieÅ„stw
    byÅ‚o to, Å¼e dowody implikacji sÄ… funkcjami. Kolejnym jest fakt, Å¼e
    <span class="inlinecode"><span class="id" title="var">False</span></span> jest odpowiednikiem <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, od ktÃ³rego rÃ³Å¼ni siÄ™ tym, Å¼e
    Å¼yje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Ta definicja rzuca teÅ¼ trochÄ™ Å›wiatÅ‚a na sposÃ³b wnioskowania "ex falso
    quodlibet" (z faÅ‚szu wynika wszystko), ktÃ³ry poznaliÅ›my w rozdziale
    pierwszym.

<div class="paragraph"> </div>

    UÅ¼ycie taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> lub <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> na termie dowolnego typu
    induktywnego to sprawdzenie, ktÃ³rym konstruktorem term ten zostaÅ‚
    zrobiony â€” generujÄ… one dokÅ‚adnie tyle podcelÃ³w, ile jest moÅ¼liwych
    konstruktorÃ³w. UÅ¼ycie ich na termie typu <span class="inlinecode"><span class="id" title="var">False</span></span> generuje zero
    podcelÃ³w, co ma efekt natychmiastowego zakoÅ„czenia dowodu. DziÄ™ki
    temu majÄ…c dowÃ³d <span class="inlinecode"><span class="id" title="var">False</span></span> moÅ¼emy udowodniÄ‡ cokolwiek. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">True</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">I</span> : <span class="id" title="var">True</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">True</span></span> jest odpowiednikiem <span class="inlinecode"><span class="id" title="var">unit</span></span>, od ktÃ³rego rÃ³Å¼ni siÄ™ tym, Å¼e Å¼yje
    w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Ma dokÅ‚adnie jeden dowÃ³d, ktÃ³ry w Coqu
    nazwano, z zupeÅ‚nie nieznanych powodÃ³w (zapewne dla hecy), <span class="inlinecode"><span class="id" title="var">I</span></span>. 
<div class="paragraph"> </div>

<a name="lab125"></a><h3 class="section">Koniunkcja i dysjunkcja</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">and</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">conj</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
</div>

<div class="doc">
DowÃ³d koniunkcji zdaÅ„ <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> to para dowodÃ³w: pierwszy element
    pary jest dowodem <span class="inlinecode"><span class="id" title="var">P</span></span>, zaÅ› drugi dowodem <span class="inlinecode"><span class="id" title="var">Q</span></span>. Koniunkcja jest
    odpowiednkiem produktu, od ktÃ³rego rÃ³Å¼ni siÄ™ tym, Å¼e Å¼yje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    a nie w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">or</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> : <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
</div>

<div class="doc">
DowÃ³d dysjunkcji zdaÅ„ <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> to dowÃ³d <span class="inlinecode"><span class="id" title="var">P</span></span> albo dowÃ³d <span class="inlinecode"><span class="id" title="var">Q</span></span> wraz ze
    wskazaniem, ktÃ³rego zdania jest to dowÃ³d. Dysjunkcja jest odpowiednikiem
    sumy, od ktÃ³rej rÃ³Å¼ni siÄ™ tym, Å¼e Å¼yje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyConnectives</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab126"></a><h2 class="section">RÃ³wnoÅ›Ä‡</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyEq</span>.<br/>

<br/>
</div>

<div class="doc">
Czym jest rÃ³wnoÅ›Ä‡? To pytanie stawiaÅ‚o sobie wielu filozofÃ³w,
    szczegÃ³lnie politycznych, zaÅ› wyjÄ…tkowo rzadko nad tÄ… sprawÄ…
    zastanawiali siÄ™ sami bojownicy o rÃ³wnoÅ›Ä‡, tak jakby wszystko
    dokÅ‚adnie wiedzieli. OdpowiedÅº na nie jest jednym z najwiÄ™kszych
    osiÄ…gniÄ™Ä‡ matematyki w dziejach: rÃ³wnoÅ›Ä‡ to jeden z typÃ³w induktywnych,
    ktÃ³re moÅ¼emy zdefiniowaÄ‡ w Coqu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">eq</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">eq_refl</span> : <span class="id" title="var">eq</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
SprÃ³bujmy przeczytaÄ‡ tÄ™ definicjÄ™: dla danego typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz termu
    <span class="inlinecode"><span class="id" title="var">x</span></span> tego typu, <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> jest predykatem, ktÃ³ry ma jeden konstruktor
    gÅ‚oszÄ…cy, Å¼e <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zachodzi. ChoÄ‡ definicja taka brzmi obco i
    dziwacznie, ma ona swoje uzasadnienie (ktÃ³re niestety poznamy
    dopiero w przyszÅ‚oÅ›ci). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_trivial</span> : <span class="id" title="var">eq</span> 42 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Poznane przez nas dotychczas taktyki potrafiÄ…ce udowadniaÄ‡ proste
    rÃ³wnoÅ›ci, jak <span class="inlinecode"><span class="id" title="tactic">trivial</span></span> czy <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> dziaÅ‚ajÄ… w ten sposÃ³b,
    Å¼e po prostu aplikujÄ… na celu <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>. Nazwa <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> to skrÃ³t
    od ang. "reflexivity of equality", czyli "zwrotnoÅ›Ä‡ rÃ³wnoÅ›ci" â€”
    jest to najwaÅ¼niejsza cecha rÃ³wnoÅ›ci, ktÃ³ra oznacza, Å¼e kaÅ¼dy term
    jest rÃ³wny samemu sobie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_nontrivial</span> : <span class="id" title="var">eq</span> (1 + 41) 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
MogÅ‚oby wydawaÄ‡ siÄ™, Å¼e zwrotnoÅ›Ä‡ nie wystarcza do udowadniania
    "nietrywialnych" rÃ³wnoÅ›ci pokroju <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">41</span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>, jednak tak nie jest.
    Dlaczego <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> odnosi na tym celu sukces skoro <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">41</span> oraz <span class="inlinecode">42</span>
    zdecydowanie rÃ³Å¼niÄ… siÄ™ postaciÄ…? OdpowiedÅº jest prosta: typ <span class="inlinecode"><span class="id" title="var">eq</span></span> w
    rzeczywistoÅ›ci owija jedynie rÃ³wnoÅ›Ä‡ pierwotnÄ…, wbudowanÄ… w samo jÄ…dro
    Coqa, ktÃ³rÄ… jest konwertowalnoÅ›Ä‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_alpha</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">eq</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">change</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>) <span class="id" title="keyword">with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_beta</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">eq</span> ((<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">n</span> + <span class="id" title="var">n</span>) <span class="id" title="var">m</span>) (<span class="id" title="var">m</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ultimate_answer</span> : <span class="id" title="var">nat</span> := 42.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_delta</span> : <span class="id" title="var">eq</span> <span class="id" title="var">ultimate_answer</span> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ultimate_answer</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_iota</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">eq</span> 42 (<span class="id" title="keyword">match</span> 0 <span class="id" title="keyword">with</span> | 0 =&gt; 42 | <span class="id" title="var">_</span> =&gt; 13 <span class="id" title="keyword">end</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_refl_zeta</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := 42 <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span> <span class="id" title="var">n</span> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, co juÅ¼ wiemy o redukcjach:
<ul class="doclist">
<li> konwersja alfa pozwala nam zmieniÄ‡ nazwÄ™ zmiennej zwiÄ…zanej w
      funkcji anonimowej nowÄ…, jeÅ¼eli ta nie jest jeszcze uÅ¼ywana.
      W naszym przykÅ‚adzie zamieniamy <span class="inlinecode"><span class="id" title="var">x</span></span> w <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span>,
      otrzymujÄ…c <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">y</span></span> â€” konwersja jest legalna. Jednak
      w funkcji <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">x</span></span> nie moÅ¼emy uÅ¼yÄ‡ konwersji
      alfa, Å¼eby zmieniÄ‡ nazwÄ™ <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span>, bo <span class="inlinecode"><span class="id" title="var">y</span></span> jest juÅ¼ uÅ¼ywana
      (tak nazywa siÄ™ drugi argument).

</li>
<li> Redukcja beta zastÄ™puje argumentem kaÅ¼de wystÄ…pienie zmiennej
      zwiÄ…zanej w funkcji anonimowej. W naszym przypadku redukcja
      ta zamienia <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span> na <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> â€” w miejsce
      <span class="inlinecode"><span class="id" title="var">n</span></span> wstawiamy <span class="inlinecode"><span class="id" title="var">m</span></span>.

</li>
<li> Redukcja delta odwija definicje. W naszym przypadku zdefiniowaliÅ›my,
      Å¼e <span class="inlinecode"><span class="id" title="var">ultimate_answer</span></span> oznacza <span class="inlinecode">42</span>, wiÄ™c redukcja delta w miejsce
      <span class="inlinecode"><span class="id" title="var">ultimate_answer</span></span> wstawia <span class="inlinecode">42</span>.

</li>
<li> Redukcja jota wykonuje dopasowanie do wzorca. W naszym przypadku <span class="inlinecode">0</span>
      jest termem, ktÃ³ry postaÄ‡ jest znana (zostaÅ‚ on skonstruowany
      konstruktorem <span class="inlinecode">0</span>) i ktÃ³ry pasuje do wzorca <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">42</span>, a zatem
      redukcja jota zamienia caÅ‚e wyraÅ¼enie od <span class="inlinecode"><span class="id" title="keyword">match</span></span> aÅ¼ do <span class="inlinecode"><span class="id" title="keyword">end</span></span>
      na <span class="inlinecode">42</span>.

</li>
<li> Redukcja zeta odwija lokalnÄ… definicjÄ™ poczynionÄ… za pomocÄ… <span class="inlinecode"><span class="id" title="keyword">let</span></span>a 
</li>
</ul>

<div class="paragraph"> </div>

 Termy <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> sÄ… konwertowalne, gdy za pomocÄ… serii konwersji alfa
    oraz redukcji beta, delta, jota i zeta oba redukujÄ… siÄ™ do tego samego
    termu (ktÃ³ry dziÄ™ki silnej normalizacji istnieje i jest w postaci
    kanonicznej).

<div class="paragraph"> </div>

    UwaÅ¼ny czytelnik zada sobie w tym momencie pytanie: skoro rÃ³wnoÅ›Ä‡ to
    konwertowalnoÅ›Ä‡, to jakim cudem rÃ³wne sÄ… termy <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span>,
    gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> jest zmiennÄ…, ktÃ³re przecieÅ¼ nie sÄ… konwertowalne?

<div class="paragraph"> </div>

    Trzeba tutaj dokonaÄ‡ pewnego doprecyzowania. Termy <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> sÄ…
    konwertowalne dla kaÅ¼dego konkretnego <span class="inlinecode"><span class="id" title="var">n</span></span>, np. <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">42</span> i <span class="inlinecode">42</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> sÄ…
    konwertowalne. Konwertowalne nie sÄ… natomiast, gdy <span class="inlinecode"><span class="id" title="var">n</span></span> jest zmiennÄ… -
    jest tak dlatego, Å¼e nie moÅ¼emy wykonaÄ‡ redukcji iota, bo nie wiemy, czy
    <span class="inlinecode"><span class="id" title="var">n</span></span> jest zerem czy nastÄ™pnikiem.

<div class="paragraph"> </div>

    OdpowiedziÄ… na pytanie sÄ… reguÅ‚y eliminacji, gÅ‚Ã³wnie dla typÃ³w
    induktywnych. ReguÅ‚y te majÄ… konkluzje postaci <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>,
    wiÄ™c w szczegÃ³lnoÅ›ci moÅ¼emy uÅ¼yÄ‡ ich dla <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> dla jakiegoÅ›
    <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. DziÄ™ki nim przeprowadzaliÅ›my juÅ¼ wielokrotnie mniej wiÄ™cej
    takie rozumowania: <span class="inlinecode"><span class="id" title="var">n</span></span> jest wprawdzie nie wiadomo czym, ale przez
    indukcjÄ™ moÅ¼e to byÄ‡ albo <span class="inlinecode">0</span>, albo <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, gdzie dla <span class="inlinecode"><span class="id" title="var">n'</span></span> zachodzi
    odpowiednia hipoteza indukcyjna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyEq</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab127"></a><h2 class="section">Indukcja wzajemna</h2>

<div class="paragraph"> </div>

 Jest jeszcze jeden rodzaj indukcji, o ktÃ³rym dotychczas nie mÃ³wiliÅ›my:
    indukcja wzajemna (ang. mutual induction). Bez zbÄ™dnego teoretyzowania
    zbadajmy sprawÄ™ na przykÅ‚adzie klasykÃ³w polskiej literatury: 
<div class="paragraph"> </div>

 <i>Smok to wysuszony zmok</i> 
<div class="paragraph"> </div>

 <i>Zmok to zmoczony smok</i> 
<div class="paragraph"> </div>

 StanisÅ‚aw Lem 
<div class="paragraph"> </div>

 Idea stojÄ…ca za indukcjÄ… wzajemnÄ… jest prosta: chcemy przez indukcjÄ™
    zdefiniowaÄ‡ jednoczeÅ›nie dwa obiekty, ktÃ³re mogÄ… siÄ™ nawzajem do siebie
    odwoÅ‚ywaÄ‡.

<div class="paragraph"> </div>

    W owym definiowaniu nie mamy rzecz jasna peÅ‚nej swobody â€” obowiÄ…zujÄ… te
    same kryteria co w przypadku zwykÅ‚ych, "pojedynczych" definicji typÃ³w
    induktywnych. Wobec tego zauwaÅ¼yÄ‡ naleÅ¼y, Å¼e definicja sÅ‚owa "smok"
    podana przez Lema jest wedÅ‚ug Coqowych standardÃ³w nieakceptowalna, gdyÅ¼
    jeÅ¼eli w definicji <i>smoka</i> rozwiniemy definicjÄ™ <i>zmoka</i>, to otrzymamy

<div class="paragraph"> </div>

    <i>Smok ty wysuszony zmoczony smok</i> 
<div class="paragraph"> </div>

 WidaÄ‡ goÅ‚ym okiem, iÅ¼ prÃ³ba zredukowania (czyli obliczenia) obiektu
    <i>smok</i> nigdy siÄ™ nie skoÅ„czy. Jak juÅ¼ wiemy, niekoÅ„czÄ…ce siÄ™ obliczenia
    w logice odpowiadajÄ… sprzecznoÅ›ci, a zatem ani <i>smoki</i>, ani <i>zmoki</i> w
    Coqowym Å›wiecie nie istniejÄ….

<div class="paragraph"> </div>

    Nie znaczy to bynajmniej, Å¼e wszystkie definicje przez indukcjÄ™
    wzajemnÄ… sÄ… w Coqu niepoprawne, choÄ‡ naleÅ¼y przyznaÄ‡, Å¼e sÄ… doÅ›Ä‡
    rzadko uÅ¼ywane. Czas jednak abyÅ›my ujrzeli pierwszy prawdziwy przkÅ‚ad
    indukcji wzajemnej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MutInd</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">oddS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Aby zrozumieÄ‡ tÄ™ definicjÄ™, zestawmy jÄ… z naszÄ… definicjÄ… parzystoÅ›ci
    z sekcji <i>Induktywne predykaty</i>.

<div class="paragraph"> </div>

    ZdefiniowaliÅ›my tam predykat bycia liczbÄ… parzystÄ… tak:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste

</li>
<li> jeÅ¼eli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> teÅ¼ jest parzyste 
</li>
</ul>

<div class="paragraph"> </div>

 Tym razem jednak nie definiujemy jedynie predykatu "jest liczbÄ… parzystÄ…".
    Definiujemy jednoczeÅ›nie dwa predykaty: "jest liczbÄ… parzystÄ…" oraz
    "jest liczbÄ… nieparzystÄ…", ktÃ³re odwoÅ‚ujÄ… siÄ™ do siebi nawzajm. Definicja
    brzmi tak:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste

</li>
<li> jeÅ¼eli <span class="inlinecode"><span class="id" title="var">n</span></span> jest nieparzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest parzyste

</li>
<li> jeÅ¼eli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest nieparzyste 
</li>
</ul>

<div class="paragraph"> </div>

 Czy definicja taka rzeczywiÅ›cie ma sens? SprawdÅºmy to:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste na mocy definicji

</li>
<li> jeÅ¼eli <span class="inlinecode">0</span> jest parzyste (a jest), to <span class="inlinecode">1</span> jest nieparzyste

</li>
<li> jeÅ¼eli <span class="inlinecode">1</span> jest nieparzyste (a jest), to <span class="inlinecode">2</span> jest parzyste

</li>
<li> i tak dalej, ad infinitum

</li>
</ul>

<div class="paragraph"> </div>

 Jak widaÄ‡, za pomocÄ… naszej wzajemnie induktywnej definicji <span class="inlinecode"><span class="id" title="var">even</span></span> moÅ¼na
    wygenerowaÄ‡ wszystkie liczby parzyste (i tylko je), tak wiÄ™c nowe <span class="inlinecode"><span class="id" title="var">even</span></span>
    jest rÃ³wnowaÅ¼ne staremu <span class="inlinecode"><span class="id" title="var">even</span></span> z sekcji <i>Induktywne predykaty</i>. Podobnie
    <span class="inlinecode"><span class="id" title="var">odd</span></span> moÅ¼e wygenerowaÄ‡ wszystkie liczby nieparzyste i tylko je. 
<div class="paragraph"> </div>

<a name="lab128"></a><h4 class="section">Ä†wiczenie (upewniajÄ…ce)</h4>

<div class="paragraph"> </div>

 Upewnij siÄ™, Å¼e powyÅ¼szy akapit nie kÅ‚amie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_0</span> : <span class="id" title="var">even</span> 0.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">odd_1</span> : <span class="id" title="var">odd</span> 1.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_2</span> : <span class="id" title="var">even</span> 2.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_42</span> : <span class="id" title="var">even</span> 42.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">not_odd_0</span> : ~ <span class="id" title="var">odd</span> 0.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">not_even_1</span> : ~ <span class="id" title="var">even</span> 1.<br/>

<br/>
</div>

<div class="doc">
<a name="lab129"></a><h4 class="section">Ä†wiczenie (wÅ‚aÅ›ciwoÅ›ci <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij podstawowe wÅ‚aÅ›ciwoÅ›ci <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_SS</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">odd_SS</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>

<br/>
</div>

<div class="doc">
JeÅ›li polegÅ‚eÅ› przy ostatnim zadaniu â€” nie przejmuj siÄ™. Specjalnie
    dobraÅ‚em zÅ‚oÅ›liwy przykÅ‚ad.

<div class="paragraph"> </div>

    W tym momencie naleÅ¼y sobie zadaÄ‡ pytanie: jak dowodziÄ‡ wÅ‚aÅ›ciwoÅ›ci
    typÃ³w wzajemnie induktywnych? Aby udzieliÄ‡ odpowiedzi, sprÃ³bujmy
    udowodniÄ‡ <span class="inlinecode"><span class="id" title="var">even_plus</span></span> za pomocÄ… indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a potem przeÅ›ledÅºmy,
    co poszÅ‚o nie tak. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_plus_failed_1</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nasza indukcja po <span class="inlinecode"><span class="id" title="var">n</span></span> zawiodÅ‚a, gdyÅ¼ nasza hipoteza indukcyjna ma w
    konkluzji <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, podczas gdy nasz cel jest postaci
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. ZauwaÅ¼my, Å¼e teoretycznie cel powinno daÄ‡ siÄ™ udowodniÄ‡,
    jako Å¼e mamy hipotezy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oraz <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, a suma liczby parzystej i
    nieparzystej jest nieparzysta.

<div class="paragraph"> </div>

    Nie zraÅ¼ajmy siÄ™ jednak i sprÃ³bujmy indukcji po dowodzie <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_plus_failed_2</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nasza indukcja po dowodzie hipotezy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> zawiodÅ‚a, i to z kretesem,
    gdyÅ¼ w kontekÅ›cie nie mamy nawet Å¼adnej hipotezy indukcyjnej! Co wÅ‚aÅ›ciwie
    siÄ™ staÅ‚o? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">even_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widaÄ‡, w naszej hipotezie "indukcyjnej" wygenerowanej przez Coqa w
    ogÃ³le nie ma Å¼adnej indukcji. Jest tam jedynie odwoÅ‚anie do predykatu
    <span class="inlinecode"><span class="id" title="var">odd</span></span>...

<div class="paragraph"> </div>

    ZauwaÅ¼my jednak, Å¼e naszym celem znÃ³w byÅ‚o <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, a hipotezy
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> sprawiajÄ…, Å¼e w teorii powinno daÄ‡ siÄ™ ten cel
    udowodniÄ‡, gdyÅ¼ suma liczby parzystej i nieparzystej jest nieparzysta.

<div class="paragraph"> </div>

    MogÅ‚oby siÄ™ zdawaÄ‡, Å¼e cierpimy na niedopasowanie (prÃ³ba 1) lub brak
    (prÃ³ba 2) hipotez indukcyjnych. Wydaje siÄ™ teÅ¼, Å¼e skoro w obydwu
    prÃ³bach zatrzymaliÅ›my siÄ™ na celu <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, to pomocne mogÅ‚oby
    okazaÄ‡ siÄ™ poniÅ¼sze twierdzenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">odd_even_plus_failed</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety â€” nie dla psa kieÅ‚basa, gdyÅ¼ natykamy siÄ™ na problemy bliÅºniaczo
    podobne do tych, ktÃ³re napotkaliÅ›my w poprzednim twierdzeniu: nasza
    hipoteza indukcyjna ma w konkluzji <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, podczas gdy nasz cel
    jest postaci <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>.

<div class="paragraph"> </div>

    PrÃ³ba przepchniÄ™cia lematu za pomocÄ… indukcji po dowodzie hipotezy
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> takÅ¼e nie zadziaÅ‚a, z tych samych powodÃ³w dla ktÃ³rych indukcja
    po <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie pozwoliÅ‚a nam udowodniÄ‡ <span class="inlinecode"><span class="id" title="var">even_plus</span></span>. ZauwaÅ¼my jednak, Å¼e
    cel jest udowadnialny, gdyÅ¼ jako hipotezy mamy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    a suma dwÃ³ch liczb parzystych jest parzysta.

<div class="paragraph"> </div>

    Wydaje siÄ™, Å¼e wpadliÅ›my w bÅ‚Ä™dne koÅ‚o i jesteÅ›my w matni, bez wyjÅ›cia,
    bez nadziei, bez krzty szans na powodzenie: w dowodzie <span class="inlinecode"><span class="id" title="var">even_plus</span></span>
    potrzebujemy lematu <span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span>, ale nie moÅ¼emy go udowodniÄ‡, gdyÅ¼
    w dowodzie <span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span> wymagane jest uÅ¼ycie lematu <span class="inlinecode"><span class="id" title="var">even_plus</span></span>.
    Ehhh, gdybyÅ›my tak mogli udowodniÄ‡ oba te twierdzenia na raz...

<div class="paragraph"> </div>

    Eureka!

<div class="paragraph"> </div>

    ZauwaÅ¼, Å¼e w naszych dotychczasowych dowodach przez indukcjÄ™ posÅ‚ugiwaliÅ›my
    siÄ™ zwykÅ‚Ä…, "pojedynczÄ…" indukcjÄ…. ByÅ‚a ona wystarczajÄ…ca, gdyÅ¼ mieliÅ›my do
    czynienia jedynie ze zwykÅ‚ymi typami induktywnymi. Tym razem jednak jest
    inaczej: w ostatnich trzech dowodach chcieliÅ›my uÅ¼yÄ‡ "pojedynczej" indukcji
    do udowodnienia czegoÅ› na temat predykatÃ³w wzajemnie induktywnych.

<div class="paragraph"> </div>

    Jest to ogromny zgrzyt. Do dowodzenia wÅ‚aÅ›ciwoÅ›ci typÃ³w wzajemnie
    induktywnych powinniÅ›my uÅ¼yÄ‡... o zgrozo, jak mogliÅ›my to przeoczyÄ‡,
    przecieÅ¼ to takie oczywiste... indukcji wzajemnej!

<div class="paragraph"> </div>

    Najprostszy sposÃ³b przeprowadzenia tego dowodu wyglÄ…da tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd_even_plus</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">odd_even_plus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even_plus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Co tu siÄ™ wÅ‚aÅ›ciwie staÅ‚o? Pierwsze dwie linijki sÄ… takie same jak
    poprzednio: stwierdzamy, Å¼e bÄ™dziemy dowodziÄ‡ twierdzenia o podanej
    nazwie i postaci. NastÄ™pnie mamy sÅ‚owo kluczowe <span class="inlinecode"><span class="id" title="keyword">with</span></span>, ktÃ³re peÅ‚ni
    tu rolÄ™ podobnÄ… jak w definicjach przez indukcjÄ™ wzajemnÄ…: podajÄ…c po
    nim nazwÄ™ i postaÄ‡ twierdzenia mÃ³wimy Coqowi, Å¼e chcemy dowodziÄ‡ tego
    twierdzenia (<span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span>) jednoczeÅ›nie z poprzednim (<span class="inlinecode"><span class="id" title="var">even_plus</span></span>).

<div class="paragraph"> </div>

    Dotychczas po rozpoczÄ™ciu dowodu ukazywaÅ‚ nam siÄ™ jeden cel. Tym razem,
    jako Å¼e dowodzimy dwÃ³ch twierdzeÅ„ jednoczeÅ›nie, mamy przed sobÄ… dwa cele.
    W kontekÅ›cie mamy teÅ¼ od razu dwie hipotezy indukcyjne. Musimy na nie
    bardzo uwaÅ¼aÄ‡: dotychczas hipotezy indukcyjne pojawiaÅ‚y siÄ™ dopiero w
    kroku indukcyjnym i sposÃ³b ich uÅ¼ycia byÅ‚ oczywisty. Tym razem jest
    inaczej â€” jako, Å¼e mamy je od samego poczÄ…tku, moÅ¼emy natychmiast uÅ¼yÄ‡
    ich do "udowodnienia" naszych twierdzeÅ„.

<div class="paragraph"> </div>

    Niestety, takie "udowodnienie" odpowiada wywoÅ‚aniu rekurencyjnemu na
    argumencie, ktÃ³ry nie jest strukturalnie mniejszy (coÅ› jak <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).
    Fakt ten obrazuje wiadomoÅ›Ä‡ o bÅ‚Ä™dzie, jakÄ… Coq daje nam po tej prÃ³bie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Error:&nbsp;Cannot&nbsp;guess&nbsp;decreasing&nbsp;argument&nbsp;of&nbsp;fix.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zaczynamy dowÃ³d od nowa, tym razem juÅ¼ bez oszukiwania. Musimy udowodniÄ‡
    kaÅ¼dy z naszych celÃ³w osobno, ale moÅ¼emy korzystaÄ‡ z obydwu hipotez
    indukcyjnych. W obydwu celach zaczynamy od analizy przypadkÃ³w, czyli
    rozbicia <span class="inlinecode"><span class="id" title="var">n</span></span>, i rozwiÄ…zania przypadku bazowego. Rozbicie <span class="inlinecode"><span class="id" title="var">n</span></span> daÅ‚o nam
    <span class="inlinecode"><span class="id" title="var">n'</span></span>, ktÃ³re jest strukturalnie mniejsze od <span class="inlinecode"><span class="id" title="var">n</span></span>, a zatem moÅ¼emy bez obaw
    uÅ¼yÄ‡ naszej hipotezy indukcyjnej. Reszta jest trywialna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_double</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> (2 * <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_O</span> <span class="id" title="tactic">in</span> *. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MutInd</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab130"></a><h1 class="section">RÃ³Å¼ne</h1>

<div class="paragraph"> </div>

<a name="lab131"></a><h2 class="section">Rodziny typÃ³w induktywnych</h2>

<div class="paragraph"> </div>

 SÅ‚owo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pozwala nam definiowaÄ‡ nie tylko typy
    induktywne, ale takÅ¼e rodziny typÃ³w induktywnych â€” i to nawet na
    dwa sposoby. W tym podrozdziale przyjrzymy siÄ™ obu z nich oraz
    rÃ³Å¼nicom miÄ™dzy nimi, a takÅ¼e ich wadom i zaletom. Przyjrzyjmy siÄ™
    raz jeszcze typowi <span class="inlinecode"><span class="id" title="var">option</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">option</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;option&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;:&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> @<span class="id" title="var">None</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;@None&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
DefiniujÄ…c rodzinÄ™ typÃ³w <span class="inlinecode"><span class="id" title="var">option</span></span>, umieÅ›ciliÅ›my argument bÄ™dÄ…cy typem
    w nawiasach okrÄ…gÅ‚ych tuÅ¼ po nazwie definiowanego typu, a przed <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.
    DefiniujÄ…c konstruktory, nie napisaliÅ›my nigdzie <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">...</span>,
    a mimo tego komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> jasno pokazuje, Å¼e typy obydwu konstruktorÃ³w
    zaczynajÄ… siÄ™ od takiej wÅ‚aÅ›nie kwantyfikacji.

<div class="paragraph"> </div>

    (Przypomnijmy, Å¼e w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> argument <span class="inlinecode"><span class="id" title="var">A</span></span> jest domyÅ›lny, wiÄ™c
    wyÅ›wietlenie peÅ‚nego typu tego konstruktora wymagaÅ‚o uÅ¼ycia symbolu <span class="inlinecode">@</span>,
    ktÃ³ry oznacza "wyÅ›wietl wszystkie argumenty domyÅ›lne").

<div class="paragraph"> </div>

    W ogÃ³lnoÅ›ci, definiowanie rodziny typÃ³w <span class="inlinecode"><span class="id" title="var">T</span></span> jako <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">(<span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">xN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">AN</span>)</span>
    ma nastÄ™pujÄ…cy efekt:
<ul class="doclist">
<li> kwantyfikacja <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">xN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">AN</span>)</span> jest dodawana na
      poczÄ…tek kaÅ¼dego konstruktora

</li>
<li> w konkluzji konstruktora <span class="inlinecode"><span class="id" title="var">T</span></span> musi wystÄ…piÄ‡ zaaplikowany do tych
      argumentÃ³w, czyli jako <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xN</span></span> â€” wstawienie innych argumentÃ³w
      jest bÅ‚Ä™dem 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">option'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option'</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">option'</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
PrÃ³ba zdefiniowania typu <span class="inlinecode"><span class="id" title="var">option'</span></span> koÅ„czy siÄ™ nastÄ™pujÄ…cym komunikatem
    o bÅ‚Ä™dzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:&nbsp;Last&nbsp;occurrence&nbsp;of&nbsp;"option'"&nbsp;must&nbsp;have&nbsp;"A"&nbsp;as&nbsp;1st&nbsp;argument&nbsp;in&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;B".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Drugi sposÃ³b zdefiniowania rodziny typÃ³w <span class="inlinecode"><span class="id" title="var">option</span></span> przedstawiono
    poniÅ¼ej. Tym razem zamiast umieszczaÄ‡ argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> po
    nazwie definiowanego typu, deklarujemy, Å¼e typem <span class="inlinecode"><span class="id" title="var">option'</span></span> jest
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option'</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option'</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">option'</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Taki zabieg daje nam wiÄ™kszÄ… swobodÄ™: w kaÅ¼dym konstruktorze
    z osobna musimy explicitÃ© umieÅ›ciÄ‡ kwantyfikacjÄ™ po argumencie
    sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, dziÄ™ki czemu rÃ³Å¼ne konstruktory mogÄ… w konkluzji
    mieÄ‡ <span class="inlinecode"><span class="id" title="var">option'</span></span> zaaplikowany do rÃ³Å¼nych argumentÃ³w. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some'&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option'&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">None'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None'&nbsp;:&nbsp;forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
ZauwaÅ¼my jednak, Å¼e definicje <span class="inlinecode"><span class="id" title="var">option</span></span> i <span class="inlinecode"><span class="id" title="var">option'</span></span> sÄ… rÃ³wnowaÅ¼ne
    â€” typ konstruktora <span class="inlinecode"><span class="id" title="var">None'</span></span> rÃ³Å¼ni siÄ™ od typu <span class="inlinecode"><span class="id" title="var">None</span></span> jedynie nazwÄ…
    argumentu (<span class="inlinecode"><span class="id" title="var">A</span></span> dla <span class="inlinecode"><span class="id" title="var">None</span></span>, <span class="inlinecode"><span class="id" title="var">B</span></span> dla <span class="inlinecode"><span class="id" title="var">None'</span></span>).

<div class="paragraph"> </div>

    Jak zatem rozstrzygnÄ…Ä‡, ktÃ³ry sposÃ³b definiowania jest "lepszy"?
    W naszym przypadku lepszy jest sposÃ³b pierwszy, odpowiadajÄ…cy
    typowi <span class="inlinecode"><span class="id" title="var">option</span></span>, gdyÅ¼ jest bardziej zwiÄ™zÅ‚y. Nie jest to jednak
    jedyne kryterium. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">option_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;option&nbsp;A&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;P&nbsp;(Some&nbsp;a))&nbsp;-&gt;&nbsp;P&nbsp;None&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;o&nbsp;:&nbsp;option&nbsp;A,&nbsp;P&nbsp;o&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">option'_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;forall&nbsp;T&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;T&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(a&nbsp;:&nbsp;A),&nbsp;P&nbsp;A&nbsp;(Some'&nbsp;A&nbsp;a))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;P&nbsp;B&nbsp;(None'&nbsp;B))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(T&nbsp;:&nbsp;Type)&nbsp;(o&nbsp;:&nbsp;option'&nbsp;T),&nbsp;P&nbsp;T&nbsp;o&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Dwa powyÅ¼sze termy to reguÅ‚y indukcyjne, wygenerowane automatycznie
    przez Coqa dla typÃ³w <span class="inlinecode"><span class="id" title="var">option</span></span> oraz <span class="inlinecode"><span class="id" title="var">option'</span></span>. ReguÅ‚a dla <span class="inlinecode"><span class="id" title="var">option</span></span>
    jest wizualnie krÃ³tsza, co, jak dowiemy siÄ™ w przyszÅ‚oÅ›ci, oznacza
    zapewne, Å¼e jest prostsza, zaÅ› prostsza reguÅ‚a indukcyjna oznacza
    Å‚atwiejsze dowodzenie przez indukcjÄ™. Jest to w zasadzie najmocniejszy
    argument przemawiajÄ…cy za pierwszym sposobem zdefiniowania <span class="inlinecode"><span class="id" title="var">option</span></span>.

<div class="paragraph"> </div>

    PowyÅ¼sze rozwaÅ¼ania nie oznaczajÄ… jednak, Å¼e sposÃ³b pierwszy jest
    zawsze lepszy â€” sposÃ³b drugi jest bardziej ogÃ³lny i istniejÄ… rodziny
    typÃ³w, ktÃ³rych zdefiniowanie sposobem pierwszym jest niemoÅ¼liwe.
    Klasycznym przykÅ‚adem jest rodzina typÃ³w <span class="inlinecode"><span class="id" title="var">vec</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">vec</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">vnil</span> : <span class="id" title="var">vec</span> <span class="id" title="var">A</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">vcons</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">vec</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">vec</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Konstruktor <span class="inlinecode"><span class="id" title="var">vnil</span></span> reprezentuje listÄ™ pustÄ…, ktÃ³rej dÅ‚ugoÅ›Ä‡ wynosi
    rzecz jasna <span class="inlinecode">0</span>, zaÅ› <span class="inlinecode"><span class="id" title="var">vcons</span></span> reprezentuje listÄ™ skÅ‚adajÄ…ca siÄ™ z
    gÅ‚owy i ogona o dÅ‚ugoÅ›ci <span class="inlinecode"><span class="id" title="var">n</span></span>, ktÃ³rej dÅ‚ugoÅ›Ä‡ wynosi oczywiÅ›cie <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">vec</span></span> reprezetuje listy o dÅ‚ugoÅ›ci znanej statycznie (tzn. Coq zna
    dÅ‚ugoÅ›Ä‡ takiej listy juÅ¼ w trakcie sprawdzania typÃ³w), dziÄ™ki czemu
    moÅ¼emy obliczaÄ‡ ich dÅ‚ugoÅ›Ä‡ w czasie staÅ‚ym (po prostu odczytujÄ…c jÄ…
    z typu danej listy).

<div class="paragraph"> </div>

    ZauwaÅ¼, Å¼e w obu konstruktorach argumenty typu <span class="inlinecode"><span class="id" title="var">nat</span></span> sÄ… rÃ³Å¼ne, a zatem
    zdefiniowanie tego typu jako <span class="inlinecode"><span class="id" title="var">vec</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">...</span> byÅ‚oby
    niemoÅ¼liwe.

<div class="paragraph"> </div>

    PrzykÅ‚ad ten pokazuje nam rÃ³wnieÅ¼, Å¼e przy definiowaniu rodzin typÃ³w
    moÅ¼emy dowolnie mieszaÄ‡ sposoby pierwszy i drugi â€” w naszym przypadku
    argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest wspÃ³lny dla wszystkich konstruktorÃ³w, wiÄ™c
    umieszczamy go przed ostatnim <span class="inlinecode">:</span>, zaÅ› argument typu <span class="inlinecode"><span class="id" title="var">nat</span></span> rÃ³Å¼ni siÄ™
    w zaleÅ¼noÅ›ci od konstruktora, a zatem umieszczamy go po ostatnim <span class="inlinecode">:</span>. 
<div class="paragraph"> </div>

<a name="lab132"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj nastÄ™pujÄ…ce typy (zadbaj o to, Å¼eby wygenerowana reguÅ‚a
    indukcyjna byÅ‚a jak najkrÃ³tsza):
<ul class="doclist">
<li> typ drzew binarnych przechowujÄ…cych elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> typ drzew binarnych przechowujÄ…cych elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
      ktÃ³rych wysokoÅ›Ä‡ jest znana statycznie

</li>
<li> typ heterogenicznych drzew binarnych (mogÄ… one
      przechowywaÄ‡ elementy rÃ³Å¼nych typÃ³w)

</li>
<li> typ heterogenicznych drzew binarnych, ktÃ³rych wysokoÅ›Ä‡
      jest znana statycznie 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab133"></a><h2 class="section">Indukcja wzajemna a indeksowane rodziny typÃ³w</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MutualIndution_vs_InductiveFamilies</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja wzajemna nie jest zbyt uÅ¼yteczna. Pierwszym, praktycznym,
    powodem jest to, Å¼e, jak pewnie zdÄ…Å¼yÅ‚eÅ› siÄ™ juÅ¼ na wÅ‚asnej skÃ³rze
    przekonaÄ‡, jej uÅ¼ywanie jest doÅ›Ä‡ upierdliwe. Drugi, teoretyczny,
    powÃ³d jest taki, Å¼e definicje przez indukcjÄ™ wzajemnÄ… moÅ¼emy Å‚atwo
    zasymulowaÄ‡ za pomocÄ… indeksowanych rodzin typÃ³w. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">oddS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
RzuÄ‡my jeszcze raz okiem na znanÄ… nam juÅ¼ definicjÄ™ predykatÃ³w <span class="inlinecode"><span class="id" title="var">even</span></span>
    i <span class="inlinecode"><span class="id" title="var">odd</span></span> przez indukcjÄ™ wzajemnÄ…. Nie dzieje siÄ™ tu nic niezwykÅ‚ego, a
    najwaÅ¼niejszym spostrzeÅ¼eniem, jakie moÅ¼emy poczyniÄ‡, jest to, Å¼e
    <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span> to dwa byty - nie trzy, nie piÄ™Ä‡, ale dwa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even_odd</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0'</span> : <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenS'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even_odd</span> <span class="id" title="var">false</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">oddS'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even_odd</span> <span class="id" title="var">false</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even'</span> := <span class="id" title="var">even_odd</span> <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">odd'</span> := <span class="id" title="var">even_odd</span> <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
Co z tego wynika? Ano, zamiast definiowaÄ‡ przez indukcjÄ™ wzajemnÄ… dwÃ³ch
    predykatÃ³w <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span> moÅ¼emy za jednym zamachem zdefiniowaÄ‡ relacjÄ™
    <span class="inlinecode"><span class="id" title="var">even_odd</span></span>, ktÃ³ra jednoczeÅ›nie odpowiada obu tym predykatom. Kluczem
    w tej sztuczce jest dodatkowy indeks, ktÃ³rym jest dwuelementowy typ
    <span class="inlinecode"><span class="id" title="var">bool</span></span>. DziÄ™ki niemu moÅ¼emy zakodowaÄ‡ definicjÄ™ <span class="inlinecode"><span class="id" title="var">even</span></span> za pomocÄ…
    <span class="inlinecode"><span class="id" title="var">even_odd</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>, zaÅ› <span class="inlinecode"><span class="id" title="var">odd</span></span> jako <span class="inlinecode"><span class="id" title="var">even_odd</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_even'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even'</span> <span class="id" title="var">n</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd_odd'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd'</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even'_even</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even'</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> <span class="id" title="var">n</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd'_odd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">odd'</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">odd</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Obie definicje sÄ…, jak widaÄ‡ (Ä‡wiczenie!), rÃ³wnowaÅ¼ne, choÄ‡ pod wzglÄ™dem
    estetycznym oczywiÅ›cie duÅ¼o lepiej wypada indukcja wzajemna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MutualIndution_vs_InductiveFamilies</span>.<br/>

<br/>
</div>

<div class="doc">
Na koniec wypada jeszcze powiedzieÄ‡, Å¼e indeksowane typy induktywne sÄ…
    potÄ™Å¼niejsze od typÃ³w wzajemnie induktywnych. Wynika to z tego prostego
    faktu, Å¼e przez wzajemnÄ… indukcjÄ™ moÅ¼emy zdefiniowaÄ‡ na raz jedynie
    skoÅ„czenie wiele typÃ³w, zaÅ› indeksowane typy induktywne indeksowane
    mogÄ… byÄ‡ typami nieskoÅ„czonymi. 
<div class="paragraph"> </div>

<a name="lab134"></a><h2 class="section">Sumy zaleÅ¼ne i podtypy</h2>

<div class="paragraph"> </div>

 W Coqu, w przeciwieÅ„stwie do wielu jÄ™zykÃ³w imperatywnych, nie ma
    mechanizmu podtypowania, a kaÅ¼de dwa typy sÄ… ze sobÄ… rozÅ‚Ä…czne.
    Nie jest to problemem, gdyÅ¼ podtypowanie moÅ¼emy zasymulowaÄ‡ za
    pomocÄ… sum zaleÅ¼nych, a te zdefiniowaÄ‡ moÅ¼emy induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">sigma</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sigT</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">existT</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">sigT</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> reprezentuje sumÄ™ zaleÅ¼nÄ…, ktÃ³rej elementami sÄ… pary zaleÅ¼ne.
    Pierwszym elementem pary jest <span class="inlinecode"><span class="id" title="var">x</span></span>, ktÃ³ry jest typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaÅ› drugim
    elementem pary jest term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Suma zaleÅ¼na jest wobec tego pewnym
    uogÃ³lnieniem produktu.

<div class="paragraph"> </div>

    Niech ciÄ™ nie zmyli nazewnictwo:
<ul class="doclist">
<li> Suma jest reprezentowana przez typ <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jej elementami sÄ…
      elementy <span class="inlinecode"><span class="id" title="var">A</span></span> zawiniÄ™te w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span> oraz elementy <span class="inlinecode"><span class="id" title="var">B</span></span>
      zawiniÄ™te w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Reprezentuje ideÄ™ "lub/albo".
      Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie moÅ¼e zaleÅ¼eÄ‡ od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Produkt jest reprezentowany przez typ <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      sÄ… pary elementÃ³w <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. Reprezentuje on ideÄ™ "i/oraz". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> nie moÅ¼e zaleÅ¼eÄ‡ od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> UogÃ³lnieniem produktu jest suma zaleÅ¼na. Jest ona reprezentowana
      przez typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jej elementami sÄ… pary zaleÅ¼ne elementÃ³w
      <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pierwszym elementem pary.
      Reprezentuje ona ideÄ™ "i/oraz", gdzie typ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> moÅ¼e zaleÅ¼eÄ‡ od
      elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Typ funkcji jest reprezentowany przez <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      sÄ… termy postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. ReprezentujÄ… ideÄ™ "daj mi
      coÅ› typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coÅ› typu <span class="inlinecode"><span class="id" title="var">B</span></span>". Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie moÅ¼e
      zaleÅ¼eÄ‡ od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> UogÃ³lnieniem typu funkcji jest produkt zaleÅ¼ny <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
      Jego elementami sÄ… termu postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentuje
      on ideÄ™ "daj mi <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coÅ› typu <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> moÅ¼e zaleÅ¼eÄ‡ od typu elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">sigT</span></span> jest najogÃ³lniejszÄ… postaciÄ… pary zaleÅ¼nej â€” <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem,
    a <span class="inlinecode"><span class="id" title="var">P</span></span> rodzinÄ… typÃ³w. Mimo swej ogÃ³lnoÅ›ci jest uÅ¼ywany doÅ›Ä‡ rzadko,
    gdyÅ¼ najbardziej przydatnÄ… postaciÄ… sumy zaleÅ¼nej jest typ <span class="inlinecode"><span class="id" title="var">sig</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sig</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">exist</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">sig</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">exist</span> [<span class="id" title="var">A</span>] [<span class="id" title="var">P</span>] <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> moÅ¼na interpretowaÄ‡ jako typ skÅ‚adajÄ…cy siÄ™ z tych
    elementÃ³w <span class="inlinecode"><span class="id" title="var">A</span></span>, ktÃ³re speÅ‚niajÄ… predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Formalnie jest to
    para zaleÅ¼na, ktÃ³rej pierwszym elementem jest term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaÅ›
    drugim dowÃ³d na to, Å¼e speÅ‚nia on predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even_nat</span> : <span class="id" title="keyword">Type</span> := <span class="id" title="var">sig</span> <span class="id" title="var">nat</span> <span class="id" title="var">even</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even_four</span> : <span class="id" title="var">even_nat</span> := <span class="id" title="var">exist</span> 4 <span class="id" title="var">four_is_even</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">even_nat</span></span> reprezentuje parzyste liczby naturalne, zaÅ› term
    <span class="inlinecode"><span class="id" title="var">even_four</span></span> to liczba <span class="inlinecode">4</span> wraz z zaÅ‚Ä…czonym dowodem faktu, Å¼e <span class="inlinecode">4</span>
    jest parzyste.

<div class="paragraph"> </div>

    Interpretacja typu <span class="inlinecode"><span class="id" title="var">sig</span></span> sprawia, Å¼e jest on wykorzystywany bardzo
    czÄ™sto do podawania specyfikacji programÃ³w â€” pozwala on dodaÄ‡ do
    wyniku zwracanego przez funkcjÄ™ informacjÄ™ o jego wÅ‚aÅ›ciwoÅ›ciach.
    W przypadku argumentÃ³w raczej nie jest uÅ¼ywany, gdyÅ¼ proÅ›ciej jest
    po prostu wymagaÄ‡ dowodÃ³w Å¼Ä…danych wÅ‚aÅ›ciwoÅ›ci w osobnych argumentach
    niÅ¼ pakowaÄ‡ je w <span class="inlinecode"><span class="id" title="var">sig</span></span> po to, Å¼eby i tak zostaÅ‚y pÃ³Åºniej odpakowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">even_42</span> : <span class="id" title="var">sig</span> <span class="id" title="var">nat</span> <span class="id" title="var">even</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">exist</span> 42). <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definiowanie wartoÅ›ci typu <span class="inlinecode"><span class="id" title="var">sig</span></span> jest problematyczne, gdyÅ¼ zawierajÄ…
    one dowody. Napisanie definicji "rÄ™cznie", explicitÃ© podajÄ…c proofterm,
    nie wchodzi w grÄ™. Innym potencjalnym rozwiÄ…zaniem jest napisanie dowodu
    na boku, a nastÄ™pnie uÅ¼ycie go we wÅ‚aÅ›ciwej definicji, ale jest ono
    dÅ‚uÅ¼sze niÅ¼ to konieczne.

<div class="paragraph"> </div>

    Przypomnijmy sobie, czym sÄ… taktyki. Dowody to termy, ktÃ³rych typy sÄ…
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a taktyki sÅ‚uÅ¼Ä… do konstruowania tych dowodÃ³w. PoniewaÅ¼
    dowody nie rÃ³Å¼niÄ… siÄ™ (prawie) niczym od programÃ³w, taktyk moÅ¼na uÅ¼yÄ‡
    takÅ¼e do pisania programÃ³w. Taktyki to metaprogramy (napisane w jÄ™zku
    Ltac), ktÃ³re piszÄ… programy (w jÄ™zku termÃ³w Coqa, zwanym Gallina).

<div class="paragraph"> </div>

    Wobec tego trybu dowodzenia oraz taktyk moÅ¼emy uÅ¼ywaÄ‡ nie tylko do
    dowodzenia, ale takÅ¼e do definiowania i to wÅ‚aÅ›nie uczyniliÅ›my w
    powyÅ¼szym przykÅ‚adzie. Skonstruowanie termu typu <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>,
    czyli parzystej liczby naturalnej, odbyÅ‚o siÄ™ w nastÄ™pujÄ…cy sposÃ³b.

<div class="paragraph"> </div>

    Naszym celem jest poczÄ…tkowo <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>, czyli typ, ktÃ³rego
    element chcemy skonstrowaÄ‡. UÅ¼ywamy konstruktora <span class="inlinecode"><span class="id" title="var">exist</span></span>, ktÃ³ry
    w naszym przypadku jest typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>.
    Wobec tego <span class="inlinecode"><span class="id" title="var">exist</span></span> <span class="inlinecode">42</span> jest typu <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">42</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>, a jego
    zaaplikowanie skutkowaÄ‡ bÄ™dzie zamianÄ… naszego celu na <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">42</span>.
    NastÄ™pnie dowodzimy tego faktu, co koÅ„czy proces definiowania. 
<div class="paragraph"> </div>

<a name="lab135"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj predykat <span class="inlinecode"><span class="id" title="var">sorted</span></span>, ktÃ³ry jest speÅ‚niony, gdy jego argument
    jest listÄ… posortowanÄ…. NastÄ™pnie zdefiniuj typ list liczb naturalnych
    posortowanych wedÅ‚ug relacji <span class="inlinecode">&lt;=</span> i skonstruuj term tego typu
    odpowiadajÄ…cy liÅ›cie <span class="inlinecode">[42;</span> <span class="inlinecode">666;</span> <span class="inlinecode">1337]</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">sigma</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab136"></a><h2 class="section">Kwantyfikacja egzystencjalna</h2>

<div class="paragraph"> </div>

 Znamy juÅ¼ pary zaleÅ¼ne i wiemy, Å¼e mogÄ… sÅ‚uÅ¼yÄ‡ do reprezentowania
    podtypÃ³w, ktÃ³rych w Coqu brak. Czas zatem uÅ›wiadomiÄ‡ sobie kolejny
    fragment korespondencji Curry'ego-Howarda, a mianowicie definicjÄ™
    kwantyfikacji egzystencjalnej: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ex</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ex</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ex_intro</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">ex</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">ex</span></span> to kolejne wcielenie sumy zaleÅ¼nej. PorÃ³wnaj dokÅ‚adnie tÄ™
    definicjÄ™ z definicjÄ… <span class="inlinecode"><span class="id" title="var">sigT</span></span> oraz <span class="inlinecode"><span class="id" title="var">sig</span></span>. <span class="inlinecode"><span class="id" title="var">ex</span></span> jest niemal identyczne
    jak <span class="inlinecode"><span class="id" title="var">sig</span></span>: jest to para zaleÅ¼na, ktÃ³rej pierwszym elementem jest
    term <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugim dowÃ³d na to, Å¼e <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zachodzi. <span class="inlinecode"><span class="id" title="var">ex</span></span> jednak,
    w przeciwieÅ„stwie do <span class="inlinecode"><span class="id" title="var">sig</span></span>, Å¼yje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, czyli jest zdaniem â€” nie
    liczÄ… siÄ™ konkretne postaci jego termÃ³w ani ich iloÅ›Ä‡, a jedynie
    fakt ich istnienia. To sprawia, Å¼e <span class="inlinecode"><span class="id" title="var">ex</span></span> jest doskonaÅ‚ym kandydatem
    do reprezentowania kwantyfikacji egzystencjalnej. 
<div class="paragraph"> </div>

<a name="lab137"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, Å¼e dla kaÅ¼dej liczby naturalnej n istnieje liczba od niej
    wiÄ™ksza. NastÄ™pnie zastanÃ³w siÄ™, jak dziaÅ‚a taktyka <span class="inlinecode"><span class="id" title="tactic">exists</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">exists_greater</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ex</span> <span class="id" title="var">nat</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">k</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">n</span> &lt; <span class="id" title="var">k</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ex</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab138"></a><h1 class="section">WyÅ¼sze czary</h1>

<div class="paragraph"> </div>

 NajwyÅ¼szy czas nauczyÄ‡ siÄ™ czegoÅ› tak zaawansowanego, Å¼e nawet w Coqu
    (peÅ‚nym przecieÅ¼ dziwnych rzeczy) tego nie ma i nie zapowiada siÄ™ na
    to, Å¼e bÄ™dzie. Mam tu na myÅ›li mechanizmy takie jak indukcja-indukcja,
    indukcja-rekursja oraz indukcja-indukcja-rekursja (jak widaÄ‡, w Å›wiecie
    powaÅ¼nych uczonych, podobnie jak Å›wiecie Goebbelsa, im wiÄ™cej razy
    powtÃ³rzy siÄ™ dane sÅ‚owo, tym wiÄ™cej pÅ‚ynie z niego mocy). 
<div class="paragraph"> </div>

<a name="lab139"></a><h2 class="section">Przypomnienie</h2>

<div class="paragraph"> </div>

 Zanim jednak wyjaÅ›nimy, co to za stwory, przypomnijmy sobie rÃ³Å¼ne, coraz
    bardziej innowacyjne sposoby definiowania przez indukcjÄ™ oraz dowiedzmy
    siÄ™, jak sformuÅ‚owaÄ‡ i udowodniÄ‡ wynikajÄ…ce z nich reguÅ‚y rekursji oraz
    indukcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Elimination</span> <span class="id" title="var">Schemes</span>.<br/>

<br/>
</div>

<div class="doc">
PowyÅ¼sza komenda mÃ³wi Coqowi, Å¼eby nie generowaÅ‚ automatycznie reguÅ‚
    indukcji. Przyda nam siÄ™ ona, by uniknÄ…Ä‡ konfliktÃ³w nazw z reguÅ‚ami,
    ktÃ³re bÄ™dziemy pisaÄ‡ rÄ™cznie. 
<div class="paragraph"> </div>

<a name="lab140"></a><h3 class="section">Enumeracje</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">enum</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
Najprymitywniejszymi z typÃ³w induktywnych sÄ… enumeracje. DefiniujÄ…c je,
    wymieniamy po prostu wszystkie ich elementy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">I</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
ReguÅ‚a definiowania przez przypadki jest banalnie prosta: jeÅ¼eli w
    jakimÅ› inny typie <span class="inlinecode"><span class="id" title="var">P</span></span> uda nam siÄ™ znaleÅºÄ‡ po jednym elemencie dla kaÅ¼dego
    z elementÃ³w naszego typu <span class="inlinecode"><span class="id" title="var">I</span></span>, to moÅ¼emy zrobiÄ‡ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span> : <span class="id" title="var">I_case_nondep_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> <span class="id" title="var">c1'</span> <span class="id" title="var">c2'</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> =&gt; <span class="id" title="var">c0'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> =&gt; <span class="id" title="var">c1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> =&gt; <span class="id" title="var">c2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
ReguÅ‚Ä™ zdefiniowaÄ‡ moÅ¼emy za pomocÄ… dopasowania do wzorca. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c0</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c1</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
ZaleÅ¼nÄ… reguÅ‚Ä™ definiowania przez przypadki moÅ¼emy uzyskaÄ‡ z poprzedniej
    uzaleÅ¼niajÄ…c przeciwdziedzinÄ™ <span class="inlinecode"><span class="id" title="var">P</span></span> od dziedziny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span> : <span class="id" title="var">I_case_dep_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c0</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c1</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">P</span> <span class="id" title="var">c2</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> =&gt; <span class="id" title="var">c0'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> =&gt; <span class="id" title="var">c1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> =&gt; <span class="id" title="var">c2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja, jak widaÄ‡, jest taka sama jak poprzednio, wiÄ™c obliczeniowo
    obie reguÅ‚y zachowujÄ… siÄ™ tak samo. RÃ³Å¼nica leÅ¼y jedynie w typach -
    druga reguÅ‚a jest ogÃ³lniejsza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">enum</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab141"></a><h3 class="section">Konstruktory rekurencjne</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">rec</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">D</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
Typy induktywne stajÄ… siÄ™ naprawdÄ™ induktywne, gdy konstruktory mogÄ…
    braÄ‡ argumenty typu, ktÃ³ry wÅ‚aÅ›nie definiujemy. DziÄ™ki temu moÅ¼emy
    tworzyÄ‡ type, ktÃ³re majÄ… nieskoÅ„czenie wiele elementÃ³w, z ktÃ³rych
    kaÅ¼dy ma ksztaÅ‚t takiego czy innego drzewa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_rec_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>,  (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">I</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ reguÅ‚y rekursji (czyli rekursora) tworzymy tak jak dla enumeracji:
    jeÅ¼eli w typie <span class="inlinecode"><span class="id" title="var">P</span></span> znajdziemy rzeczy o takim samym ksztaÅ‚cie jak
    konstruktory typu <span class="inlinecode"><span class="id" title="var">I</span></span>, to moÅ¼emy zrobiÄ‡ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. W naszym
    przypadku oba konstruktory majÄ… ksztaÅ‚t <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">I</span></span>, wiÄ™c do zdefiniowania
    naszej funkcji musimy znaleÅºÄ‡ odpowiadajÄ…ce im rzeczy typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">I_rec</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x'</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">D'</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">x'</span> (<span class="id" title="var">I_rec</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">D</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">D'</span> (<span class="id" title="var">I_rec</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja rekursora jest prosta. JeÅ¼eli wyobrazimy sobie <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> jako
    drzewo, to wÄ™zÅ‚y z etykietkÄ… <span class="inlinecode"><span class="id" title="var">x</span></span> zastÄ™pujemy wywoÅ‚aniem funkcji <span class="inlinecode"><span class="id" title="var">x'</span></span>,
    a wÄ™zÅ‚y z etykietkÄ… <span class="inlinecode"><span class="id" title="var">D</span></span> zastÄ™pujemy wywoÅ‚aniami funkcji <span class="inlinecode"><span class="id" title="var">D</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_ind_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">D'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">D</span> <span class="id" title="var">i</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
ReguÅ‚a indukcji (czyli induktor - cÃ³Å¼ za piÄ™kna nazwa!) powstaje z
    reguÅ‚y rekursji przez uzaleÅ¼nienie przeciwdziedziny <span class="inlinecode"><span class="id" title="var">P</span></span> od dziedziny
    <span class="inlinecode"><span class="id" title="var">I</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">I_ind</span> (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">x'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>)) (<span class="id" title="var">D'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">D</span> <span class="id" title="var">i</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) : <span class="id" title="var">P</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">x'</span> <span class="id" title="var">i'</span> (<span class="id" title="var">I_ind</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">D</span> <span class="id" title="var">i'</span> =&gt; <span class="id" title="var">D'</span> <span class="id" title="var">i'</span> (<span class="id" title="var">I_ind</span> <span class="id" title="var">P</span> <span class="id" title="var">x'</span> <span class="id" title="var">D'</span> <span class="id" title="var">i'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, implementacja reguÅ‚y indukcji jest identyczna
    jak rekursora, jedynie typy sÄ… bardziej ogÃ³lnej.

<div class="paragraph"> </div>

    Uwaga: nazywam reguÅ‚y nieco inaczej niÅ¼ te autogenerowane przez Coqa.
    Dla Coqa reguÅ‚a indukcji dla <span class="inlinecode"><span class="id" title="var">I</span></span> to nasze <span class="inlinecode"><span class="id" title="var">I_ind</span></span> z <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    zastÄ…pionym przez <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, zaÅ› Coqowe <span class="inlinecode"><span class="id" title="var">I_rec</span></span> odpowiadaÅ‚oby
    naszemu <span class="inlinecode"><span class="id" title="var">I_ind</span></span> dla <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    JeÅ¼eli smuci ciÄ™ burdel nazewniczy, to nie przejmuj siÄ™ - kiedyÅ› bÄ™dzie
    lepiej. Klasyfikacja reguÅ‚ jest prosta:
<ul class="doclist">
<li> reguÅ‚y mogÄ… byÄ‡ zaleÅ¼ne lub nie, w zaleÅ¼noÅ›ci od tego czy <span class="inlinecode"><span class="id" title="var">P</span></span> zaleÅ¼y
      od <span class="inlinecode"><span class="id" title="var">I</span></span>

</li>
<li> reguÅ‚y mogÄ… byÄ‡ rekurencyjne lub nie

</li>
<li> reguÅ‚y mogÄ… byÄ‡ dla sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> albo nawet <span class="inlinecode"><span class="id" title="keyword">Set</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="keyword">rec</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab142"></a><h3 class="section">Parametry</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">param</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">c0</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">c1</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">c2</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
KolejnÄ… innowacjÄ… sÄ… parametry, ktÃ³rych gÅ‚Ã³wnym zastosowaniem jest
    polimorfizm. DziÄ™ki parametrom moÅ¼emy za jednym zamachem (tylko bez
    skojarzeÅ„ z Islamem!) zdefiniowaÄ‡ nieskoÅ„czenie wiele typÃ³w, po jednym
    dla kaÅ¼dego parametru. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ rekursora jest oczywisty: jeÅ¼eli znajdziemy rzeczy o ksztaÅ‚tach
    takich jak konstruktory <span class="inlinecode"><span class="id" title="var">I</span></span> z <span class="inlinecode"><span class="id" title="var">I</span></span> zastÄ…pionym przez <span class="inlinecode"><span class="id" title="var">P</span></span>, to moÅ¼emy
    zrobiÄ‡ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jako, Å¼e parametry sÄ… zawsze takie samo,
    moÅ¼emy skwantyfikowaÄ‡ je na samym poczÄ…tku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c1'</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c2'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c1'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c2'</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c1'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c1</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c2'</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> (<span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">P</span> <span class="id" title="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
A reguÅ‚Ä™ indukcjÄ™ uzyskujemy przez uzaleÅ¼nienie <span class="inlinecode"><span class="id" title="var">P</span></span> od <span class="inlinecode"><span class="id" title="var">I</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c1'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c1</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c2'</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> (<span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">P</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c1'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c2'</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">param</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab143"></a><h3 class="section">Indukcja wzajemna</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">mutual</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Smok</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">Smok</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Zmok</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">Zmok</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja wzajemna pozwala definiowaÄ‡ na raz wiele typÃ³w, ktÃ³re mogÄ…
    odwoÅ‚ywaÄ‡ siÄ™ do siebie nawzajem. CytujÄ…c klasykÃ³w: smok to wysuszony
    zmok, zmok to zmoczony smok. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">S</span>) -&gt; <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">S</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">Z</span>) -&gt; <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">Z</span>.<br/>

<br/>
</div>

<div class="doc">
ReguÅ‚a niezaleÅ¼nej analizy przypadkÃ³w dla <span class="inlinecode"><span class="id" title="var">Smok</span></span>a wyglÄ…da banalnie:
    jeÅ¼eli ze <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a potrafimy wyprodukowaÄ‡ <span class="inlinecode"><span class="id" title="var">S</span></span>, to ze <span class="inlinecode"><span class="id" title="var">Smok</span></span>a teÅ¼.
    Dla <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a jest analogicznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Wy</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">S</span>) (<span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>) : <span class="id" title="var">S</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">smok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span> =&gt; <span class="id" title="var">Wy</span> <span class="id" title="var">zmok</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Zm</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">Z</span>) (<span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>) : <span class="id" title="var">Z</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">zmok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span> =&gt; <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_rec_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) -&gt; (<span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) -&gt; <span class="id" title="var">Smok</span> -&gt; <span class="id" title="var">S</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_rec_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) -&gt; (<span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) -&gt; <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="var">Z</span>.<br/>

<br/>
</div>

<div class="doc">
Typ rekursora jest jednak nieco bardziej zaawansowany. Å»eby zdefiniowaÄ‡
    funkcjÄ™ typu <span class="inlinecode"><span class="id" title="var">Smok</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span>, musimy mieÄ‡ nie tylko rzeczy w ksztaÅ‚cie
    konstruktorÃ³w <span class="inlinecode"><span class="id" title="var">Smok</span></span>a, ale takÅ¼e w ksztaÅ‚cie konstruktorÃ³w <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a,
    gdyÅ¼ rekurencyjna struktura obu typÃ³w jest ze sobÄ… nierozerwalnie
    zwiÄ…zana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">Smok_rec</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Wy</span> : <span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) (<span class="id" title="var">Zm</span> : <span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) (<span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>) : <span class="id" title="var">S</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">smok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span> =&gt; <span class="id" title="var">Wy</span> (<span class="id" title="var">Zmok_rec</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">zmok</span>)<br/>
<span class="id" title="keyword">end</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Zmok_rec</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> <span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Wy</span> : <span class="id" title="var">Z</span> -&gt; <span class="id" title="var">S</span>) (<span class="id" title="var">Zm</span> : <span class="id" title="var">S</span> -&gt; <span class="id" title="var">Z</span>) (<span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>) : <span class="id" title="var">Z</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">zmok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span> =&gt; <span class="id" title="var">Zm</span> (<span class="id" title="var">Smok_rec</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja wymaga rekursji wzajemnej, ale poza nie jest jakoÅ›
    wybitnie groÅºna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Smok_ind_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Zmok_ind_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">Smok_ind</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>) : <span class="id" title="var">S</span> <span class="id" title="var">smok</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">smok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span> =&gt; <span class="id" title="var">Wy</span> <span class="id" title="var">zmok</span> (<span class="id" title="var">Zmok_ind</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">zmok</span>)<br/>
<span class="id" title="keyword">end</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Zmok_ind</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="var">Smok</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">Z</span> : <span class="id" title="var">Zmok</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Wy</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>, <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">Wysuszony</span> <span class="id" title="var">zmok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Zm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">smok</span> : <span class="id" title="var">Smok</span>, <span class="id" title="var">S</span> <span class="id" title="var">smok</span> -&gt; <span class="id" title="var">Z</span> (<span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">zmok</span> : <span class="id" title="var">Zmok</span>) : <span class="id" title="var">Z</span> <span class="id" title="var">zmok</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">zmok</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zmoczony</span> <span class="id" title="var">smok</span> =&gt; <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span> (<span class="id" title="var">Smok_ind</span> <span class="id" title="var">S</span> <span class="id" title="var">Z</span> <span class="id" title="var">Wy</span> <span class="id" title="var">Zm</span> <span class="id" title="var">smok</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
MajÄ…c rekursor, napisanie typu reguÅ‚y indukcji jest banalne, podobnie
    jak jego implementacja. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">mutual</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab144"></a><h3 class="section">Indeksy</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">index</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">I</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">I</span> 42.<br/>

<br/>
</div>

<div class="doc">
OstatniÄ… poznanÄ… przez nas innowacjÄ… sÄ… typy indeksowane. Tutaj rÃ³wnieÅ¼
    definiujemy za jednym zamachem (ekhem...) duÅ¼o typÃ³w, ale nie sÄ… one
    niezaleÅ¼ne jak w przypadku parametrÃ³w, lecz mogÄ… od siebie wzajemnie
    zaleÅ¼eÄ‡. SÅ‚owem, tak naprawdÄ™ definiujemy przez indukcjÄ™ funkcjÄ™
    typu <span class="inlinecode"><span class="id" title="var">A_1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A_n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>/<span class="id" title="keyword">Prop</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A_i</span></span> to indeksy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_very_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_very_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;{<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">c42'</span> <span class="id" title="var">n</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
MoÅ¼liwych reguÅ‚ analizy przypadkÃ³w mamy tutaj trochÄ™ wiÄ™cej niÅ¼ w
    przypadku parametrÃ³w. W powyÅ¼szej regule <span class="inlinecode"><span class="id" title="var">P</span></span> nie zaleÅ¼y od indeksu
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span> 0) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span> 42),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_nondep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">c0'</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">P</span> 0) (<span class="id" title="var">c42'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">P</span> 42)<br/>
&nbsp;&nbsp;{<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">c42'</span> <span class="id" title="var">n</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
... a w powyÅ¼szej tak. Jako, Å¼e indeksy zmieniajÄ… siÄ™ pomiÄ™dzy
    konstruktorami, kaÅ¼dy z nich musi kwantyfikowaÄ‡ je osobno (co akurat
    nie jest potrzebne w naszym przykÅ‚adzie, gdyÅ¼ jest zbyt prosty). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> 0 (<span class="id" title="var">c0</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c42'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> 42 (<span class="id" title="var">c42</span> <span class="id" title="var">n</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>), <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">i</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_case_dep</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">I</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> 0 (<span class="id" title="var">c0</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">c42'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> 42 (<span class="id" title="var">c42</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">i</span> : <span class="id" title="var">I</span> <span class="id" title="var">n</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">i</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">c0'</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c42</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">c42'</span> <span class="id" title="var">n</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
OgÃ³lnie reguÅ‚a jest taka: reguÅ‚a niezaleÅ¼na (pierwsza) nie zaleÅ¼y od
    niczego, a zaleÅ¼na (trzecia) zaleÅ¼y od wszystkiego. ReguÅ‚a druga jest
    poÅ›rednia - ot, take ciepÅ‚e kluchy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">index</span>.<br/>

<br/>
</div>

<div class="doc">
Nie zapomnijmy ponownie nakazaÄ‡ Coqowi generowania reguÅ‚ indukcji. 
</div>
<div class="code">
<span class="id" title="keyword">Set</span> <span class="id" title="var">Elimination</span> <span class="id" title="var">Schemes</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab145"></a><h2 class="section">Indukcja-indukcja</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ind_ind</span>.<br/>

<br/>
</div>

<div class="doc">
Po powtÃ³rce nadszedÅ‚ czas nowoÅ›ci. Zacznijmy od nazwy, ktÃ³ra jest iÅ›cie
    kretyÅ„ska: indukcja-indukcja. KaÅ¼dy rozsÄ…dny czÅ‚owiek zgodzi siÄ™,
    Å¼e duÅ¼o lepszÄ… nazwÄ… byÅ‚oby coÅ› w stylu "indukcja wzajemna indeksowana".

<div class="paragraph"> </div>

    Ta alternatywna nazwa rzuca sporo Å›wiatÅ‚a: indukcja-indukcja to poÅ‚Ä…czenie
    i uogÃ³lnienie mechanizmÃ³w definiowania typÃ³w wzajemnie induktywnych oraz
    indeksowanych typÃ³w induktywnych.

<div class="paragraph"> </div>

    Typy wzajemnie induktywne mogÄ… odnosiÄ‡ siÄ™ do siebie nawzajem, ale co
    to dokÅ‚adnie znaczy? Ano to, Å¼e konstruktory kaÅ¼dego typu mogÄ… braÄ‡
    argumenty wszystkch innych typÃ³w definiowanych jednoczeÅ›nie z nim. To
    jest clou caÅ‚ej sprawy: konstruktory.

<div class="paragraph"> </div>

    A co to ma do typÃ³w indeksowanych? Ano, zastanÃ³wmy siÄ™, co by siÄ™ staÅ‚o,
    gdybyÅ›my chcieli zdefiniowaÄ‡ przez wzajemnÄ… indukcjÄ™ typ <span class="inlinecode"><span class="id" title="var">A</span></span> oraz rodzinÄ™
    typÃ³w <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. OtÃ³Å¼ nie da siÄ™: konstruktory <span class="inlinecode"><span class="id" title="var">A</span></span> mogÄ… odnosiÄ‡
    siÄ™ do <span class="inlinecode"><span class="id" title="var">B</span></span> i vice-versa, ale <span class="inlinecode"><span class="id" title="var">A</span></span> nie moÅ¼e byÄ‡ indeksem <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Indukcja-indukcja to coÅ›, co... tam taram tam tam... pozwala wÅ‚aÅ›nie na
    to: moÅ¼emy jednoczeÅ›nie zdefiniowaÄ‡ typ i indeksowanÄ… nim rodzinÄ™ typÃ³w.
    I wszystko to ukryte pod takÄ… smutnÄ… nazwÄ…... lobby teoriotypowe nie
    chciaÅ‚o, Å¼ebyÅ› siÄ™ o tym dowiedziaÅ‚.

<div class="paragraph"> </div>

    Czas na przykÅ‚ad! 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span><br/>
<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">slist</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">snil</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">scons</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">A</span>), <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">A</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">ok</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ok_snil</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">ok</span> <span class="id" title="var">x</span> <span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> -&gt; <span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>).<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;reference&nbsp;slist&nbsp;was&nbsp;not&nbsp;found&nbsp;in&nbsp;the&nbsp;current&nbsp;environment.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jako siÄ™ juÅ¼ wczeÅ›niej rzekÅ‚o, indukcja-indukcja nie jest wspierana
    przez Coqa - powyÅ¼sza definicja koÅ„czy siÄ™ informacjÄ… o bÅ‚Ä™dzie: Coq
    nie widzi <span class="inlinecode"><span class="id" title="var">slist</span></span> kiedy czyta indeksy <span class="inlinecode"><span class="id" title="var">ok</span></span> wÅ‚aÅ›nie dlatego, Å¼e nie
    dopuszcza on moÅ¼liwoÅ›ci jednoczesnego definiowania rodziny (w tym
    wypadku relacji) <span class="inlinecode"><span class="id" title="var">ok</span></span> wraz z jednym z jej indeksÃ³w, <span class="inlinecode"><span class="id" title="var">slist</span></span>.

<div class="paragraph"> </div>

    BÄ™dziemy zatem musieli poradziÄ‡ sobie z przykÅ‚adem jakoÅ› inaczej -
    po prostu damy go sobie za pomocÄ… aksjomatÃ³w. Zanim jednak to zrobimy,
    omÃ³wimy go dokÅ‚adniej, gdyÅ¼ deklarowanie aksjomatÃ³w jest niebezpieczne
    i nie chcemy siÄ™ pomyliÄ‡.

<div class="paragraph"> </div>

    ZamysÅ‚em powyÅ¼szego przykÅ‚adu byÅ‚o zdefiniowanie typu list posortowanych
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> peÅ‚ni rolÄ™ relacji porzÄ…dku, jednoczeÅ›nie z relacjÄ…
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> wyraÅ¼a, Å¼e dostawienie <span class="inlinecode"><span class="id" title="var">x</span></span>
    na poczÄ…tek listy posortowanej <span class="inlinecode"><span class="id" title="var">l</span></span> daje listÄ™ posortowanÄ….

<div class="paragraph"> </div>

    PrzykÅ‚ad jest oczywiÅ›cie doÅ›Ä‡ bezsensowny, bo dokÅ‚adnie to samo moÅ¼na
    osiÄ…gnÄ…Ä‡ bez uÅ¼ywania indukcji-indukcji - wystarczy najpierw zdefiniowaÄ‡
    listy, a potem relacjÄ™ bycia listÄ… posortowanÄ…, a na koniec zapakowaÄ‡
    wszystko razem. Nie bÄ™dziemy siÄ™ tym jednak przejmowaÄ‡.

<div class="paragraph"> </div>

    Definicja <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> jest nastÄ™pujÄ…ca:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">snil</span></span> to lista pusta

</li>
<li> <span class="inlinecode"><span class="id" title="var">scons</span></span> robi posortowanÄ… listÄ™ z gÅ‚owy <span class="inlinecode"><span class="id" title="var">h</span></span> i ogona <span class="inlinecode"><span class="id" title="var">t</span></span> pod warunkiem, Å¼e
      dostanie teÅ¼ dowÃ³d zdania <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> mÃ³wiÄ…cego, Å¼e moÅ¼na dostawiÄ‡ <span class="inlinecode"><span class="id" title="var">h</span></span> na
      poczÄ…tek listy <span class="inlinecode"><span class="id" title="var">t</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Definicja <span class="inlinecode"><span class="id" title="var">ok</span></span> teÅ¼ jest banalna:
<ul class="doclist">
<li> kaÅ¼dy <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> moÅ¼e byÄ‡ dostawiony do pustej listy

</li>
<li> jeÅ¼eli mamy listÄ™ <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> oraz element <span class="inlinecode"><span class="id" title="var">x</span></span>, o ktÃ³rym wiemy,
      Å¼e jest mniejszy od <span class="inlinecode"><span class="id" title="var">h</span></span>, tzn. <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, to <span class="inlinecode"><span class="id" title="var">x</span></span> moÅ¼e zostaÄ‡ dostawiony
      do listy <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Jak powinny wyglÄ…daÄ‡ reguÅ‚y rekursji oraz indukcji? Na szczÄ™Å›cie wciÄ…Å¼
    dziaÅ‚ajÄ… schematy, ktÃ³re wypracowaliÅ›my dotychczas.

<div class="paragraph"> </div>

    ReguÅ‚a rekursji mÃ³wi, Å¼e jeÅ¼eli znajdziemy w typie <span class="inlinecode"><span class="id" title="var">P</span></span> coÅ› o ksztaÅ‚cie
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a w relacji <span class="inlinecode"><span class="id" title="var">Q</span></span> coÅ› o ksztaÅ‚cie <span class="inlinecode"><span class="id" title="var">ok</span></span>, to moÅ¼emy zdefiniowaÄ‡
    funkcjÄ™ <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>),</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>.

<div class="paragraph"> </div>

    ReguÅ‚e indukcji moÅ¼na uzyskaÄ‡ dodajÄ…c tyle zaleÅ¼noÅ›ci, ile tylko zdoÅ‚amy
    unieÅ›Ä‡.

<div class="paragraph"> </div>

    Zobaczmy wiÄ™c, jak zrealizowaÄ‡ to wszystko za pomocÄ… aksjomatÃ³w. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">slist</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Prop</span>).<br/>

<br/>
</div>

<div class="doc">
Najpierw musimy zadeklarowaÄ‡ <span class="inlinecode"><span class="id" title="var">slist</span></span>, gdyÅ¼ wymaga tego typ <span class="inlinecode"><span class="id" title="var">ok</span></span>. Obie
    definicje wyglÄ…dajÄ… dokÅ‚adnie tak, jak nagÅ‚Ã³wki w powyÅ¼szej definicji
    odrzuconej przez Coqa.

<div class="paragraph"> </div>

    WidaÄ‡ teÅ¼, Å¼e gdybyÅ›my chcieli zdefiniowaÄ‡ rodziny <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>, ktÃ³re sÄ…
    nawzajem swoimi indeksami, to nie moglibyÅ›my tego zrobiÄ‡ nawet za pomocÄ…
    aksjomatÃ³w. Rodzi to pytanie o to, ktÃ³re dokÅ‚adnie definicje przez
    indukcjÄ™-indukcjÄ™ sÄ… legalne. OdpowiedÅº brzmi: nie wiem, ale moÅ¼e kiedyÅ›
    siÄ™ dowiem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">snil</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}, <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">ok</span> <span class="id" title="var">x</span> (@<span class="id" title="var">snil</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> -&gt; <span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)).<br/>

<br/>
</div>

<div class="doc">
NastÄ™pnie definiujemy konstruktory: najpierw konstruktory <span class="inlinecode"><span class="id" title="var">slist</span></span>, a
    potem <span class="inlinecode"><span class="id" title="var">ok</span></span>. Musimy to zrobiÄ‡ w tej kolejnoÅ›ci, bo konstruktor <span class="inlinecode"><span class="id" title="var">ok_snil</span></span>
    odnosi siÄ™ do <span class="inlinecode"><span class="id" title="var">snil</span></span>, a <span class="inlinecode"><span class="id" title="var">ok_scons</span></span> do <span class="inlinecode"><span class="id" title="var">scons</span></span>.

<div class="paragraph"> </div>

    Znowu widzimy, Å¼e gdyby konstruktory obu typÃ³w odnosiÅ‚y siÄ™ do siebie
    nawzajem, to nie moglibyÅ›my zdefiniowaÄ‡ takiego typu aksjomatycznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Q</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>), <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Psnil</span> : <span class="id" title="var">P</span> <span class="id" title="var">snil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pscons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">Q</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Qok_snil</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">Q</span> <span class="id" title="var">x</span> <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Qok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">Q</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> -&gt; <span class="id" title="var">Q</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) (<span class="id" title="var">ok_scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span>) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">g</span> : (<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>), <span class="id" title="var">Q</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">Psnil</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">Pscons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>) (<span class="id" title="var">g</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">x</span> <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> <span class="id" title="var">x</span>) = <span class="id" title="var">Qok_snil</span> <span class="id" title="var">x</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) (<span class="id" title="var">ok_scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Qok_scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>) (<span class="id" title="var">g</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}}).<br/>

<br/>
</div>

<div class="doc">
Ugh, co za potfur. SprÃ³bujmy rozÅ‚oÅ¼yÄ‡ go na czynniki pierwsze.

<div class="paragraph"> </div>

    Przede wszystkim, Å¼eby za duÅ¼o nie pisaÄ‡, zobaczymy tylko reguÅ‚Ä™ indukcji.
    Teoretycznie powinny to byÄ‡ dwie reguÅ‚y (tak jak w przypadku <span class="inlinecode"><span class="id" title="var">Smok</span></span>a i
    <span class="inlinecode"><span class="id" title="var">Zmok</span></span>a) - jedna dla <span class="inlinecode"><span class="id" title="var">slist</span></span> i jedna dla <span class="inlinecode"><span class="id" title="var">ok</span></span>, ale Å¼eby za duÅ¼o nie
    pisaÄ‡, moÅ¼emy zapisaÄ‡ je razem.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">A</span></span> i relacja <span class="inlinecode"><span class="id" title="var">R</span></span> sÄ… parametrami obu definicji, wiÄ™c skwantyfikowane
    sÄ… na samym poczÄ…tku. Nasza reguÅ‚a pozwala nam zdefiniowaÄ‡ przez wzajemnÄ…
    rekursjÄ™ dwie funkcje, <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>)</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>),</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Tak wiÄ™c <span class="inlinecode"><span class="id" title="var">P</span></span>
    to kodziedzina <span class="inlinecode"><span class="id" title="var">f</span></span>, a <span class="inlinecode"><span class="id" title="var">Q</span></span> - <span class="inlinecode"><span class="id" title="var">g</span></span>.

<div class="paragraph"> </div>

    Teraz potrzebujemy rozwaÅ¼yÄ‡ wszystkie moÅ¼liwe przypadki - tak jak przy
    dopasowaniu do wzorca. Przypadek <span class="inlinecode"><span class="id" title="var">snil</span></span> jest doÅ›Ä‡ banalny. Przypadek
    <span class="inlinecode"><span class="id" title="var">scons</span></span> jest trochÄ™ ciÄ™Å¼szy. Przede wszystkim chcemy, Å¼eby konkluzja
    byÅ‚a postaci <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span>, ale jak powinny wyglÄ…daÄ‡ hipotezy
    indukcyjne?

<div class="paragraph"> </div>

    Jedyna sÅ‚uszna odpowiedÅº brzmi: odpowiadajÄ… one typom wszystkich moÅ¼liwych
    wywoÅ‚aÅ„ rekurencyjnych <span class="inlinecode"><span class="id" title="var">f</span></span> i <span class="inlinecode"><span class="id" title="var">g</span></span> na strukturalnych podtermach
    <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Jedynymi typami speÅ‚niajÄ…cymi te warunki sÄ… <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, wiÄ™c dajemy je sobie jako hipotezy indukcyjne.

<div class="paragraph"> </div>

    Przypadki dla <span class="inlinecode"><span class="id" title="var">Q</span></span> wyglÄ…dajÄ… podobnie: <span class="inlinecode"><span class="id" title="var">ok_snil</span></span> jest banalne, a dla
    <span class="inlinecode"><span class="id" title="var">ok_scons</span></span> konkluzja musi byÄ‡ jedynej sÅ‚usznej postaci, a hipotezami
    indukcyjnymi jest wszystko, co pasuje.

<div class="paragraph"> </div>

    W efekcie otrzymujemy dwie funkcje, <span class="inlinecode"><span class="id" title="var">f</span></span> i <span class="inlinecode"><span class="id" title="var">g</span></span>. Tym razem nastÄ™puje jednak
    maÅ‚y twist: poniewaÅ¼ nasza definicja jest aksjomatyczna, zagwarantowaÄ‡
    musimy sobie takÅ¼e reguÅ‚y obliczania, ktÃ³re dotychczas byÅ‚y zamilaczne,
    bo wynikaÅ‚y z definicji przez dopasowanie do wzorca. Teraz wszystkie te
    "dopasowania" musimy napisaÄ‡ rÄ™cznie w postaci odpowiednio
    skwantyfikowanych rÃ³wnaÅ„. Widzimy wiÄ™c, Å¼e <span class="inlinecode"><span class="id" title="var">Psnil</span></span>, <span class="inlinecode"><span class="id" title="var">Pscons</span></span>, <span class="inlinecode"><span class="id" title="var">Qok_snil</span></span>
    i <span class="inlinecode"><span class="id" title="var">Qok_scons</span></span> odpowiadajÄ… klauzulom w dopasowaniu do wzorca.

<div class="paragraph"> </div>

    Ufff... udaÅ‚o siÄ™. Tak spreparowanÄ… definicjÄ… aksjomatycznÄ… moÅ¼emy siÄ™
    jako-tako posÅ‚ugiwaÄ‡: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">rec'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">snil'</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">scons'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">P</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">snil'</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">scons'</span> <span class="id" title="var">h</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span><br/>
&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">A</span> <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">P</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">True</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">t</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">scons'</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">I</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">I</span>)<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">g</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span> &amp; <span class="id" title="var">H3</span> &amp; <span class="id" title="var">H4</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H2</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
MoÅ¼emy na przykÅ‚ad doÅ›Ä‡ Å‚atwo zdefiniowaÄ‡ niezaleÅ¼ny rekursor tylko dla
    <span class="inlinecode"><span class="id" title="var">slist</span></span>, nie odnoszÄ…cy siÄ™ w Å¼aden sposÃ³b do <span class="inlinecode"><span class="id" title="var">ok</span></span>. Widzimy jednak, Å¼e
    "programowanie" w taki aksjomatyczny sposÃ³b jest doÅ›Ä‡ ciÄ™Å¼kie - zamiast
    eleganckich dopasowaÅ„ do wzorca musimy rÄ™cznie wpisywaÄ‡ argumenty do
    reguÅ‚y indukcyjnej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = [] /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">h</span> :: <span class="id" title="var">f</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">rec'</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) [] <span class="id" title="var">cons</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>} : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">proj1_sig</span> <span class="id" title="var">toList'</span>.<br/>

<br/>
</div>

<div class="doc">
UÅ¼ywanie takiego rekursora jest juÅ¼ duÅ¼o prostsze, co ilustruje powyÅ¼szy
    przykÅ‚ad funkcji, ktÃ³ra zapomina o tym, Å¼e lista jest posortowana i daje
    nam zwykÅ‚Ä… listÄ™.

<div class="paragraph"> </div>

    PrzykÅ‚adowe posortowane listy wyglÄ…dajÄ… tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">le</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">scons</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> 1 <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> 1) 0 (<span class="id" title="var">le_S</span> 0 0 (<span class="id" title="var">le_n</span> 0))).<br/>

<br/>
</div>

<div class="doc">
Niezbyt piÄ™kna, prawda? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span>.<br/>

<br/>
</div>

<div class="doc">
Utrapieniem jest teÅ¼ to, Å¼e nasza funkcja siÄ™ nie oblicza. Jest tak, bo
    zostaÅ‚a zdefiniowana za pomocÄ… reguÅ‚y indukcji, ktÃ³ra jest aksjomatem.
    Aksjomaty zaÅ›, jak wiadomo, nie obliczajÄ… siÄ™.

<div class="paragraph"> </div>

    Wyniku powyÅ¼szego wywoÅ‚ania nie bÄ™dÄ™ nawet wklejaÅ‚, gdyÅ¼ jest naprawdÄ™
    ohydny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">toList_slist_01_result</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span> = [0; 1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">toList</span>, <span class="id" title="var">slist_01</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">toList'</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">H2</span>, <span class="id" title="var">H1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Najlepsze, co moÅ¼emy osiÄ…gnÄ…Ä‡, majÄ…c takÄ… definicjÄ™, to udowodnienie, Å¼e
    jej wynik faktycznie jest taki, jak siÄ™ spodziewamy. 
<div class="paragraph"> </div>

<a name="lab146"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj dla list posortowanych funkcjÄ™ <span class="inlinecode"><span class="id" title="var">slen</span></span>, ktÃ³ra liczy ich dÅ‚ugoÅ›Ä‡.
    Udowodnij oczywiste twierdzenie wiÄ…Å¼Ä…ce ze sobÄ… <span class="inlinecode"><span class="id" title="var">slen</span></span>, <span class="inlinecode"><span class="id" title="var">toList</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">length</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab147"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, Å¼e przykÅ‚ad faktycznie jest bez sensu: zdefiniuje relacjÄ™
    <span class="inlinecode"><span class="id" title="var">sorted</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">sorted</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>
    oznacza, Å¼e lista <span class="inlinecode"><span class="id" title="var">l</span></span> jest posortowana wedÅ‚ug porzÄ…dku <span class="inlinecode"><span class="id" title="var">R</span></span>. UÅ¼ywajÄ…c
    <span class="inlinecode"><span class="id" title="var">sorted</span></span> zdefiniuj typ list posortowanych <span class="inlinecode"><span class="id" title="var">slist'</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a nastÄ™pnie znajdÅº
    dwie funkcje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">slist'</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist'</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>,
    ktÃ³re sÄ… swoimi odwrotnoÅ›ciami. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab148"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Å»eby przekonaÄ‡ siÄ™, Å¼e przykÅ‚ad byÅ‚ naprawdÄ™ bezsensowny, zdefiniuj
    rodzinÄ™ typÃ³w <span class="inlinecode"><span class="id" title="var">blist</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, gdzie elementami
    <span class="inlinecode"><span class="id" title="var">blist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> sÄ… listy posortowane, ktÃ³rych elementy sÄ… <span class="inlinecode"><span class="id" title="var">R</span></span>-wiÄ™ksze od <span class="inlinecode"><span class="id" title="var">x</span></span>.
    UÅ¼yj <span class="inlinecode"><span class="id" title="var">blist</span></span> do zdefiniowania typu <span class="inlinecode"><span class="id" title="var">slist''</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a nastÄ™pnie udowodnij,
    Å¼e <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">slist''</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> sÄ… sobie rÃ³wnowaÅ¼ne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ind_ind</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab149"></a><h4 class="section"> </h4>

<div class="paragraph"> </div>

 Na koniec wypadaÅ‚oby jeszcze wspomnieÄ‡, do czego tak naprawdÄ™ moÅ¼na w
    praktyce uÅ¼yÄ‡ indukcji-indukcji (definiowanie list posortowanych nie
    jest jednÄ… z tych rzeczy, o czym przekonaÅ‚eÅ› siÄ™ w Ä‡wiczeniach). OtÃ³Å¼
    najciekawszym przykÅ‚adem wydaje siÄ™ byÄ‡ formalizacja teorii typÃ³w, czyli,
    parafrazujÄ…c, implementacja Coqa w Coqu.

<div class="paragraph"> </div>

    Å»eby siÄ™ za to zabraÄ‡, musimy zdefiniowaÄ‡ konteksty, typy i termy, a
    takÅ¼e relacje konwertowalnoÅ›ci dla typÃ³w i termÃ³w. SÄ… tutaj moÅ¼liwe dwa
    podejÅ›cia:
<ul class="doclist">
<li> Curry'ego (ang. Curry style lub mÄ…drzej extrinsic style) - staramy
      siÄ™ definiowaÄ‡ wszystko osobno, a potem zdefiniowaÄ‡ relacje "term x
      jest typu A w kontekÅ›cie Î“", "typ A jest poprawnie sformowany w
      kontekÅ›cie Î“" etc. NajwaÅ¼niejszÄ… cechÄ… tego sposobu jest to, Å¼e
      moÅ¼emy tworzyÄ‡ termy, ktÃ³rym nie da siÄ™ przypisaÄ‡ Å¼adnego typu oraz
      typy, ktÃ³re nie sÄ… poprawnie sformowane w Å¼adnym kontekÅ›cie.

</li>
<li> Churcha (ang. Church style lub mÄ…drzej intrinsic style) - definiujemy
      wszystko na raz w jednej wielkiej wzajemnej indukcji. ZamiastÃ³w
      typÃ³w definiujemy od razu predykat "typ A jest poprawnie sformowany
      w kontekÅ›cie Î“", a zamiast termÃ³w definiujemy od razu relacjÄ™
      "term x ma typ A w kontekÅ›cie Î“". ParafrazujÄ…c - wszystkie termy,
      ktÃ³re jesteÅ›my w stanie skonstruowaÄ‡, sÄ… poprawnie typowane (a
      wszystkie typy poprawnie sformowane w swoich kontekstach). 
</li>
</ul>

<div class="paragraph"> </div>

 Zamiast tyle gadaÄ‡ zobaczmy, jak mogÅ‚oby to wyglÄ…daÄ‡ w Coqu. OczywiÅ›cie
    bÄ™dÄ… to same nagÅ‚Ã³wki, bo podanie tutaj peÅ‚nej definicji byÅ‚oby mocno
    zaciemniajÄ…cym przegiÄ™ciem. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;Ctx&nbsp;:&nbsp;Type&nbsp;:=&nbsp;...<br/>
<br/>
with&nbsp;Ty&nbsp;:&nbsp;Ctx&nbsp;-&gt;&nbsp;Type&nbsp;:=&nbsp;...<br/>
<br/>
with&nbsp;Term&nbsp;:&nbsp;forall&nbsp;Î“&nbsp;:&nbsp;Ctx,&nbsp;Ty&nbsp;Î“&nbsp;-&gt;&nbsp;Type&nbsp;:=&nbsp;...<br/>
<br/>
with&nbsp;TyConv&nbsp;:&nbsp;forall&nbsp;Î“&nbsp;:&nbsp;Ctx,&nbsp;Ty&nbsp;Î“&nbsp;-&gt;&nbsp;Ty&nbsp;Î“&nbsp;-&gt;&nbsp;Prop&nbsp;:=&nbsp;...<br/>
<br/>
with<br/>
&nbsp;&nbsp;TermConv&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(Î“&nbsp;:&nbsp;Ctx)&nbsp;(A&nbsp;:&nbsp;Ty&nbsp;Î“),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Term&nbsp;Î“&nbsp;A&nbsp;-&gt;&nbsp;Term&nbsp;Î“&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=&nbsp;...<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
NagÅ‚Ã³wki w tej definicji powinniÅ›my interpretowaÄ‡ tak:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">Ctx</span></span> to typ reprezentujÄ…cy konteksty.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Ty</span></span> ma reprezentowaÄ‡ typy, ale nie jest to typ, lecz rodzina typÃ³w
      indeksowana kontekstami - kaÅ¼dy typ jest typem w jakimÅ› kontekÅ›cie,
      np. <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem w kontekÅ›cie zawierajÄ…cym <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, ale
      nie jest typem w pustym kontekÅ›cie.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Term</span></span> ma reprezentowaÄ‡ termy, ale nie jest to typ, lecz rodzina typÃ³w
      indeksowana kontekstami i typami - kaÅ¼dy term ma jakiÅ› typ, a typy,
      jak juÅ¼ siÄ™ rzekÅ‚o, zawsze sÄ… typami w jakimÅ› kontekÅ›cie. PrzykÅ‚ad:
      jeÅ¼eli <span class="inlinecode"><span class="id" title="var">x</span></span> jest zmiennÄ…, to <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">nil</span></span> jest typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> w
      kontekÅ›cie, w ktÃ³rym <span class="inlinecode"><span class="id" title="var">x</span></span> jest typu <span class="inlinecode"><span class="id" title="var">A</span></span>, ale nie ma Å¼adnego typu (i nie
      jest nawet poprawnym termem) w kontekÅ›cie pustym ani w Å¼adnym, w ktÃ³rym
      nie wystÄ™puje <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">TyConv</span></span> <span class="inlinecode"><span class="id" title="var">Î“</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> zachodzi, gdy typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> sÄ… konwertowalne, czyli
      obliczajÄ… siÄ™ do tego samego (relacja taka jest potrzebna, gdyÅ¼ w Coqu
      i ogÃ³lnie w teorii typÃ³w wystÄ™powaÄ‡ mogÄ… takie typy jak <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span>
      <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, ktÃ³ry jest konwertowalny z <span class="inlinecode"><span class="id" title="var">nat</span></span>). Jako siÄ™ rzekÅ‚o,
      typy zawsze wystÄ™pujÄ… w kontekÅ›cie, wiÄ™c konwertowalne mogÄ… byÄ‡ teÅ¼
      tylko w kontekÅ›cie.

</li>
<li> <span class="inlinecode"><span class="id" title="var">TermConv</span></span> <span class="inlinecode"><span class="id" title="var">Î“</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> znaczy, Å¼e termy <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> sÄ… konwertowalne,
      np. <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode">0</span> jest konwertowalne z <span class="inlinecode">42</span>. PoniewaÅ¼ kaÅ¼dy
      term ciÄ…gnie za sobÄ… swÃ³j typ, <span class="inlinecode"><span class="id" title="var">TermConv</span></span> ma jako indeks typ <span class="inlinecode"><span class="id" title="var">A</span></span>, a
      poniewaÅ¼ typ ciÄ…gnie za sobÄ… kontekst, indeksem <span class="inlinecode"><span class="id" title="var">TermConv</span></span> jest takÅ¼e
      <span class="inlinecode"><span class="id" title="var">Î“</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Jak widaÄ‡, indukcji-indukcji jest w powyÅ¼szym przykÅ‚adzie na pÄ™czki -
    jest ona wrÄ™cz teleskopowa, gdyÅ¼ <span class="inlinecode"><span class="id" title="var">Ctx</span></span> jest indeksem <span class="inlinecode"><span class="id" title="var">Ty</span></span>, <span class="inlinecode"><span class="id" title="var">Ctx</span></span> i <span class="inlinecode"><span class="id" title="var">Ty</span></span>
    sÄ… indeksami <span class="inlinecode"><span class="id" title="var">Term</span></span>, a <span class="inlinecode"><span class="id" title="var">Ctx</span></span>, <span class="inlinecode"><span class="id" title="var">Ty</span></span> i <span class="inlinecode"><span class="id" title="var">Term</span></span> sÄ… indeksami <span class="inlinecode"><span class="id" title="var">TermConv</span></span>.

<div class="paragraph"> </div>

    CÃ³Å¼, to by byÅ‚o na tyle w tym temacie. Åawa oburzonych wyraÅ¼a w tym
    momencie swoje najwyÅ¼sze oburzenie na brak indukcji-indukcji w Coqu:
    https://www.sadistic.pl/lawa-oburzonych-vt22270.htm

<div class="paragraph"> </div>

    Jednak uszy do gÃ³ry - istniejÄ… juÅ¼ jÄ™zyki, ktÃ³re jakoÅ› sobie radzÄ… z
    indukcjÄ…-indukcjÄ…. Jednym z nich jest wspomniana we wstÄ™pie Agda,
    ktÃ³rÄ… moÅ¼na znaleÅºÄ‡ tu:
    https://agda.readthedocs.io/en/latest/ 
<div class="paragraph"> </div>

<a name="lab150"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Typ stert binarnych <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest relacjÄ…
    porzÄ…dku, skÅ‚ada siÄ™ z drzew, ktÃ³re mogÄ… byÄ‡ albo puste, albo byÄ‡ wÄ™zÅ‚em
    przechowujÄ…cym wartoÅ›Ä‡ <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wraz z dwoma poddrzewami <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>,
    przy czym <span class="inlinecode"><span class="id" title="var">v</span></span> musi byÄ‡ <span class="inlinecode"><span class="id" title="var">R</span></span>-wiÄ™ksze od wszystkich elementÃ³w <span class="inlinecode"><span class="id" title="var">l</span></span> oraz <span class="inlinecode"><span class="id" title="var">r</span></span>.

<div class="paragraph"> </div>

    UÅ¼yj indukcji-indukcji, Å¼eby zdefiniowaÄ‡ jednoczeÅ›nie typ <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> oraz
    relacjÄ™ <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> zachodzi, gdy <span class="inlinecode"><span class="id" title="var">v</span></span> jest <span class="inlinecode"><span class="id" title="var">R</span></span>-wiÄ™ksze od
    wszystkich elementÃ³w <span class="inlinecode"><span class="id" title="var">h</span></span>.

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicjÄ™, a potem przetÅ‚umacz jÄ… na odpowiedni
    zestaw aksjomatÃ³w.

<div class="paragraph"> </div>

    NastÄ™pnie uÅ¼yj swojej aksjomatycznej definicji, aby zdefiniowaÄ‡ funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, ktÃ³ra tworzy lustrzane odbicie sterty <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. WskazÃ³wka:
    prawdopodobnie nie uda ci siÄ™ zdefiniowaÄ‡ <span class="inlinecode"><span class="id" title="var">mirror</span></span>. ZastanÃ³w siÄ™,
    dlaczego jest tak trudno. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab151"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Typ drzew wyszukiwaÅ„ binarnych <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest
    relacjÄ… porzÄ…dku, skÅ‚ada siÄ™ z drzew, ktÃ³re mogÄ… byÄ‡ albo puste, albo byÄ‡
    wÄ™zÅ‚em przechowujÄ…cym wartoÅ›Ä‡ <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wraz z dwoma poddrzewami
    <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, przy czym <span class="inlinecode"><span class="id" title="var">v</span></span> musi byÄ‡ <span class="inlinecode"><span class="id" title="var">R</span></span>-wiÄ™ksze od wszystkich elemtnÃ³w
    <span class="inlinecode"><span class="id" title="var">l</span></span> oraz <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejsze od wszystkich elementÃ³w <span class="inlinecode"><span class="id" title="var">r</span></span>.

<div class="paragraph"> </div>

    UÅ¼yj indukcji-indukcji, Å¼eby zdefiniowaÄ‡ jednoczeÅ›nie typ <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> wraz
    z odpowiednimi relacjami zapewniajÄ…cymi poprawnoÅ›Ä‡ konstrukcji wÄ™zÅ‚a.
    WyprÃ³buj trzy podejÅ›cia:
<ul class="doclist">
<li> jest jedna relacja, <span class="inlinecode"><span class="id" title="var">oklr</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">oklr</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> oznacza, Å¼e z <span class="inlinecode"><span class="id" title="var">v</span></span>, <span class="inlinecode"><span class="id" title="var">l</span></span> i
      <span class="inlinecode"><span class="id" title="var">r</span></span> moÅ¼na zrobiÄ‡ wÄ™zeÅ‚

</li>
<li> sÄ… dwie relacje, <span class="inlinecode"><span class="id" title="var">okl</span></span> i <span class="inlinecode"><span class="id" title="var">okr</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">okl</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> oznacza, Å¼e <span class="inlinecode"><span class="id" title="var">v</span></span> jest
      <span class="inlinecode"><span class="id" title="var">R</span></span>-wiÄ™ksze od wszystkich elementÃ³w <span class="inlinecode"><span class="id" title="var">l</span></span>, zaÅ› <span class="inlinecode"><span class="id" title="var">okr</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>, Å¼e <span class="inlinecode"><span class="id" title="var">v</span></span> jest
      <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejsze od wszystkich elementÃ³w <span class="inlinecode"><span class="id" title="var">r</span></span>

</li>
<li> jest jedna relacja, <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> oznacza, Å¼e <span class="inlinecode"><span class="id" title="var">v</span></span> jest
      <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejsze od wszystkich elementÃ³w <span class="inlinecode"><span class="id" title="var">t</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Najpierw napisz pseudodefinicjÄ™, a potem przetÅ‚umacz jÄ… na odpowiedni
    zestaw aksjomatÃ³w.

<div class="paragraph"> </div>

    NastÄ™pnie uÅ¼yj swojej aksjomatycznej definicji, aby zdefiniowaÄ‡ funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, ktÃ³ra tworzy lustrzane odbicie drzewa <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. WskazÃ³wka:
    doÅ›Ä‡ moÅ¼liwe, Å¼e ci siÄ™ nie uda. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab152"></a><h2 class="section">Indukcja-rekursja</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ind_rec</span>.<br/>

<br/>
</div>

<div class="doc">
A oto kolejny potfur do naszej kolekcji: indukcja-rekursja. Nazwa, choÄ‡
    brzmi tak gÅ‚upio, jak "indukcja-indukcja", niesie ze sobÄ… jednak duÅ¼o
    wiÄ™cej wyobraÅºni: indukcja-rekursja pozwala nam jednoczeÅ›nie definiowaÄ‡
    typy induktywne oraz operujÄ…ce na nich funkcje rekurencyjne.

<div class="paragraph"> </div>

    Co to dokÅ‚adnie znaczy? Dotychczas nasz modus operandi wyglÄ…daÅ‚ tak, Å¼e
    najpierw definiowaliÅ›my jakiÅ› typ induktywny, a potem przez rekursjÄ™
    definiowaliÅ›my operujÄ…ce na nim funkcje, np:
<ul class="doclist">
<li> najpierw zdefiniowaliÅ›my typ <span class="inlinecode"><span class="id" title="var">nat</span></span>, a potem dodawanie, mnoÅ¼enie etc.

</li>
<li> najpierw zdefiniowaliÅ›my typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a potem <span class="inlinecode"><span class="id" title="var">app</span></span>, <span class="inlinecode"><span class="id" title="var">rev</span></span> etc. 
</li>
</ul>

<div class="paragraph"> </div>

 Dlaczego mielibyÅ›my chcieÄ‡ definiowaÄ‡ typ i funkcjÄ™ jednoczeÅ›nie? Dla
    tego samego, co zawsze, czyli zaleÅ¼noÅ›ci - indukcja-rekursja pozwala,
    Å¼eby definicja typu odnosiÅ‚a siÄ™ do funkcji, ktÃ³ra to z kolei jest
    zdefiniowana przez rekursjÄ™ strukturalnÄ… po argumencie o tym typie.

<div class="paragraph"> </div>

    Zobaczmy dobrze nam juÅ¼ znany bezsensowny przykÅ‚ad, czyli listy
    posortowane, tym razem zaimplementowane za pomocÄ… indukcji-rekursji. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;slist&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;bool)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;snil&nbsp;:&nbsp;slist&nbsp;R<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;scons&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(h&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;slist&nbsp;R),&nbsp;ok&nbsp;h&nbsp;t&nbsp;=&nbsp;true&nbsp;-&gt;&nbsp;slist&nbsp;R<br/>
<br/>
with<br/>
<br/>
Definition&nbsp;ok<br/>
&nbsp;&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;{R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;bool}&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;slist&nbsp;R)&nbsp;:&nbsp;bool&nbsp;:=<br/>
match&nbsp;t&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;snil&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;scons&nbsp;h&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;R&nbsp;x&nbsp;h<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Coq niestety nie wspiera indukcji-rekursji, a prÃ³ba napisania powyÅ¼szej
    definicji koÅ„czy siÄ™ bÅ‚Ä™dem skÅ‚adni, przy ktÃ³rym nie pomaga nawet komenda
    <span class="inlinecode"><span class="id" title="var">Fail</span></span>. Podobnie jak poprzednio, pomoÅ¼emy sobie za pomocÄ… aksjomatÃ³w,
    jednak najpierw przeÅ›ledÅºmy definicjÄ™.

<div class="paragraph"> </div>

    Typ slist dziaÅ‚a nastÄ™pujÄ…co:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> to jakiÅ› porzÄ…dek. ZauwaÅ¼, Å¼e tym razem <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a
      wiÄ™c porzÄ…dek jest reprezentowany przez funkcjÄ™, ktÃ³ra go rozstrzyga

</li>
<li> <span class="inlinecode"><span class="id" title="var">snil</span></span> to lista pusta

</li>
<li> <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> to lista z gÅ‚owÄ… <span class="inlinecode"><span class="id" title="var">h</span></span> i ogonem <span class="inlinecode"><span class="id" title="var">t</span></span>, zaÅ› <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>
      to dowÃ³d na to, Å¼e dostawienie <span class="inlinecode"><span class="id" title="var">h</span></span> przed <span class="inlinecode"><span class="id" title="var">t</span></span> daje listÄ™ posortowanÄ…. 
</li>
</ul>

<div class="paragraph"> </div>

 Tym razem jednak <span class="inlinecode"><span class="id" title="var">ok</span></span> nie jest relacjÄ…, lecz funkcjÄ… zwracajÄ…cÄ… <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    ktÃ³ra dziaÅ‚a nastÄ™pujÄ…co:
<ul class="doclist">
<li> dla <span class="inlinecode"><span class="id" title="var">snil</span></span> zwrÃ³Ä‡ <span class="inlinecode"><span class="id" title="var">true</span></span> - kaÅ¼de <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> moÅ¼na dostawiÄ‡ do listy pustej

</li>
<li> dla <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> zwrÃ³Ä‡ wynik porÃ³wnania <span class="inlinecode"><span class="id" title="var">x</span></span> z <span class="inlinecode"><span class="id" title="var">h</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 IstotÄ… mechanizmu indukcji-rekursji w tym przykÅ‚adzie jest to, Å¼e <span class="inlinecode"><span class="id" title="var">scons</span></span>
    wymaga dowodu na to, Å¼e funkcja <span class="inlinecode"><span class="id" title="var">ok</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span>, podczas gdy funkcja
    ta jest zdefiniowana przez rekursjÄ™ strukturalnÄ… po argumencie typu
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    UÅ¼ycie indukkcji-rekursji do zaimplementowania <span class="inlinecode"><span class="id" title="var">slist</span></span> ma swoje zalety:
    dla konkretnych list (zÅ‚oÅ¼onych ze staÅ‚ych, a nie ze zmiennych) dowody
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> bÄ™dÄ… postaci <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>, bo <span class="inlinecode"><span class="id" title="var">ok</span></span> po prostu obliczy siÄ™
    do <span class="inlinecode"><span class="id" title="var">true</span></span>. W przypadku indukcji-indukcji dowody na <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> byÅ‚y caÅ‚kiem
    sporych rozmiarÃ³w drzewami. Innymi sÅ‚owy, udaÅ‚o nam siÄ™ zastÄ…piÄ‡ czÄ™Å›Ä‡
    termu obliczeniami. Ten intrygujÄ…cy motyw jeszcze siÄ™ w przyszÅ‚oÅ›ci
    pojawi, gdy omawiaÄ‡ bÄ™dziemy dowÃ³d przez reflekcjÄ™.

<div class="paragraph"> </div>

    DosyÄ‡ gadania! Zobaczmy, jak zakodowaÄ‡ powyÅ¼szÄ… definicjÄ™ za pomocÄ…
    aksjomatÃ³w. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">slist</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}, <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">x</span> (@<span class="id" title="var">snil</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span>) = <span class="id" title="var">true</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> <span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>).<br/>

<br/>
</div>

<div class="doc">
Najpierw musimy zadeklarowaÄ‡ <span class="inlinecode"><span class="id" title="var">slist</span></span>, a nastÄ™pnie <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdyÅ¼ typ <span class="inlinecode"><span class="id" title="var">ok</span></span>
    zaleÅ¼y od <span class="inlinecode"><span class="id" title="var">slist</span></span>. NastÄ™pnym krokiem jest zadeklarowanie konstruktorÃ³w
    <span class="inlinecode"><span class="id" title="var">slist</span></span>, a pÃ³Åºniej rÃ³wnaÅ„ definiujÄ…cych funkcjÄ™ <span class="inlinecode"><span class="id" title="var">ok</span></span> - koniecznie w tej
    kolejnoÅ›ci, gdyÅ¼ rÃ³wnania zaleÅ¼Ä… od konstruktorÃ³w.

<div class="paragraph"> </div>

    Jak widaÄ‡, aksjomaty sÄ… bardzo proste i sprowadzajÄ… siÄ™ do przepisania
    powyÅ¼szej definicji odrzuconej przez Coqa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Psnil</span> : <span class="id" title="var">P</span> <span class="id" title="var">snil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pscons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">Psnil</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">Pscons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>))}.<br/>

<br/>
</div>

<div class="doc">
Innym zyskiem z uÅ¼ycia indukcji-rekursji jest postaÄ‡ reguÅ‚y indukcyjnej.
    Jest ona duÅ¼o prostsza, niÅ¼ w przypadku indukcji-indukcji, gdyÅ¼ teraz
    definiujemy tylko jeden typ, zaÅ› towarzyszÄ…ca mu funkcja nie wymaga w
    regule niczego specjalnego - po prostu pojawia siÄ™ w niej tam, gdzie
    spodziewamy siÄ™ jej po definicji <span class="inlinecode"><span class="id" title="var">slist</span></span>, ale nie robi niczego
    ponad to. MoÅ¼e to sugerowaÄ‡, Å¼e zamiast indukcji-indukcji, o ile to
    moÅ¼liwe, lepiej jest uÅ¼ywaÄ‡ indukcji-rekursji, a predykaty i relacje
    definiowaÄ‡ przez rekursjÄ™.

<div class="paragraph"> </div>

    PowyÅ¼szÄ… reguÅ‚Ä™ moÅ¼emy odczytaÄ‡ nastÄ™pujÄ…co:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> to parametry <span class="inlinecode"><span class="id" title="var">slist</span></span>, wiÄ™c muszÄ… siÄ™
      pojawiÄ‡

</li>
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> to przeciwdziedzina funkcji definiowanej za
      pomocÄ… reguÅ‚y

</li>
<li> <span class="inlinecode"><span class="id" title="var">Psnil</span></span> to wynik funkcji dla <span class="inlinecode"><span class="id" title="var">snil</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">Pscons</span></span> produkuje wynik funkcji dla <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> z hipotezy
      indukcyjnej/wywoÅ‚ania rekurencyjnego dla <span class="inlinecode"><span class="id" title="var">t</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> to funkcja zdefiniowana przez reguÅ‚Ä™,
      zaÅ› rÃ³wnania formalizujÄ… to, co zostaÅ‚o napisane powyÅ¼ej o <span class="inlinecode"><span class="id" title="var">Psnil</span></span>
      i <span class="inlinecode"><span class="id" title="var">Pscons</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Termy induktywno-rekurencyjnego <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> wyglÄ…dajÄ… nastÄ™pujÄ…co
    (najpierw definiujemy sobie funkcjÄ™ rozstrzygajÄ…cÄ… standardowy
    porzÄ…dek na liczbach naturalnych): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">leb</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, 0 =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">leb</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">leb</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">scons</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> 0 1 <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> 1)).<br/>

<br/>
</div>

<div class="doc">
Nie wyglÄ…da wiele lepiej od poprzedniej, induktywno-induktywnej wersji,
    prawda? Ta raÅ¼Ä…ca kiepskoÅ›Ä‡ nie jest jednak zasÅ‚ugÄ… indukcji-rekursji,
    lecz kodowania za pomocÄ… aksjomatÃ³w - funkcja <span class="inlinecode"><span class="id" title="var">ok</span></span> siÄ™ nie oblicza,
    wiÄ™c zamiast <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> musimy uÅ¼ywaÄ‡ aksjomatÃ³w <span class="inlinecode"><span class="id" title="var">ok_snil</span></span> i <span class="inlinecode"><span class="id" title="var">ok_scons</span></span>.

<div class="paragraph"> </div>

    W tym momencie znÃ³w wkracza Å‚awa oburzonych i wyraÅ¼a swoje oburzenie na
    fakt, Å¼e Coq nie wspiera indukcji-rekursji (ale Agda juÅ¼ tak). Gdyby
    <span class="inlinecode"><span class="id" title="var">Coq</span></span> wspieraÅ‚ indukcjÄ™-rekursjÄ™, to ten term wyglÄ…daÅ‚by tak: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">leb</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0 (<span class="id" title="var">scons</span> 1 <span class="id" title="var">snil</span> <span class="id" title="var">eq_refl</span>) <span class="id" title="var">eq_refl</span>.<br/>

<br/>
</div>

<div class="doc">
DuÅ¼o lepiej, prawda? Na koniec zobaczmy, jak zdefiniowaÄ‡ funkcjÄ™
    zapominajÄ…cÄ… o fakcie, Å¼e lista jest posortowana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = [] /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">h</span> :: <span class="id" title="var">f</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ind</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>) [] (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> =&gt; <span class="id" title="var">h</span> :: <span class="id" title="var">r</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">proj1_sig</span> <span class="id" title="var">toList'</span>.<br/>

<br/>
</div>

<div class="doc">
Ponownie jest to duÅ¼o prostsze, niÅ¼ w przypadku indukcji-indukcji -
    wprawdzie wciÄ…Å¼ musimy rÄ™cznie wpisywaÄ‡ termy do reguÅ‚y indukcji,
    ale dziÄ™ki prostocie reguÅ‚y jest to znacznie Å‚atwiejsze. Alternatywnie:
    udaÅ‚o nam siÄ™ zaoszczÄ™dziÄ‡ trochÄ™ czasu na definiowaniu reguÅ‚y rekursji,
    co w przypadku indukcji-indukcji byÅ‚o niemal konieczne, Å¼eby nie
    zwariowaÄ‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">toList_slist_01_result</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span> = [0; 1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">toList</span>, <span class="id" title="var">slist_01</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">toList'</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">H2</span>, <span class="id" title="var">H1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Udowodnienie, Å¼e nasza funkcja daje taki wynik jak chcieliÅ›my, jest
    rÃ³wnie proste jak poprzednio. 
<div class="paragraph"> </div>

<a name="lab153"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj dla list posortowanych funkcjÄ™ <span class="inlinecode"><span class="id" title="var">slen</span></span>, ktÃ³ra liczy ich dÅ‚ugoÅ›Ä‡.
    Udowodnij oczywiste twierdzenie wiÄ…Å¼Ä…ce ze sobÄ… <span class="inlinecode"><span class="id" title="var">slen</span></span>, <span class="inlinecode"><span class="id" title="var">toList</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">length</span></span>. Czy byÅ‚o Å‚atwiej, niÅ¼ w przypadku indukcji-indukcji? 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ind_rec</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab154"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 No cÃ³Å¼, jeszcze raz to samo. Zdefiniuj za pomocÄ… indukcji-rekursji
    jednoczeÅ›nie typ stert binarnych <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    rozstrzyga porzÄ…dek, i funkcjÄ™ <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy stertÄ™ <span class="inlinecode"><span class="id" title="var">h</span></span> moÅ¼na podczepiÄ‡ pod element <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicjÄ™, a potem przetÅ‚umacz jÄ… na odpowiedni
    zestaw aksjomatÃ³w.

<div class="paragraph"> </div>

    NastÄ™pnie uÅ¼yj swojej aksjomatycznej definicji, aby zdefiniowaÄ‡ funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, ktÃ³ra tworzy lustrzane odbicie sterty <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. WskazÃ³wka:
    tym razem powinno ci siÄ™ udaÄ‡.

<div class="paragraph"> </div>

    PorÃ³wnaj induktywno-rekurencyjnÄ… implementacjÄ™ <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">ok</span></span> z
    implementacjÄ… przez indukcjÄ™-indukcjÄ™. KtÃ³ra jest bardziej ogÃ³lna?
    KtÃ³ra jest "lÅ¼ejsza"? KtÃ³ra jest lepsza? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab155"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 No cÃ³Å¼, jeszcze raz to samo. Zdefiniuj za pomocÄ… indukcji-rekursji
    jednoczeÅ›nie typ drzew wyszukiwaÅ„ binarnych <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> rozstrzyga porzÄ…dek, oraz funkcje
    <span class="inlinecode"><span class="id" title="var">oklr</span></span>/<span class="inlinecode"><span class="id" title="var">okl</span></span> i <span class="inlinecode"><span class="id" title="var">okr</span></span>/<span class="inlinecode"><span class="id" title="var">ok</span></span>, ktÃ³re dbajÄ… o odpowiednie warunki (wybierz
    tylko jeden wariant z trzech, ktÃ³re testowaÅ‚eÅ› w tamtym zadaniu).

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicjÄ™, a potem przetÅ‚umacz jÄ… na odpowiedni
    zestaw aksjomatÃ³w.

<div class="paragraph"> </div>

    NastÄ™pnie uÅ¼yj swojej aksjomatycznej definicji, aby zdefiniowaÄ‡ funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, ktÃ³ra tworzy lustrzane odbicie drzewa <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. WskazÃ³wka:
    tym razem powinno ci siÄ™ udaÄ‡.

<div class="paragraph"> </div>

    PorÃ³wnaj induktywno-rekurencyjnÄ… implementacjÄ™ <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> z implementacjÄ…
    przez indukcjÄ™-indukcjÄ™. KtÃ³ra jest bardziej ogÃ³lna? KtÃ³ra jest
    "lÅ¼ejsza"? KtÃ³ra jest lepsza? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, pojawia siÄ™ pytanie: do czego w praktyce
    moÅ¼na uÅ¼yÄ‡ indukcji-rekursji (poza rzecz jasna gÅ‚upimi strukturami
    danych, jak listy posortowane)? W Å›wierszczykach dla bystrzakÃ³w
    (czyli tzw. "literaturze naukowej") przewija siÄ™ gÅ‚Ã³wnie jeden (ale
    jakÅ¼e uÅ¼yteczny) pomysÅ‚: uniwersa.

<div class="paragraph"> </div>

    Czym sÄ… uniwersa i co majÄ… wspÃ³lnego z indukcjÄ…-rekursjÄ…? Najlepiej
    bÄ™dzie przekonaÄ‡ siÄ™ na przykÅ‚adzie programowania generycznego: 
<div class="paragraph"> </div>

<a name="lab156"></a><h4 class="section">Ä†wiczenie (zdecydowanie za trudne)</h4>

<div class="paragraph"> </div>

 Zaimplementuj generycznÄ… funkcjÄ™ <span class="inlinecode"><span class="id" title="var">flatten</span></span>, ktÃ³ra spÅ‚aszcza dowolnie
    zagnieÅ¼dÅ¼one listy list do jednej, pÅ‚askiej listy.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">5</span> <span class="inlinecode">=</span> <span class="inlinecode">[5]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[[1];</span> <span class="inlinecode">[2];</span> <span class="inlinecode">[3]]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[[[1;</span> <span class="inlinecode">2]];</span> <span class="inlinecode">[[3]];</span> <span class="inlinecode">[[4;</span> <span class="inlinecode">5];</span> <span class="inlinecode">[6]]]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6]</span> 
<div class="paragraph"> </div>

 Trudne, prawda? Ale robialne, a robi siÄ™ to tak.

<div class="paragraph"> </div>

    W typach argumentÃ³w <span class="inlinecode"><span class="id" title="var">flatten</span></span> na powyÅ¼szym przykÅ‚adzie widaÄ‡ pewien
    wzorzec: sÄ… to kolejno <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>,
    <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>))</span> i tak dalej. MoÅ¼emy ten "wzorzec" bez problemu
    opisaÄ‡ za pomocÄ… nastÄ™pujÄ…cego typu: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">FlattenType</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> : <span class="id" title="var">FlattenType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">List</span> : <span class="id" title="var">FlattenType</span> -&gt; <span class="id" title="var">FlattenType</span>.<br/>

<br/>
</div>

<div class="doc">
Å»eby byÅ‚o Å›mieszniej, <span class="inlinecode"><span class="id" title="var">FlattenType</span></span> to dokÅ‚adnie to samo co <span class="inlinecode"><span class="id" title="var">nat</span></span>, ale
    przemilczmy to. Co dalej? MoÅ¼emy myÅ›leÄ‡ o elementach <span class="inlinecode"><span class="id" title="var">FlattenType</span></span> jak
    o kodach prawdziwych typÃ³w, a skoro sÄ… to kody, to moÅ¼na teÅ¼ napisaÄ‡
    funkcjÄ™ dekodujÄ…cÄ…: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">decode</span> (<span class="id" title="var">t</span> : <span class="id" title="var">FlattenType</span>) : <span class="id" title="keyword">Type</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> =&gt; <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">List</span> <span class="id" title="var">t'</span> =&gt; <span class="id" title="var">list</span> (<span class="id" title="var">decode</span> <span class="id" title="var">t'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">decode</span></span> kaÅ¼demu kodowi przyporzÄ…dkowuje odpowiadajÄ…cy mu typ. O
    kodach moÅ¼emy myÅ›leÄ‡ jak o nazwach - <span class="inlinecode"><span class="id" title="var">Nat</span></span> to nazwa <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaÅ›
    <span class="inlinecode"><span class="id" title="var">List</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> to nazwa typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">decode</span></span> <span class="inlinecode"><span class="id" title="var">t'</span>)</span>, np. <span class="inlinecode"><span class="id" title="var">List</span></span> <span class="inlinecode">(<span class="id" title="var">List</span></span> <span class="inlinecode"><span class="id" title="var">Nat</span>)</span>
    to nazwa typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>.

<div class="paragraph"> </div>

    Para <span class="inlinecode">(<span class="id" title="var">FlattenType</span>,</span> <span class="inlinecode"><span class="id" title="var">decode</span>)</span> jest przykÅ‚adem uniwersum.

<div class="paragraph"> </div>

    Uniwersum to, najproÅ›ciej piszÄ…c, worek, ktÃ³ry zawiera jakieÅ› typy.
    Formalnie uniwersum skÅ‚ada siÄ™ z typu kodÃ³w (czyli "nazw" typÃ³w) oraz
    funkcji dekodujÄ…cej, ktÃ³ra przyporzÄ…dkowuje kodom prawdziwe typy.

<div class="paragraph"> </div>

    Programowanie generyczne to programowanie funkcji, ktÃ³re operujÄ… na
    kolekcjach typÃ³w o dowolnych ksztaÅ‚tach, czyli na uniwersach wÅ‚aÅ›nie.
    GenerycznoÅ›Ä‡ od polimorfizmu rÃ³Å¼ni siÄ™ tym, Å¼e funkcja polimorficzna
    dziaÅ‚a dla dowolnego typu, zaÅ› generyczna - tylko dla typu o pasujÄ…cym
    ksztaÅ‚cie.

<div class="paragraph"> </div>

    Jak dokoÅ„czyÄ‡ implementacjÄ™ funkcji <span class="inlinecode"><span class="id" title="var">flatten</span></span>? Kluczowe jest zauwaÅ¼enie,
    Å¼e moÅ¼emy zdefiniowaÄ‡ <span class="inlinecode"><span class="id" title="var">flatten</span></span> przez rekursjÄ™ strutkuralnÄ… po argumencie
    domyÅ›lnym typu <span class="inlinecode"><span class="id" title="var">FlattenType</span></span>. Ostatni problem to jak zrobiÄ‡, Å¼eby Coq sam
    zgadywaÅ‚ kod danego typu - dowiemy siÄ™ tego w rozdziale o klasach.

<div class="paragraph"> </div>

    Co to wszystko ma wspÃ³lnego z uniwersami? Ano, jeÅ¼eli chcemy definiowaÄ‡
    bardzo zaawansowane funkcje generyczne, musimy mieÄ‡ do dyspozycji bardzo
    potÄ™Å¼ne uniwersa i to wÅ‚aÅ›nie je zapewnia nam indukcja-rekursja. PoniewaÅ¼
    w powyÅ¼szym przykÅ‚adzie generycznoÅ›Ä‡ nie byÅ‚a zbyt wyrafinowana, nie byÅ‚o
    potrzeby uÅ¼ywania indukcji-rekursji, jednak uszy do gÃ³ry: przykÅ‚ad nieco
    bardziej skomplikowanego uniwersum pojawi siÄ™ jeszcze w tym rozdziale. 
<div class="paragraph"> </div>

<a name="lab157"></a><h4 class="section">Ä†wiczenia</h4>

<div class="paragraph"> </div>

 Nieco podchwytliwe zadanie: zdefiniuj uniwersum funkcji <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>, <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> i tak dalej, dowolnie zagnieÅ¼dÅ¼onych.

<div class="paragraph"> </div>

    Zagadka: czy potrzebna jest nam indukcja-rekursja? 
<div class="paragraph"> </div>

<a name="lab158"></a><h2 class="section">Indeksowana indukcja-rekursja</h2>

<div class="paragraph"> </div>

 Za siedmioma gÃ³rami, za siedmioma lasami, za siedmioma rzekami, za
    siedmioma budkami telefonicznymi, nawet za indukcjÄ…-rekursjÄ… (choÄ‡
    tylko o kroczek) leÅ¼y indeksowana indukcja-rekursja, czyli poÅ‚Ä…czenie
    indukcji-rekursji oraz indeksowanych rodzin typÃ³w.

<div class="paragraph"> </div>

    Jako, Å¼e w porÃ³wnaniu do zwykÅ‚ej indukcji-rekursji nie ma tu za wiele
    innowacyjnoÅ›ci, przejdÅºmy od razu do przykÅ‚adu przydatnej techniki,
    ktÃ³rÄ… nasza tytuÅ‚owa bohaterka umoÅ¼liwia, a zwie siÄ™ on metodÄ…
    induktywnej dziedziny.

<div class="paragraph"> </div>

    Pod tÄ… nazwÄ… kryje siÄ™ sposÃ³b definiowania funkcji, pozwalajÄ…cy oddzieliÄ‡
    samÄ… definicjÄ™ od dowodu jej terminacji. JeÅ¼eli ten opis nic ci nie mÃ³wi,
    nie martw siÄ™: dotychczas definiowaliÅ›my tylko tak prymitywne funkcje, Å¼e
    tego typu fikoÅ‚ki nie byÅ‚y nam potrzebne.

<div class="paragraph"> </div>

    Metoda induktywnej dziedziny polega na tym, Å¼eby zamiast funkcji
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, ktÃ³ra nie jest strukturalnie rekurencyjna (na co Coq
    nie pozwala) napisaÄ‡ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest "predykatem dziedziny", ktÃ³ry sprawia, Å¼e dziwna
    rekursja z oryginalnej definicji <span class="inlinecode"><span class="id" title="var">f</span></span> staje siÄ™ rekursjÄ… strukturalnÄ…
    po dowodzie <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Å»eby zdefiniowaÄ‡ oryginalne <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wystarczy
    udowodniÄ‡, Å¼e kaÅ¼de <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> speÅ‚nia predykat dziedziny.

<div class="paragraph"> </div>

    Co to wszystko ma wspÃ³lnego z indeksowanÄ… indukcjÄ…-rekursjÄ…? JuÅ¼ piszÄ™.
    OtÃ³Å¼ metoda ta nie wymaga w ogÃ³lnoÅ›ci indukcji-rekursji - ta staje siÄ™
    potrzebna dopiero, gdy walczymy z bardzo zÅ‚oÅ›liwymi funkcjami, czyli
    takimi, w ktÃ³rych rekursja jest zagnieÅ¼dÅ¼ona, tzn. robimy wywoÅ‚anie
    rekurencyjne na wyniku poprzedniego wywoÅ‚ania rekurencyjnego.

<div class="paragraph"> </div>

    Predykat dziedziny dla takiej funkcji musi zawieraÄ‡ konstruktor w stylu
    "jeÅ¼eli wynik wywoÅ‚ania rekurencyjnego na x naleÅ¼y do dziedziny, to x teÅ¼
    naleÅ¼y do dziedziny".To wÅ‚aÅ›nie tu ujawnia siÄ™ indukcja-rekursja: Å¼eby
    zdefiniowaÄ‡ predykat dziedziny, musimy odwoÅ‚aÄ‡ siÄ™ do funkcji (Å¼eby mÃ³c
    powiedzieÄ‡ coÅ› o wyniku wywoÅ‚ania rekurencyjnego), a Å¼eby zdefiniowaÄ‡
    funkcjÄ™, musimy mieÄ‡ predykat dziedziny.

<div class="paragraph"> </div>

    Brzmi skomplikowanie? JeÅ¼eli czegoÅ› nie rozumiesz, to jesteÅ› debi...
    a nie, czekaj. JeÅ¼eli czegoÅ› nie rozumiesz, to nie martw siÄ™: powyÅ¼szy
    przykÅ‚ad miaÅ‚ na celu jedynie zilustrowaÄ‡ jakieÅ› praktyczne zastosowanie
    indeksowanej indukcji-rekursji. Do metody induktywnej dziedziny powrÃ³cimy
    w kolejnym rozdziale. PokaÅ¼emy, jak wyeliminowaÄ‡ z niej indukcjÄ™-rekursjÄ™,
    tak Å¼eby uzyskane za jej pomocÄ… definicje moÅ¼na byÅ‚o odpalaÄ‡ w Coqu.
    Zobaczymy teÅ¼, jakimi sposobami dowodziÄ‡, Å¼e kaÅ¼dy element dziedziny
    speÅ‚nia predykat dziedziny, co pozwoli nam odzyskaÄ‡ oryginalnÄ… definicjÄ™
    funkcji, a takÅ¼e dowiemy siÄ™, jak z "predykatu" o typie <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    zrobiÄ‡ prawdziwy predykat <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
<div class="paragraph"> </div>

<a name="lab159"></a><h2 class="section">Indukcja-indukcja-rekursja</h2>

<div class="paragraph"> </div>

 Ufff... przebrnÄ™liÅ›my przez indukcjÄ™-indukcjÄ™ i (indeksowanÄ…)
    indukcjÄ™-rekursjÄ™. Czy mogÄ… istnieÄ‡ jeszcze potÄ™Å¼niejsze i bardziej
    innowacyjne sposoby definiowania typÃ³w przez indukcjÄ™?

<div class="paragraph"> </div>

    AleÅ¼ oczywiÅ›cie. Jest nim... uwaga uwaga, niespodzianka...
    indukcja-indukcja-rekursja, ktÃ³ra jest nie tylko strasznym
    potfurem, ale teÅ¼ powinna dostaÄ‡ Oskara za najlepszÄ… nazwÄ™.

<div class="paragraph"> </div>

    Chodzi tu oczywiÅ›cie o poÅ‚Ä…czenie indukcji-indukcji i indukcji-rekursji:
    moÅ¼emy jednoczeÅ›nie zdefiniowaÄ‡ jakiÅ› typ <span class="inlinecode"><span class="id" title="var">A</span></span>, rodzinÄ™ typÃ³w <span class="inlinecode"><span class="id" title="var">B</span></span>
    indeksowanÄ… przez <span class="inlinecode"><span class="id" title="var">A</span></span> oraz operujÄ…ce na nich funkcje, do ktÃ³rych
    konstruktory <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> mogÄ… siÄ™ odwoÅ‚ywaÄ‡.

<div class="paragraph"> </div>

    Nie ma tu jakiejÅ› wielkiej filozofii: wszystkiego, co powinieneÅ› wiedzieÄ‡
    o indukcji-indukcji-rekursji, dowiedziaÅ‚eÅ› siÄ™ juÅ¼ z dwÃ³ch poprzednich
    podrozdziaÅ‚Ã³w. Nie muszÄ™ chyba dodawaÄ‡, Å¼e Å‚awa oburzonych jest oburzona
    faktem, Å¼e Coq nie wspiera indukcji-indukcji-rekursji.

<div class="paragraph"> </div>

    Rodzi siÄ™ jednak to samo super powaÅ¼ne pytanie co zawsze, czyli do czego
    moÅ¼na tego taÅ‚atajstwa uÅ¼yÄ‡? Przez caÅ‚kiem dÅ‚ugi czas nie miaÅ‚em pomysÅ‚u,
    ale okazuje siÄ™, Å¼e jest jedno takie zastosowanie i w sumie narzuca siÄ™
    ono samo.

<div class="paragraph"> </div>

    Przypomnij sobie metodÄ™ induktywno-rekurencyjnej dziedziny, czyli jedno
    ze sztandarowych zastosowaÅ„ indeksowanej indukcji-rekursji. Zaczynamy od
    typu <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, na ktÃ³rym chcemy zdefiniowaÄ‡ funkcjÄ™ o niestandardowym
    ksztaÅ‚cie rekursji. W tym celu definiujemy dziedzinÄ™ <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    wraz z funkcjÄ… <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span>,</span> <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    ZauwaÅ¼my, jaki jest zwiÄ…zek typu <span class="inlinecode"><span class="id" title="var">I</span></span> z funkcjÄ… <span class="inlinecode"><span class="id" title="var">f</span></span>: najpierw jest typ,
    potem funkcja. Co jednak, gdy musimy <span class="inlinecode"><span class="id" title="var">I</span></span> oraz <span class="inlinecode"><span class="id" title="var">f</span></span> zdefiniowaÄ‡ razem za
    pomocÄ… indukcji-rekursji? Wtedy <span class="inlinecode"><span class="id" title="var">f</span></span> moÅ¼e byÄ‡ zdefiniowane jedynie za
    pomocÄ… rekursji strukturalnej po <span class="inlinecode"><span class="id" title="var">I</span></span>, co wyklucza rekursjÄ™ o fikuÅ›nym
    ksztaÅ‚cie...

<div class="paragraph"> </div>

    I tu wchodzi indukcja-indukcja-rekursja, caÅ‚a na biaÅ‚o. MoÅ¼emy uÅ¼yÄ‡
    jej w taki sposÃ³b, Å¼e definiujemy jednoczeÅ›nie:
<ul class="doclist">
<li> typ <span class="inlinecode"><span class="id" title="var">I</span></span>, ktÃ³ry odnosi siÄ™ do funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>

</li>
<li> predykat dziedziny <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, ktÃ³ry jest indeksowany przez <span class="inlinecode"><span class="id" title="var">I</span></span>

</li>
<li> funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span>, ktÃ³ra zdefiniowana jest przez rekursjÄ™ strukturalnÄ… po
      dowodzie naleÅ¼enia do dziedziny

</li>
</ul>

<div class="paragraph"> </div>

    Jak widaÄ‡, typ zaleÅ¼y od funkcji, funkcja od predykatu, a predykat od
    typu i koÅ‚o siÄ™ zamyka.

<div class="paragraph"> </div>

    NastÄ™puje jednak skÄ…dinÄ…d uzasadnione pytanie: czy faktycznie istnieje
    jakaÅ› sytuacja, w ktÃ³rej powyÅ¼szy schemat dziaÅ‚ania jest tym sÅ‚usznym?
    OdpowiedÅº pÃ³ki co moÅ¼e byÄ‡ tylko jedna: nie wiem, ale siÄ™ domyÅ›lam. 
<div class="paragraph"> </div>

<a name="lab160"></a><h2 class="section">Najstraszniejszy potfur</h2>

<div class="paragraph"> </div>

 Na koniec dodam jeszcze na zachÄ™tÄ™ (albo zniechÄ™tÄ™, zaleÅ¼y jakie kto
    ma podejÅ›cie), Å¼e istnieje jeszcze jeden potfur, straszniejszy nawet
    niÅ¼ indukcja-indukcja-rekursja, ale jest on zbyt straszny jak na ten
    rozdziaÅ‚ i byÄ‡ moÅ¼e w ogÃ³le zbyt straszny jak na tÄ™ ksiÄ…Å¼kÄ™ - panie
    boÅ¼e, daj odwagÄ™ na omÃ³wienie go! 
<div class="paragraph"> </div>

<a name="lab161"></a><h1 class="section">Dobre, zÅ‚e i podejrzane typy induktywne</h1>

<div class="paragraph"> </div>

 Poznana przez nas dotychczas definicja typÃ³w induktywnych (oraz wszelkich
    ich ulepszeÅ„, jak indukcja-indukcja, indukcja-rekursja etc.) jest
    niepeÅ‚na. Tak jak Å›wiat peÅ‚en jest zÅ‚oczyÅ„cÃ³w oszukujÄ…cych starszych
    ludzi metodÄ… "na wnuczka", tak nie kaÅ¼dy typ podajÄ…cy siÄ™ za induktywny
    faktycznie jest praworzÄ…dnym obywatelem krainy typÃ³w induktywnych. 
<div class="paragraph"> </div>

 Na szczÄ™Å›cie typy induktywne to istoty bardzo prostolinijne, zaÅ› te zÅ‚e
    moÅ¼na odrÃ³Å¼niÄ‡ od tych dobrych goÅ‚ym okiem, za pomocÄ… bardzo prostego
    kryterium: zÅ‚e typy induktywne to te, ktÃ³re nie sÄ… Å›ciÅ›le pozytywne.
    Zanim jednak dowiemy siÄ™, jak rozpoznawaÄ‡ zÅ‚e typy, poznajmy najpierw
    dwa powody, przez ktÃ³re zÅ‚e typy induktywne sÄ… zÅ‚e. 
<div class="paragraph"> </div>

<a name="lab162"></a><h2 class="section">Nieterminacja jako ÅºrÃ³dÅ‚o zÅ‚a na Å›wiecie</h2>

<div class="paragraph"> </div>

 Przyjrzyjmy siÄ™ poniÅ¼szemu typowemu przypadkowi negatywnego typu
    induktywnego (czyli takiego, ktÃ³ry wyglÄ…da na induktywny, ale ma
    konstruktory z negatywnymi wystÄ…pieniami argumentu indukcyjnego): 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;"(wut&nbsp;A&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;wut&nbsp;A".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Uwaga: poprzedzenie komendÄ… <span class="inlinecode"><span class="id" title="var">Fail</span></span> innej komendy oznajmia Coqowi, Å¼e
    spodziewamy siÄ™, iÅ¼ komenda zawiedzie. Coq akceptuje komendÄ™ <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>,
    jeÅ¼eli komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zawodzi, i wypisuje komunikat o bÅ‚Ä™dzie. JeÅ¼eli
    komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zakoÅ„czy siÄ™ sukcesem, komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> zwrÃ³ci bÅ‚Ä…d.
    Komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> jest przydatna w sytuacjach takich jak obecna, gdy
    chcemy zilustrowaÄ‡ fakt, Å¼e jakaÅ› komenda zawodzi.

<div class="paragraph"> </div>

    Pierwszym powodem nielegalnoÅ›ci nie-Å›ciÅ›le-pozytywnych typÃ³w induktywnych
    jest to, Å¼e uniewaÅ¼niajÄ… one filozoficznÄ… interpretacjÄ™ teorii typÃ³w i
    ogÃ³lnie wszystkiego, co robimy w Coqu. W praktyce problemy filozoficzne
    mogÄ… teÅ¼ prowadziÄ‡ do sprzecznoÅ›ci.

<div class="paragraph"> </div>

    ZaÅ‚Ã³Å¼my, Å¼e Coq akceptuje powyÅ¼szÄ… definicjÄ™ <span class="inlinecode"><span class="id" title="var">wut</span></span>. MoÅ¼emy wtedy napisaÄ‡
    nastÄ™pujÄ…cy program: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> (<span class="id" title="var">w</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">w</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">g</span> <span class="id" title="var">w</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">in</span> <span class="id" title="var">f</span> (<span class="id" title="var">C</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
JuÅ¼ sam typ tego programu wyglÄ…da podejrzanie: dla kaÅ¼dego typu <span class="inlinecode"><span class="id" title="var">A</span></span>
    zwraca on element typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Nie dziwota wiÄ™c, Å¼e moÅ¼emy uzyskaÄ‡ z niego
    dowÃ³d faÅ‚szu. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">santa_is_a_pedophile</span> : <span class="id" title="var">False</span> := <span class="id" title="var">loop</span> <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
Paradoksalnie jednak to nie ta raÅ¼Ä…ca sprzecznoÅ›Ä‡ jest naszym najwiÄ™kszym
    problemem - nie z kaÅ¼dego zÅ‚ego typu induktywnego da siÄ™ tak Å‚atwo dostaÄ‡
    sprzecznoÅ›Ä‡ (a przynajmniej ja nie umiem; systematyczny sposÃ³b dostawania
    sprzecznoÅ›ci z istnienia takich typÃ³w zobaczymy pÃ³Åºniej). W rzeczywistoÅ›ci
    jest nim nieterminacja.

<div class="paragraph"> </div>

    Nieterminacja (ang. nontermination, divergence) lub kolokwialniej
    "zapÄ™tlenie" to sytuacja, w ktÃ³rej program nigdy nie skoÅ„czy siÄ™
    wykonywaÄ‡. Ta wÅ‚aÅ›nie bolÄ…czka jest przypadÅ‚oÅ›ciÄ… <span class="inlinecode"><span class="id" title="var">loop</span></span>, czego nie
    trudno domyÅ›liÄ‡ siÄ™ z nazwy.

<div class="paragraph"> </div>

    Dlaczego tak jest? Przyjrzyjmy siÄ™ definicji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Za pomocÄ… <span class="inlinecode"><span class="id" title="keyword">let</span></span>a
    definiujemy funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, ktÃ³ra odpakowuje swÃ³j argument
    <span class="inlinecode"><span class="id" title="var">w</span></span>, wyciÄ…ga z niego funkcjÄ™ <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> i aplikuje <span class="inlinecode"><span class="id" title="var">g</span></span> do <span class="inlinecode"><span class="id" title="var">w</span></span>.
    Wynikiem programu jest <span class="inlinecode"><span class="id" title="var">f</span></span> zaaplikowane do siebie samego zawiniÄ™tego
    w konstruktor <span class="inlinecode"><span class="id" title="var">C</span></span>.

<div class="paragraph"> </div>

    Przyjrzyjmy siÄ™, jak przebiegajÄ… prÃ³by wykonania tego nieszczÄ™snego
    programu:

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span>

<div class="paragraph"> </div>

    i tak dalej.

<div class="paragraph"> </div>

    Nie powinno nas to dziwiÄ‡ - praktycznie rzecz biorÄ…c aplikujemy <span class="inlinecode"><span class="id" title="var">f</span></span> samo
    do siebie, zaÅ› konstruktor <span class="inlinecode"><span class="id" title="var">C</span></span> jest tylko poÅ›rednikiem sprawiajÄ…cym, Å¼e
    typy siÄ™ zgadzajÄ…. OgÃ³lniej sytuacja, w ktÃ³rej coÅ› odnosi siÄ™ samo do
    siebie, nazywa siÄ™ autoreferencjÄ… i czÄ™sto prowadzi do rÃ³Å¼nych wesoÅ‚ych
    paradoksÃ³w. 
<div class="paragraph"> </div>

<a name="lab163"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 PoniÅ¼szÄ… zagadkÄ™ pozwolÄ™ sobie wesoÅ‚o nazwaÄ‡ "paradoks hetero". Zagadka
    brzmi tak:

<div class="paragraph"> </div>

    NiektÃ³re sÅ‚owa opisujÄ… same siebie, np. sÅ‚owo "krÃ³tki" jest krÃ³tkie,
    a niektÃ³re inne nie, np. sÅ‚owo "dÅ‚ugi" nie jest dÅ‚ugie. Podobnie sÅ‚owo
    "polski" jest sÅ‚owem polskim, ale sÅ‚owo "niemiecki" nie jest sÅ‚owem
    niemieckim. SÅ‚owa, ktÃ³re nie opisujÄ… samych siebie bÄ™dziemy nazywaÄ‡
    sÅ‚owami heterologicznymi. Pytanie: czy sÅ‚owo "heterologiczny" jest
    heterologiczne? 
<div class="paragraph"> </div>

 Czujesz sprzecznoÅ›Ä‡? Innym przyk... dobra, wystarczy tych gÅ‚upot.

<div class="paragraph"> </div>

    Przyjrzyjmy siÄ™ teraz problemom filozoficznym powodowanym przez
    nieterminacjÄ™. W skrÃ³cie: zmienia ona fundamentalne wÅ‚aÅ›ciwoÅ›ci
    obliczeÅ„, co prowadzi do zmiany interpretacji pojÄ™cia typu, zaÅ›
    to pociÄ…ga za sobÄ… kolejne przykre skutki, takie jak np. to, Å¼e
    reguÅ‚y eliminacji tracÄ… swoje uzasadnienie.

<div class="paragraph"> </div>

    Brzmi mega groÅºnie, prawda? Kiedy wspomniaÅ‚em o tym Sokratesowi, to
    sturlaÅ‚ siÄ™ z podÅ‚ogi na sufit bez poÅ›rednictwa Å›ciany.

<div class="paragraph"> </div>

    Na szczÄ™Å›cie tak naprawdÄ™, to sprawa jest prosta. W Coqu wymagamy, aby
    kaÅ¼de obliczenie siÄ™ koÅ„czyÅ‚o. WartoÅ›ci, czyli koÅ„cowe wyniki obliczeÅ„
    (ktÃ³re sÄ… teÅ¼ nazywane postaciami kanonicznymi albo normalnymi), moÅ¼emy
    utoÅ¼samiaÄ‡ z elementami danego typu. Dla przykÅ‚adu wynikami obliczania
    termÃ³w typu <span class="inlinecode"><span class="id" title="var">bool</span></span> sÄ… <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>, wiÄ™c moÅ¼emy myÅ›leÄ‡, Å¼e sÄ… to
    elementy typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> skÅ‚ada siÄ™ tylko z nich. To z kolei daje
    nam uzasadnienie reguÅ‚y eliminacji (czyli indukcji) dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span>:
    Å¼eby udowodniÄ‡ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> dla kaÅ¼dego <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, wystarczy
    udowodniÄ‡ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>, gdyÅ¼ <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span> sÄ… jedynymi
    elementami typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    Nieterminacja obraca tÄ™ jakÅ¼e piÄ™knÄ… filozoficznÄ… wizjÄ™ w perzynÄ™:
    nie kaÅ¼de obliczenie siÄ™ koÅ„czy, a przez to powstajÄ… nowe, "dziwne"
    elementy rÃ³Å¼nych typÃ³w. <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> nigdy nie obliczy siÄ™ do <span class="inlinecode"><span class="id" title="var">true</span></span> ani
    do <span class="inlinecode"><span class="id" title="var">false</span></span>, wiÄ™c moÅ¼emy traktowaÄ‡ je jako nowy element typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. To
    sprawia, Å¼e <span class="inlinecode"><span class="id" title="var">bool</span></span>, typ z zaÅ‚oÅ¼enia dwuelementowy, ma teraz co najmniej
    trzy elementy - <span class="inlinecode"><span class="id" title="var">true</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Z tego teÅ¼ powodu reguÅ‚a
    eliminacji przestaje obowiÄ…zywaÄ‡, bo wymaga ona dowodÃ³w jedynie dla
    <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>, ale milczy na temat <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. MoglibyÅ›my prÃ³bowaÄ‡
    naiwnie jÄ… zaÅ‚ataÄ‡, uwzglÄ™dniajÄ…c ten dodatkowy przypadek, ale tak po
    prawdzie, to nie wiadomo nawet za bardzo jakie jeszcze paskudztwa
    rozpanoszyÅ‚y siÄ™ w typie <span class="inlinecode"><span class="id" title="var">bool</span></span> z powodu nieterminacji.

<div class="paragraph"> </div>

    MoraÅ‚ jest prosty: nieterminacja to wynalazek szatana, a negatywne
    typy induktywne to teÅ¼ wynalazek szatana. 
<div class="paragraph"> </div>

<a name="lab164"></a><h2 class="section">Twierdzenie Cantora</h2>

<div class="paragraph"> </div>

 Zanim zaczniemy ten rozdziaÅ‚ na powaÅ¼nie, mam dla ciebie wesoÅ‚y Å‚amaniec
    jÄ™zykowy:

<div class="paragraph"> </div>

    Cantor - kanciarz, ktÃ³ry skradÅ‚ zza kurtyny kantoru z Kantonu kontury
    kartonu Koranicznemu kanarowi, ktÃ³ry czasem karaÅ‚ karczystych kafarÃ³w
    czarami za karÄ™ za kantowanie i za zakatowanie zza kontuaru konarem
    kontrkulturowych kuluarowych karÅ‚Ã³w.

<div class="paragraph"> </div>

    Dobra, wystarczy. Reszta tego podrozdziaÅ‚u bÄ™dzie Å›miertelnie powaÅ¼na,
    a przyjrzymy siÄ™ w niej jednemu z mega klasycznych twierdzeÅ„ z koÅ„ca
    XIX w. gÅ‚oszÄ…cemu mniej wiÄ™cej, Å¼e "zbiÃ³r potÄ™gowy zbioru liczb
    naturalnych ma wiÄ™kszÄ… moc od zbioru liczb naturalnych".

<div class="paragraph"> </div>

    Co za beÅ‚kot, pomyÅ›lisz zapewne. Ten podrozdziaÅ‚ poÅ›wiÄ™cimy wÅ‚aÅ›nie temu,
    Å¼eby Ã³w beÅ‚kot nieco wyklarowaÄ‡. JeÅ¼eli zaÅ› zastanawiasz siÄ™, po co nam
    to, to odpowiedÅº jest prosta - na (uogÃ³lnionym) twierdzeniu Cantora
    opieraÄ‡ siÄ™ bÄ™dzie nasza systematyczna metoda dowodzenia nielegalnoÅ›ci
    negatywnych typÃ³w induktywnych.

<div class="paragraph"> </div>

    OczywiÅ›cie oryginalne sformuÅ‚owanie twierdzenia powstaÅ‚o na dÅ‚ugo przed
    powstaniem teorii typÃ³w czy Coqa, co objawia siÄ™ np. w tym, Å¼e mÃ³wi ono
    o <i>zbiorze</i> liczb naturalnych, podczas gdy my dysponujemy <i>typem</i> liczb
    naturalnych. Musimy wiÄ™c oryginalne sformuÅ‚owanie lekko przeformuÅ‚owaÄ‡,
    a takÅ¼e wprowadziÄ‡ wszystkie niezbÄ™dne nam pojÄ™cia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">surjective</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">a</span> = <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszym niezbÄ™dnym pojÄ™ciem jest pojÄ™cie surjekcji. PowyÅ¼sza definicja
    gÅ‚osi, Å¼e funkcja jest surjektywna, gdy kaÅ¼dy element przeciwdziedziny
    jest wynikiem funkcji dla pewnego elementu dziedziny. Surjekcja to
    funkcja, ktÃ³ra jest surjektywna.

<div class="paragraph"> </div>

    O co chodzi w tej definicji? Samo sÅ‚owo "surjekcja" pochodzi od fr.
    "sur" - "na" oraz Å‚ac. "iacere" - "rzucaÄ‡". Ubogim tÅ‚umaczeniem na
    polski moÅ¼e byÄ‡ sÅ‚owo "narzut".

<div class="paragraph"> </div>

    Idea jest taka, Å¼e surjekcja <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> "narzuca" swojÄ… dziedzinÄ™
    <span class="inlinecode"><span class="id" title="var">A</span></span> na przeciwdziedzinÄ™ <span class="inlinecode"><span class="id" title="var">B</span></span> tak, Å¼e <span class="inlinecode"><span class="id" title="var">A</span></span> "pokrywa" caÅ‚e <span class="inlinecode"><span class="id" title="var">B</span></span>. Innymi
    sÅ‚owy, kaÅ¼dy element <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest pokryty przez jakiÅ› element <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    co wyraÅ¼a rÃ³wnoÅ›Ä‡ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>. OczywiÅ›cie to <span class="inlinecode"><span class="id" title="var">a</span></span> nie musi byÄ‡ unikalne -
    <span class="inlinecode"><span class="id" title="var">b</span></span> moÅ¼e byÄ‡ pokrywane przez duÅ¼o rÃ³Å¼nych <span class="inlinecode"><span class="id" title="var">a</span></span>. Jak widaÄ‡, dokÅ‚adnie to
    jest napisane w powyÅ¼szej definicji.

<div class="paragraph"> </div>

    MÃ³wiÄ…c jeszcze proÅ›ciej: jeÅ¼eli <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest surjekcjÄ…, to typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> jest wiÄ™kszy (a precyzyjniej mÃ³wiÄ…cy, nie mniejszy) niÅ¼ typ <span class="inlinecode"><span class="id" title="var">B</span></span>.
    OczywiÅ›cie nie znaczy to, Å¼e jeÅ¼eli <span class="inlinecode"><span class="id" title="var">f</span></span> nie jest surjekcjÄ…, to typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> jest mniejszy niÅ¼ <span class="inlinecode"><span class="id" title="var">B</span></span> - mogÄ… przecieÅ¼ istnieÄ‡ inne surjekcje.
    Powiemy, Å¼e <span class="inlinecode"><span class="id" title="var">A</span></span> jest mniejszy od <span class="inlinecode"><span class="id" title="var">B</span></span>, jeÅ¼eli nie istnieje Å¼adna
    surjekcja miÄ™dzy nimi.

<div class="paragraph"> </div>

    SprÃ³bujmy rozrysowaÄ‡ to niczym Jacek Gmoch... albo nie, bo nie umiem
    jeszcze rysowaÄ‡, wiÄ™c zamiast tego bÄ™dzie przykÅ‚ad i Ä‡wiczenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isZero</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_isZero</span> : <span class="id" title="var">surjective</span> <span class="id" title="var">isZero</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 42. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">isZero</span></span>, ktÃ³ra sprawdza, czy jej argument jest zerem, jest
    surjekcjÄ…, bo kaÅ¼dy element typu <span class="inlinecode"><span class="id" title="var">bool</span></span> moÅ¼e byÄ‡ jej wynikiem -
    <span class="inlinecode"><span class="id" title="var">true</span></span> jest wynikiem dla <span class="inlinecode">0</span>, zaÅ› <span class="inlinecode"><span class="id" title="var">false</span></span> jest jej wynikiem dla
    wszystkich innych argumentÃ³w. Wobec tego moÅ¼emy skonkludowaÄ‡, Å¼e
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span> jest wiÄ™kszy niÅ¼ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> i w rzeczywistoÅ›ci faktycznie
    tak jest: <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dwa elementy, a <span class="inlinecode"><span class="id" title="var">nat</span></span> nieskoÅ„czenie wiele.

<div class="paragraph"> </div>

    Do kwestii tego, ktÃ³ry typ ma ile elementÃ³w wrÃ³cimy jeszcze w rozdziale
    o typach i funkcjach. Tam teÅ¼ zapoznamy siÄ™ lepiej z surjekcjami i
    innymi rodzajami funkcji. Tymczasem Ä‡wiczenie: 
<div class="paragraph"> </div>

<a name="lab165"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Czy funkcja <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">5</span> jest surjekcjÄ…? A funkcja <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">minus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">5</span>?
    SprawdÅº swoje odpowiedzi w Coqu. Na koniec filozoficznie zinterpretuj
    otrzymany wynik.

<div class="paragraph"> </div>

    WskazÃ³wka: <span class="inlinecode"><span class="id" title="var">minus</span></span> to funkcja z biblioteki standardowej, ktÃ³ra
    implementuje odejmowanie liczb naturalnych z obciÄ™ciem, tzn. np.
    <span class="inlinecode">2</span> <span class="inlinecode">-</span> <span class="inlinecode">5</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. UÅ¼yj <span class="inlinecode"><span class="id" title="keyword">Print</span></span>a, Å¼eby dokÅ‚adnie zbadaÄ‡ jej definicjÄ™. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Pozostaje jeszcze kwestia tego, czym jest "zbiÃ³r potÄ™gowy zbioru liczb
    naturalnych". Mimo groÅºnej nazwy sprawa jest prosta: jest to archaiczne
    okreÅ›lenie na typ funkcji <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. KaÅ¼dÄ… funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    moÅ¼emy interpretowaÄ‡ jako pewnÄ… kolekcjÄ™ (czyli wÅ‚aÅ›nie zbiÃ³r) elementÃ³w
    typu <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaÅ› <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, czyli wynik <span class="inlinecode"><span class="id" title="var">f</span></span> na konkretnym <span class="inlinecode"><span class="id" title="var">n</span></span>, mÃ³wi nam, czy
    <span class="inlinecode"><span class="id" title="var">n</span></span> znajduje siÄ™ w tej kolekcji, czy nie.

<div class="paragraph"> </div>

    To w zasadzie wyczerpuje zestaw pojÄ™Ä‡ potrzebnych nam do sformuÅ‚owania
    twierdzenia. PojawiajÄ…ca siÄ™ w oryginalnej wersji "wiÄ™ksza moc" to po
    prostu synonim okreÅ›lenia "wiÄ™kszy", ktÃ³re potrafimy juÅ¼ wyraÅ¼aÄ‡ za
    pomocÄ… pojÄ™cia surjekcji. Tak wiÄ™c nowszÄ… (czyli bardziej postÄ™powÄ…)
    wersjÄ™ twierdzenia Cantora moÅ¼emy sformuÅ‚owaÄ‡ nastÄ™pujÄ…co: nie istnieje
    surjekcja z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Lub jeszcze bardziej obrazowo: <span class="inlinecode"><span class="id" title="var">nat</span></span>
    jest mniejsze niÅ¼ <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Cantor</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <span class="id" title="var">nat</span> -&gt; (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">bool</span>), ~ <span class="id" title="var">surjective</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">Hf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">diagonal</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">negb</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hf</span> <span class="id" title="var">diagonal</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">Hn</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">bool</span> =&gt; <span class="id" title="var">h</span> <span class="id" title="var">n</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">diagonal</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">inversion</span> <span class="id" title="var">Hn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
DowÃ³d twierdzenia jest rÃ³wnie legendarny jak samo twierdzenie, a na
    dodatek bajecznie prosty i niesamowicie uÅ¼yteczny - jeÅ¼eli bÄ™dziesz
    zajmowaÅ‚ siÄ™ w Å¼yciu matematykÄ… i informatykÄ…, spotkasz go w jeszcze
    wielu odsÅ‚onach. Metoda stojÄ…ca za dowodem nazywana bywa argumentem
    przekÄ…tniowym - choÄ‡ nazwa ta moÅ¼e siÄ™ wydawaÄ‡ dziwna, to za chwilÄ™
    stanie siÄ™ zupeÅ‚nia jasna.

<div class="paragraph"> </div>

    O co wiÄ™c chodzi w powyÅ¼szym dowodzie? Po pierwsze zauwaÅ¼my, Å¼e
    mamy do czynienia z funkcjÄ… <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>, czyli
    funkcjÄ…, ktÃ³ra bierze liczbÄ™ naturalnÄ… i zwraca funkcjÄ™ z liczb
    naturalnych w <span class="inlinecode"><span class="id" title="var">bool</span></span>. PamiÄ™tajmy jednak, Å¼e <span class="inlinecode">-&gt;</span> Å‚Ä…czy w prawo
    i wobec tego typ <span class="inlinecode"><span class="id" title="var">f</span></span> moÅ¼emy zapisaÄ‡ teÅ¼ jako <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    Tak wiÄ™c <span class="inlinecode"><span class="id" title="var">f</span></span> jest funkcjÄ…, ktÃ³ra bierze dwie liczby naturalne i
    zwraca element typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    DziÄ™ki temu zabiegowi moÅ¼emy wyobraÅ¼aÄ‡ sobie <span class="inlinecode"><span class="id" title="var">f</span></span> jako dwuwymiarowÄ…
    tabelkÄ™, ktÃ³rej wiersze i kolumny sÄ… indeksowane liczbami naturalnymi,
    a komÃ³rki w tabelce wypeÅ‚nione sÄ… wartoÅ›ciami typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. Przyjmijmy,
    Å¼e pierwszy argument <span class="inlinecode"><span class="id" title="var">f</span></span> to indeks wiersza, zaÅ› drugi to indeks kolumny.
    W takim ukÅ‚adzie <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> to wartoÅ›Ä‡ <span class="inlinecode"><span class="id" title="var">n</span></span>-tej funkcji na argumencie <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Wobec tego twierdzenie moÅ¼emy sparafrazowaÄ‡ mÃ³wiÄ…c, Å¼e kaÅ¼da funkcja
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> znajduje siÄ™ w ktÃ³rymÅ› wierszu tabelki.

<div class="paragraph"> </div>

    To tyle wyobraÅºni - moÅ¼emy juÅ¼ udowodniÄ‡ twierdzenie. Na poczÄ…tku
    oczywiÅ›cie bierzemy dowolne <span class="inlinecode"><span class="id" title="var">f</span></span> oraz zakÅ‚adamy, Å¼e jest surjekcjÄ…,
    uprzednio odwijajÄ…c definicjÄ™ bycia surjekcjÄ….

<div class="paragraph"> </div>

    Teraz musimy jakoÅ› wyciÄ…gnÄ…Ä‡ sprzecznoÅ›Ä‡ z hipotezy <span class="inlinecode"><span class="id" title="var">Hf</span></span>, czyli,
    uÅ¼ywajÄ…c naszej tabelkowej parafrazy, znaleÅºÄ‡ funkcjÄ™ z <span class="inlinecode"><span class="id" title="var">nat</span></span> w
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, ktÃ³ra nie znajduje siÄ™ w tabelce. A nie znajdowaÄ‡ siÄ™ w
    tabelce, panie Ferdku, to znaczy: rÃ³Å¼niÄ‡ siÄ™ od kaÅ¼dej funkcji z
    tabelki na jakimÅ› argumencie.

<div class="paragraph"> </div>

    Zamiast jednak szukaÄ‡ takiej funkcji po omacku, skonstruujmy jÄ…
    z tego, co mamy pod rÄ™kÄ… - czyli z naszej tabelki. Jak przerobiÄ‡
    funkcje z tabelki na nowÄ…, ktÃ³rej w nie ma w tabelce? Tu wÅ‚aÅ›nie
    ujawnia siÄ™ geniuszalnoÅ›Ä‡ Cantora: uÅ¼yjemy metody przekÄ…tniowej,
    czyli spojrzymy na przekÄ…tnÄ… naszej tabelki.

<div class="paragraph"> </div>

    Definiujemy wiÄ™c nowÄ… funkcjÄ™ <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> nastÄ™pujÄ…co:
    dla argumentu <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> bierzemy funkcjÄ™ z <span class="inlinecode"><span class="id" title="var">n</span></span>-tego wiersza w tabelce,
    patrzymy na <span class="inlinecode"><span class="id" title="var">n</span></span>-tÄ… kolumnÄ™, czyli na wartoÅ›Ä‡ funkcji na argumencie
    <span class="inlinecode"><span class="id" title="var">n</span></span>, i zwracamy negacjÄ™ tego, co tam znajdziemy. Czujesz sprzecznoÅ›Ä‡?

<div class="paragraph"> </div>

    Nasze zaÅ‚oÅ¼enie mÃ³wi, Å¼e <span class="inlinecode"><span class="id" title="var">diagonal</span></span> znajduje siÄ™ w ktÃ³rymÅ› wierszu
    tabelki - niech ma on numer <span class="inlinecode"><span class="id" title="var">n</span></span>. Wiemy jednak, Å¼e <span class="inlinecode"><span class="id" title="var">g</span></span> rÃ³Å¼ni siÄ™ od
    <span class="inlinecode"><span class="id" title="var">n</span></span>-tej funkcji z tabelki na argumencie <span class="inlinecode"><span class="id" title="var">n</span></span>, gdyÅ¼ zdefiniowaliÅ›my jÄ…
    jako negacjÄ™ tej wÅ‚aÅ›nie komÃ³rki w tabelce. Dostajemy stÄ…d rÃ³wnoÅ›Ä‡
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, co po analizie przypadkÃ³w daje
    ostatecznie <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span> lub <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>.

<div class="paragraph"> </div>

    VoilÃ ! SprzecznoÅ›Ä‡ osiÄ…gniÄ™ta, a zatem poczÄ…tkowe zaÅ‚oÅ¼enie byÅ‚o
    bÅ‚Ä™dne i nie istnieje Å¼adna surjekcja z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
<div class="paragraph"> </div>

<a name="lab166"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, Å¼e nie ma surjekcji z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Czy jest surjekcja
    z <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>? A w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>? 
<div class="paragraph"> </div>

 Poznawszy twierdzenie Cantora, moÅ¼emy powrÃ³ciÄ‡ do Å›cisÅ‚ej pozytywnoÅ›ci,
    czyÅ¼ nie? OtÃ³Å¼ nie, bo twierdzenie Cantora jest biedne. Å»eby czerpaÄ‡
    garÅ›ciami niebotyczne profity, musimy najpierw uogÃ³lniÄ‡ je na dowolne
    dwa typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> znajdujÄ…c kryterium mÃ³wiÄ…ce, kiedy nie istnieje
    surjekcja z <span class="inlinecode"><span class="id" title="var">A</span></span> w <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Cantor'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>)) (<span class="id" title="var">modify</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">modify</span> <span class="id" title="var">b</span> &lt;&gt; <span class="id" title="var">b</span>) -&gt; ~ <span class="id" title="var">surjective</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">modify</span> <span class="id" title="var">H</span> <span class="id" title="var">Hf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">modify</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hf</span> <span class="id" title="var">g</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">Hx</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> =&gt; <span class="id" title="var">h</span> <span class="id" title="var">x</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">H</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
UogÃ³lnienie jest doÅ›Ä‡ banalne. Najpierw zastÄ™pujemy <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> przez
    dowolne typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. W oryginalnym twierdzeniu nie uÅ¼yliÅ›my Å¼adnej
    wÅ‚aÅ›ciwoÅ›ci liczb naturalnych, wiÄ™c nie musimy szukaÄ‡ Å¼adnych kryteriÃ³w
    dla typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Nasza tabelka moÅ¼e rÃ³wnie dobrze byÄ‡ indeksowana elementami
    dowolnego typu - dalej jest to tabelka i dalej ma przekÄ…tnÄ….

<div class="paragraph"> </div>

    Twierdzenie byÅ‚o jednak zaleÅ¼ne od pewnej wÅ‚aÅ›ciwoÅ›ci <span class="inlinecode"><span class="id" title="var">bool</span></span>, mianowicie
    funkcja <span class="inlinecode"><span class="id" title="var">diagonal</span></span> byÅ‚a zdefiniowana jako negacja przekÄ…tnej. ByÅ‚o nam
    jednak potrzeba po prostu funkcji, ktÃ³ra dla kaÅ¼dego elementu z przekÄ…tnej
    zwraca element <span class="inlinecode"><span class="id" title="var">bool</span></span> od niego rÃ³Å¼ny. PoniewaÅ¼ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dokÅ‚adnie dwa
    elementy, to negacja jest jedynÄ… takÄ… funkcjÄ….

<div class="paragraph"> </div>

    Jednak w ogÃ³lnym przypadku dobra bÄ™dzie dowolna <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja bez
    punktÃ³w staÅ‚ych. Ha! NagÅ‚y atak Å¼argonu bezzÄ™bnych ryb, co? ZrÃ³bmy
    krÃ³tkÄ… przerwÄ™, Å¼eby zbadaÄ‡ sposÃ³b komunikacji tych czarodziejskich
    zwierzÄ…t pÅ‚ywajÄ…cych po uczelnianych korytarzach.

<div class="paragraph"> </div>

    Endofunkcja to funkcja, ktÃ³ra ma takÄ… samÄ… dziedzinÄ™ i przeciwdziedzinÄ™.
    MoÅ¼na siÄ™ zatem domyÅ›laÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja to funkcja o typie <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.
    Punkt staÅ‚y zaÅ› to takie <span class="inlinecode"><span class="id" title="var">x</span></span>, Å¼e <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Jest to wiÄ™c dokÅ‚adnie ta
    wÅ‚asnoÅ›Ä‡, ktÃ³rej chcemy, Å¼eby poÅ¼Ä…dana przez nas funkcja nie miaÅ‚a dla
    Å¼adnego <span class="inlinecode"><span class="id" title="var">x</span></span>. Jak widaÄ‡, Å¼argon bezzÄ™bnych ryb jest rÃ³wnie zwiÄ™zÅ‚y jak
    niepenetrowalny dla zwykÅ‚ych Å›miertelnikÃ³w.

<div class="paragraph"> </div>

    PodsumowujÄ…c: w uogÃ³lnionym twierdzeniu Cantora nie wymagamy niczego od
    <span class="inlinecode"><span class="id" title="var">A</span></span>, zaÅ› od <span class="inlinecode"><span class="id" title="var">B</span></span> wymagamy tylko, Å¼eby istniaÅ‚a funkcja <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>,
    ktÃ³ra speÅ‚nia <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">b</span></span>. DowÃ³d twierdzenia jest taki
    jak poprzednio, przy czym zastÄ™pujemy uÅ¼ycie <span class="inlinecode"><span class="id" title="var">negb</span></span> przez <span class="inlinecode"><span class="id" title="var">modify</span></span>. 
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 ZnajdÅº jedyny sÅ‚uszny typ <span class="inlinecode"><span class="id" title="var">B</span></span>, dla ktÃ³rego nie istnieje Å¼adna
    <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja bez punktÃ³w staÅ‚ych.

<div class="paragraph"> </div>

    PodpowiedÅº: to zadanie jest naprawdÄ™ proste i naprawdÄ™ istnieje jedyny
    sÅ‚uszny typ o tej wÅ‚aÅ›ciwoÅ›ci.

<div class="paragraph"> </div>

    Pytanie (bardzo trudne): czy da siÄ™ udowodniÄ‡ w Coqu, Å¼e istnieje
    dokÅ‚adnie jeden taki typ? JeÅ¼eli tak, to w jakim sensie typ ten
    jest unikalny i jakich aksjomatÃ³w potrzeba do przepchniÄ™cia dowodu? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab168"></a><h2 class="section">Twierdzenie Cantora jako mÅ‚ot na negatywnoÅ›Ä‡</h2>

<div class="paragraph"> </div>

 Z Cantorem po naszej stronie moÅ¼emy wreszcie kupiÄ‡ ruble... ekhem,
    moÅ¼emy wreszcie zaprezentowaÄ‡ ogÃ³lnÄ… metodÄ™ dowodzenia, Å¼e negatywne
    typy induktywne prowadzÄ… do sprzecznoÅ›ci. Mimo szumnej nazwy ogÃ³lna
    metoda nie jest aÅ¼ taka ogÃ³lna i czÄ™sto bÄ™dziemy musieli siÄ™ bonusowo
    napracowaÄ‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Example1</span>.<br/>

<br/>
</div>

<div class="doc">
Otworzymy sobie nowy moduÅ‚, Å¼eby nie zaÅ›miecaÄ‡ globalnej przestrzeni
    nazw - wszystkie nasze zÅ‚e typy bÄ™dÄ… siÄ™ nazywaÅ‚y <span class="inlinecode"><span class="id" title="var">wut</span></span>. Przy okazji,
    zdecydowanie powinieneÅ› nabraÄ‡ podejrzeÅ„ do tej nazwy - jeÅ¼eli coÅ› w
    tej ksiÄ…Å¼ce nazywa siÄ™ <span class="inlinecode"><span class="id" title="var">wut</span></span>, to musi to byÄ‡ zÅ‚owrogie, podejrzane
    paskudztwo. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">C</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PC</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">C</span> <span class="id" title="var">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">w</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">w</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>, <span class="id" title="var">f</span> (<span class="id" title="var">C</span> <span class="id" title="var">g</span>) = <span class="id" title="var">PC</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">wut</span></span> to aksjomatyczne kodowanie tego samego typu, o ktÃ³rym poprzednio
    tylko udawaliÅ›my, Å¼e istnieje. ZauwaÅ¼my, Å¼e nie jest nam potrzebna
    reguÅ‚a indukcji - wystarczy jeden z prostszych eliminatorÃ³w, mianowicie
    <span class="inlinecode"><span class="id" title="var">dcase</span></span>, czyli zaleÅ¼na reguÅ‚a analizy przypadkÃ³w. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">A</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dlaczego typ <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest nielegalny, a jego definicja za pomocÄ… komendy
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> jest odrzucana przez Coqa? Poza wspomnianymi w poprzednim
    podrozdziale problemami filozoficznymi wynikajÄ…cymi z nieterminacji,
    jest teÅ¼ drugi, bardziej namacalny powÃ³d: istnienie typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest
    sprzeczne z (uogÃ³lnionym) twierdzeniem Cantora.

<div class="paragraph"> </div>

    PowÃ³d tej sprzecznoÅ›ci jest doÅ›Ä‡ prozaiczny: za pomocÄ… konstruktora <span class="inlinecode"><span class="id" title="var">C</span></span>
    moÅ¼emy z dowolnej funkcji <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> zrobiÄ‡ element <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a skoro
    tak, to dowolne <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> moÅ¼emy odpakowaÄ‡ i wyjÄ…Ä‡ z niego funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">surjective</span> (<span class="id" title="var">bad</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">g</span> <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">C</span> <span class="id" title="var">f</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro moÅ¼emy wÅ‚oÅ¼yÄ‡ dowolnÄ… funkcjÄ™, to moÅ¼emy takÅ¼e wyjÄ…Ä‡ dowolnÄ…
    funkcjÄ™, a zatem mamy do czynienia z surjekcjÄ…. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">worst</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> (<span class="id" title="var">bad</span> <span class="id" title="var">bool</span>) <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">bad_sur</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W poÅ‚Ä…czeniu zaÅ› z twierdzeniem Cantora surjekcja <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>
    prowadzi do sprzecznoÅ›ci - wystarczy za <span class="inlinecode"><span class="id" title="var">A</span></span> wstawiÄ‡ <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Example1</span>.<br/>

<br/>
</div>

<div class="doc">
PrzykÅ‚ad moÅ¼e ci siÄ™ jednak wydaÄ‡ niezadowalajÄ…cy - typ <span class="inlinecode"><span class="id" title="var">wut</span></span> jest
    przecieÅ¼ doÅ›Ä‡ nietypowy, bo ma tylko jeden konstruktor. A co, gdy
    konstruktorÃ³w jest wiÄ™cej?

<div class="paragraph"> </div>

    PoczÄ…tkowo miaÅ‚em opisaÄ‡ kilka przypadkÃ³w z wiÄ™kszÄ… liczbÄ… konstruktorÃ³w,
    ale stwierdziÅ‚em, Å¼e jednak mi siÄ™ nie chce. W Ä‡wiczeniach zobaczymy, czy
    bÄ™dziesz w stanie sam wykombinowaÄ‡, jak siÄ™ z nimi uporaÄ‡. 
<div class="paragraph"> </div>

<a name="lab169"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 PoniÅ¼sze paskudztwo Å‚amie prawo Å›cisÅ‚ej pozytywnoÅ›ci nie jednym, lecz
    aÅ¼ dwoma swoimi konstruktorami.

<div class="paragraph"> </div>

    Zakoduj ten typ aksjomatycznie i udowodnij, Å¼e jego istnienie prowadzi
    do sprzecznoÅ›ci. Metoda jest podobna jak w naszym przykÅ‚adzie, ale
    trzeba jÄ… troszkÄ™ dostosowaÄ‡ do zastanej sytuacji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise1</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C0</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">wut</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C1</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">wut</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise1</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab170"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 PoniÅ¼sze paskudztwo ma jeden konstruktor negatywny, a drugi pozytywny,
    niczym typowa panienka z borderlinem...

<div class="paragraph"> </div>

    Polecenie jak w poprzednim Ä‡wiczeniu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise2</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C0</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">wut</span>) -&gt; <span class="id" title="var">wut</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">wut</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise2</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab171"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 PoniÅ¼szy typ reprezentuje termy beztypowego rachunku lambda, gdzie <span class="inlinecode"><span class="id" title="var">V</span></span>
    to typ reprezentujÄ…cy zmienne. Co to za zwierzÄ…tko ten rachunek lambda
    to my siÄ™ jeszcze przekonamy... chyba, oby.

<div class="paragraph"> </div>

    Taki sposÃ³b reprezentowania rachunku lambda (i ogÃ³lnie skÅ‚adni jÄ™zykÃ³w
    programowania) nazywa siÄ™ HOAS, co jest skrÃ³tem od ang. Higher Order
    Abstract Syntax. W wielu jÄ™zykach funkcyjnych jest to popularna technika,
    ale w Coqu, jak zaraz udowodnisz, jest ona nielegalna. Åawa oburzonych
    jest rzecz jasna oburzona! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise3</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">Term</span> (<span class="id" title="var">V</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Var</span> : <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Lam</span> : (<span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span>) -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">App</span> : <span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Term_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise3</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab172"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 PoniÅ¼sze bydle jest najgorsze z moÅ¼liwych - pÃ³ki co nie wiem, jak to
    udowodniÄ‡. Powodzenia! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise4</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">wut</span>) -&gt; <span class="id" title="var">wut</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise4</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab173"></a><h2 class="section">Poradnik rozpoznawania negatywnych typÃ³w induktywnych</h2>

<div class="paragraph"> </div>

 Skoro juÅ¼ wiemy, Å¼e negatywne typy induktywne sÄ… wynalazkiem szatana,
    to czas podaÄ‡ proste kryterium na ich rozpoznawanie. JeÅ¼eli jesteÅ›
    sprytny, to pewnie sam zdÄ…Å¼yÅ‚eÅ› juÅ¼ zauwaÅ¼yÄ‡ ogÃ³lnÄ… reguÅ‚Ä™. Jednak aby
    nie dyskryminowaÄ‡ osÃ³b maÅ‚o sprytnych, trzeba napisaÄ‡ jÄ… wprost.

<div class="paragraph"> </div>

    Kryterium jest banalne. MajÄ…c dany typ <span class="inlinecode"><span class="id" title="var">T</span></span> musimy rzuciÄ‡ okiem na jego
    konstruktory, a konkretniej na ich argumenty. Argumenty nieindukcyjne
    (czyli o typach, w ktÃ³rych nie wystÄ™puje <span class="inlinecode"><span class="id" title="var">T</span></span>) sÄ… zupeÅ‚nie niegroÅºnie.
    InteresowaÄ‡ nas powinny jedynie argumenty indukcyjne, czyli takie, w
    ktÃ³rych wystÄ™puje typ <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    NiektÃ³re typy argumentÃ³w indukcyjnych sÄ… niegroÅºne, np. <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> albo <span class="inlinecode">{<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>}</span>, ale powodujÄ… one, Å¼e Coq nie potrafi
    wygenerowaÄ‡ odpowiedniej reguÅ‚y indukcji i zadowala siÄ™ jedynie reguÅ‚Ä…
    analizy przypadkÃ³w. Nie prowadzÄ… one do sprzecznoÅ›ci, ale powinniÅ›my ich
    unikaÄ‡.

<div class="paragraph"> </div>

    Argument typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span> moÅ¼na zastÄ…piÄ‡ dwoma argumentami typu <span class="inlinecode"><span class="id" title="var">T</span></span>
    i podobnie dla <span class="inlinecode">{<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>}</span>. Konstruktor z argumentem typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    moÅ¼emy rozbiÄ‡ na dwa konstruktory (i powinniÅ›my, bo jest to bardziej
    czytelne). Konstruktor z wystÄ…pieniem <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> moÅ¼emy przerobiÄ‡ na
    definicjÄ™ przez indukcjÄ™ wzajemnÄ… (Ä‡wiczenie: sprawdÅº jak), ale lepiej
    chyba po prostu zaimplementowaÄ‡ reguÅ‚Ä™ indukcji rÄ™cznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T0</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c3</span> : <span class="id" title="var">nat</span> * <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c4</span> : <span class="id" title="var">T0</span> * <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c5</span> : <span class="id" title="var">T0</span> + <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c6</span> : <span class="id" title="var">list</span> <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span>.<br/>

<br/>
</div>

<div class="doc">
Rodzaje nieszkodliwych typÃ³w argumentÃ³w widaÄ‡ na powyÅ¼szym przykÅ‚adzie.
    Konstruktory <span class="inlinecode"><span class="id" title="var">c0</span></span> i <span class="inlinecode"><span class="id" title="var">c1</span></span> sÄ… nieindukcyjne, wiÄ™c sÄ… ok. Konstruktor <span class="inlinecode"><span class="id" title="var">c2</span></span>
    jest indukcyjny - jest jeden argument typu <span class="inlinecode"><span class="id" title="var">T0</span></span>. ZauwaÅ¼, Å¼e typem
    konstruktora <span class="inlinecode"><span class="id" title="var">c2</span></span> jest <span class="inlinecode"><span class="id" title="var">T0</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T0</span></span>, ale nie oznacza to, Å¼e <span class="inlinecode"><span class="id" title="var">T0</span></span>
    wystÄ™puje po lewej stronie strzaÅ‚ki!

<div class="paragraph"> </div>

    Jest tak, gdyÅ¼ ostatnie wystÄ…pienie <span class="inlinecode"><span class="id" title="var">T0</span></span> jest konkluzjÄ… konstruktora
    <span class="inlinecode"><span class="id" title="var">c2</span></span>. WaÅ¼ne sÄ… tylko wystÄ…pienia po lewej stronie strzaÅ‚ki w argumentach
    (gdyby konstruktor <span class="inlinecode"><span class="id" title="var">c2</span></span> nie byÅ‚ legalny, to jedynymi legalnymi typami
    induktywnymi byÅ‚yby enumeracje).

<div class="paragraph"> </div>

    Konstruktory <span class="inlinecode"><span class="id" title="var">c3</span></span>, <span class="inlinecode"><span class="id" title="var">c4</span></span>, <span class="inlinecode"><span class="id" title="var">c5</span></span> i <span class="inlinecode"><span class="id" title="var">c6</span></span> sÄ… induktywne i rÃ³wnieÅ¼ w peÅ‚ni
    legalne, ale sÄ… one powodem tego, Å¼e Coq nie generuje dla <span class="inlinecode"><span class="id" title="var">T0</span></span> reguÅ‚y
    indukcji, a jedynie reguÅ‚Ä™ analizy przypadkÃ³w (choÄ‡ nazwa siÄ™ ona
    <span class="inlinecode"><span class="id" title="var">T0_ind</span></span>). 
<div class="paragraph"> </div>

<a name="lab174"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zrefaktoryzuj powyÅ¼szy upoÅ›ledzony typ. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Problem pojawia siÄ™ dopiero, gdy typ <span class="inlinecode"><span class="id" title="var">T</span></span> wystÄ™puje po lewej stronie
    strzaÅ‚ki, np. <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, lub gdy jest
    skwantyfikowany uniwersalnie, np. <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>,
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>),</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span>.

<div class="paragraph"> </div>

    W trzech poprzednich podrozdziaÅ‚ach mierzyliÅ›my siÄ™ z sytuacjami, gdy
    typ <span class="inlinecode"><span class="id" title="var">T</span></span> wystÄ™powaÅ‚ bezpoÅ›rednio na lewo od strzaÅ‚ki, ale oczywiÅ›cie
    moÅ¼e on byÄ‡ dowolnie zagnieÅ¼dÅ¼ony. Dla kaÅ¼dego wystÄ…pienia <span class="inlinecode"><span class="id" title="var">T</span></span> w
    argumentach moÅ¼emy policzyÄ‡, na lewo od ilu strzaÅ‚ek (albo jako
    jak mocno zagnieÅ¼dÅ¼ona dziedzina kwantyfikacji) siÄ™ ono znajduje.
    LiczbÄ™ tÄ™ nazywaÄ‡ bÄ™dziemy niedobroÅ›ciÄ…. W zaleÅ¼noÅ›ci od niedobroÅ›ci,
    wystÄ…pienie nazywamy:
<ul class="doclist">
<li> 0 - wystÄ…pienie Å›ciÅ›le pozytywne

</li>
<li> liczba nieparzysta - wystÄ…pienie negatywne

</li>
<li> liczba parzysta (poza 0) - wystÄ…pienie pozytywne 
</li>
</ul>

<div class="paragraph"> </div>

 JeÅ¼eli w definicji mamy wystÄ…pienie negatywne, to typ moÅ¼emy nazywaÄ‡
    negatywnym typem induktywnym (choÄ‡ oczywiÅ›cie nie jest to typ
    induktywny). JeÅ¼eli nie ma wystÄ…pieÅ„ negatywnych, ale sÄ… wystÄ…pienia
    pozytywne, to typ nazywamy pozytywnym typem induktywnym (lub nie Å›ciÅ›le
    pozytywnym typem induktywnym), choÄ‡ oczywiÅ›cie rÃ³wnieÅ¼ nie jest to typ
    induktywny. JeÅ¼eli wszystkiego wystÄ…pienia sÄ… Å›ciÅ›le pozytywne, to mamy
    do czynienia po prostu z typem induktywnym.

<div class="paragraph"> </div>

    Podobne nazewnictwo moÅ¼emy sobie wprowadziÄ‡ dla konstruktorÃ³w
    (konstruktory negatywne, pozytywne i Å›ciÅ›le pozytywne), ale nie
    ma sensu, bo za tydzieÅ„ i zapomnisz o tych maÅ‚o istotnych detalach.
    WaÅ¼ne, Å¼ebyÅ› zapamiÄ™taÅ‚ najwaÅ¼niejsze, czyli ideÄ™. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">T1</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T1_0</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T1_1</span> : (<span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T1</span>) -&gt; <span class="id" title="var">T1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T1_2</span> : ((<span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T1</span>) -&gt; <span class="id" title="var">T1</span>) -&gt; <span class="id" title="var">T1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T1_3</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">t</span> : <span class="id" title="var">T1</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">T1</span>.<br/>

<br/>
</div>

<div class="doc">
W powyÅ¼szym przykÅ‚adzie wystÄ…pienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w pierwszym argumencie
    <span class="inlinecode"><span class="id" title="var">T1_0</span></span> jest Å›ciÅ›le pozytywne (na lewo od 0 strzaÅ‚ek). Pierwsze
    wystÄ…pienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w <span class="inlinecode"><span class="id" title="var">T1_1</span></span> jest negatywne (na lewo od 1 strzaÅ‚ki),
    a drugie Å›ciÅ›le pozytywne (na lewo od 0 strzaÅ‚ek). Pierwsze
    wystÄ…pienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w <span class="inlinecode"><span class="id" title="var">T1_2</span></span> jest pozytywne (na lewo od 2 strzaÅ‚ek),
    drugie negatywne (na lewo od 1 strzaÅ‚ki), trzecie zaÅ› Å›ciÅ›le
    pozytywne (na lewo od 0 strzaÅ‚ek). Pierwsze wystÄ…pienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w
    <span class="inlinecode"><span class="id" title="var">T1_3</span></span> jest negatywne (dziedzina kwantyfikacji), drugie zaÅ›
    pozytywne (na lewo od jednej strzaÅ‚ki, ale ta strzaÅ‚ka jest w
    typie, po ktÃ³rym kwantyfikujemy).

<div class="paragraph"> </div>

    Konstruktor <span class="inlinecode"><span class="id" title="var">T1_0</span></span> jest Å›ciÅ›le pozytywne, zaÅ› konstruktory <span class="inlinecode"><span class="id" title="var">T1_1</span></span>,
    <span class="inlinecode"><span class="id" title="var">T1_2</span></span> oraz <span class="inlinecode"><span class="id" title="var">T1_3</span></span> sÄ… negatywne. Wobec tego typ <span class="inlinecode"><span class="id" title="var">T1</span></span> jest negatywnym
    typem induktywnym (czyli wynalazkiem szatana, ktÃ³rego zaakceptowanie
    prowadzi do sprzecznoÅ›ci). 
<div class="paragraph"> </div>

<a name="lab175"></a><h4 class="section">Ä†wiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">T2</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T2_0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> : <span class="id" title="var">T2</span>, <span class="id" title="var">nat</span>), <span class="id" title="keyword">Prop</span>), <span class="id" title="var">T2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T2_1</span> : (((((<span class="id" title="var">T2</span> -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T2_2</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">T2</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> : <span class="id" title="var">T2</span>, <span class="id" title="var">nat</span>)) -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T2</span> -&gt; <span class="id" title="var">T2</span> -&gt; <span class="id" title="var">T2</span>.<br/>

<br/>
</div>

<div class="doc">
Policz niedobroÅ›Ä‡ kaÅ¼dego wstÄ…pienia <span class="inlinecode"><span class="id" title="var">T2</span></span> w powyÅ¼szej definicji.
    Sklasyfikuj konstruktory jako negatywne, pozytywne lub Å›ciÅ›le
    pozytywne. NastÄ™pnie sklasyfikuj sam typ jako negatywny, pozytywny
    lub Å›ciÅ›le pozytywny. 
<div class="paragraph"> </div>

<a name="lab176"></a><h4 class="section">Ä†wiczenie</h4>

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Inductive&nbsp;T&nbsp;:&nbsp;Type&nbsp;:=&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Rozstrzygnij, czy nastÄ™pujÄ…ce konstruktory speÅ‚niajÄ… kryterium Å›cisÅ‚ej
    pozytywnoÅ›ci. JeÅ¼eli tak, narysuj wesoÅ‚ego jeÅ¼a. JeÅ¼eli nie, napisz
    zapÄ™tlajÄ…cÄ… siÄ™ funkcjÄ™ podobnÄ… do <span class="inlinecode"><span class="id" title="var">loop</span></span> (zakÅ‚adamy, Å¼e typ <span class="inlinecode"><span class="id" title="var">T</span></span> ma
    tylko ten jeden konstruktor). NastÄ™pnie sprawdÅº w Coqu, czy udzieliÅ‚eÅ›
    poprawnej odpowiedzi.
<ul class="doclist">
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C3</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C4</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C5</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C6</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C7</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C8</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C9</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C10</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>),</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C11</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span>
                  <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab177"></a><h2 class="section">Kilka bonusowych puÅ‚apek</h2>

<div class="paragraph"> </div>

 Wiemy juÅ¼, Å¼e niektÃ³re typy argumentÃ³w indukcyjnych sÄ… ok (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>), a niektÃ³re inne nie (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">...</span>).
    UwaÅ¼ny i Å¼Ä…dny wiedzy czytelnik (daj boÅ¼e, Å¼eby tacy istnieli) zeche
    zapewne postawiÄ‡ sobie pytanie: ktÃ³re dokÅ‚adnie typy argumentÃ³w
    indukcyjnych sÄ… ok, a ktÃ³re sÄ… wynalazkiem szatana?

<div class="paragraph"> </div>

    NajproÅ›ciej bÄ™dzie sprawÄ™ zbadaÄ‡ empirycznie, czyli na przykÅ‚adzie.
    Å»eby zaÅ› przykÅ‚ad byÅ‚ reprezentatywny, niech parametrem definicji
    bÄ™dzie dowolna funkcja <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">wut_0</span> : <span class="id" title="var">F</span> (<span class="id" title="var">wut</span> <span class="id" title="var">F</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">F</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"F&nbsp;(wut&nbsp;F)&nbsp;-&gt;&nbsp;wut&nbsp;F".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widaÄ‡, jeÅ¼eli zaaplikujemy <span class="inlinecode"><span class="id" title="var">F</span></span> do argumentu indukcyjnego, to Coq
    krzyczy, Å¼e to wystÄ…pienie nie jest Å›ciÅ›le pozytywne. Dlaczego tak
    jest, skoro <span class="inlinecode"><span class="id" title="var">F</span></span> nie jest ani strzaÅ‚kÄ…, ani kwantyfikatorem uniwersalnym?
    Dlatego, Å¼e choÄ‡ nie jest nimi, to moÅ¼e nimi zostaÄ‡. JeÅ¼eli zdefiniujemy
    sobie gdzieÅ› na boku <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, to wtedy
    <span class="inlinecode"><span class="id" title="var">wut_0</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span>, a z takim diabelstwem juÅ¼ siÄ™
    mierzyliÅ›my i wiemy, Å¼e nie wrÃ³Å¼y ono niczego dobrego.

<div class="paragraph"> </div>

    MoraÅ‚ z tej historii jest doÅ›Ä‡ banalny: gdy definiujemy typ induktywny
    <span class="inlinecode"><span class="id" title="var">T</span></span>, jedynymi prawilnymi typami dla argumentu indukcyjnego sÄ… <span class="inlinecode"><span class="id" title="var">T</span></span> oraz
    typy funkcji, ktÃ³re majÄ… <span class="inlinecode"><span class="id" title="var">T</span></span> jako konkluzjÄ™ (<span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    etc.). Wszystkie inne albo rodzÄ… problemy z automatycznÄ… generacjÄ…
    reguÅ‚ indukcji (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>), albo prowadzÄ… do sprzecznoÅ›ci
    (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">...</span>), albo mogÄ… prowadziÄ‡ do sprzecznoÅ›ci,
    jeÅ¼eli wstawi siÄ™ za nie coÅ› niedobrego (<span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>). 
<div class="paragraph"> </div>

<a name="lab178"></a><h4 class="section">Ä†wiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">wutF</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">F</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> := <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Zakoduj aksjomatycznie rodzinÄ™ typÃ³w <span class="inlinecode"><span class="id" title="var">wut</span></span> z powyÅ¼szego przykÅ‚adu.
    NastÄ™pnie wstaw za parametr zdefiniowane powyÅ¼ej <span class="inlinecode"><span class="id" title="var">F</span></span> i udowodnij,
    Å¼e typ <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> prowadzi do sprzecznoÅ›ci. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">wutF</span>.<br/>

<br/>
</div>

<div class="doc">
To jeszcze nie koniec wraÅ¼eÅ„ na dziÅ› - pÃ³ki co omÃ³wiliÅ›my wszakÅ¼e
    kryterium Å›cisÅ‚ej pozytywnoÅ›ci jedynie dla bardzo prostych typÃ³w
    induktywnych. SÅ‚owem nie zajÄ…knÄ™liÅ›my siÄ™ nawet na temat typÃ³w
    wzajemnie induktywnych czy indeksowanych typÃ³w induktywnych. Nie
    trudno bÄ™dzie nam jednak uzupeÅ‚niÄ‡ naszÄ… wiedzÄ™, gdyÅ¼ w przypadku
    oby tych mechanizmÃ³w kryterium Å›cisÅ‚ej pozytywnoÅ›ci wyglÄ…da podobnie
    jak w znanych nam juÅ¼ przypadkach. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">X0</span> : <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">X1</span> : (<span class="id" title="var">Y</span> -&gt; <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Y</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Y0</span> : <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Y1</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">Y</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"Y"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;"(Y&nbsp;-&gt;&nbsp;X)&nbsp;-&gt;&nbsp;X".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widaÄ‡, definicja <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> przez wzajemnÄ… indukcjÄ™ jest nielegalna,
    gdyÅ¼ jedyny argument konstruktora <span class="inlinecode"><span class="id" title="var">X1</span></span> ma typ <span class="inlinecode"><span class="id" title="var">Y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span>. MogÅ‚oby wydawaÄ‡
    siÄ™, Å¼e wszystko jest w porzÄ…dku, wszakÅ¼e <span class="inlinecode"><span class="id" title="var">X</span></span> wystÄ™puje tutaj na pozycji
    Å›ciÅ›le pozytywnej. Jednak poniewaÅ¼ jest to definicja przez indukcjÄ™
    wzajemnÄ…, kryterium Å›cisÅ‚ej pozytywnoÅ›ci stosuje siÄ™ nie tylko do
    wystÄ…pieÅ„ <span class="inlinecode"><span class="id" title="var">X</span></span>, ale takÅ¼e do wystÄ…pieÅ„ <span class="inlinecode"><span class="id" title="var">Y</span></span> - wszystkie wystÄ…pienia <span class="inlinecode"><span class="id" title="var">X</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">Y</span></span> muszÄ… byÄ‡ Å›ciÅ›le pozytywne zarÃ³wno w konstruktorach typu <span class="inlinecode"><span class="id" title="var">X</span></span>,
    jak i w konstruktorach typu <span class="inlinecode"><span class="id" title="var">Y</span></span>. 
<div class="paragraph"> </div>

<a name="lab179"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zakoduj aksjomatycznie definicjÄ™ typÃ³w <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span>. SprÃ³buj napisaÄ‡
    zapÄ™tlajÄ…cÄ… siÄ™ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">loop</span></span> (czy raczej dwie wzajemnie rekurencyjne
    zapÄ™tlajÄ…ce siÄ™ funkcje <span class="inlinecode"><span class="id" title="var">loopx</span></span> i <span class="inlinecode"><span class="id" title="var">loopy</span></span>), a nastÄ™pnie udowodnij za
    pomocÄ… twierdzenia Cantora, Å¼e typy <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> sÄ… nielegalne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">XY</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">XY_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">XY</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab180"></a><h2 class="section">Jeszcze wiÄ™cej puÅ‚apek</h2>

<div class="paragraph"> </div>

 To juÅ¼ prawie koniec naszej wÄ™drÃ³wki przez Å›wiat nielegalnych typÃ³w
    "induktywnych". DowiedzieliÅ›my siÄ™, Å¼e negatywne typy induktywne
    prowadzÄ… do nieterminacji i nauczyliÅ›my siÄ™ wykorzystywaÄ‡ twierdzenie
    Cantora do dowodzenia nielegalnoÅ›ci takich typÃ³w.

<div class="paragraph"> </div>

    PoznaliÅ›my teÅ¼ jednak klasyfikacjÄ™ typÃ³w wyglÄ…dajÄ…cych na induktywne
    (Å›ciÅ›le pozytywne, pozytywne, negatywne), a w szczegÃ³lnoÅ›ci pojÄ™cie
    "niedobroÅ›ci" indukcyjnego wystÄ…pienia definiowanego typu w konstruktorze
    (upraszczajÄ…c, na lewo od ilu strzaÅ‚ek znajduje siÄ™ to wystÄ…pienie).

<div class="paragraph"> </div>

    PiszÄ™ "jednak", gdyÅ¼ z jej powodu moÅ¼emy czuÄ‡ pewien niedosyt - wszystkie
    dotychczasowe przykÅ‚ady byÅ‚y typami negatywnymi o niedobroÅ›ci rÃ³wnej 1.
    Podczas naszej intelektualnej wÄ™drÃ³wki zwiedziliÅ›my mniej miejscÃ³wek,
    niÅ¼ moglibyÅ›my chcieÄ‡. W tym podrozdziale sprÃ³bujemy ten przykry niedosyt
    zaÅ‚ataÄ‡, rozwaÅ¼ajÄ…c (nie Å›ciÅ›le) pozytywne typy induktywne. Zobaczymy
    formalny dowÃ³d na to, Å¼e nie sÄ… one legalne (lub, precyzyjniej piszÄ…c,
    dowÃ³d na to, Å¼e conajmniej jeden z nich nie jest legalny). Zanim jednak
    to siÄ™ stanie, zobaczmy, czy wypracowane przez nas techniki dziaÅ‚ajÄ… na
    negatywne typy induktywne o niedobroÅ›ci innej niÅ¼ 1. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T3</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">T3</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T3_0</span> : (((<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">T3</span>.<br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy siÄ™ powyÅ¼szej definicji. WystÄ™pienie indukcyjne typu <span class="inlinecode"><span class="id" title="var">T3</span></span>
    ma wspÃ³Å‚czynnik niedobroÅ›ci rÃ³wny 3, gdyÅ¼ znajduje siÄ™ na lewo od 3
    strzaÅ‚ek. Prawe strony wszystkich z nich to <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">T3</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">T3_0</span> : (((<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">T3</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">T3_case</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">T3</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PT3_0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> (<span class="id" title="var">T3_0</span> <span class="id" title="var">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T3</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : ((<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">T3_0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">PT3_0</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
Po ciÄ™Å¼kich bojach, przez ktÃ³re przeszedÅ‚eÅ›, aksjomatyczne kodowanie
    tego typu nie powinno ciÄ™ dziwiÄ‡. Warto zauwaÅ¼yÄ‡ jedynie, Å¼e do naszej
    dyspozycji mamy jedynie reguÅ‚Ä™ zaleÅ¼nej analizy przypadkÃ³w, gdyÅ¼ nie
    wiadomo, jak miaÅ‚yby wyglÄ…daÄ‡ wywoÅ‚ania indukcyjne.

<div class="paragraph"> </div>

    Zanim zobaczymy, jak pokazaÄ‡ nielegalnoÅ›Ä‡ tego typu metodÄ… Cantora,
    przypomnijmy sobie pewien kluczowy fakt dotyczÄ…cy negacji i jego
    banalne uogÃ³lnienie. 
<div class="paragraph"> </div>

<a name="lab181"></a><h4 class="section">Ä†wiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_negation</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ ~ ~ <span class="id" title="var">P</span> -&gt; ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_arrow</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, (((<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>).<br/>

<br/>
</div>

<div class="doc">
Ä†wiczenie to przypomina nam, Å¼e jeÅ¼eli chodzi o spamowanie negacjÄ…, to
    sÄ… w zasadzie tylko trzy sytuacje:
<ul class="doclist">
<li> brak negacji

</li>
<li> pojedyncza negacja

</li>
<li> podwÃ³jna negacja 
</li>
</ul>

<div class="paragraph"> </div>

 JeÅ¼eli mamy do czynienia z wiÄ™kszÄ… liczbÄ… negacji, to moÅ¼emy zdejmowaÄ‡
    po dwie aÅ¼ dojdziemy do ktÃ³regoÅ› z powyÅ¼szych przypadkÃ³w. PoniewaÅ¼
    negacja to tylko implikacja, ktÃ³rej kodziedzinÄ… jest <span class="inlinecode"><span class="id" title="var">False</span></span>, a nie
    korzystamy w dowodzie z Å¼adnych specjalnych wÅ‚aÅ›ciwoÅ›ci <span class="inlinecode"><span class="id" title="var">False</span></span>,
    analogiczna wÅ‚aÅ›ciwoÅ›Ä‡ zachodzi takÅ¼e dla dowolnego innego <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> : <span class="id" title="var">T3</span> -&gt; (<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">T3_case</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">g</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Wobec powyÅ¼szych rozwaÅ¼aÅ„ definicja funkcji bad zupeÅ‚nie nie powinna
    ciÄ™ zaskakiwaÄ‡. Szczerze piszÄ…c, reszta dowodu rÃ³wnieÅ¼ nie jest jakoÅ›
    specjalnie wymagajÄ…ca czy oÅ›wiecajÄ…ca. 
<div class="paragraph"> </div>

<a name="lab182"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 DokoÅ„cz dowÃ³d. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">bad</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">T3_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab183"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Napisanie zapÄ™tlajÄ…cej siÄ™ funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T3</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> teÅ¼ nie jest
    jakoÅ› wybitnie trudne. Napisz jÄ… i udowodnij (nieformlanie), Å¼e
    istnieje takie <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T3</span></span>, Å¼e <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> siÄ™ zapÄ™tla. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T3</span>.<br/>

<br/>
</div>

<div class="doc">
MoraÅ‚ z powyÅ¼szych rozwaÅ¼aÅ„ jest prosty: nasze techniki dziaÅ‚ajÄ… takÅ¼e
    na negatywne typy induktywne o niedobroÅ›ci rÃ³wnej 3. MyÅ›lÄ™, Å¼e jesteÅ›
    caÅ‚kiem skÅ‚onny uwierzyÄ‡ teÅ¼, Å¼e zadziaÅ‚ajÄ… na te o niedobroÅ›ci rÃ³wnej
    5, 7 i tak dalej.

<div class="paragraph"> </div>

    To wszystko jest prawdÄ… jednak tylko wtedy, gdy wszystkie typy po prawych
    stronach strzaÅ‚ek bÄ™dÄ… takie same. A co, gdy bÄ™dÄ… rÃ³Å¼ne? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T4</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">T4</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T4</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">T4</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0</span> : (((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T4</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">T4</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pc0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T4</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : ((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">c0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">Pc0</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
PowyÅ¼szy przykÅ‚ad jest podobny do poprzedniego, ale tym razem zamiast
    trzech wystÄ…pieÅ„ <span class="inlinecode"><span class="id" title="var">bool</span></span> mamy <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">Color</span></span> (to typ, ktÃ³ry
    zdefiniowaliÅ›my na samym poczÄ…tku tego rozdziaÅ‚u, gdy uczyliÅ›my siÄ™
    o enumeracjach). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> : <span class="id" title="var">T4</span> -&gt; (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">dcase</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">T4</span> -&gt; <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Nasz modus operandi bÄ™dzie taki jak poprzednio: sprÃ³bujemy wyjÄ…Ä‡ z
    elementu <span class="inlinecode"><span class="id" title="var">T4</span></span> funkcjÄ™ typu <span class="inlinecode"><span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. W tym celu uÅ¼ywamy zaleÅ¼nej
    reguÅ‚y analizy przypadkÃ³w i wprowadzamy rzeczy do kontekstu.

<div class="paragraph"> </div>

    Tym razem nie moÅ¼emy jednak bezpoÅ›rednio zaaplikowaÄ‡ <span class="inlinecode"><span class="id" title="var">f</span></span>, gdyÅ¼ jej
    kodziedzinÄ… jest <span class="inlinecode"><span class="id" title="var">Color</span></span>, a my musimy skonstruowaÄ‡ coÅ› typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    MoÅ¼emy temu jednak zaradziÄ‡ aplikujÄ…c do celu skonstruowanÄ… naprÄ™dce
    funkcjÄ™ typu <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Ta funkcja powinna byÄ‡ surjekcjÄ… (jeÅ›li
    nie wierzysz, sprawdÅº, co siÄ™ stanie, jeÅ¼eli zamienimy jÄ… na funckjÄ™
    staÅ‚Ä…).

<div class="paragraph"> </div>

    MoÅ¼emy juÅ¼ zaaplikowaÄ‡ <span class="inlinecode"><span class="id" title="var">f</span></span> i wprowadziÄ‡ <span class="inlinecode"><span class="id" title="var">g</span></span> do kontekstu. ChcielibyÅ›my
    teraz zaaplikowaÄ‡ <span class="inlinecode"><span class="id" title="var">g</span></span>, ale nie moÅ¼emy, bo typy siÄ™ nie zgadzajÄ… - <span class="inlinecode"><span class="id" title="var">g</span></span>
    zwraca <span class="inlinecode"><span class="id" title="var">bool</span></span>, a my musimy skonstruowaÄ‡ liczbÄ™ naturalnÄ…. Robimy tutaj
    to samo co poprzednio - aplikujemy do celu jakÄ…Å› funkcjÄ™ <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>.
    Tym razem nie musi ona byÄ‡ surjekcjÄ… (nie jest to nawet moÅ¼liwe, gdyÅ¼
    nie ma surjekcji z <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span>). DziÄ™ki temu moÅ¼emy zaaplikowaÄ‡ <span class="inlinecode"><span class="id" title="var">g</span></span>
    i zakoÅ„czyÄ‡, uÅ¼ywajÄ…c <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
</div>

<div class="doc">
Å»eby pokazaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">bad</span></span> jest surjekcjÄ…, bÄ™dziemy potrzebowaÄ‡ aksjomatu
    ekstensjonalnoÅ›ci dla funkcji (ang. functional extensionality axiom,
    w skrÃ³cie funext). GÅ‚osi on, Å¼e dwie funkcje <span class="inlinecode"><span class="id" title="var">f</span>,</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> sÄ… rÃ³wne,
    jeÅ¼eli uda nam siÄ™ pokazaÄ‡, Å¼e dajÄ… rÃ³wne wyniki dla kaÅ¼dego argumentu
    (czyli <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).

<div class="paragraph"> </div>

    ImportujÄ…c powyÅ¼szy moduÅ‚ zakÅ‚adamy prawdziwoÅ›Ä‡ tego aksjomatu oraz
    uzyskujemy dostÄ™p do taktyki <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span>, ktÃ³ra uÅ‚atwia dowody
    wymagajÄ…ce uÅ¼ycia ekstensjonalnoÅ›ci. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">bad</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">t</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
DowÃ³d jest prawie taki jak zawsze: odwijamy definicjÄ™ surjektywnoÅ›ci i
    wprowadzamy hipotezy do kontekstu, a nastÄ™pnie odwijamy definicjÄ™ <span class="inlinecode"><span class="id" title="var">bad</span></span>
    i rozbijamy jÄ… dla czytelnoÅ›ci na wÅ‚aÅ›ciwÄ… funkcjÄ™ <span class="inlinecode"><span class="id" title="var">bad</span></span> oraz rÃ³wnanie
    <span class="inlinecode"><span class="id" title="var">eq</span></span>.

<div class="paragraph"> </div>

    NastÄ™pnie musimy znaleÅºÄ‡ <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T4</span></span>, ktÃ³re <span class="inlinecode"><span class="id" title="var">bad</span></span> mapuje na <span class="inlinecode"><span class="id" title="var">f</span></span>. Zaczynamy
    od <span class="inlinecode"><span class="id" title="var">c0</span></span>, bo jest to jedyny konstruktor <span class="inlinecode"><span class="id" title="var">T4</span></span>. Bierze on jako argument
    funkcjÄ™ typu <span class="inlinecode">((<span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span></span>. Å»eby jÄ… wyprodukowaÄ‡,
    bierzemy na wejÅ›ciu funkcjÄ™ <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> i musimy zrobiÄ‡
    coÅ› typu <span class="inlinecode"><span class="id" title="var">Color</span></span>.

<div class="paragraph"> </div>

    Nie moÅ¼e to byÄ‡ jednak byle co - musimy uÅ¼yÄ‡ <span class="inlinecode"><span class="id" title="var">f</span></span>, a jedynym sensownym
    sposobem, Å¼eby to zrobiÄ‡, jest zaaplikowaÄ‡ <span class="inlinecode"><span class="id" title="var">g</span></span> do <span class="inlinecode"><span class="id" title="var">f</span></span>. Musimy zadbaÄ‡
    teÅ¼ o to, Å¼eby odwrÃ³ciÄ‡ funkcje konwertujÄ…ce <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, ktÃ³rych uÅ¼yliÅ›my w definicji <span class="inlinecode"><span class="id" title="var">bad</span></span>. Pierwsza z nich
    konwertowaÅ‚a <span class="inlinecode"><span class="id" title="var">R</span></span> (czyli kolor czerwony) na <span class="inlinecode"><span class="id" title="var">true</span></span>, a inne kolory na
    <span class="inlinecode"><span class="id" title="var">false</span></span>, zaÅ› druga konwertowaÅ‚a <span class="inlinecode"><span class="id" title="var">true</span></span> na <span class="inlinecode">0</span>, a <span class="inlinecode"><span class="id" title="var">false</span></span> na <span class="inlinecode">1</span>.
    Wobec tego dopasowujÄ…c <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> musimy przekonwertowaÄ‡ <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">R</span></span>,
    zaÅ› <span class="inlinecode">1</span> na coÅ› innego niÅ¼ <span class="inlinecode"><span class="id" title="var">R</span></span>, np. na <span class="inlinecode"><span class="id" title="var">G</span></span> (czyli kolor zielony).

<div class="paragraph"> </div>

    ZnalazÅ‚szy odpowiedni argument, moÅ¼emy przepisaÄ‡ rÃ³wnanie definiujÄ…ce
    <span class="inlinecode"><span class="id" title="var">bad</span></span>. To juÅ¼ prawie koniec, ale prÃ³ba uÅ¼ycia taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> w
    tym momencie skoÅ„czyÅ‚aby siÄ™ poraÅ¼kÄ…. Na ratunek przychodzi nam
    aksjomat ekstensjonalnoÅ›ci, ktÃ³rego uÅ¼ywamy piszÄ…c <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>.
    DziÄ™ki temu pozostaje nam pokazaÄ‡ jedynie, Å¼e <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> jest rÃ³wne tej
    drugie funkcji dla argumentu <span class="inlinecode"><span class="id" title="var">t</span></span>. W tym celu rozbijamy <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, a oba
    wyraÅ¼enia okazujÄ… siÄ™ byÄ‡ konwertowalne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">T4_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> <span class="id" title="var">bad</span> <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">bad_sur</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro mamy surjekcjÄ™ z <span class="inlinecode"><span class="id" title="var">T4</span></span> w <span class="inlinecode"><span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, katastrofy nie da siÄ™
    uniknÄ…Ä‡.

<div class="paragraph"> </div>

    MoglibyÅ›my siÄ™ teÅ¼ zastanowiÄ‡ nad napisaniem zapÄ™tlajÄ…cej siÄ™ funkcji
    <span class="inlinecode"><span class="id" title="var">loop</span></span>, ale coÅ› czujÄ™, Å¼e ty coÅ› czujesz, Å¼e byÅ‚oby to babranie siÄ™
    w niepotrzebnym problemie. Wobec tego (oczywiÅ›cie o ile dotychczas
    siÄ™ nie skapnÄ…Å‚eÅ›) poczuj siÄ™ oÅ›wiecony! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T4</span>) : <span class="id" title="var">bool</span> := <span class="id" title="var">bad</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Ha! Tak tak, <span class="inlinecode"><span class="id" title="var">loop</span></span> nie jest niczym innym niÅ¼ lekko rozmnoÅ¼onÄ… wersjÄ…
    <span class="inlinecode"><span class="id" title="var">bad</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">loop</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">loop</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop</span>, <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 5!<span class="id" title="var">eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
A skoro <span class="inlinecode"><span class="id" title="var">loop</span></span> to tylko inne <span class="inlinecode"><span class="id" title="var">bad</span></span>, to nie powinno ciÄ™ teÅ¼ wcale a
    wcale zdziwiÄ‡, Å¼e najbardziej oczywisty argument, dla ktÃ³rego <span class="inlinecode"><span class="id" title="var">loop</span></span>
    siÄ™ zapÄ™tla, jest Å¼ywcem wziÄ™ty z dowodu <span class="inlinecode"><span class="id" title="var">bad_sur</span></span> (choÄ‡ oczywiÅ›cie
    musimy zastÄ…piÄ‡ <span class="inlinecode"><span class="id" title="var">f</span></span> przez <span class="inlinecode"><span class="id" title="var">loop</span></span>).

<div class="paragraph"> </div>

    OczywiÅ›cie niemoÅ¼liwe jest, Å¼eby formalnie udowodniÄ‡ w Coqu, Å¼e coÅ›
    siÄ™ zapÄ™tla. PowyÅ¼szy lemat ma byÄ‡ jedynie demonstracjÄ… - rÄ™czne
    rozpisanie tego przykÅ‚adu byÅ‚oby zbyt karkoÅ‚omne. Jak widaÄ‡ z dowodu,
    przepisywanie rÃ³wnania definiujÄ…cego <span class="inlinecode"><span class="id" title="var">bad</span></span> tworzy wesoÅ‚Ä… piramidkÄ™
    zrobionÄ… z <span class="inlinecode"><span class="id" title="keyword">match</span></span>y i <span class="inlinecode"><span class="id" title="keyword">if</span></span>Ã³w. JeÅ¼eli chcesz poczuÄ‡ peÅ‚niÄ™ zapÄ™tlenia,
    wypbrÃ³uj taktykÄ™ <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">!<span class="id" title="var">eq</span></span> - zapÄ™tli siÄ™ ona, gdyÅ¼ rÃ³wnanie <span class="inlinecode"><span class="id" title="var">eq</span></span>
    moÅ¼na przepisywaÄ‡ w nieskoÅ„czonoÅ›Ä‡. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T4</span>.<br/>

<br/>
</div>

<div class="doc">
MogÅ‚oby siÄ™ wydawaÄ‡, Å¼e teraz to juÅ¼ na pewno nasze metody dziaÅ‚ajÄ… na
    wszystkie moÅ¼liwe negatywne typy induktywne. CytujÄ…c Tadeusza Sznuka:
    "Nic bardziej mylnego!". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T5</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">T5</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0</span> : (((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T5</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pc0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T5</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : ((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">c0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">Pc0</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
RzuÄ‡my okiem na powyÅ¼szy typ. WyglÄ…da podobnie do poprzedniego, ale jest
    nieco inny - typy <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> zamieniÅ‚y siÄ™ miejscami. Jakie rodzi to
    konsekwencje? SprawdÅºmy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> : <span class="id" title="var">T5</span> -&gt; (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">dcase</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">G</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">B</span> =&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isZero</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja <span class="inlinecode"><span class="id" title="var">bad</span></span> jest podobna jak poprzednio, ale tym razem konwertujemy
    <span class="inlinecode"><span class="id" title="var">Color</span></span> na <span class="inlinecode"><span class="id" title="var">nat</span></span> za pomocÄ… funkcji, ktÃ³ra nie jest surjekcjÄ…. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">bad</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">t</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
DowÃ³d rÃ³wnieÅ¼ przebiega podobnie jak poprzednio. ZaÅ‚amuje siÄ™ on dopiero,
    gdy na samym koÅ„cu rozbijamy wyraÅ¼enie <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> i upraszczamy uÅ¼ywajÄ…c <span class="inlinecode"><span class="id" title="var">cbn</span></span>.
    W pierwszym podcelu <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> jeszcze jakoÅ› udaje siÄ™ nam udowodniÄ‡, ale w
    drugim naszym oczom ukazuje siÄ™ cel <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Problem polega na tym, Å¼e <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> moÅ¼e byÄ‡ dowolnÄ… liczbÄ… naturalnÄ…, ale
    zastosowana przez nas funkcja konwertujÄ…ca <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> moÅ¼e zwracaÄ‡
    jedynie <span class="inlinecode">0</span>, <span class="inlinecode">1</span> lub <span class="inlinecode">2</span>. Teraz widzimy jak na dÅ‚oni, skÄ…d wziÄ…Å‚ siÄ™
    wymÃ³g, by funkcja konwertujÄ…ca byÅ‚a surjekcjÄ…. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T5</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">bad</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;42 = <span class="id" title="var">loop</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">loop</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop</span>, <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 15!<span class="id" title="var">eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Co ciekawe, mimo Å¼e nie jesteÅ›my w stanie pokazaÄ‡ surjektywnoÅ›ci <span class="inlinecode"><span class="id" title="var">bad</span></span>,
    to wciÄ…Å¼ moÅ¼emy uÅ¼yÄ‡ tej funkcji do zdefiniowania zapÄ™tlajÄ…cej siÄ™
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>, zupeÅ‚nie jak w poprzednim przykÅ‚adzie.

<div class="paragraph"> </div>

    Niesmak jednak pozostaje, gdyÅ¼ szczytem naszych ambicji nie powinno byÄ‡
    ograniczanie siÄ™ do zdefiniowania <span class="inlinecode"><span class="id" title="var">loop</span></span>, lecz do formalnego udowodnienia
    nielegalnoÅ›ci <span class="inlinecode"><span class="id" title="var">T5</span></span>. Czy wszystko stracone? Czy umrzemy? Tu dramatyczna
    pauza.

<div class="paragraph"> </div>

    Nie.

<div class="paragraph"> </div>

    Okazuje siÄ™, Å¼e jest pewien trikowy sposÃ³b na rozwiÄ…zanie tego problemu,
    a mianowicie: zamiast prÃ³bowaÄ‡ wyjÄ…Ä‡ z <span class="inlinecode"><span class="id" title="var">T5</span></span> funkcjÄ™ <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, wyjmiemy
    stamtÄ…d po prostu funckjÄ™ <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> i to mimo tego, Å¼e jej tam nie ma!

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad'</span> : <span class="id" title="var">T5</span> -&gt; (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">dcase</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isZero</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
W kluczowych momentach najpierw konwertujemy <span class="inlinecode"><span class="id" title="var">Color</span></span> na <span class="inlinecode"><span class="id" title="var">bool</span></span> tak jak
    w jednym z poprzednich przykÅ‚adÃ³w, a potem konwertujemy <span class="inlinecode"><span class="id" title="var">nat</span></span> na <span class="inlinecode"><span class="id" title="var">bool</span></span>
    za pomocÄ… funkcji <span class="inlinecode"><span class="id" title="var">isZero</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad'_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">bad'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">bad'</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad'</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> : <span class="id" title="var">T5</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">f</span> <span class="id" title="var">t</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">then</span> <span class="id" title="var">R</span> <span class="id" title="keyword">else</span> <span class="id" title="var">G</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">t</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>); <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
PoniewaÅ¼ obydwie nasze funkcjÄ™ konwertujÄ…ce byÅ‚y surjekcjami, moÅ¼emy je
    teraz odwrÃ³ciÄ‡ i wykazaÄ‡ ponad wszelkÄ… wÄ…tpliwoÅ›Ä‡, Å¼e <span class="inlinecode"><span class="id" title="var">bad'</span></span> faktycznie
    jest surjekcjÄ…. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">T5_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> <span class="id" title="var">bad'</span> <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">bad'_sur</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
SprÃ³bujmy podsumowaÄ‡, co tak naprawdÄ™ staÅ‚o siÄ™ w tym przykÅ‚adzie.

<div class="paragraph"> </div>

    Tym razem, mimo Å¼e do <span class="inlinecode"><span class="id" title="var">T5</span></span> moÅ¼emy wÅ‚oÅ¼yÄ‡ dowolnÄ… funkcjÄ™ <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    to nie moÅ¼emy jej potem wyjÄ…Ä‡, uzyskujÄ…c surjekcjÄ™, gdyÅ¼ zawadzajÄ…
    nam w tym typy po prawych stronach strzaÅ‚ek (<span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">Color</span></span>), ktÃ³re
    majÄ… za maÅ‚o elementÃ³w, Å¼eby mÃ³c surjektywnie przekonwertowaÄ‡ je na
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    Jednak jeÅ¼eli mamy wszystkie moÅ¼liwe funkcje typu <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, to
    moÅ¼emy przerobiÄ‡ je (w locie, podczas "wyciÄ…gania") na wszystkie
    moÅ¼liwe funkcje typu <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, skÅ‚adajÄ…c je z odpowiedniÄ…
    surjekcjÄ… (np. <span class="inlinecode"><span class="id" title="var">isZero</span></span>). PoniewaÅ¼ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">Color</span></span> jesteÅ›my
    w stanie surjektywnie przekonwertowaÄ‡ na <span class="inlinecode"><span class="id" title="var">bool</span></span>, reszta procesu
    dziaÅ‚a podobnie jak w poprzednich przykÅ‚adach. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop'</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T5</span>) : <span class="id" title="var">bool</span> := <span class="id" title="var">bad'</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">loop'</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> : <span class="id" title="var">T5</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">loop'</span> <span class="id" title="var">t</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop'</span>, <span class="id" title="var">bad'</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad'</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 15!<span class="id" title="var">eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Takie trikowe <span class="inlinecode"><span class="id" title="var">bad'</span></span> wciÄ…Å¼ pozwala nam bez wiÄ™kszych przeszkÃ³d
    zdefiniowaÄ‡ zapÄ™tlajÄ…cÄ… siÄ™ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">loop'</span></span>. OsiÄ…gnÄ™liÅ›my wiÄ™c
    peÅ‚en sukces.

<div class="paragraph"> </div>

    W ogÃ³lnoÅ›ci nasz trik moÅ¼naby sformuÅ‚owaÄ‡ tak: jeÅ¼eli mamy konstruktor
    negatywny typu <span class="inlinecode"><span class="id" title="var">T</span></span>, to moÅ¼emy wyjÄ…Ä‡ z niego funkcjÄ™ <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest najmniejszym z typÃ³w wystÄ™pujÄ…cych po prawych stronach strzaÅ‚ek.

<div class="paragraph"> </div>

    No, teraz to juÅ¼ na pewno mamy obcykane wszystkie przypadki, prawda?
    Tadeuszu Sznuku przybywaj: "OtÃ³Å¼ nie tym razem!". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T5</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T6</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">T6</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0</span> : (((<span class="id" title="var">T6</span> -&gt; <span class="id" title="var">unit</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T6</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">T6</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pc0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T6</span> -&gt; <span class="id" title="var">unit</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T6</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : ((<span class="id" title="var">T6</span> -&gt; <span class="id" title="var">unit</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">c0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">Pc0</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
Kolejnym upierdliwym przypadkiem, burzÄ…cym nawet nasz ostateczny
    trik, jest sytuacja, w ktÃ³rej po prawej stronie strzaÅ‚ki wystÄ…pi
    typ <span class="inlinecode"><span class="id" title="var">unit</span></span>. OczywiÅ›cie zgodnie z trikiem moÅ¼emy z <span class="inlinecode"><span class="id" title="var">T6</span></span> wyciÄ…gnÄ…Ä‡
    surjekcjÄ™ <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, ale jest ona oczywiÅ›cie bezuÅ¼yteczna, bo
    takÄ… samÄ… moÅ¼emy zrobiÄ‡ za darmo, stale zwracajÄ…c po prostu <span class="inlinecode"><span class="id" title="var">tt</span></span>.
    Surjekcja ta nie wystarcza rzecz jasna, Å¼eby odpaliÄ‡ twierdzenie
    Cantora.

<div class="paragraph"> </div>

    Tym razem jednak nie powinniÅ›my spodziewaÄ‡ siÄ™, Å¼e upierdliwoÅ›Ä‡ tÄ™
    bÄ™dzie daÅ‚o siÄ™ jakoÅ› obejÅ›Ä‡. Typ <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> jest jednoelementowy
    (jedynym elementem jest <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">tt</span></span>) podobnie jak <span class="inlinecode"><span class="id" title="var">unit</span></span>. Bardziej
    poetycko moÅ¼emy powiedzieÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> i <span class="inlinecode"><span class="id" title="var">unit</span></span> sÄ… izomorficzne,
    czyli prawie rÃ³wne - rÃ³Å¼niÄ… siÄ™ tylko nazwami elementÃ³w ("nazwa"
    jedynego elementu <span class="inlinecode"><span class="id" title="var">unit</span></span>a to <span class="inlinecode"><span class="id" title="var">tt</span></span>).

<div class="paragraph"> </div>

    Skoro tak, to typ konstruktora <span class="inlinecode"><span class="id" title="var">c0</span></span>, czyli
    <span class="inlinecode">(((<span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span>)</span>, moÅ¼emy rÃ³wnie dobrze
    zapisaÄ‡ jako <span class="inlinecode">((<span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span>)</span>. ZauwaÅ¼my teraz,
    Å¼e <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> jest izomorficzne z <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdyÅ¼ ma tylko dwa
    elementy, a mianowicie <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">false</span></span>.
    Tak wiÄ™c typ <span class="inlinecode"><span class="id" title="var">c0</span></span> moÅ¼emy jeszcze proÅ›ciej zapisaÄ‡ jako
    <span class="inlinecode">(<span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span></span>, a to oznacza, Å¼e typ <span class="inlinecode"><span class="id" title="var">T6</span></span> jest jedynie
    owijkÄ… na funkcje typu <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span></span>. Twierdzenie Cantora nie
    pozwala tutaj uzyskaÄ‡ sprzecznoÅ›ci.

<div class="paragraph"> </div>

    Czy zatem takie typy sa legalne? Syntaktycznie nie - Coq odrzuca je
    podobnie jak wszystkie inne negatywne typy induktywne. Semantycznie
    rÃ³wnieÅ¼ nie - o ile nie moÅ¼emy uzyskaÄ‡ jawnej sprzecznoÅ›ci, to nasze
    rozwaÅ¼ania o nieterminacji wciÄ…Å¼ sÄ… w mocy.

<div class="paragraph"> </div>

    Przypomnij sobie poprzedni przykÅ‚ad i nieudanÄ… prÃ³bÄ™ wyÅ‚uskania z
    <span class="inlinecode"><span class="id" title="var">T5</span></span> surjekcji <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. UdaÅ‚o nam siÄ™ zaimplementowaÄ‡ funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">bad</span></span>, ktÃ³rej surjektywnoÅ›ci nie potrafiliÅ›my pokazaÄ‡, ale pomimo
    tego bez problemu udaÅ‚o nam siÄ™ uÅ¼yÄ‡ jej do napisania funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>.
    W obecnym przykÅ‚adzie jest podobnie i nieterminacja to najlepsze, na
    co moÅ¼emy liczyÄ‡. 
<div class="paragraph"> </div>

<a name="lab184"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcjÄ™ <span class="inlinecode"><span class="id" title="var">bad</span></span>, a nastÄ™pnie uÅ¼yj jej do zdefiniowania funkcji
    <span class="inlinecode"><span class="id" title="var">loop</span></span>. Zademonstruj w sposÃ³b podobny jak poprzednio, Å¼e <span class="inlinecode"><span class="id" title="var">loop</span></span> siÄ™
    zapÄ™tla. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T6</span>.<br/>

<br/>
</div>

<div class="doc">
No, teraz to juÅ¼ na pewno wiemy wszystko... 
<div class="paragraph"> </div>

<a name="lab185"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 OtÃ³Å¼ nie do koÅ„ca. Ostatnim hamulcowym, groÅºniejszym nawet niÅ¼ <span class="inlinecode"><span class="id" title="var">unit</span></span>,
    jest wystÄ…pienie po prawej stronie strzaÅ‚ki typu (czy raczej zdania)
    <span class="inlinecode"><span class="id" title="var">False</span></span>. W tym przypadku nie tylko nie pomaga nam Cantor, ale nie
    pomaga teÅ¼ nieterminacja, gdyÅ¼ najzwyczajniej w Å›wiecie nie da siÄ™
    zdefiniowaÄ‡ Å¼adnej funkcji.

<div class="paragraph"> </div>

    Jako, Å¼e za cholerÄ™ nie wiem, co z tym fantem zrobiÄ‡, zostawiam go tobie
    jako Ä‡wiczenie: wymyÅ›l metodÄ™ pokazywania nielegalnoÅ›ci negatywnych typÃ³w
    induktywnych, w ktÃ³rych po prawej stronie strzaÅ‚ki jest co najmniej
    jedno wystÄ…pienie <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T8</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">T8</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c0</span> : (((<span class="id" title="var">T8</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">False</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T8</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">T8</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pc0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T8</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">False</span>) -&gt; <span class="id" title="var">Color</span>, <span class="id" title="var">P</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T8</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : ((<span class="id" title="var">T8</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">False</span>) -&gt; <span class="id" title="var">Color</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">c0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">Pc0</span> <span class="id" title="var">g</span>}).<br/>

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T8</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab186"></a><h2 class="section">Promocja 2 w 1 czyli paradoksy Russella i Girarda</h2>

<div class="paragraph"> </div>

 <i>Istnieje teoria, Å¼e jeÅ›li kiedyÅ› ktoÅ› siÄ™ dowie, dlaczego powstaÅ‚o i
    czemu sÅ‚uÅ¼y uniwersum, to zniknie ono i zostanie zastÄ…pione czymÅ›
    znacznie dziwaczniejszym i jeszcze bardziej pozbawionym sensu</i>. 
<div class="paragraph"> </div>

 <i>Istnieje takÅ¼e teoria, Å¼e dawno juÅ¼ tak siÄ™ staÅ‚o</i>. 
<div class="paragraph"> </div>

 Douglas Adams, <i>Restauracja na koÅ„cu wszechÅ›wiata</i> 
<div class="paragraph"> </div>

 W poprzednich podrozdziaÅ‚ach poznaliÅ›my twierdzenie Cantora oraz
    nauczyliÅ›my siÄ™ uÅ¼ywaÄ‡ go jako mÅ‚ota na negatywne typy induktywne.

<div class="paragraph"> </div>

    W tym podrozdziale zapoznamy siÄ™ z dwoma paradoksami (a precyzyjniej
    piszÄ…c, z dwoma wersjami tego samego paradoksu), ktÃ³re okaÅ¼Ä… siÄ™ byÄ‡
    Å›ciÅ›le powiÄ…zane z twierdzeniem Cantora, a ktÃ³re bÄ™dÄ… sÅ‚uÅ¼yÄ‡ nam gdy
    staniemy w szranki z negatwynymi typami induktywno-rekurencyjnymi
    (czyli tymi, ktÃ³re definiuje siÄ™ przez indukcjÄ™-rekursjÄ™). O tak: w
    tym podrozdziale, niczym Thanos, staniemy do walki przeciw uniwersum!

<div class="paragraph"> </div>

    Zacznijmy od paradoksu Russella. Jest to bardzo stary paradoks, odkryty
    w roku 1901 przez... zgadnij kogo... gdy Ã³w czÅ‚ek szukaÅ‚ dziury w caÅ‚ym
    w naiwnej teorii zbiorÃ³w (ktÃ³ra to teoria jest juÅ¼ od dawna martwa).

<div class="paragraph"> </div>

    SformuÅ‚owanie paradoksu brzmi nastÄ™pujÄ…co: niech V bÄ™dzie zbiorem
    wszystkich zbiorÃ³w, ktÃ³re nie naleÅ¼Ä… same do siebie. Pytanie: czy
    V naleÅ¼y do V?

<div class="paragraph"> </div>

    Gdzie tu paradoks? OtÃ³Å¼ jeÅ¼eli V naleÅ¼y do V, to na mocy definicji V,
    V nie naleÅ¼y do V. JeÅ¼eli zaÅ› V nie naleÅ¼y do V, to na mocy definicji V,
    V naleÅ¼y do V. Nie trzeba chyba dodawaÄ‡, Å¼e jednoczesne naleÅ¼enie i
    nienaleÅ¼enie prowadzi do sprzecznoÅ›ci. 
<div class="paragraph"> </div>

<a name="lab187"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 To genialne Ä‡wiczenie wymyÅ›liÅ‚em dziÄ™ki zabÅ‚Ä…dzeniu na esperanckiej
    Wikipedii (ha! nikt nie spodziewaÅ‚ siÄ™ esperanckiej Wikipedii w
    Ä‡wiczeniu dotyczÄ…cym paradoksu Russella). Ä†wiczenie brzmi tak:

<div class="paragraph"> </div>

    W Wikipedii niektÃ³re artykuÅ‚y sÄ… listami (nie, nie w sensie typu
    induktywnego :)), np. lista krajÃ³w wedÅ‚ug PKB per capita. Pytanie:
    czy moÅ¼na stworzyÄ‡ w Wikipedii listÄ™ wszystkich list? Czy na liÅ›cie
    wszystkich list ona sama jest wymieniona? Czy moÅ¼na w Wikipedii
    stworzyÄ‡ listÄ™ wszystkich list, ktÃ³re nie wymieniajÄ… same siebie? 
<div class="paragraph"> </div>

 Na czym tak naprawdÄ™ polega paradoks? JakiÅ› mÄ…dry (czyli przemÄ…drzaÅ‚y)
    filozof mÃ³gÅ‚by rzec, Å¼e na naduÅ¼yciu pojÄ™cia zbioru... albo czymÅ›
    rÃ³wnie absurdalnym. OtÃ³Å¼ nie! Paradoks Russella polega na tym samym,
    co caÅ‚a masa innych paradoksÃ³w, czyli na autoreferencji.

<div class="paragraph"> </div>

    Z autoreferencjÄ… spotkaliÅ›my siÄ™ juÅ¼ co najmniej raz, w rozdziale
    pierwszym. Przypomnij sobie, Å¼e golibroda goli tych i tylko tych,
    ktÃ³rzy sami siebie nie golÄ…. Czy golibroda goli sam siebie?

<div class="paragraph"> </div>

    Takie postawienie sprawy daje paradoks. Podobnie z Russellem: V zawiera
    te i tylko te zbiory, ktÃ³re nie zawierajÄ… same siebie. Czy V zawiera
    V? Wot, paradoks. Å»eby lepiej wczuÄ‡ siÄ™ w ten klimat, czas na wiÄ™cej
    Ä‡wiczeÅ„. 
<div class="paragraph"> </div>

<a name="lab188"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 A jak jest z poniÅ¼szym paradoksem wujka Janusza?

<div class="paragraph"> </div>

    Wujek Janusz lubi tych (i tylko tych) czÅ‚onkÃ³w rodziny, ktÃ³rzy sami
    siebie nie lubiÄ… oraz nie lubi tych (i tylko tych), ktÃ³rzy sami siebie
    lubiÄ…. Czy wujek Janusz lubi sam siebie? 
<div class="paragraph"> </div>

<a name="lab189"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 PowyÅ¼sze Ä‡wiczenie miaÅ‚o byÄ‡ ostatnim, ale co tam, dam jeszcze trochÄ™.
    Co czuje serce twoje (ewentualnie: co widzisz przed oczyma duszy swojej)
    na widok poniÅ¼szych wesoÅ‚ych zdaÅ„?

<div class="paragraph"> </div>

    "To zdanie jest faÅ‚szywe."

<div class="paragraph"> </div>

    "Zdanie po prawej jest faÅ‚szywe. Zdanie po lewej jest prawdziwe."

<div class="paragraph"> </div>

    "Zdanie po prawej jest prawdziwe. Zdanie po lewej jest faÅ‚szywe."

<div class="paragraph"> </div>

 Dobra, wystarczy juÅ¼ tych paradoksÃ³w... a nie, czekaj. PrzecieÅ¼ zostaÅ‚
    nam do omÃ³wienia jeszcze paradoks Girarda. Jednak poznawszy juÅ¼ tajniki
    autoreferencji, powinno pÃ³jÅ›Ä‡ jak z pÅ‚atka.

<div class="paragraph"> </div>

    Paradoks Girarda to paradoks, ktÃ³ry moÅ¼e zaistnieÄ‡ w wielu systemach
    formalnych, takich jak teorie typÃ³w, jÄ™zyki programowania, logiki i
    inne takie. Å¹rÃ³dÅ‚em caÅ‚ego zÅ‚a jest zazwyczaj stwierdzenie w stylu
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
O nie! CzyÅ¼byÅ›my wÅ‚aÅ›nie zostali zaatakowani przez paradoks Girarda?
    W tym miejscu naleÅ¼y przypomnieÄ‡ (albo obwieÅ›ciÄ‡ - niestety nie pamiÄ™tam,
    czy juÅ¼ o tym wspominaÅ‚em), Å¼e <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest w Coqu jedynie synonimem dla
    czegoÅ› w stylu <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">i</span></span> jest "poziomem" sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, zaÅ›
    kaÅ¼de <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span> Å¼yje tak naprawdÄ™ w jakimÅ› <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">j</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">j</span></span> jest
    wiÄ™ksze od <span class="inlinecode"><span class="id" title="var">i</span></span> - typy niÅ¼szego poziomu Å¼yjÄ… w typach wyÅ¼szego poziomu.
    BÄ™dziesz mÃ³gÅ‚ Ã³w fakt ujrzeÄ‡ na wÅ‚asne oczy, gdy w CoqIDE zaznaczysz
    opcjÄ™ <span class="inlinecode"><span class="id" title="var">View</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode"><span class="id" title="var">Display</span></span> <span class="inlinecode"><span class="id" title="var">universe</span></span> <span class="inlinecode"><span class="id" title="var">levels</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type@{Top.590}&nbsp;:&nbsp;Type@{Top.590+1}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widaÄ‡, jest mniej wiÄ™cej tak jak napisaÅ‚em wyÅ¼ej. Nie przejmuj siÄ™
    tym tajemniczym <span class="inlinecode"><span class="id" title="var">Top</span></span> - to tylko nic nieznaczÄ…cy bibelocik. W twoim
    przypadku rÃ³wnieÅ¼ poziom uniwersum moÅ¼e byÄ‡ inny niÅ¼ <span class="inlinecode">590</span>. Co wiÄ™cej,
    poziom ten bÄ™dzie siÄ™ zwiÄ™kszaÅ‚ wraz z kaÅ¼dym odpaleniem komendy <span class="inlinecode"><span class="id" title="keyword">Check</span></span>
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> (czyÅ¼byÅ› pomyÅ›laÅ‚ wÅ‚aÅ›nie o doliczeniu w ten sposÃ³b do zyliona?).

<div class="paragraph"> </div>

    Skoro juÅ¼ wiemy, Å¼e NIE zostaliÅ›my zaatakowani przez paradoks Girarda,
    to w czym problem z tym caÅ‚ym <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>? JakiÅ› przemÄ…drzaÅ‚y (czyli
    mÄ…dry) adept informatyki teoretycznej mÃ³gÅ‚by odpowiedzieÄ‡, Å¼e to zaleÅ¼y
    od konkretnego systemu formalnego albo coÅ› w tym stylu. OtÃ³Å¼ niet! Jak
    zawsze, chodzi oczywiÅ›cie o autoreferencjÄ™.

<div class="paragraph"> </div>

    Gdyby ktoÅ› byÅ‚ zainteresowany, to najlepsze dotychczas sformuÅ‚owanie
    paradoksu znalazÅ‚em (zupeÅ‚nie przez przypadek, wcale nie szukajÄ…c) w
    pracy "An intuitionistic theory of types" Martina-LÃ¶fa (swojÄ… drogÄ…,
    ten koleÅ› wymyÅ›liÅ‚ podstawy duÅ¼ej czÄ™Å›ci wszystkiego, czym siÄ™ tutaj
    zajmujemy). MoÅ¼na jÄ… przeczytaÄ‡ tu (paradoks Girarda jest pod koniec
    pierwszej sekcji):
    archive-pml.github.io/martin-lof/pdfs
    /An-Intuitionistic-Theory-of-Types-1972.pdf

<div class="paragraph"> </div>

    Nasze sformuÅ‚owanie paradoksu bÄ™dzie w sumie podobne do tego z powyÅ¼szej
    pracy (co jest w sumie ciekawe, bo wymyÅ›liÅ‚em je samodzielnie i to przez
    przypadek), ale dowÃ³d sprzecznoÅ›ci bÄ™dzie inny - na szczÄ™Å›cie duÅ¼o
    prostszy (albo i nie...).

<div class="paragraph"> </div>

    Dobra, koniec tego glÄ™dzenia. Czas na konkrety. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Fail&nbsp;Inductive&nbsp;U&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;:&nbsp;U<br/>
<br/>
with&nbsp;El&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;Type&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;forall&nbsp;x&nbsp;:&nbsp;El&nbsp;A,&nbsp;B&nbsp;x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
PowyÅ¼sza induktywno-rekurencyjna definicja typu <span class="inlinecode"><span class="id" title="var">U</span></span> (i interpretujÄ…cej
    go funkcji <span class="inlinecode"><span class="id" title="var">El</span></span>), ktÃ³rÄ… Coq rzecz jasna odrzuca (uczcijmy Å‚awÄ™ oburzonych
    minutÄ… oburzenia) to definicja pewnego uniwersum.

<div class="paragraph"> </div>

    W tym miejscu wypadaÅ‚oby wytÅ‚umaczyÄ‡, czym sÄ… uniwersa. OtÃ³Å¼ odpowiedÅº
    jest doÅ›Ä‡ prosta: uniwersum skÅ‚ada siÄ™ z typu <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> oraz funkcji
    <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Intuicja w tym wszystkim jest taka, Å¼e elementami
    typu <span class="inlinecode"><span class="id" title="var">U</span></span> sÄ… nazwy typÃ³w (czyli bytÃ³w sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), zaÅ› fukncja <span class="inlinecode"><span class="id" title="var">El</span></span>
    zwraca typ, ktÃ³rego nazwÄ™ dostanie.

<div class="paragraph"> </div>

    ChoÄ‡ z definicji widaÄ‡ to na pierwszy rzut oka, to zaskakujÄ…cy moÅ¼e
    wydaÄ‡ ci siÄ™ fakt, Å¼e w zasadzie kaÅ¼dy typ moÅ¼na zinterpretowaÄ‡ jako
    uniwersum i to zazwyczaj na bardzo wiele rÃ³Å¼nych sposobÃ³w (tyle ile
    rÃ³Å¼nych interpretacji <span class="inlinecode"><span class="id" title="var">El</span></span> jesteÅ›my w stanie wymyÅ›liÄ‡). Najlepiej
    bÄ™dzie, jeÅ¼eli przemyÅ›lisz to wszystko w ramach Ä‡wiczenia. 
<div class="paragraph"> </div>

<a name="lab190"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Ä†wiczenie bÄ™dzie konceptualne, a skÅ‚ada siÄ™ na nie kilka Å‚amigÅ‚Ã³wek:
<ul class="doclist">
<li> zinterpretuj <span class="inlinecode"><span class="id" title="var">False</span></span> jako uniwersum

</li>
<li> zinterpretuj <span class="inlinecode"><span class="id" title="var">unit</span></span> jako uniwersum (ile jest moÅ¼liwych sposobÃ³w?)

</li>
<li> czy istnieje uniwersum, ktÃ³re zawiera nazwÄ™ samego siebie? Uwaga:
      to nie jest tak proste, jak moÅ¼e siÄ™ wydawaÄ‡ na pierwszy rzut oka.

</li>
<li> wymyÅ›l ideologicznie sÅ‚usznÄ… interpretacjÄ™ typu <span class="inlinecode"><span class="id" title="var">nat</span></span> jako uniwersum
      (tak, jest taka). NastÄ™pnie wymyÅ›l jakÄ…Å› gÅ‚upiÄ… interpretacjÄ™ <span class="inlinecode"><span class="id" title="var">nat</span></span>
      jako uniwersum. Dlaczego ta interpretacja jest gÅ‚upia?

</li>
<li> zdefiniuj uniwersum, ktÃ³rego elementami sÄ… nazwy typÃ³w funkcji z
      n-krotek liczb naturalnych w liczby naturalne. Uwaga: rozwiÄ…zanie
      jest bardzo eleganckie i moÅ¼esz siÄ™ go nie spodziewaÄ‡.

</li>
<li> czy istnieje uniwersum, ktÃ³rego interpretacja jest surjekcjÄ…? Czy
      da siÄ™ w Coqu udowodniÄ‡, Å¼e tak jest albo nie jest? Uwaga: tak
      bardzo podchwytliwe, Å¼e aÅ¼ sam siÄ™ zÅ‚apaÅ‚em. 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Skoro wiemy juÅ¼, czym sÄ… uniwersa, przyjrzyjmy siÄ™ temu, ktÃ³re wÅ‚aÅ›nie
    zdefiniowaliÅ›my. Å»ebyÅ› nie musiaÅ‚ w rozpaczy przewijaÄ‡ do gÃ³ry, tak
    wyglÄ…da aksjomatyczne kodowanie tego uniwersum: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">PoorUniverse</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">U</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">El</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">Pi</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>), <span class="id" title="var">U</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">UU</span> : <span class="id" title="var">U</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">El_Pi</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">El</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) = <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span>), <span class="id" title="var">El</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">El_UU</span> : <span class="id" title="var">El</span> <span class="id" title="var">UU</span> = <span class="id" title="var">U</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PPi</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">A</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PUU</span> : <span class="id" title="var">P</span> <span class="id" title="var">UU</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span>, <span class="id" title="var">P</span> <span class="id" title="var">u</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">PPi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> <span class="id" title="var">A</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>))) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> <span class="id" title="var">UU</span> = <span class="id" title="var">PUU</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">U</span></span> to typ, ktÃ³rego elementami sÄ… nazwy typÃ³w, zaÅ› <span class="inlinecode"><span class="id" title="var">El</span></span> jest jego
    interpretacjÄ…. Nazwy moÅ¼emy tworzyÄ‡ tylko na dwa sposoby: jeÅ¼eli <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    jest nazwÄ… typu, zaÅ› <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> jest rodzinÄ… nazw typÃ³w indeksowanÄ…
    przez elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>, to <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest nazwÄ… typu
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span>. Drugim konstruktorem jest <span class="inlinecode"><span class="id" title="var">UU</span></span>, ktÃ³re
    oznacza nazwÄ™ samego uniwersum, tzn. <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>.

<div class="paragraph"> </div>

    ReguÅ‚a indukcji jest doÅ›Ä‡ prosta: jeÅ¼eli <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest rodzinÄ…
    typÃ³w (tych prawdziwych) indeksowanÄ… przez <span class="inlinecode"><span class="id" title="var">U</span></span> (czyli nazwy typÃ³w), to
    Å¼eby zdefiniowaÄ‡ funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> musimy mieÄ‡ dwie rzeczy:
    po pierwsze, musimy pokazaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> zachodzi, gdy zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> dla kaÅ¼dego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Po drugie, musi zachodziÄ‡ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>.

<div class="paragraph"> </div>

    Mimo, Å¼e uniwersum wydaje siÄ™ biedne, jest ono Å›miertelnie sprzeczne,
    gdyÅ¼ zawiera nazwÄ™ samego siebie. JeÅ¼eli rozwiÄ…zaÅ‚eÅ› (poprawnie, a nie
    na odwal!) ostatnie Ä‡wiczenie, to powinieneÅ› wiedzieÄ‡, Å¼e niektÃ³re
    uniwersa mogÄ… zawieraÄ‡ nazwy samego siebie i wcale to a wcale nie daje
    to Å¼adnych problemÃ³w.

<div class="paragraph"> </div>

    Dlaczego wiÄ™c w tym przypadku jest inaczej? Skoro <span class="inlinecode"><span class="id" title="var">UU</span></span> nie jest zÅ‚e samo
    w sobie, to problem musi leÅ¼eÄ‡ w <span class="inlinecode"><span class="id" title="var">Pi</span></span>, bo niby gdzie indziej? Zobaczmy
    wiÄ™c, gdzie kryje siÄ™ sprzecznoÅ›Ä‡. W tym celu posÅ‚uÅ¼ymy siÄ™ twierdzeniem
    Cantora: najpierw pokaÅ¼emy surjekcjÄ™ <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span>)</span>, a potem, za pomocÄ…
    metody przekÄ…tniowej, Å¼e taka surjekcja nie moÅ¼e istnieÄ‡. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Definition&nbsp;bad&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;UU&nbsp;B&nbsp;=&gt;&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;fun&nbsp;u&nbsp;:&nbsp;U&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
JeÅ¼eli dostajemy <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span> to <span class="inlinecode"><span class="id" title="var">UU</span></span>, to wtedy <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    tak naprawdÄ™ jest typu <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> (bo <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>). W innych przypadkach
    wystarczy po prostu zwrÃ³ciÄ‡ funkcjÄ™ identycznoÅ›ciowÄ…. Niestety Coq nie
    wspiera indukcji-rekursji (Å‚awa oburzonych), wiÄ™c funkcjÄ™ <span class="inlinecode"><span class="id" title="var">bad</span></span> musimy
    zdefiniowaÄ‡ rÄ™cznie: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> : <span class="id" title="var">U</span> -&gt; (<span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Focus</span> 2. <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span> =&gt; <span class="id" title="var">u</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. <span class="id" title="var">revert</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> : <span class="id" title="var">U</span> =&gt; (<span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>) -&gt; (<span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">El_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
PowyÅ¼sza definicja za pomocÄ… taktyk dziaÅ‚a dokÅ‚adnie tak samo jak
    nieformalna definicja <span class="inlinecode"><span class="id" title="var">bad</span></span> za pomocÄ… dopasowania do wzorca. Jedyna
    rÃ³Å¼nica jest taka, Å¼e <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> nie jest definicyjnie rÃ³wne <span class="inlinecode"><span class="id" title="var">U</span></span>, lecz
    sÄ… one jedynie zdaniowo rÃ³wne na mocy aksjomatu <span class="inlinecode"><span class="id" title="var">El_UU</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>.
    Musimy wiÄ™c przepisaÄ‡ go w <span class="inlinecode"><span class="id" title="var">B</span></span>, Å¼eby typy siÄ™ zgadzaÅ‚y.

<div class="paragraph"> </div>

    Zanim bÄ™dziemy mogli pokazaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">bad</span></span> jest surjekcjÄ…, czeka nas kilka
    niemiÅ‚ych detali technicznych (gdyby <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> i <span class="inlinecode"><span class="id" title="var">U</span></span> byÅ‚y definicyjnie
    rÃ³wne, wszystkie te problemy by zniknÄ™Å‚y). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">eq_rect</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">eq_rect_r</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;y&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">eq_rect</span></span> oraz <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> to groÅºnie wyglÄ…dajÄ…ce lematy, ale sprawa tak
    na prawdÄ™ jest doÅ›Ä‡ prosta: to one wykonujÄ… caÅ‚Ä… pracÄ™ za kaÅ¼dym razem,
    kiedy uÅ¼ywasz taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. JeÅ¼eli cel jest postaci <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> i uÅ¼yjemy
    na nim <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, to <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> zamienia cel na
    <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">cel</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, ktÃ³re jest juÅ¼ typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> dziaÅ‚a
    podobnie, ale tym razem rÃ³wnoÅ›Ä‡ jest postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> (czyli obrÃ³cona).

<div class="paragraph"> </div>

    PoniewaÅ¼ w definicji <span class="inlinecode"><span class="id" title="var">bad</span></span> uÅ¼ywaliÅ›my <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>'a, to przy dowodzeniu,
    Å¼e <span class="inlinecode"><span class="id" title="var">bad</span></span> jest surjekcjÄ…, bÄ™dziemy musieli zmierzyÄ‡ siÄ™ wÅ‚aÅ›nie z
    <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> i <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span>. StÄ…d poniÅ¼szy lemat, ktÃ³ry mÃ³wi mniej wiÄ™cej,
    Å¼e jeÅ¼eli przepiszemy z prawa na lewo, a potem z lewa na prawo, to tak,
    jakby nic siÄ™ nie staÅ‚o. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">right_to_left_to_right</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">y</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_rect</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> (@<span class="id" title="var">eq_rect_r</span> <span class="id" title="var">A</span> <span class="id" title="var">y</span> <span class="id" title="var">P</span> <span class="id" title="var">u</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>) <span class="id" title="var">y</span> <span class="id" title="var">p</span> = <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
DowÃ³d jest banalny. PoniewaÅ¼ <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> i <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> sÄ… zdefiniowane
    przez dopasowanie do wzorca <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, to wystarczy <span class="inlinecode"><span class="id" title="var">p</span></span> potraktowaÄ‡
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>em, a dalej wszystko juÅ¼ Å‚adnie siÄ™ oblicza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">bad</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">bad</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad</span> [<span class="id" title="var">bad_Pi</span> <span class="id" title="var">bad_UU</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">bad'</span> [<span class="id" title="var">bad'_Pi</span> <span class="id" title="var">bad'_UU</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">f'</span> := <span class="id" title="var">eq_rect_r</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span> =&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="var">U</span>) <span class="id" title="var">f</span> <span class="id" title="var">El_UU</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">UU</span> <span class="id" title="var">f'</span>). <span class="id" title="tactic">unfold</span> <span class="id" title="var">f'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">bad_Pi</span>, <span class="id" title="var">bad'_UU</span>, <span class="id" title="var">right_to_left_to_right</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dlaczego <span class="inlinecode"><span class="id" title="var">bad</span></span> jest surjekcjÄ…? Intuicyjnie piszÄ…c, kaÅ¼dÄ… funkcjÄ™
    <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> moÅ¼emy wÅ‚oÅ¼yÄ‡ do konstruktora <span class="inlinecode"><span class="id" title="var">Pi</span></span> jako jego drugi argument,
    jeÅ¼eli tylko zamienimy pierwsze <span class="inlinecode"><span class="id" title="var">U</span></span> na <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>. Skoro kaÅ¼dÄ… moÅ¼emy
    tam wÅ‚oÅ¼yÄ‡, to kaÅ¼dÄ… moÅ¼emy wyjÄ…Ä‡. Ot i caÅ‚y sekret.

<div class="paragraph"> </div>

    Technicznie dowÃ³d realizujemy tak: odwijamy definicje i wprowadzamy do
    kontekstu funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span>. NastÄ™pnie rozbijamy <span class="inlinecode"><span class="id" title="var">ind</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> pochodzÄ…ce z definicji
    <span class="inlinecode"><span class="id" title="var">bad</span></span>, rozkÅ‚adajÄ…c w ten sposÃ³b definicjÄ™ <span class="inlinecode"><span class="id" title="var">bad</span></span> na wÅ‚aÅ›ciwe <span class="inlinecode"><span class="id" title="var">bad</span></span> (sama
    funkcja), <span class="inlinecode"><span class="id" title="var">bad'</span></span> (wewnÄ™trzna funkcja pomocnicza) oraz rÃ³wnania dla <span class="inlinecode"><span class="id" title="var">bad</span></span>
    i <span class="inlinecode"><span class="id" title="var">bad'</span></span> dla poszczegÃ³lnych przypadkÃ³w.

<div class="paragraph"> </div>

    NastÄ™pnie musimy znaleÅºÄ‡ takie <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>, Å¼e <span class="inlinecode"><span class="id" title="var">bad</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span>. Robimy to, co
    zasugerowaÅ‚em wyÅ¼ej, czyli w <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> pierwsze <span class="inlinecode"><span class="id" title="var">U</span></span> zamieniamy na
    <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>, uzyskujÄ…c w ten sposÃ³b <span class="inlinecode"><span class="id" title="var">f'</span></span>. Temu wÅ‚aÅ›nie sÅ‚uÅ¼y uÅ¼ycie
    <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> (nie uÅ¼ywamy <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, bo potrzeba nam wiÄ™kszej precyzji).

<div class="paragraph"> </div>

    Wobec tego szukanym przez nas elementem <span class="inlinecode"><span class="id" title="var">U</span></span>, ktÃ³remu <span class="inlinecode"><span class="id" title="var">bad</span></span> przyporzÄ…dkuje
    <span class="inlinecode"><span class="id" title="var">f</span></span>, jest <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode"><span class="id" title="var">f'</span></span>. MoÅ¼emy w tym miejscu odwinÄ…Ä‡ definicjÄ™ <span class="inlinecode"><span class="id" title="var">f'</span></span>. Gdyby
    Coq wspieraÅ‚ indukcjÄ™-rekursjÄ™, to w tym miejscu wystarczyÅ‚oby uÅ¼yÄ‡ tylko
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> - <span class="inlinecode"><span class="id" title="var">bad</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode"><span class="id" title="var">f'</span>)</span> obliczyÅ‚oby siÄ™ do <span class="inlinecode"><span class="id" title="var">f</span></span> na mocy definicji
    <span class="inlinecode"><span class="id" title="var">bad</span></span> oraz dziÄ™ki temu, Å¼e <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> obliczyÅ‚oby siÄ™ do <span class="inlinecode"><span class="id" title="var">U</span></span>. Niestety Coq
    nie wspiera indukcji rekursji (Å‚awa oburzonych), wiÄ™c musimy wszystkie
    te trzy kroki obliczeÅ„ wykonaÄ‡ rÄ™cznie za pomocÄ… taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    Ufff, udaÅ‚o siÄ™! JeÅ¼eli przeraÅ¼a ciÄ™ ten dowÃ³d - nie martw siÄ™. Chodzi
    w nim o to samo, o co chodziÅ‚o w poprzednich dowodach bycia surjekcjÄ….
    Ten jest po prostu trochÄ™ bardziej skomplikowany, bo indukcja-rekursja
    jest nieco bardziej skomplikowana do uÅ¼ycia w Coqu niÅ¼ prymitywniejsze
    formy indukcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="tactic">change</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">UU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">UU</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">UU</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz czas udowodniÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">bad</span></span> nie jest surjekcjÄ…. Zrobimy to metodÄ…
    przekÄ…tniowÄ…, a w tym celu potrzebowaÄ‡ bÄ™dziemy funkcji <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>, ktÃ³ra
    dla kaÅ¼dego argumentu zwraca coÅ›, co jest od niego rÃ³Å¼ne.

<div class="paragraph"> </div>

    Na szczÄ™Å›cie sprawa jest prosta: jeÅ¼eli argumentem jest <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, to
    zwracamy <span class="inlinecode"><span class="id" title="var">UU</span></span>, zaÅ› jeÅ¼eli <span class="inlinecode"><span class="id" title="var">UU</span></span>, to zwracamy <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">UU</span>)</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">discern</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">true</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
PrzydaÅ‚aby siÄ™ teÅ¼ funkcja, ktÃ³ra pozwoli nam rozrÃ³Å¼niÄ‡ konstruktory
    typu <span class="inlinecode"><span class="id" title="var">U</span></span>. Normalnie uÅ¼ylibyÅ›my do tego taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, ale
    uÅ¼ywamy kodowania aksjomatycznego, wiÄ™c <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> nie zadziaÅ‚a i
    musimy rÄ™cznie zaimplementowaÄ‡ sobie coÅ› w jej stylu.

<div class="paragraph"> </div>

    Nasza funkcja dla <span class="inlinecode"><span class="id" title="var">Pi</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span>, a dla <span class="inlinecode"><span class="id" title="var">UU</span></span> daje <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">change_neq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span>, <span class="id" title="tactic">change</span> <span class="id" title="var">u</span> &lt;&gt; <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">H1</span> <span class="id" title="var">H2</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">discern</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="tactic">change</span>, <span class="id" title="var">discern</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">d</span> [<span class="id" title="var">d_Pi</span> <span class="id" title="var">d_UU</span>]],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">ch</span> [<span class="id" title="var">ch_Pi</span> <span class="id" title="var">ch_UU</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">d_Pi</span>, <span class="id" title="var">ch_Pi</span>, <span class="id" title="var">d_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">discern</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="tactic">change</span>, <span class="id" title="var">discern</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">d</span> [<span class="id" title="var">d_Pi</span> <span class="id" title="var">d_UU</span>]],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">ch</span> [<span class="id" title="var">ch_Pi</span> <span class="id" title="var">ch_UU</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">ch_UU</span>, <span class="id" title="var">d_Pi</span>, <span class="id" title="var">d_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">eq</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
WypadaÅ‚oby teÅ¼ pokazaÄ‡, Å¼a nasza funkcja dziaÅ‚a tak, jak sobie tego
    Å¼yczymy. DowÃ³d jest bardzo prosty, ale aksjomatyczne kodowanie znacznie
    go zaciemnia.

<div class="paragraph"> </div>

    Zaczynamy od indukcji po <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>. W pierwszym przypadku mamy hipotezÄ™
    <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, a skoro tak, to po zaaplikowaniu
    <span class="inlinecode"><span class="id" title="var">discern</span></span> musi byÄ‡ takÅ¼e <span class="inlinecode"><span class="id" title="var">discern</span></span> <span class="inlinecode">(<span class="id" title="tactic">change</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">discern</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span>.

<div class="paragraph"> </div>

    NastÄ™pnie rozkÅ‚adamy definicje <span class="inlinecode"><span class="id" title="tactic">change</span></span> i <span class="inlinecode"><span class="id" title="var">discern</span></span> na atomy (<span class="inlinecode"><span class="id" title="tactic">change</span></span>
    nazywa siÄ™ teraz <span class="inlinecode"><span class="id" title="var">ch</span></span>, a <span class="inlinecode"><span class="id" title="var">discern</span></span> nazywa siÄ™ <span class="inlinecode"><span class="id" title="var">d</span></span>). Przepisujemy
    odpowiednie rÃ³wnania w hipotezie <span class="inlinecode"><span class="id" title="var">eq</span></span>, dziÄ™ki czemu uzyskujemy
    <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, co jest sprzeczne. Drugi przypadek jest analogiczny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_not_sur</span> :<br/>
&nbsp;&nbsp;~ <span class="id" title="var">surjective</span> <span class="id" title="var">bad</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">H</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span> =&gt; <span class="id" title="tactic">change</span> (<span class="id" title="var">bad</span> <span class="id" title="var">u</span> <span class="id" title="var">u</span>))) <span class="id" title="keyword">as</span> [<span class="id" title="var">u</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">u</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">change_neq</span> (<span class="id" title="var">bad</span> <span class="id" title="var">u</span> <span class="id" title="var">u</span>)). <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz moÅ¼emy juÅ¼ pokazaÄ‡, Å¼e <span class="inlinecode"><span class="id" title="var">bad</span></span> nie jest surjekcjÄ…. W tym celu
    wyobraÅºmy sobie <span class="inlinecode"><span class="id" title="var">bad</span></span> jako kwadratowÄ… tabelkÄ™, ktÃ³rej wiersze i
    kolumny sÄ… indeksowane przez <span class="inlinecode"><span class="id" title="var">U</span></span>. Tworzymy nowÄ… funkcjÄ™ <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    biorÄ…c elementy z przekÄ…tnej i modyfikujÄ…c je za pomocÄ… <span class="inlinecode"><span class="id" title="tactic">change</span></span>.

<div class="paragraph"> </div>

    Skoro <span class="inlinecode"><span class="id" title="var">bad</span></span> jest surjekcjÄ…, to ta nowa funkcja musi byÄ‡ postaci
    <span class="inlinecode"><span class="id" title="var">bad</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> dla jakiegoÅ› <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>. AplikujÄ…c obie strony jeszcze raz
    do <span class="inlinecode"><span class="id" title="var">u</span></span> dostajemy rÃ³wnanie <span class="inlinecode"><span class="id" title="var">bad</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode">(<span class="id" title="var">bad</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">u</span>)</span>, ktÃ³re
    jest sprzeczne na mocy lematu <span class="inlinecode"><span class="id" title="var">change_neq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">U_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">bad_not_sur</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">bad_sur</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
PoniewaÅ¼ <span class="inlinecode"><span class="id" title="var">bad</span></span> jednoczeÅ›nie jest i nie jest surjekcjÄ…, nastepuje nagÅ‚y
    atak sprzecznoÅ›ci. Definicja uniwersum <span class="inlinecode"><span class="id" title="var">U</span></span> przez indukcjÄ™-rekursjÄ™ jest
    nielegalna. Tak wÅ‚aÅ›nie prezentujÄ… siÄ™ paradoksy Russella i Girarda w
    Coqowym wydaniu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PoorUniverse</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab191"></a><h4 class="section">Ä†wiczenie</h4>

<div class="paragraph"> </div>

 Tak naprawdÄ™, to w tym podrozdziale byliÅ›my co najwyÅ¼ej bieda-Thanosem,
    gdyÅ¼ uniwersum, z ktÃ³rym siÄ™ Å›cieraliÅ›my, samo byÅ‚o biedne. W niniejszym
    Ä‡wiczeniu zmierzysz siÄ™ z uniwersum, ktÃ³re zawiera teÅ¼ nazwy typu pustego,
    typu <span class="inlinecode"><span class="id" title="var">unit</span></span> i liczb naturalnych, nazwy produktÃ³w, sum i funkcji, a takÅ¼e
    sum zaleÅ¼nych.

<div class="paragraph"> </div>

    MÃ³wiÄ…c wprost: zakoduj aksjomatycznie poniÅ¼szÄ… definicjÄ™ uniwersum <span class="inlinecode"><span class="id" title="var">U</span></span>,
    a nastÄ™pnie udowodnij, Å¼e jest ona nielegalna. Nie powinno to byÄ‡
    trudne - metoda jest podobna jak w przypadku biednego uniwersum. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NonPoorUniverse</span>.<br/>

<br/>
<span class="comment">(*<br/>
Fail&nbsp;Inductive&nbsp;U&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Empty&nbsp;:&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Unit&nbsp;:&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Nat&nbsp;:&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Prod&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sum&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Arr&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sigma:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;:&nbsp;U<br/>
<br/>
with&nbsp;El&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;Type&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Empty&nbsp;=&gt;&nbsp;Empty_set<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Unit&nbsp;=&gt;&nbsp;unit<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Nat&nbsp;=&gt;&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Prod&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;*&nbsp;El&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sum&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;+&nbsp;El&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Arr&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;El&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pi&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;forall&nbsp;x&nbsp;:&nbsp;El&nbsp;A,&nbsp;B&nbsp;x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sigma&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;{x&nbsp;:&nbsp;El&nbsp;A&nbsp;&amp;&nbsp;El&nbsp;(B&nbsp;x)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;UU&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">U_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NonPoorUniverse</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab192"></a><h2 class="section">Pozytywne typy induktywne</h2>

<div class="paragraph"> </div>

 Na koniec rozprawimy siÄ™ z pozytywnymi typami "induktywnymi" (ale tylko
    do pewnego stopnia; tak po prawdzie, to raczej one rozprawiÄ… siÄ™ z
    nami). 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Pos0</span> : ((<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Pos</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"Pos"&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"((Pos&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;Pos".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coq odrzuca powyÅ¼szÄ… definicjÄ™ typu <span class="inlinecode"><span class="id" title="var">Pos</span></span>, gdyÅ¼ pierwsze wystÄ…pienie <span class="inlinecode"><span class="id" title="var">Pos</span></span>
    w typie konstruktora <span class="inlinecode"><span class="id" title="var">Pos0</span></span> nie jest Å›ciÅ›le pozytywne. I faktycznie - gdy
    policzymy niedobroÅ›Ä‡ tego wystÄ…pienia zgodnie z naszym wzorem, to wyjdzie,
    Å¼e wynosi ona 2, gdyÅ¼ <span class="inlinecode"><span class="id" title="var">Pos</span></span> wystÄ™puje na lewo od dwÃ³ch strzaÅ‚ek (pamiÄ™taj,
    Å¼e najbardziej zewnÄ™trzna strzaÅ‚ka, czyli ta, na prawo od ktÃ³rej teÅ¼ jest
    <span class="inlinecode"><span class="id" title="var">Pos</span></span>, nie liczy siÄ™ - wzÃ³r dotyczy tylko argumentÃ³w konstruktora, a nie
    caÅ‚ego konstruktora). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">Pos</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Pos0</span> : ((<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Pos</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">Pos</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PPos0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : (<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> (<span class="id" title="var">Pos0</span> <span class="id" title="var">g</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Pos</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : (<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">Pos0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">PPos0</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
SprÃ³bujmy zawalczyÄ‡ z typem <span class="inlinecode"><span class="id" title="var">Pos</span></span> naszÄ… metodÄ… opartÄ… o twierdzenie
    Cantora. Najpierw kodujemy typ <span class="inlinecode"><span class="id" title="var">Pos</span></span> aksjomatycznie, a nastÄ™pnie
    sprÃ³bujemy zdefiniowaÄ‡ <span class="inlinecode"><span class="id" title="var">bad</span></span>, czyli surjekcjÄ™ z <span class="inlinecode"><span class="id" title="var">Pos</span></span> w <span class="inlinecode"><span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> : <span class="id" title="var">Pos</span> -&gt; (<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">dcase</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;ad&nbsp;infinitum&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
MogÅ‚oby siÄ™ wydawaÄ‡, Å¼e wyciÄ…gniÄ™cie z <span class="inlinecode"><span class="id" title="var">Pos</span></span> funkcji <span class="inlinecode"><span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    nie moÅ¼e byÄ‡ trudniejsze, niÅ¼ zabranie dziecku cukierka. Niestety
    jednak nie jest tak, gdyÅ¼ w <span class="inlinecode"><span class="id" title="var">Pos</span></span> tak naprawdÄ™ nie ma Å¼adnej takiej
    funkcji - jest funkcja <span class="inlinecode">(<span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a to juÅ¼ zupeÅ‚nie
    coÅ› innego.

<div class="paragraph"> </div>

    Å»eby lepiej zrozumieÄ‡ tÄ™ materiÄ™, musimy metaforycznie zinterpretowaÄ‡
    znany nam juÅ¼ wspÃ³Å‚czynnik niedobroÅ›ci i wynikajÄ…cy z niego podziaÅ‚
    na wystÄ…pienia Å›ciÅ›le pozytywne, pozytywne i negatywne. DziÄ™ki tej
    interpretacji dowiemy siÄ™ teÅ¼, dlaczego nieparzysta niedobroÅ›Ä‡ jest
    negatywna, a niezerowa parzysta jest pozytywna.

<div class="paragraph"> </div>

    NajproÅ›ciej jest zinterpretowaÄ‡ wystÄ…pienia Å›ciÅ›le pozytywne, gdyÅ¼
    mieliÅ›my juÅ¼ z nimi sporo do czynienia. WeÅºmy konstruktor
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Jest tutaj jedno Å›ciÅ›le pozytywne
    wystÄ…pienie typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, ktÃ³re moÅ¼emy interpretowaÄ‡ tak: gdy
    uÅ¼ywamy dopasowania do wzorca i dopasuje siÄ™ <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, to "mamy"
    element <span class="inlinecode"><span class="id" title="var">t</span></span> typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Ot i caÅ‚a filozofia.

<div class="paragraph"> </div>

    ZaÅ‚Ã³Å¼my teraz na chwilÄ™, Å¼e Coq akceptuje negatywne i pozytywne
    typy induktywne. Co by byÅ‚o, gdybyÅ›my dopasowali konstruktor postaci
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>? Tym razem nie mamy elementu typu <span class="inlinecode"><span class="id" title="var">T</span></span>, lecz
    funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. ParafrazujÄ…c: musimy "daÄ‡" funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>
    element typu <span class="inlinecode"><span class="id" title="var">T</span></span>, Å¼eby dostaÄ‡ <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    A co by byÅ‚o, gdybyÅ›my dopasowali konstruktor postaci
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode">((<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>? Tym razem rÃ³wnieÅ¼ nie mamy Å¼adnego
    elementu typu <span class="inlinecode"><span class="id" title="var">T</span></span>, lecz funkcjÄ™ <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode">((<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>.
    ParafrazujÄ…c: musimy daÄ‡ funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> jakÄ…Å› funkcjÄ™ typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    Å¼eby dostaÄ‡ <span class="inlinecode"><span class="id" title="var">bool</span></span>. Ale gdy konstruujemy funkcjÄ™ <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, to na
    wejÅ›ciu dostajemy <span class="inlinecode"><span class="id" title="var">T</span></span>. Tak wiÄ™c poczÄ…tkowo nie mamy Å¼adnego <span class="inlinecode"><span class="id" title="var">T</span></span>, ale
    gdy o nie poprosimy, to moÅ¼emy je dostaÄ‡. Ba! Jak pokazuje przykÅ‚ad,
    moÅ¼emy dostaÄ‡ bardzo duÅ¼o <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Taka wÅ‚aÅ›nie jest rÃ³Å¼nica miÄ™dzy Å›cisÅ‚Ä… pozytywnoÅ›ciÄ… (mamy coÅ›),
    negatywnoÅ›ciÄ… (musimy coÅ› daÄ‡) i pozytywnoÅ›ciÄ… (moÅ¼emy coÅ› dostaÄ‡,
    i to nawet w duÅ¼ej liczbie sztuk). ZauwaÅ¼my, Å¼e jedynie w przypadku
    negatywnym moÅ¼emy wyjÄ…Ä‡ z <span class="inlinecode"><span class="id" title="var">T</span></span> funkcjÄ™ <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">co</span>Å›</span> (chyba, Å¼e zawadza
    nam <span class="inlinecode"><span class="id" title="var">unit</span></span> lub <span class="inlinecode"><span class="id" title="var">False</span></span>), bo to jedyny przypadek, gdy Å¼Ä…dajÄ… od nas
    <span class="inlinecode"><span class="id" title="var">T</span></span> (a skoro Å¼Ä…dajÄ… <span class="inlinecode"><span class="id" title="var">T</span></span>, to muszÄ… mieÄ‡ funkcjÄ™, ktÃ³ra coÅ› z tym <span class="inlinecode"><span class="id" title="var">T</span></span>
    zrobi). W przypadku pozytywnym nie ma Å¼adnej takiej funkcji - to my
    dostajemy <span class="inlinecode"><span class="id" title="var">T</span></span> i musimy coÅ› z niego wyprodukowaÄ‡, wiÄ™c to my jesteÅ›my
    tÄ… funkcjÄ…!

<div class="paragraph"> </div>

    Ufff... mam nadziejÄ™, Å¼e powyÅ¼sza bajeczka jest sformuÅ‚owana zrozumiale,
    bo lepszego wytÅ‚umaczenia nie udaÅ‚o mi siÄ™ wymyÅ›liÄ‡.

<div class="paragraph"> </div>

    MoglibyÅ›my w tym miejscu zastanowiÄ‡ siÄ™, czy nie uda nam siÄ™ pokazaÄ‡
    sprzecznoÅ›ci choÄ‡ na metapoziomie, poprzez napisanie nieterminujÄ…cej
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Szczerze piszÄ…c, to niezbyt w to wierzÄ™. Przypomnij
    sobie, Å¼e okazaÅ‚o siÄ™, Å¼e funkcja <span class="inlinecode"><span class="id" title="var">loop</span></span> jest bardzo Å›ciÅ›le powiÄ…zana
    z funkcjÄ… <span class="inlinecode"><span class="id" title="var">bad</span></span>, zaÅ› esencja nieterminacji polegaÅ‚a na przekazaniu
    do <span class="inlinecode"><span class="id" title="var">loop</span></span> jako argument czegoÅ›, co zawieraÅ‚o <span class="inlinecode"><span class="id" title="var">loop</span></span> jako podterm
    (jeÅ¼eli nie zauwaÅ¼yÅ‚eÅ›, to wszystkie nasze nieterminujÄ…ce funkcje
    udaÅ‚o nam siÄ™ zdefiniowaÄ‡ jedynie za pomocÄ… reguÅ‚y zaleÅ¼nej analizy
    przypadkÃ³w - bez indukcji, bez rekursji!). To daje nam jako takÄ…
    podstawÄ™ by wierzyÄ‡, Å¼e nawet nieterminacja nie jest w tym przypadku
    osiÄ…galna. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W tym momencie naleÅ¼y sobie zadaÄ‡ zasadnicze pytanie: dlaczego w ogÃ³le
    pozytywne typy induktywne sÄ… nielegalne? PrzecieÅ¼ odrÃ³Å¼nienie wystÄ…pienia
    pozytywnego od negatywnego nie jest czymÅ› trudnym, wiÄ™c Coq nie moÅ¼e ich
    od tak po prostu nie rozrÃ³Å¼niaÄ‡ - musi mieÄ‡ jakiÅ› powÃ³d!

<div class="paragraph"> </div>

    I faktycznie, powÃ³d jest. Nie ma on jednak wiele wspÃ³lnego z mechanizmem
    (pozytywnych) typÃ³w induktywnych samym w sobie, a z impredykatywnoÅ›ciÄ…
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Trudne sÅ‚owo, co? Nie pamiÄ™tam, czy juÅ¼ to wyjaÅ›niaÅ‚em,
    wiÄ™c wyjaÅ›niÄ™ jeszcze raz.

<div class="paragraph"> </div>

    ImpredykatywnoÅ›Ä‡ (lub teÅ¼ impredykatywizm) to pewna forma autoreferencji,
    ktÃ³ra czasem jest nieszkodliwa, a czasem bardzo mordercza. Przyjrzyjmy
    siÄ™ nastÄ™pujÄ…cej definicji: "wujek Janusz to najbardziej wÄ…sata osoba w
    tym pokoju". Definicja ta jest impredykatywna, gdyÅ¼ definiuje ona wujka
    Janusza poprzez wyrÃ³Å¼nienie go z pewnej kolekcji osÃ³b, ale definicja tej
    kolekcji osÃ³b musi odwoÅ‚ywaÄ‡ siÄ™ do wujka Janusza ("w pokoju sÄ… wujek
    Janusz, ciocia GraÅ¼ynka, Sebastianek i Karynka"). W Coqu impredykatywny
    jest sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, co ilustruje przykÅ‚ad: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja zdania <span class="inlinecode"><span class="id" title="var">X</span></span> jest impredykatywna, gdyÅ¼ kwantyfikujemy w niej po
    wszystkich zdaniach (<span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), a zatem kwantyfikujemy takÅ¼e
    po zdaniu <span class="inlinecode"><span class="id" title="var">X</span></span>, ktÃ³re wÅ‚aÅ›nie definiujemy.

<div class="paragraph"> </div>

    ImpredykatywnoÅ›Ä‡ sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest niegroÅºna (no chyba, Å¼e pragniemy
    pozytywnych typÃ³w induktywnych, to wtedy jest), ale impredykatywnoÅ›Ä‡
    dla <span class="inlinecode"><span class="id" title="keyword">Type</span></span> byÅ‚aby zabÃ³jcza, co zresztÄ… powinien nam byÅ‚ uÅ›wiadomiÄ‡
    paradoks Russella.

<div class="paragraph"> </div>

    Dobra, koniec gadania. PoniÅ¼szy przykÅ‚ad poÅ›rednio pochodzi z sekcji
    3.1 pracy "Inductively defined types", ktÃ³rej autorami sÄ… Thierry
    Coquand oraz Christine Pauling-Mohring, zaÅ› bezpoÅ›rednio jest przerÃ³bkÄ…
    kodu wziÄ™tego z
    vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Pos'0</span> : ((<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="var">Pos'</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">Pos'</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Pos'0</span> : ((<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="var">Pos'</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">dcase'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PPos'0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : (<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> (<span class="id" title="var">Pos'0</span> <span class="id" title="var">g</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Pos'</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> : (<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">Pos'0</span> <span class="id" title="var">g</span>) = <span class="id" title="var">PPos'0</span> <span class="id" title="var">g</span>}).<br/>

<br/>
</div>

<div class="doc">
Jak widaÄ‡, podejrzanym typem jest <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, bliÅºniaczo podobne do <span class="inlinecode"><span class="id" title="var">Pos</span></span>,
    ale zamiast <span class="inlinecode"><span class="id" title="var">bool</span></span> wystÄ™puje tutaj <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">unwrap</span> : <span class="id" title="var">Pos'</span> -&gt; ((<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">dcase'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; (<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Zaczynamy od zdefiniowania funkcji odwijajÄ…cej konstruktor. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Pos'0_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : (<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Pos'0</span> <span class="id" title="var">x</span> = <span class="id" title="var">Pos'0</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">unwrap</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">unwrap</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase'</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">unwrap</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">eq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
DziÄ™ki <span class="inlinecode"><span class="id" title="var">unwrap</span></span> moÅ¼emy Å‚atwo pokazaÄ‡, Å¼e konstruktor <span class="inlinecode"><span class="id" title="var">Pos'0</span></span> jest
    injekcjÄ… (to coÅ›, co w przypadku zwykÅ‚ych typÃ³w induktywnych dostajemy
    za darmo od taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, ale cÃ³Å¼, nie tym razem!). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">i</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">i_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">i</span> <span class="id" title="var">x</span> = <span class="id" title="var">i</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">y</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejnym krokiem jest zdefiniowanie funkcji <span class="inlinecode"><span class="id" title="var">i</span></span>, ktÃ³ra jest injekcjÄ…
    z dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span> w typ <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. ZauwaÅ¼my, Å¼e krok ten w
    kluczowy sposÃ³b korzysta z rÃ³wnoÅ›ci, Å¼yjÄ…cej w sorcie <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> - gdyby
    zamiast <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> byÅ‚o <span class="inlinecode"><span class="id" title="var">bool</span></span>, nie moglibyÅ›my zdefiniowaÄ‡ tej injekcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">Pos'</span> := <span class="id" title="var">Pos'0</span> (<span class="id" title="var">i</span> <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>, <span class="id" title="var">f</span> <span class="id" title="var">P</span> = <span class="id" title="var">f</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span> = <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">unwrap</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">unwrap</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">dcase'</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">unwrap</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">eq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">i_inj</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
SkÅ‚adajÄ…c ze soba <span class="inlinecode"><span class="id" title="var">i</span></span> oraz konstruktor <span class="inlinecode"><span class="id" title="var">Pos'0</span></span> dostajemy injekcjÄ™ z
    <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> w <span class="inlinecode"><span class="id" title="var">Pos'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wut</span> (<span class="id" title="var">x</span> : <span class="id" title="var">Pos'</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>, <span class="id" title="var">f</span> <span class="id" title="var">P</span> = <span class="id" title="var">x</span> /\ ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">x</span> : <span class="id" title="var">Pos'</span> := <span class="id" title="var">f</span> <span class="id" title="var">wut</span>.<br/>

<br/>
</div>

<div class="doc">
Tutaj nastÄ™pujÄ… najwiÄ™ksze czary, ktÃ³re uÅ¼ywajÄ… impredykatywnoÅ›ci. Nie
    mam Å¼adnego dobrej bajeczki, ktÃ³ra by je wyjaÅ›niaÅ‚a. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">paradox</span> : <span class="id" title="var">wut</span> <span class="id" title="var">x</span> &lt;-&gt; ~ <span class="id" title="var">wut</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> (<span class="id" title="var">P</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>). <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f_inj</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">wut</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">wut</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">paradox</span></span> to twierdzenie, ktÃ³re chwyta esencjÄ™ caÅ‚ej sprawy. Z lewa na
    prawo rozbijamy dowÃ³d <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> i dostajemy predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Wiemy, Å¼e
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>, ale <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span>, a poniewaÅ¼ <span class="inlinecode"><span class="id" title="var">f</span></span> jest injekcjÄ…, to <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">wut</span></span>.
    To jednak koÅ„czy siÄ™ sprzecznoÅ›ciÄ…, bo <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, ale <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Z prawa na lewo jest Å‚atwiej. Mamy <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> i musimy udowodniÄ‡ <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
    Wystarczy, Å¼e istnieje pewien predykat, na ktÃ³ry wybieramy oczywiÅ›cie
    <span class="inlinecode"><span class="id" title="var">wut</span></span>, ktÃ³ry speÅ‚nia <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>, co jest prawdÄ… na mocy definicji <span class="inlinecode"><span class="id" title="var">x</span></span>,
    oraz <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, co zachodzi na mocy zaÅ‚oÅ¼enia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">Pos'_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">paradox</span>. <span class="id" title="tactic">firstorder</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
No i bum. Jak widaÄ‡, pozytywne typy induktywne prowadzÄ… do sprzecznoÅ›ci,
    ale nie ma to z nimi wiele wspÃ³lnego, za to ma wiele wspÃ³lnego z sortem
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i jego impredykatywnoÅ›ciÄ…. 
<div class="paragraph"> </div>

<a name="lab193"></a><h1 class="section">Podsumowanie</h1>

<div class="paragraph"> </div>

 To juÅ¼ koniec naszej przydÅ‚ugiej podrÃ³Å¼y przez mechanizmy definiowania
    typÃ³w przez indukcjÄ™. W jej trakcie nauczyliÅ›my siÄ™ bardzo wielu rzeczy.

<div class="paragraph"> </div>

    ZaczÄ™liÅ›my od definiowania prostych enumeracji, operujÄ…cych na nich
    funkcji definiowanych za pomocÄ… dopasowania do wzorca oraz omÃ³wienia
    mechanizmu obliczania wyniku funkcji.

<div class="paragraph"> </div>

    NastÄ™pnie poznaliÅ›my rÃ³Å¼ne rozszerzenia tego podstawowego pomysÅ‚u
    definiowania typu za pomocÄ… konstruktorÃ³w reprezentujÄ…cych moÅ¼liwe
    wartoÅ›ci:
<ul class="doclist">
<li> rekurencjÄ™, dziÄ™ki ktÃ³rej moÅ¼emy definiowaÄ‡ typy, ktÃ³rych
      termy majÄ… najprzerÃ³Å¼niejsze drzewiaste ksztaÅ‚ty

</li>
<li> parametryzowane typy induktywne, ktÃ³rych gÅ‚Ã³wnym zastosowaniem
      jest definiowanie kontenerÃ³w o takich samych ksztaÅ‚tach, ale
      rÃ³Å¼nych przechowywanych typach

</li>
<li> indukcjÄ™ wzajemnÄ…, w praktyce niezbyt uÅ¼ytecznÄ…, dziÄ™ki ktÃ³rej
      moÅ¼emy na raz zdefiniowaÄ‡ wiele typÃ³w odnoszÄ…cych siÄ™ do siebie
      nawzajem

</li>
<li> indeksowane rodziny typÃ³w induktywnych, dziÄ™ki ktÃ³rym moÅ¼emy
      przez indukcjÄ™ definiowaÄ‡ predykaty oraz relacje

</li>
<li> indukcjÄ™-indukcjÄ™, dziÄ™ki ktÃ³rej moÅ¼emy jednoczeÅ›nie zdefiniowaÄ‡
      typ oraz indeksowanÄ… nim rodzinÄ™ typÃ³w

</li>
<li> indukcjÄ™-rekursjÄ™, dziÄ™ki ktÃ³rej moÅ¼emy jednoczesnie zdefiniowaÄ‡
      typ oraz funkcjÄ™ operujÄ…cÄ… na tym typie 
</li>
</ul>

<div class="paragraph"> </div>

 NauczyliÅ›my siÄ™ definiowaÄ‡ funkcje przez rekursjÄ™ oraz dowodziÄ‡ ich
    wÅ‚aÅ›ciwoÅ›ci przez indukcjÄ™. PoznaliÅ›my definicje poznanych w pierwszym
    rozdziale spÃ³jnikÃ³w logicznych oraz odpowiadajÄ…cych im konstrukcji na
    typach, a takÅ¼e definicjÄ™ bardzo waÅ¼nej rodziny typÃ³w, czyli rÃ³wnoÅ›ci.

<div class="paragraph"> </div>

    PoznaliÅ›my podstawowe obiekty, ktÃ³rymi musi potrafiÄ‡ posÅ‚ugiwaÄ‡
    siÄ™ kaÅ¼dy programista, informatyk czy matematyk, a mianowicie
    wartoÅ›ci boolowskie, liczby naturalne oraz listy.

<div class="paragraph"> </div>

    NauczyliÅ›my siÄ™ formuÅ‚owaÄ‡ i implementowaÄ‡ reguÅ‚y indukcyjne (TODO:
    opisaÄ‡ to w gÅ‚Ã³wnym tekÅ›cie, a nie dopiero w przypomnieniu), a takÅ¼e,
    co powiÄ…zane, programowaÄ‡ listy przy pomocy foldÃ³w i unfoldÃ³w.

<div class="paragraph"> </div>

    Na koÅ„cu poznaliÅ›my kryterium Å›cisÅ‚ej pozytywnoÅ›ci, ktÃ³re obowiÄ…zuje
    wszystkie definicje typÃ³w induktywnych. DowiedzieliÅ›my siÄ™, Å¼e negatywne
    typy induktywne prowadzÄ… do nieterminacji, ktÃ³ra jest zÅ‚em wcielonym.
    PoznaliÅ›my pojÄ™cie surjekcji oraz twierdzenie Cantora, ktÃ³re rÃ³wnieÅ¼
    zabrania negatywnym typom induktywnym istnienia.

<div class="paragraph"> </div>

    PoznaliÅ›my teÅ¼ paradoks Russela/Girarda i jego zwiÄ…zek z twierdzeniem
    Cantora, autoreferencjÄ… oraz ideÄ… uniwersum zdefiniowanego za pomocÄ…
    indukcji-rekursji.

<div class="paragraph"> </div>

    Ostatecznie dowiedzieliÅ›my siÄ™, Å¼e pozytywne typy induktywne takÅ¼e sÄ…
    nielegalne, choÄ‡ jesteÅ›my wobec nich raczej bezsilni, no chyba Å¼e chodzi
    o impredykatywny (tego sÅ‚owa teÅ¼ siÄ™ nauczyliÅ›my) sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    CaÅ‚kiem sporo, prawda? Nie? No to w kolejnych rozdziaÅ‚ach bÄ™dzie jeszcze
    wiÄ™cej. 
</div>
<div class="code">
</div>
