<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">D1a: Proste typy induktywne</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W poprzednim rozdziale dowiedzieliśmy się już co nieco o typach, a
    także spotkaliśmy kilka z nich oraz kilka sposobów tworzenia nowych
    typów ze starych (takich jak np. koniunkcja; pamiętaj, że zdania są
    typami). W tym rozdziale dowiemy się, jak definiować nowe typy przy
    pomocy indukcji oraz jak użyć rekursji do definiowania funkcji, które
    operują na tych typach. 
<div class="paragraph"> </div>

 W Coqu są trzy główne rodzaje typów: produkt zależny, typy induktywne
    i typy koinduktywne. Z pierwszym z nich już się zetknęliśmy, drugi
    poznamy w tym rozdziale, trzeci na razie pominiemy.

<div class="paragraph"> </div>

    Typ induktywny definiuje się przy pomocy zbioru konstruktorów, które
    służą, jak sama nazwa wskazuje, do budowania termów tego typu.
    Konstruktory te są funkcjami (być może zależnymi), których
    przeciwdziedziną jest definiowany typ, ale niczego nie
    obliczają — nadają jedynie termom ich "kształt". W szczególności, nie
    mają nic wspólnego z konstruktorami w takich językach jak C++ lub Java
    — nie mogą przetwarzać swoich argumentów, alokować pamięci, dokonywać
    operacji wejścia/wyjścia etc.

<div class="paragraph"> </div>

    Tym, co jest ważne w przypadku konstruktorów, jest ich ilość, nazwy
    oraz ilość i typy przyjmowanych argumentów. To te cztery rzeczy decydują
    o tym, jakie "kształty" będą miały termy danego typu, a więc i czym
    będzie sam typ. W ogolności każdy term jest skończonym, ukorzenionym
    drzewem, którego kształt zależy od charakterystyki konstruktorów tak:
<ul class="doclist">
<li> każdy konstruktor to inny rodzaj węzła (nazwa konstruktora to nazwa
      węzła)

</li>
<li> konstruktory nierekurencyjne to liście, a rekurencyjne — węzły
      wewnętrzne

</li>
<li> argumenty konstruktorów to dane przechowywane w danym węźle 
</li>
</ul>

<div class="paragraph"> </div>

 Typ induktywny można wyobrażać sobie jako przestrzeń zawierającą
    te i tylko te drzewa, które można zrobić przy pomocy jego
    konstruktorów. Nie przejmuj się, jeżeli opis ten wydaje ci się
    dziwny — sposób definiowania typów induktywnych i ich wartości
    w Coqu jest diametralnie różny od sposobu definiowania klas i
    obiektów w językach imperatywnych i wymaga przyzwyczajenia się
    do niego. Zobaczmy, jak powyższy opis ma się do konkretnych
    przykładów. 
<div class="paragraph"> </div>

<a id="lab467"></a><h1 class="section">Enumeracje</h1>

<div class="paragraph"> </div>

 Najprostszym rodzajem typów induktywnych są enumeracje, czyli typy,
    których wszystkie konstruktory są stałymi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">true</span> : <span class="id" title="var">bool</span><br/>
| <span class="id" title="var">false</span> : <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja typu induktywnego ma następującą postać: najpierw występuje
    słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, następnie nazwa typu, a po dwukropku sort
    (<span class="inlinecode"><span class="id" title="keyword">Set</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>). Następnie wymieniamy konstruktory typu —
    dla czytelności każdy w osobnej linii. Mają one swoje unikalne nazwy i
    są funkcjami, których przeciwdziedziną jest definiowany typ. W naszym
    przypadku mamy 2 konstruktory, zwane <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="var">false</span></span>, które są
    funkcjami zeroargumentowymi.

<div class="paragraph"> </div>

    Definicję tę możemy odczytać następująco: "<span class="inlinecode"><span class="id" title="var">true</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    <span class="inlinecode"><span class="id" title="var">false</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i nie ma żadnych więcej wartości typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span>".

<div class="paragraph"> </div>

    Uwaga: należy odróżnić symbole <span class="inlinecode">:=</span> oraz <span class="inlinecode">=</span>. Pierwszy z nich służy
    do definiowania, a drugi do zapisywania równości.

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">term</span></span> oznacza "niech od teraz <span class="inlinecode"><span class="id" title="var">name</span></span> będzie inną nazwą
    dla <span class="inlinecode"><span class="id" title="var">term</span></span>". Jest to komenda, a nie zdanie logiczne. Od teraz jeżeli
    natkniemy się na nazwę <span class="inlinecode"><span class="id" title="var">name</span></span>, będziemy mogli odwinąć jej definicję i
    wstawić w jej miejsce <span class="inlinecode"><span class="id" title="var">term</span></span>. Przykład: <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span>.
    Antyprzykład: <span class="inlinecode">2</span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span> (błąd składni).

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> oznacza "<span class="inlinecode"><span class="id" title="var">a</span></span> jest równe <span class="inlinecode"><span class="id" title="var">b</span></span>". Jest to zdanie logiczne,
    a nie komenda. Zdanie to rzecz jasna nie musi być prawdziwe. Przykład:
    <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>. Antyprzykład: <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> (jeżeli <span class="inlinecode"><span class="id" title="var">five</span></span> nie jest zdefiniowane,
    to dostajemy komunikat w stylu "nie znaleziono nazwy <span class="inlinecode"><span class="id" title="var">five</span></span>"). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">false</span><br/>
| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji wygląda tak: najpierw mamy słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>
    (jeżeli funkcja nie jest rekurencyjna), następnie argumenty funkcji
    w postaci <span class="inlinecode">(<span class="id" title="var">name</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">type</span>)</span>; po dwukropku przeciwdziedzina, a po symbolu
    <span class="inlinecode">:=</span> ciało funkcji.

<div class="paragraph"> </div>

    Podstawowym narzędziem służącym do definiowania funkcji jest
    dopasowanie do wzorca (ang. pattern matching). Pozwala ono sprawdzić,
    którego konstruktora użyto do zrobienia dopasowywanej wartości.
    Podobnym tworem występującym w językach imperatywnych jest instrukcja
    switch, ale dopasowanie do wzorca jest od niej dużo potężniejsze.

<div class="paragraph"> </div>

    Nasza funkcja działa następująco: sprawdzamy, którym konstruktorem
    zrobiono argument <span class="inlinecode"><span class="id" title="var">b</span></span> — jeżeli było to <span class="inlinecode"><span class="id" title="var">true</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">false</span></span>, a
    gdy było to <span class="inlinecode"><span class="id" title="var">false</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a id="lab468"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">andb</span></span> i <span class="inlinecode"><span class="id" title="var">orb</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">andb</span></span> (koniunkcja boolowska) i <span class="inlinecode"><span class="id" title="var">orb</span></span> (alternatywa
    boolowska). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zanim odpalimy naszą funkcję, powinniśmy zadać sobie pytanie: w jaki
    sposób programy są wykonywane? W celu lepszego zrozumienia tego
    zagadnienia porównamy ewaluację programów napisanych w językach
    imperatywnych oraz funkcyjnych.

<div class="paragraph"> </div>

    Rozważmy bardzo uproszczony model: interpreter wykonuje program,
    który nie dokonuje operacji wejścia/wyjścia, napisany w jakimś
    języku imperatywnym. W tej sytuacji działanie interpretera
    sprowadza się do tego, że czyta on kod programu instrukcja po
    instrukcji, a następnie w zależności od przeczytanej instrukcji
    odpowiednio zmienia swój stan.

<div class="paragraph"> </div>

    W języku czysto funkcyjnym taki model ewaluacji jest niemożliwy,
    gdyż nie dysponujemy globalnym stanem. Zamiast tego, w Coqu
    wykonanie programu polega na jego redukcji. O co chodzi?
    Przypomnijmy najpierw, że program to term, którego typem jest
    specyfikacja, czyli typ sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Termy mogą być redukowane,
    czyli zamieniane na równoważne, ale prostsze, przy użyciu
    reguł redukcji. Prześledźmy wykonanie programu <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    krok po kroku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;(fun&nbsp;b&nbsp;:&nbsp;bool&nbsp;=&gt;&nbsp;match&nbsp;b&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja delta odwija definicje. Żeby użyć jakiejś redukcji, używamy
    komendy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> <span class="inlinecode"><span class="id" title="var">redukcje</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">term</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;match&nbsp;true&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja beta podstawia argument do funkcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">iota</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja jota dopasowuje term do wzorca i zamienia go na term
    znajdujący się po prawej stronie <span class="inlinecode">=&gt;</span> dla dopasowanego przypadku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">negb</span> <span class="id" title="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żeby zredukować term za jednym zamachem, możemy pominąć nazwy
    redukcji występujące po <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> — w taki wypadku zostaną zaaplikowane
    wszystkie możliwe redukcje, czyli program zostanie wykonany. Do jego
    wykonania możemy też użyć komend <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (a
    także <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ale taktyka <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> jest przestarzała, więc nie
    polecam). 
<div class="paragraph"> </div>

<a id="lab469"></a><h4 class="section">Ćwiczenie (redukcja)</h4>

<div class="paragraph"> </div>

 Zredukuj "ręcznie" programy <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> oraz <span class="inlinecode"><span class="id" title="var">orb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 Jak widać, wykonanie programu w Coqu jest dość toporne. Wynika to
    z faktu, że Coq nie został stworzony do wykonywania programów, a
    jedynie do ich definiowania i dowodzenia ich poprawności. Aby użyć
    programu napisanego w Coqu w świecie rzeczywistym, stosuje się
    zazwyczaj mechanizm ekstrakcji, który pozwala z programu napisanego
    w Coqu automatycznie uzyskać program w Scheme, OCamlu lub Haskellu,
    które są od Coqa dużo szybsze i dużo powszechniej używane. My jednak
    nie będziemy się tym przejmować. 

<div class="paragraph"> </div>

    Zdefiniowawszy naszą funkcję, możemy zadać sobie pytanie:
    czy definicja jest poprawna? Gdybyśmy pisali w jednym z
    języków imperatywnych, moglibyśmy napisać dla niej testy
    jednostkowe, polegające np. na tym, że generujemy losowo
    wejście funkcji i sprawdzamy, czy wynik posiada żądaną przez
    nas właściwość. Coq umożliwia nam coś dużo silniejszego:
    możemy wyrazić przy pomocy twierdzenia, że funkcja posiada
    interesującą nas własność, a następnie spróbować je udowodnić.
    Jeżeli nam się powiedzie, mamy całkowitą pewność, że funkcja
    rzeczywiście posiada żądaną własność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_involutive</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie głosi, że funkcja <span class="inlinecode"><span class="id" title="var">negb</span></span> jest inwolucją,
    tzn. że dwukrotne jej zaaplikowanie do danego argumentu
    nie zmienia go, lub też, innymi słowy, że <span class="inlinecode"><span class="id" title="var">negb</span></span> jest
    swoją własną odwrotnością.

<div class="paragraph"> </div>

    Dowód przebiega w następujący sposób: taktyką <span class="inlinecode"><span class="id" title="tactic">intro</span></span>
    wprowadzamy zmienną <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu, a następnie
    używamy taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, aby sprawdzić, którym
    konstruktorem została zrobiona. Ponieważ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma
    dwa konstruktory, taktyka ta generuje nam dwa podcele:
    musimy udowodnić twierdzenie osobno dla przypadku, gdy
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz dla <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. Potem przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> redukujemy (czyli wykonujemy) programy
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span>. Zauważ, że
    byłoby to niemożliwe, gdyby argument był postaci <span class="inlinecode"><span class="id" title="var">b</span></span>
    (nie można wtedy zaaplikować żadnej redukcji), ale jest
    jak najbardziej możliwe, gdy jest on postaci <span class="inlinecode"><span class="id" title="var">true</span></span> albo
    <span class="inlinecode"><span class="id" title="var">false</span></span> (wtedy redukcja przebiega jak w przykładzie). Na
    koniec używamy taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, która potrafi udowodnić
    cel postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> jest taktykowym odpowiednikiem dopasowania do wzorca
    i bardzo często jest używany, gdy mamy do czynienia z czymś,
    co zostało za jego pomocą zdefiniowane.

<div class="paragraph"> </div>

    Być może poczułeś dyskomfort spowodowany tym, że cel postaci
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> można udowodnić dwoma różnymi taktykami (<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>) albo że termy można redukować na cztery różne
    sposoby (<span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>).
    Niestety, będziesz musiał się do tego przyzwyczaić — język
    taktyka Coqa jest strasznie zabałaganiony i niesie ze sobą
    spory bagaż swej mrocznej przeszłości. Na szczęście od niedawna
    trwają prace nad jego ucywilizowaniem, czego pierwsze efekty
    widać już od wersji 8.5. W chwilach desperacji uratować może
    cię jedynie dokumentacja:
<ul class="doclist">
<li> <a class='link' href='https://coq.inria.fr/refman/coq-tacindex.html'>Indeks taktyk</a>

</li>
<li> <a class='link' href='https://coq.inria.fr/refman/proof-engine/ltac.html'>Ltac</a> 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_involutive'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że nie musimy używać taktyki <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, żeby wprowadzić
    <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu: taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sama jest w stanie wykryć,
    że nie ma go w kontekście i wprowadzić je tam przed rozbiciem
    go na konstruktory. Zauważmy też, że oba podcele rozwiązaliśmy
    w ten sam sposób, więc możemy użyć kombinatora <span class="inlinecode">;</span> (średnika),
    żeby rozwiązać je oba za jednym zamachem. 
<div class="paragraph"> </div>

<a id="lab470"></a><h4 class="section">Ćwiczenie (logika boolowska)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">andb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">andb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span>) = <span class="id" title="var">orb</span> (<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) <span class="id" title="var">b3</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_comm</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">orb</span> <span class="id" title="var">b2</span> <span class="id" title="var">b1</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_true_elim</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">b1</span> = <span class="id" title="var">true</span> /\ <span class="id" title="var">b2</span> = <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab471"></a><h4 class="section">Ćwiczenie (róża kierunków)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj typ opisujący kierunki podstawowe (północ, południe, wschód,
    zachód - dodatkowe punkty za nadanie im sensownych nazw). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>, które reprezentują obrót o 90
    stopni przeciwnie/zgodnie z ruchem wskazówek zegara. Sformułuj i
    udowodnij twierdzenia mówiące, że:
<ul class="doclist">
<li> obrót cztery razy w lewo/prawo niczego nie zmienia

</li>
<li> obrót trzy razy w prawo to tak naprawdę obrót w lewo (jest to tzw.
      pierwsze twierdzenie korwinizmu)

</li>
<li> obrót trzy razy w lewo to obrót w prawo (jest to tzw. drugie
      twierdzenie korwinizmu)

</li>
<li> obrót w prawo, a potem w lewo niczego nie zmienia

</li>
<li> obrót w lewo, a potem w prawo niczego nie zmienia

</li>
<li> każdy kierunek to północ, południe, wschód lub zachód (tzn. nie ma
      innych kierunków) 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">opposite</span></span>, które danemu kierunkowi przyporządkowuje
    kierunek do niego przeciwny (czyli północy przyporządkowuje południe
    etc.). Wymyśl i udowodnij jakąś ciekawę specyfikację dla tej funkcji
    (wskazówka: powiąż ją z <span class="inlinecode"><span class="id" title="var">turnL</span></span> i <span class="inlinecode"><span class="id" title="var">turnR</span></span>). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">is_opposite</span></span>, która bierze dwa kierunki i zwraca
    <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy są one przeciwne oraz <span class="inlinecode"><span class="id" title="var">false</span></span> w przeciwnym wypadku. Wymyśl
    i udowodnij jakąś specyfikację dla tej funkcji. Wskazówka: jakie są jej
    związku z <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> i <span class="inlinecode"><span class="id" title="var">opposite</span></span>? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Pokaż, że funkcje <span class="inlinecode"><span class="id" title="var">turnL</span></span>, <span class="inlinecode"><span class="id" title="var">turnR</span></span> oraz <span class="inlinecode"><span class="id" title="var">opposite</span></span> są injekcjami i
    surjekcjami (co to dokładnie znacz, dowiemy się później). Uwaga: to
    zadanie wymaga użyci taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, która jest opisana w
    podrozdziale o polimorfizmie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnL</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">turnR</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">opposite</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnL_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnL</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">turnR_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">turnR</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">opposite_sur</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">D</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">D</span>, <span class="id" title="var">opposite</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Directions</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab472"></a><h4 class="section">Ćwiczenie (różne enumeracje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj typy induktywne reprezentujące:
<ul class="doclist">
<li> dni tygodnia

</li>
<li> miesiące

</li>
<li> kolory podstawowe systemu RGB 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Wymyśl do nich jakieś ciekawe funkcje i twierdzenia. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab473"></a><h1 class="section">Typy polimorficzne i właściwości konstruktorów</h1>

<div class="paragraph"> </div>

 Przy pomocy komendy <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> możemy definiować nie tylko typy
    induktywne, ale także rodziny typów induktywnych. Jeżeli taka
    rodzina parametryzowana jest typem, to mamy do czynienia z
    polimorfizmem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Some</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option</span> <span class="id" title="var">A</span><br/>
| <span class="id" title="var">None</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">option</span></span> jest rodziną typów, zaś samo <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dla ustalonego <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest typem, który reprezentuje możliwość istnienia wartości typu <span class="inlinecode"><span class="id" title="var">A</span></span>
    (konstruktor <span class="inlinecode"><span class="id" title="var">Some</span></span>) albo i nie (konstruktor <span class="inlinecode"><span class="id" title="var">None</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Some</span> <span class="id" title="var">nat</span> 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;nat&nbsp;5&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">None</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Some</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">None</span> {<span class="id" title="var">A</span>}.<br/>

<br/>
</div>

<div class="doc">
Jak widać typ <span class="inlinecode"><span class="id" title="var">A</span></span>, będący parametrem <span class="inlinecode"><span class="id" title="var">option</span></span>, jest też pierwszym
    argumentem każdego z konstruktorów.
    Pisanie go bywa uciążliwe, ale na szczęście Coq może sam wywnioskować
    jego wartość, jeżeli mu każemy. Komenda <span class="inlinecode"><span class="id" title="var">Arguments</span></span> pozwala nam
    określić, które argumenty mają być domyślne — chcemy, aby argument <span class="inlinecode"><span class="id" title="var">A</span></span>
    był domyślny, gdyż w przypadku konstruktura <span class="inlinecode"><span class="id" title="var">Some</span></span> może być wywnioskowany
    z drugiego argumentu, a w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> — zazwyczaj z kontekstu.

<div class="paragraph"> </div>

    Konstruktory typów induktywnych mają kilka właściwości, o którch
    warto wiedzieć. Po pierwsze, wartości zrobione za pomocą różnych
    konstruktorów są różne. Jest to konieczne, gdyż za pomocą dopasowania
    do wzorca możemy rozróżnić różne konstruktory — gdyby były one
    równe, uzyskalibyśmy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isSome</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">a</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">Some</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">True</span><br/>
| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">False</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Pomocnicza funkcja <span class="inlinecode"><span class="id" title="var">isSome</span></span> ma za zadanie sprawdzić, którym
    konstruktorem zrobiono wartość typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span>
    oznacza, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest argumentem domyślnym funkcji — Coq może go
    wywnioskować, gdyż zna typ argumentu <span class="inlinecode"><span class="id" title="var">a</span></span> (jest nim <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).
    Zauważ też, że funkcja ta zwraca zdania logiczne, a nie wartości
    boolowskie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_not_none</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">change</span> <span class="id" title="var">False</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">isSome</span> (@<span class="id" title="var">None</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Możemy użyć tej pomocniczej funkcji, aby udowodnić, że konstruktory
    <span class="inlinecode"><span class="id" title="var">Some</span></span> i <span class="inlinecode"><span class="id" title="var">None</span></span> tworzą różne wartości. Taktyka <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span>
    pozwala nam zamienić term <span class="inlinecode"><span class="id" title="var">t1</span></span> na <span class="inlinecode"><span class="id" title="var">t2</span></span> pod warunkiem, że są one
    konwertowalne (czyli jeden z nich redukuje się do drugiego). W naszym
    wypadku chcemy zastąpić <span class="inlinecode"><span class="id" title="var">False</span></span> przez <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(@<span class="id" title="var">None</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, który
    redukuje się do <span class="inlinecode"><span class="id" title="var">False</span></span> (spróbuj zredukować to wyrażenie ręcznie).

<div class="paragraph"> </div>

    Użycie symbolu <span class="inlinecode">@</span> pozwala nam dla danego wyrażenia zrezygnować z
    próby automatycznego wywnioskowania argumentów domyślnych — w tym
    przypadku Coq nie potrafiłby wywnioskować argumentu dla konstruktora
    <span class="inlinecode"><span class="id" title="var">None</span></span>, więc musimy podać ten argument ręcznie. 

<div class="paragraph"> </div>

    Następnie możemy skorzystać z równania <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>, żeby
    uzyskać cel postaci <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(<span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>. Cel ten redukuje się
    do <span class="inlinecode"><span class="id" title="var">True</span></span>, którego udowodnienie jest trywialne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_not_none'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">a</span> &lt;&gt; <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">inversion</span> 1. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Cała procedura jest dość skomplikowana — w szczególności wymaga
    napisania funkcji pomocniczej. Na szczęście Coq jest w stanie
    sam wywnioskować, że konstruktory są różne. Możemy zrobić to
    przy pomocy znanej nam z poprzedniego rozdziału taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Zapis <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> oznacza: wprowadź zmienne związane przez
    kwantyfikację uniwersaną do kontekstu i użyj taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    na pierwszej przesłance implikacji. W naszym przypadku implikacja
    jest ukryta w definicji negacji: <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">None</span></span> to tak naprawdę
    <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_inj</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną właściwością konstruktorów jest fakt, że są one injekcjami,
    tzn. jeżeli dwa termy zrobione tymi samymi konstruktorami są równe,
    to argumenty tych konstruktorów też są równe.

<div class="paragraph"> </div>

    Aby skorzystać z tej właściwości w dowodzie, możemy użyć taktyki
    <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, podając jej jako argument nazwę hipotezy. Jeżeli
    hipoteza jest postaci <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">yn</span></span>, to nasz cel <span class="inlinecode"><span class="id" title="var">G</span></span>
    zostanie zastąpiony przez implikację <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">yn</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>.
    Po wprowadzeniu hipotez do kontekstu możemy użyć ich do udowodnienia
    <span class="inlinecode"><span class="id" title="var">G</span></span>, zazwyczaj przy pomocy taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">H</span></span> miało postać <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a cel <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    więc <span class="inlinecode"><span class="id" title="tactic">injection</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> przekształciło cel do postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    który jest trywialny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_inj'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> może nam pomóc również wtedy, kiedy chcemy skorzystać
    z injektywności konstruktorów. W zasadzie jest ona nawet bardziej
    przydatna — działa ona tak jak <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, ale zamiast zostawiać cel w
    postaci <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>, wprowadza ona wygenerowane hipotezy do
    kontekstu, a następnie przepisuje w celu wszystkie, których przepisanie
    jest możliwe. W ten sposób oszczędza nam ona nieco pisania.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">inverson</span></span> <span class="inlinecode">1</span> dodała do kontekstu hipotezę <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    a następnie przepisała ją w celu (który miał postać <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>), dając
    cel postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">some_inj''</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">Some</span> <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">injection</span> 1. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyką ułatwiającą pracę z <span class="inlinecode"><span class="id" title="tactic">injection</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> jest <span class="inlinecode"><span class="id" title="tactic">subst</span></span>.
    Taktyka ta wyszukuje w kontekście hipotezy postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>,
    przepisuje je we wszystkich hipotezach w kontekście i celu, w których
    jest to możliwe, a następnie usuwa. Szczególnie często spotykana
    jest kombinacja <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, gdyż <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> często
    generuje sporą ilość hipotez postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, które <span class="inlinecode"><span class="id" title="tactic">subst</span></span> następnie
    "sprząta".

<div class="paragraph"> </div>

    W naszym przypadku hipoteza <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> została przepisana nie tylko
    w celu, dając <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, ale także w hipotezie <span class="inlinecode"><span class="id" title="var">H</span></span>, dając
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
<div class="paragraph"> </div>

<a id="lab474"></a><h4 class="section">Ćwiczenie (zero i jeden)</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenie bez używania taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Żeby było trudniej, nie pisz osobnej funkcji pomocniczej — zdefiniuj
    swoją funkcję bezpośrednio w miejscu, w którym chcesz jej użyć.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">zero_not_one</span> : 0 &lt;&gt; 1.<br/>

<br/>
</div>

<div class="doc">
Dwie opisane właściwości, choć pozornie niewinne, a nawet przydatne,
    mają bardzo istotne i daleko idące konsekwencje. Powoduję one na
    przykład, że nie istnieją typy ilorazowe. Dokładne znaczenie tego
    faktu omówimy później, zaś teraz musimy zadowolić się jedynie
    prostym przykładem w formie ćwiczenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">rational</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">mk_rational</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">sign</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">numerator</span> <span class="id" title="var">denominator</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">denominator</span> &lt;&gt; 0 -&gt; <span class="id" title="var">rational</span>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">rational_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> <span class="id" title="var">p'</span> <span class="id" title="var">q</span> <span class="id" title="var">q'</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="var">q</span> &lt;&gt; 0) (<span class="id" title="var">H'</span> : <span class="id" title="var">q'</span> &lt;&gt; 0), <span class="id" title="var">p</span> * <span class="id" title="var">q'</span> = <span class="id" title="var">p'</span> * <span class="id" title="var">q</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mk_rational</span> <span class="id" title="var">s</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">H</span> = <span class="id" title="var">mk_rational</span> <span class="id" title="var">s'</span> <span class="id" title="var">p'</span> <span class="id" title="var">q'</span> <span class="id" title="var">H'</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">rational</span></span> ma reprezentować liczby wymierne. Znak jest typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span> — możemy interpretować, że <span class="inlinecode"><span class="id" title="var">true</span></span> oznacza obecność znaku
    minus, a <span class="inlinecode"><span class="id" title="var">false</span></span> brak znaku. Dwie liczby naturalne będą oznaczać
    kolejno licznik i mianownik, a na końcu żądamy jeszcze dowodu na
    to, że mianownik nie jest zerem.

<div class="paragraph"> </div>

    Oczywiście typ ten sam w sobie niewiele ma wspólnego z liczbami
    wymiernymi — jest to po prostu trójka elementów o typach <span class="inlinecode"><span class="id" title="var">bool</span>,</span>
    <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, z których ostatni nie jest zerem. Żeby rzeczywiście
    reprezentował liczby wymierne musimy zapewnić, że termy, które
    reprezentują te same wartości, są równe, np. 1/2 musi być równa
    2/4.

<div class="paragraph"> </div>

    W tym celu postulujemy aksjomat, który zapewni nam pożądane
    właściwości relacji równości. Komenda <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> pozwala nam
    wymusić istnienie termu pożądanego typu i nadać mu nazwę,
    jednak jest szalenie niebezpieczna — jeżeli zapostulujemy
    aksjomat, który jest sprzeczny, jesteśmy zgubieni.

<div class="paragraph"> </div>

    W takiej sytuacji całe nasze dowodzenie idzie na marne, gdyż
    ze sprzecznego aksjomatu możemy wywnioskować <span class="inlinecode"><span class="id" title="var">False</span></span>, z
    <span class="inlinecode"><span class="id" title="var">False</span></span> zaś możemy wywnioskować cokolwiek, o czym przekonaliśmy
    się w rozdziale pierwszym. Tak też jest w tym przypadku —
    aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny, gdyż łamie zasadę
    injektywności konstruktorów. 
<div class="paragraph"> </div>

<a id="lab475"></a><h4 class="section">Ćwiczenie (niedobry aksjomat)</h4>

<div class="paragraph"> </div>

 Udowodnij, że aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny. Wskazówka: znajdź
    dwie liczby wymierne, które są równe na mocy tego aksjomatu, ale które
    można rozróżnić za pomocą dopasowania do wzorca. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rational_eq_inconsistent</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">rational</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab476"></a><h1 class="section">Przydatne komendy</h1>

<div class="paragraph"> </div>

 Czas, aby opisać kilka przydatnych komend. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;unit&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">unit</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, że komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> wyświetla typ danego jej termu,
    a <span class="inlinecode"><span class="id" title="keyword">Print</span></span> wypisuje jego definicję. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Search</span></span> wyświetla wszystkie obiekty, które zawierają podaną nazwę.
    W naszym przypadku pokazały się wszystkie funkcje, w których
    sygnaturze występuje typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span><span class="id" title="var">Pattern</span> (<span class="id" title="var">_</span> + <span class="id" title="var">_</span> = <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchPattern</span></span> jako argument bierze wzorzec i wyświetla wszystkie
    obiekty, które zawierają podterm pasujący do danego wzorca. W naszym
    przypadku pokazały się twierdzenia, w których występuje podterm
    mający po lewej dodawanie, a po prawej cokolwiek.

<div class="paragraph"> </div>

    Dokładny opis wszystkich komend znajdziesz
    <a class='link' href='https://coq.inria.fr/refman/coq-cmdindex.html'>tutaj</a>. 
<div class="paragraph"> </div>

<a id="lab477"></a><h1 class="section">Ważne typy induktywne</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab478"></a><h2 class="section">Typ pusty</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty_set</span> : <span class="id" title="keyword">Set</span> := .<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Empty_set</span></span> jest, jak sama nazwa wskazuje, typem pustym. Żaden term
    nie jest tego typu. Innymi słowy: jeżeli jakiś term jest typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    to mamy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">create</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli mamy term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, to możemy w sposób niemal magiczny
    wyczarować term dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span>, używając dopasowania do wzorca z
    pustym wzorcem. 
<div class="paragraph"> </div>

<a id="lab479"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">create_unique</span></span>)</h4>

<div class="paragraph"> </div>

 Udowodnij, że powyższa funkcja jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">create_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">Empty_set</span> -&gt; <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>, <span class="id" title="var">create</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab480"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">no_fun_from_nonempty_to_empty</span></span>)</h4>

<div class="paragraph"> </div>

 Pokaż, że nie istnieją funkcje z typu niepustego w pusty. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">no_fun_from_nonempty_to_empty</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>), <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab481"></a><h2 class="section">Singleton</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">unit</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">tt</span> : <span class="id" title="var">unit</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">unit</span></span> jest typem, który ma tylko jeden term, zwany <span class="inlinecode"><span class="id" title="var">tt</span></span> (nazwa ta
    jest wzięta z sufitu). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">delete</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">unit</span> := <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest w pewien sposób "dualna" do napotkanej przez
    nas wcześniej funkcji <span class="inlinecode"><span class="id" title="var">create</span></span>. Mając term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span> mogliśmy
    stworzyć term dowolnego innego typu, zaś mając term dowolnego typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>, możemy "zapomnieć o nim" albo "skasować go", wysyłając go
    funkcją <span class="inlinecode"><span class="id" title="var">delete</span></span> w jedyny term typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, czyli <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

    Uwaga: określenie "skasować" nie ma nic wspólnego z fizycznym
    niszczeniem albo dealokacją pamięci. Jest to tylko metafora. 
<div class="paragraph"> </div>

<a id="lab482"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">delete_unique</span></span>)</h4>

<div class="paragraph"> </div>

 Pokaż, że funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">delete_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">unit</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">delete</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab483"></a><h2 class="section">Produkt</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">prod</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">pair</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">pair</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Produkt typów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termami są pary. Pierwszy
    element pary to term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugi to term typu <span class="inlinecode"><span class="id" title="var">B</span></span>. Tym, co
    charakteryzuje produkt, są projekcje:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">fst</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wyciąga z pary jej
      pierwszy element

</li>
<li> <span class="inlinecode"><span class="id" title="var">snd</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wyciąga z pary jej
      drugi element 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab484"></a><h4 class="section">Ćwiczenie (projekcje)</h4>

<div class="paragraph"> </div>

 Zdefiniuj projekcje i udowodnij poprawność swoich definicji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">proj_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> = <span class="id" title="var">pair</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab485"></a><h2 class="section">Suma</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sum</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">inl</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">inr</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inl</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inr</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Suma <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termy są albo termami typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    zawiniętymi w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span>, albo termami typu <span class="inlinecode"><span class="id" title="var">B</span></span>, zawiniętymi
    w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Suma, w przeciwieństwie do produktu, zdecydowanie
    nie ma projekcji. 
<div class="paragraph"> </div>

<a id="lab486"></a><h4 class="section">Ćwiczenie (sumy bez projekcji)</h4>

<div class="paragraph"> </div>

 Pokaż, że suma nie ma projekcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sum_no_fst</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sum_no_snd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>), <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ImportantTypes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab487"></a><h1 class="section">Sumy zależne i podtypy</h1>

<div class="paragraph"> </div>

 W Coqu, w przeciwieństwie do wielu języków imperatywnych, nie ma
    mechanizmu podtypowania, a każde dwa typy są ze sobą rozłączne.
    Nie jest to problemem, gdyż podtypowanie możemy zasymulować za
    pomocą sum zależnych, a te zdefiniować możemy induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">sigma</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sigT</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">existT</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">sigT</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> reprezentuje sumę zależną, której elementami są pary zależne.
    Pierwszym elementem pary jest <span class="inlinecode"><span class="id" title="var">x</span></span>, który jest typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś drugim
    elementem pary jest term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Suma zależna jest wobec tego pewnym
    uogólnieniem produktu.

<div class="paragraph"> </div>

    Niech cię nie zmyli nazewnictwo:
<ul class="doclist">
<li> Suma jest reprezentowana przez typ <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jej elementami są
      elementy <span class="inlinecode"><span class="id" title="var">A</span></span> zawinięte w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span> oraz elementy <span class="inlinecode"><span class="id" title="var">B</span></span>
      zawinięte w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Reprezentuje ideę "lub/albo".
      Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie może zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Produkt jest reprezentowany przez typ <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      są pary elementów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. Reprezentuje on ideę "i/oraz". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> nie może zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Uogólnieniem produktu jest suma zależna. Jest ona reprezentowana
      przez typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jej elementami są pary zależne elementów
      <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pierwszym elementem pary.
      Reprezentuje ona ideę "i/oraz", gdzie typ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> może zależeć od
      elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Typ funkcji jest reprezentowany przez <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      są termy postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentują ideę "daj mi
      coś typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coś typu <span class="inlinecode"><span class="id" title="var">B</span></span>". Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie może
      zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Uogólnieniem typu funkcji jest produkt zależny <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
      Jego elementami są termu postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentuje
      on ideę "daj mi <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coś typu <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> może zależeć od typu elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">sigT</span></span> jest najogólniejszą postacią pary zależnej — <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem,
    a <span class="inlinecode"><span class="id" title="var">P</span></span> rodziną typów. Mimo swej ogólności jest używany dość rzadko,
    gdyż najbardziej przydatną postacią sumy zależnej jest typ <span class="inlinecode"><span class="id" title="var">sig</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sig</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">exist</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">sig</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">exist</span> {<span class="id" title="var">A</span> <span class="id" title="var">P</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> można interpretować jako typ składający się z tych
    elementów <span class="inlinecode"><span class="id" title="var">A</span></span>, które spełniają predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Formalnie jest to
    para zależna, której pierwszym elementem jest term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś
    drugim dowód na to, że spełnia on predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">big_nat</span> : <span class="id" title="keyword">Type</span> := <span class="id" title="var">sig</span> <span class="id" title="var">nat</span> (<span class="id" title="var">le</span> 100).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">big_100</span> : <span class="id" title="var">big_nat</span> := <span class="id" title="var">exist</span> 100 (<span class="id" title="var">le_n</span> 100).<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">big_nat</span></span> reprezentuje liczby naturalne większe lub równe 100,
    zaś term <span class="inlinecode"><span class="id" title="var">big_100</span></span> to liczba <span class="inlinecode">100</span> wraz z załączonym dowodem faktu, 
    że jest ona większa lub równa 100.

<div class="paragraph"> </div>

    Interpretacja typu <span class="inlinecode"><span class="id" title="var">sig</span></span> sprawia, że jest on wykorzystywany bardzo
    często do podawania specyfikacji programów — pozwala on dodać do
    wyniku zwracanego przez funkcję informację o jego właściwościach.
    W przypadku argumentów raczej nie jest używany, gdyż prościej jest
    po prostu wymagać dowodów żądanych właściwości w osobnych argumentach
    niż pakować je w <span class="inlinecode"><span class="id" title="var">sig</span></span> po to, żeby i tak zostały później odpakowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">big_101</span> : <span class="id" title="var">big_nat</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">exist</span> 101).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definiowanie wartości typu <span class="inlinecode"><span class="id" title="var">sig</span></span> jest problematyczne, gdyż zawierają
    one dowody. Napisanie definicji "ręcznie", explicité podając proofterm,
    nie wchodzi w grę. Innym potencjalnym rozwiązaniem jest napisanie dowodu
    na boku, a następnie użycie go we właściwej definicji, ale jest ono
    dłuższe niż to konieczne.

<div class="paragraph"> </div>

    Przypomnijmy sobie, czym są taktyki. Dowody to termy, których typy są
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a taktyki służą do konstruowania tych dowodów. Ponieważ
    dowody nie różnią się (prawie) niczym od programów, taktyk można użyć
    także do pisania programów. Taktyki to metaprogramy (napisane w jęzku
    Ltac), które piszą programy (w jęzku termów Coqa, zwanym Gallina).

<div class="paragraph"> </div>

    Wobec tego trybu dowodzenia oraz taktyk możemy używać nie tylko do
    dowodzenia, ale także do definiowania i to właśnie uczyniliśmy w
    powyższym przykładzie. Skonstruowanie termu typu <span class="inlinecode"><span class="id" title="var">big_nat</span></span>,
    czyli parzystej liczby naturalnej, odbyło się w następujący sposób.

<div class="paragraph"> </div>

    Naszym celem jest początkowo <span class="inlinecode"><span class="id" title="var">big_nat</span></span>, czyli typ, którego
    element chcemy skonstrować. Używamy konstruktora <span class="inlinecode"><span class="id" title="var">exist</span></span>, który
    w naszym przypadku jest typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode">100</span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">big_nat</span></span>.
    Wobec tego <span class="inlinecode"><span class="id" title="var">exist</span></span> <span class="inlinecode">101</span> jest typu <span class="inlinecode">100</span> <span class="inlinecode">&lt;=</span> <span class="inlinecode">101</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">big_nat</span></span>, a jego
    zaaplikowanie skutkować będzie zamianą naszego celu na <span class="inlinecode">100</span> <span class="inlinecode">&lt;=</span> <span class="inlinecode">101</span>.
    Następnie dowodzimy tego faktu, co kończy proces definiowania. 
<div class="paragraph"> </div>

<a id="lab488"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj predykat <span class="inlinecode"><span class="id" title="var">sorted</span></span>, który jest spełniony, gdy jego argument
    jest listą posortowaną. Następnie zdefiniuj typ list liczb naturalnych
    posortowanych według relacji <span class="inlinecode">&lt;=</span> i skonstruuj term tego typu
    odpowiadający liście <span class="inlinecode">[42;</span> <span class="inlinecode">666;</span> <span class="inlinecode">1337]</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">sigma</span>.<br/>
</div>
