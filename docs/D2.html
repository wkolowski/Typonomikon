<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
</head>
<h1 class="libtitle">D2: Rekursja i indukcja</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W poprzednim rozdziale dość dogłębnie zapoznaliśmy się z mechanizmem
    definiowania induktywnych typów i rodzin typów. Nauczyliśmy się też
    definiować funkcje operujące na ich elementach za pomocą dopasowania
    do wzorca oraz rekursji.

<div class="paragraph"> </div>

    Indukcja i rekursja są ze sobą bardzo ściśle powiązane. Obie opierają
    się na autoreferencji, czyli odnoszeniu się do samego siebie:
<ul class="doclist">
<li> liczba naturalna to zero lub następnik liczby naturalnej

</li>
<li> długość listy złożonej z głowy i ogona to jeden plus długość ogona 
</li>
</ul>

<div class="paragraph"> </div>

 Można użyć nawet mocniejszego stwierdzenia: indukcja i rekursja są
    dokładnie tym samym zjawiskiem. Skoro tak, dlaczego używamy na jego
    opisanie dwóch różnych słów? Cóż, jest to zaszłość historyczna, jak
    wiele innych, które napotkaliśmy. Rozróżniamy zdania i typy/specyfikacje,
    relacje i rodziny typów, dowody i termy/programy etc., choć te pierwsze
    są specjalnymi przypadkami tych drugich. Podobnie indukcja pojawiła się
    po raz pierwszy jako technika dowodzenia faktów o liczbach naturalnych,
    zaś rekursja jako technika pisania programów.

<div class="paragraph"> </div>

    Dla jasności, terminów tych będziemy używać w następujący sposób:
<ul class="doclist">
<li> indukcja będzie oznaczać metodę definiowania typów oraz
      metodę dowodzenia

</li>
<li> rekursja będzie oznaczać metodę definiowania funkcji 
</li>
</ul>

<div class="paragraph"> </div>

 W tym rozdziale zbadamy dokładniej rekursję: poznamy różne jej rodzaje,
    zobaczymy w jaki sposób za jej pomocą można zrobić własne niestandardowe
    reguły indukcyjne, poznamy rekursję (i indukcję) dobrze ufundowaną oraz
    zobaczymy, w jaki sposób połączyć indukcję i rekursję, by móc dowodzić
    poprawności pisanych przez nas funkcji wciśnięciem jednego przycisku
    (no, prawie).

<div class="paragraph"> </div>

    Zanim jednak to nastąpi, rzućmy okiem na rekursję z dwóch odmiennych
    perspektyw. 
<div class="paragraph"> </div>

<a id="lab337"></a><h1 class="section">Rekursja jako najlepszość</h1>

<div class="paragraph"> </div>

 Znamy już podstawowe typy induktywne, jak liczby naturalne oraz
    listy elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Wiemy też, że ich induktywność objawia
    się głównie w tym, że możemy definiować funkcje przez rekursję
    strukturalną po argumentach tych typów oraz dowodzić przez indukcję.

<div class="paragraph"> </div>

    W takim podejściu indukcja i sama induktywność typów induktywnych
    wydają się być czymś w rodzaju domina - wystarczy popchnąć pierwsze
    kilka kostek (przypadki bazowe) i zapewnić, że pozostałe kostki są
    dobrze ułożone (przypadki rekurencyjne), aby zainicjować reakcję
    łańcuchową, która będzie przewracać kostki w nieskończoność.

<div class="paragraph"> </div>

    Nie jest to jednak jedyny sposób patrzenia na typy induktywne. W tym
    podrozdziale spróbuję przedstawić inny sposób patrzenia, w którym typ
    induktywny to najlepszy typ do robienia termów o pewnym kształcie, a
    rekursja to zmiana kształtu z lepszego na gorszy, ale bardziej
    użyteczny.

<div class="paragraph"> </div>

    Żeby móc patrzeć z tej perspektywy musimy najpierw ustalić, czym
    jest kształt. Uwaga: "kształt" nie jest pojęciem technicznym i nie
    ma ścisłej definicji - używam tego słowa, żeby ułatwić pracę twojej
    wyobraźni.

<div class="paragraph"> </div>

    Czym jest kształt termu? Najprościej rzecz ujmując każdy term jest
    drzewkiem, którego korzeniem jest jakiś konstrukt językowy (stała,
    konstruktor, uprzednio zdefiniowana funkcja, dopasowanie do wzorca,
    <span class="inlinecode"><span class="id" title="keyword">let</span></span>, lub cokolwiek innego), a jego poddrzewa to argumenty tego
    konstruktu.

<div class="paragraph"> </div>

    Dla przykładu, termy typu <span class="inlinecode"><span class="id" title="var">nat</span></span> mogą mieć takie kształty:
<ul class="doclist">
<li> <span class="inlinecode">0</span> - stała

</li>
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0))</span> - konstruktor

</li>
<li> <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">0</span> <span class="inlinecode">5</span>, <span class="inlinecode"><span class="id" title="var">mult</span></span> <span class="inlinecode">0</span> <span class="inlinecode">5</span> - uprzednio zdefiniowana funkcja

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">42</span> - <span class="inlinecode"><span class="id" title="keyword">if</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">666</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">123</span> - dopasowanie do wzorca

</li>
<li> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">[<span class="id" title="var">true</span>;</span> <span class="inlinecode"><span class="id" title="var">false</span>]</span> - uprzednio zdefiniowana funkcja

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode">16</span> - <span class="inlinecode"><span class="id" title="keyword">let</span></span>

</li>
<li> ... i wiele, wiele innych!

</li>
</ul>

<div class="paragraph"> </div>

    Tak wiele różnych sposobów robienia termów to niesamowite bogactwo,
    więc żeby zgodnie z przysłowiem od tego przybytku nie rozbolała nas
    głowa, musimy pomyśleć o nich w nieco bardziej jednorodny sposób.
    Rozwiązanie jest na szczęście bajecznie proste: zauważ, że wszystkie
    powyższe konstrukty językowe można po prostu zawinąć w funkcję, która
    bierze pewną liczbę argumentów (być może zero) i zwraca coś typu
    <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    To jednak nie w pełni mityguje przyszły-niedoszły ból głowy. O ile
    mamy teraz jednorodny sposób myślenia o kształtach termów, to i tak
    kształtów tych mogą być olbrzymie ilości. Z tego powodu dokonamy
    samoograniczenia i zamiast o wszystkich możliwych kształtach termów
    będziemy wybiórczo skupiać naszą uwagę tylko na tych kształtach,
    które akurat będą nas interesować.

<div class="paragraph"> </div>

    Dla przykładu, możemy interesować się termami typu <span class="inlinecode"><span class="id" title="var">nat</span></span> zrobionymi
    wyłącznie za pomocą:
<ul class="doclist">
<li> konstruktorów <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">S</span></span>

</li>
<li> konstruktora <span class="inlinecode">0</span>, stałej <span class="inlinecode">1</span> oraz funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">2</span>

</li>
<li> funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> i stałych <span class="inlinecode">5</span> oraz <span class="inlinecode">42</span>

</li>
<li> funkcji <span class="inlinecode"><span class="id" title="var">mult</span></span> i stałej <span class="inlinecode">1</span>

</li>
<li> funkcji <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab338"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Narysuj jakieś nietrywialne termy typu <span class="inlinecode"><span class="id" title="var">nat</span></span> o takich kształtach. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab339"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Liczbę <span class="inlinecode"><span class="id" title="var">n</span></span> da się wyrazić za pomocą termu <span class="inlinecode"><span class="id" title="var">t</span></span>, jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span> oblicza
    się do <span class="inlinecode"><span class="id" title="var">n</span></span>, tzn. komenda <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> daje w wyniku <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Pytanie: termy o których z powyższych kształtów mogą wyrazić
    wszystkie liczby naturalne? 
<div class="paragraph"> </div>

<a id="lab340"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Liczba <span class="inlinecode"><span class="id" title="var">n</span></span> ma unikalną reprezentację za pomocą termów o danym
    kształcie, gdy jest tylko jeden term <span class="inlinecode"><span class="id" title="var">t</span></span>, który reprezentuje <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Pytanie: które z powyższych sposobów unikalnie reprezentują
    wszystkie liczby naturalne? 
<div class="paragraph"> </div>

 Sporo już osiągnęliśmy w wyklarowywaniu pojęcia kształtu, ale
    zatrzymajmy się na chwilę i zastanówmy się, czy jest ono zgodne
    z naszymi intuicjami.

<div class="paragraph"> </div>

    Okazuje się, że otóż nie do końca, bo w naszej obecnej formulacji
    kształty <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">plus</span>)</span> oraz <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">mult</span>)</span> są różne, podczas gdy obrazki
    (narysuj je!) jasno pokazują nam, że np. <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">0</span> <span class="inlinecode">(<span class="id" title="var">plus</span></span> <span class="inlinecode">0</span> <span class="inlinecode">0)</span> oraz
    <span class="inlinecode"><span class="id" title="var">mult</span></span> <span class="inlinecode">1</span> <span class="inlinecode">(<span class="id" title="var">mult</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1)</span> wyglądają bardzo podobnie, tylko nazwy są różne.

<div class="paragraph"> </div>

    Dlatego też modyfikujemy nasze pojęcie kształtu - teraz kształtem
    zamiast stałych i funkcji, jak <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">plus</span></span>, nazywać będziemy typy
    tych stałych i funkcji. Tak więc kształtem termów zrobionych z <span class="inlinecode">0</span>
    i <span class="inlinecode"><span class="id" title="var">plus</span></span> będzie <span class="inlinecode"><span class="id" title="var">nat</span></span> (bo <span class="inlinecode">0</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>) i <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> (bo
    <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>). Teraz jest już jasne, że <span class="inlinecode">1</span> i <span class="inlinecode"><span class="id" title="var">mult</span></span>
    dają dokładnie ten sam kształt, bo typem <span class="inlinecode">1</span> jest <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaś typem
    <span class="inlinecode"><span class="id" title="var">mult</span></span> jest <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    Zauważmy, że można nasze pojęcie kształtu jeszcze troszkę uprościć:
<ul class="doclist">
<li> po pierwsze, każdą stałą można traktować jako funkcję biorącą
      argument typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, np. możemy <span class="inlinecode">0</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> reprezentować za pomocą
      funkcji <span class="inlinecode"><span class="id" title="var">Z</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> zdefiniowanej jako
      <span class="inlinecode"><span class="id" title="var">Z</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">0</span>

</li>
<li> po drugie, funkcje biorące wiele argumentów możemy reprezentować za
      pomocą funkcji biorących jeden argument, np.
      <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> możemy reprezentować za pomocą
      <span class="inlinecode"><span class="id" title="var">plus'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, który jest zdefiniowany jako
      <span class="inlinecode"><span class="id" title="var">plus'</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">'(<span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>

</li>
<li> po trzecie, ponieważ kodziedzina wszystkich funkcji jest taka
      sama (w naszym przypadku <span class="inlinecode"><span class="id" title="var">nat</span></span>), możemy połączyć wiele funkcji w
      jedną, np. <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">plus</span></span> możemy razem reprezentować jako
      <span class="inlinecode"><span class="id" title="var">Zplus</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, zdefiniowaną jako
      <span class="inlinecode"><span class="id" title="var">Zplus</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">0</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">inr</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Dzięki tym uproszczeniom (albo utrudnieniom, zależy kogo spytacie)
    możemy teraz jako kształt traktować nie funkcje albo same ich typy,
    lecz tylko jeden typ, który jest dziedziną takiej połączonej funkcji.
    Tak więc zarówno <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">plus</span>)</span> jak i <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">mult</span>)</span> są kształtu
    <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Ma to sporo sensu: drzewa reprezentujące te termy
    są albo liściem (reprezentowanym przez <span class="inlinecode"><span class="id" title="var">unit</span></span>), albo węzłem, który
    rozgałęzia się na dwa poddrzewa (reprezentowanym przez <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>).

<div class="paragraph"> </div>

    Ale to jeszcze nie wszystko. Przecież <span class="inlinecode"><span class="id" title="var">nat</span></span> to nie jedyny typ, w
    którym można robić termy o kształcie <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Jeżeli
    przyjrzymy się, jak wyglądają termy zrobione za pomocą (<span class="inlinecode"><span class="id" title="var">true</span>,</span> <span class="inlinecode"><span class="id" title="var">andb</span></span>)
    albo <span class="inlinecode">(<span class="id" title="var">false</span>,</span> <span class="inlinecode"><span class="id" title="var">orb</span>)</span>, to okaże się, że... mają one dokładnie ten sam
    kształt, mimo że według naszej definicji ich kształt to
    <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, czyli niby coś innego.

<div class="paragraph"> </div>

    Ostatnim stadium ewolucji naszego pojęcia kształtu jest taki oto
    zestaw definicji:
<ul class="doclist">
<li> kształt to funkcja <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>

</li>
<li> realizacją kształtu <span class="inlinecode"><span class="id" title="var">F</span></span> jest typ <span class="inlinecode"><span class="id" title="var">X</span></span> oraz funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Widzimy teraz, że <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">plus</span>)</span>, <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">mult</span>)</span>, <span class="inlinecode">(<span class="id" title="var">true</span>,</span> <span class="inlinecode"><span class="id" title="var">andb</span>)</span> oraz
    <span class="inlinecode">(<span class="id" title="var">false</span>,</span> <span class="inlinecode"><span class="id" title="var">orb</span>)</span> nie są kształtami, lecz realizacjami kształtu
    <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">X</span></span>.

<div class="paragraph"> </div>

    Pora powoli zmierzać ku konkluzji. Na początku powiedzieliśmy, że
    typ induktywny to najlepszy typ do robienia termów o pewnym kształcie.
    Jakim kształcie, zapytasz pewnie, i jak objawia się owa najlepszość?
    Czas się tego dowiedzieć.

<div class="paragraph"> </div>

    Definiując typ induktywny podajemy jego konstruktory, a całą resztę,
    czyli możliwość definiowania przez dopasowanie do wzorca i rekursję,
    reguły eliminacji etc. dostajemy za darmo. Nie dziwota więc, że to
    właśnie konstruktory są realizacją kształtu, którego dany typ jest
    najlepszym przykładem.

<div class="paragraph"> </div>

    Napiszmy to jeszcze raz, dla jasności: typ induktywny to najlepszy
    sposób robienia termów o kształcie realizowanym przez jego
    konstruktory.

<div class="paragraph"> </div>

    W naszym <span class="inlinecode"><span class="id" title="var">nat</span></span>owym przykładzie oznacza to, że <span class="inlinecode"><span class="id" title="var">nat</span></span> jest najlepszym
    sposobem robienia termów o kształcie <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>, czyli
    termów w kształcie "sznurków" (konstruktor <span class="inlinecode"><span class="id" title="var">S</span></span> to taki supełek na
    sznurku, a <span class="inlinecode">0</span> reprezentuje koniec sznurka). Są też inne realizacje
    tego sznurkowego kształtu, jak np. stała <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> i funkcja
    <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">8</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> albo stała <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> i funkcja
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, albo nawet zdanie <span class="inlinecode"><span class="id" title="var">False</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> oraz
    negacja <span class="inlinecode"><span class="id" title="var">not</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, ale żadna z nich nie jest najlepsza.

<div class="paragraph"> </div>

    Jak objawia się najlepszość typu induktywnego? Ano, dwojako:
<ul class="doclist">
<li> po pierwsze, objawia się w postaci rekursora, który bierze jako
      argument docelową realizację danego kształtu i przerabia term
      typu induktywnego, podmieniając najlepszą realizację na docelową

</li>
<li> po drugie, rekursor jest unikalny, czyli powyższa podmiana
      realizacji odbywa się w jedyny słuszny sposób

</li>
</ul>

<div class="paragraph"> </div>

    Żeby nie być gołosłownym, zobaczmy przykłady: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_rec'</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">z</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">s</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">X</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">s</span> (<span class="id" title="var">nat_rec'</span> <span class="id" title="var">z</span> <span class="id" title="var">s</span> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Tak wygląda rekursor dla liczb naturalnych. Widzimy, że "zmiana
    realizacji" termu o danym kształcie intuicyjnie polega na tym, że
    bierzemy term i zamieniamy <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">z</span></span>, a <span class="inlinecode"><span class="id" title="var">S</span></span> na <span class="inlinecode"><span class="id" title="var">s</span></span>, czyli dla
    przykładu liczba <span class="inlinecode">4</span> (czyli <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span>) zostanie zamieniona
    na <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">z</span>)))</span>. Jeszcze konkretniejszy przykład:
    <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">negb</span></span> zamieni liczbę <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span> w
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)))</span>. Oczywiście term ten następnie
    oblicza się do <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a id="lab341"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Mamy <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a zatem zmiana realizacji
    sznurka z <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">S</span>)</span> na <span class="inlinecode">(<span class="id" title="var">true</span>,</span> <span class="inlinecode"><span class="id" title="var">negb</span>)</span> odpowiada sprawdzeniu jakiejś
    właściwości liczb naturalnych. Jakiej?

<div class="paragraph"> </div>

    Pisząc wprost: zdefiniuj bezpośrednio przez rekursję taką funkcję
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, że <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    (oczywiście musisz udowodnić, że wszystko się zgadza). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Uwaga: Coq domyślnie generuje dla typu "rekursor", ale ma on na
    myśli coś innego, niż my: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_rec</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat_rec&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Set,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coqowe <span class="inlinecode"><span class="id" title="var">nat_rec</span></span> to w zasadzie to samo, co <span class="inlinecode"><span class="id" title="var">nat_ind</span></span>, czyli reguła
    indukcji, tyle że kodziedziną motywu nie jest <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
    (możesz myśleć, że <span class="inlinecode"><span class="id" title="keyword">Set</span></span> to to samo co <span class="inlinecode"><span class="id" title="keyword">Type</span></span>).

<div class="paragraph"> </div>

    Podobieństwo naszego <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> oraz reguły indukcji nie jest
    przypadkowe - myślenie o typach induktywnych w przedstawiony wyżej
    sposób jest najlepszym sposobem na spamiętanie wszystkich możliwych
    reguł rekursji, indukcji i tympodobnych. A robi się to tak (naszym
    przykładem tym razem będzie typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).

<div class="paragraph"> </div>

    Krok pierwszy: każda lista to albo <span class="inlinecode"><span class="id" title="var">nil</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> albo
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> zaaplikowany do głowy <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> i
    ogona <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Krok drugi: skoro tak, to <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest najlepszym sposobem na
    robienie termów w kształcie <span class="inlinecode">(<span class="id" title="var">nil</span>,</span> <span class="inlinecode"><span class="id" title="var">cons</span>)</span>.

<div class="paragraph"> </div>

    Krok trzeci: wobec tego mamy (a raczej musimy sobie zrobić)
    rekursor <span class="inlinecode"><span class="id" title="var">list_rec'</span></span>, który, gdy damy mu inną realizację kształtu
    <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">X</span></span>, to podmieni on <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span>y w
    dowolnej liście <span class="inlinecode"><span class="id" title="var">l</span></span> na tą inną realizację. Jego typ wygląda tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">list_rec'_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)        <span class="comment">(*&nbsp;parametr&nbsp;<span class="inlinecode"><span class="id" title="var">list</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)        <span class="comment">(*&nbsp;inna&nbsp;realizacja&nbsp;kształtu&nbsp;-&nbsp;typ&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">P</span>)           <span class="comment">(*&nbsp;inna&nbsp;realizacja&nbsp;kształtu&nbsp;-&nbsp;<span class="inlinecode"><span class="id" title="var">nil</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) <span class="comment">(*&nbsp;inna&nbsp;realizacja&nbsp;kształtu&nbsp;-&nbsp;<span class="inlinecode"><span class="id" title="var">cons</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),     <span class="comment">(*&nbsp;lista,&nbsp;w&nbsp;której&nbsp;chcemy&nbsp;zrobić&nbsp;podmianę&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span>. <span class="comment">(*&nbsp;wynik&nbsp;podmiany&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Krócej można ten typ zapisać tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">list_rec'_type'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">P</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">list_rec'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">c</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">n</span> <span class="comment">(*&nbsp;podmieniamy&nbsp;<span class="inlinecode"><span class="id" title="var">nil</span></span>&nbsp;na&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">c</span> <span class="id" title="var">h</span> (<span class="id" title="var">list_rec'</span> <span class="id" title="var">n</span> <span class="id" title="var">c</span> <span class="id" title="var">t</span>) <span class="comment">(*&nbsp;...&nbsp;a&nbsp;<span class="inlinecode"><span class="id" title="var">cons</span></span>&nbsp;na&nbsp;<span class="inlinecode"><span class="id" title="var">c</span></span>&nbsp;*)</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Krok czwarty: żeby uzyskać regułę indukcji, bierzemy rekursor i
    zamieniamy <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> na <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Żeby uzyskać
    najbardziej ogólną regułę eliminacji, używamy <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">list_ind'_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">P</span> <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>

<br/>
</div>

<div class="doc">
Oczywiście musimy też dostosować typy argumentów. Może to prowadzić
    do pojawienia się nowych argumentów. <span class="inlinecode"><span class="id" title="var">c</span></span> w rekursorze miało typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Pierwszy argument typu <span class="inlinecode"><span class="id" title="var">A</span></span> musimy nazwać <span class="inlinecode"><span class="id" title="var">h</span></span>, żeby
    móc go potem użyć. Ostatnie <span class="inlinecode"><span class="id" title="var">P</span></span> to konkluzja, która musi być postaci
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>)</span>, ale <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> nigdzie nie ma, więc je dodajemy.
    Pierwsze <span class="inlinecode"><span class="id" title="var">P</span></span> zmienia się w hipotezę indukcyjną <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. 
<div class="paragraph"> </div>

 Krok piąty: definicja reguły indukcji jest prawie taka sama jak
    poprzednio (musimy uwzględnić pojawienie się <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jako
    argumentu w <span class="inlinecode"><span class="id" title="var">c</span></span>. Poza tym drobnym detalem zmieniają się tylko
    typy: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">list_ind'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">P</span> <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">P</span> <span class="id" title="var">l</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">c</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> (<span class="id" title="var">list_ind'</span> <span class="id" title="var">n</span> <span class="id" title="var">c</span> <span class="id" title="var">t</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Włala, mamy regułę indukcji.

<div class="paragraph"> </div>

    Na sam koniec wypadałoby jeszcze opisać drobne detale dotyczące
    najlepszości. Czy skoro <span class="inlinecode"><span class="id" title="var">nat</span></span> jest najlepszym typem do robienia
    termów w kształcie sznurków, to znaczy, że inne realizacje tego
    kształtu są gorsze? I w jaki sposób objawia się ich gorszość?

<div class="paragraph"> </div>

    Odpowiedź na pierwsze pytanie jest skomplikowańsza niż bym chciał:
    <span class="inlinecode"><span class="id" title="var">nat</span></span> jest najlepsze, ale inne typy też mogą być najlepsze.
    Rozważmy poniższy typ: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Z'</span> : <span class="id" title="var">nat'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S'</span> : <span class="id" title="var">nat'</span> -&gt; <span class="id" title="var">nat'</span>.<br/>

<br/>
</div>

<div class="doc">
Jako, że <span class="inlinecode"><span class="id" title="var">nat'</span></span> jest typem induktywnym, to jest najlepszym sposobem
    robienia termów w kształcie <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>. Ale jak to?
    Przecież najlepsze dla tego kształtu jest <span class="inlinecode"><span class="id" title="var">nat</span></span>! Tak, to prawda.
    Czy zatem <span class="inlinecode"><span class="id" title="var">nat'</span></span> jest gorsze? Nie: oba te typy, <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">nat'</span></span>,
    są najlepsze.

<div class="paragraph"> </div>

    Wynika stąd ciekawa konkluzja: <span class="inlinecode"><span class="id" title="var">nat'</span></span> to w zasadzie to samo co
    <span class="inlinecode"><span class="id" title="var">nat</span></span>, tylko inaczej nazwane. Fakt ten łatwo jest udowodnić:
    mając <span class="inlinecode"><span class="id" title="var">nat</span></span>owy sznurek możemy za pomocą <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> przerobić
    go na <span class="inlinecode"><span class="id" title="var">nat'</span></span>owy sznurek. Podobnie <span class="inlinecode"><span class="id" title="var">nat'</span></span>owy sznurek można
    za pomocą <span class="inlinecode"><span class="id" title="var">nat'_rec'</span></span> przerobić na <span class="inlinecode"><span class="id" title="var">nat</span></span>owy sznurek. Widać na
    oko, że obie te funkcje są swoimi odwrotnościami, a zatem typy
    <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">nat'</span></span> są izomorficzne, czyli mają takie same elementy
    i takie same właściwości. 
<div class="paragraph"> </div>

<a id="lab342"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat'</span></span> i <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat'</span></span>,
    które spełniają
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat'</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Nie musisz w tym celu używać
    <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> ani <span class="inlinecode"><span class="id" title="var">nat'_rec'</span></span> (no chyba, że chcesz). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Drugie pytanie brzmiało: w czym objawia się brak najlepszości innych
    realizacji danego kształtu? Odpowiedź jest prosta: skoro najlepszość
    to unikalny rekursor, to brak najlepszości oznacza brak unikalnego
    rekursora. Przeżyjmy to na przykładzie:

<div class="paragraph"> </div>

    Używając rekursora dla <span class="inlinecode"><span class="id" title="var">nat</span></span> możemy podmienić <span class="inlinecode"><span class="id" title="var">S</span></span> na negację, a
    <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">false</span></span>, i otrzymać dzięki temu funkcję sprawdzającą, czy
    długość sznurka (czyli liczby naturalnej) jest nieparzysta. Czy
    dla innych realizacji tego samego kształtu też możemy tak zrobić?

<div class="paragraph"> </div>

    Nie zawsze. Rozważmy typ <span class="inlinecode"><span class="id" title="var">unit</span></span> wraz ze stałą <span class="inlinecode"><span class="id" title="var">tt</span></span> i funkcją
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">tt</span></span>, które realizują ten sam kształt co <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">S</span></span>. Zauważmy, że <span class="inlinecode"><span class="id" title="var">tt</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">tt</span></span>, a zatem różne sznurki
    obliczają się do tej samej wartości. Jest to sytuacja zgoła
    odmienna od <span class="inlinecode"><span class="id" title="var">nat</span></span>owej - różne ilości <span class="inlinecode"><span class="id" title="var">S</span></span>ów dają różne liczby
    naturalne.

<div class="paragraph"> </div>

    Gdybyśmy mieli dla tej realizacji rekursor podmieniający <span class="inlinecode"><span class="id" title="var">f</span></span> na
    jakąś funkcję <span class="inlinecode"><span class="id" title="var">g</span></span>, zaś <span class="inlinecode"><span class="id" title="var">tt</span></span> na stałą <span class="inlinecode"><span class="id" title="var">x</span></span>, to niechybnie doszłoby
    do katastrofy. Dla przykładu, gdybyśmy próbowali tak jak wyżej
    sprawdzić, czy długość sznurka jest nieparzysta, zamieniając <span class="inlinecode"><span class="id" title="var">tt</span></span>
    na <span class="inlinecode"><span class="id" title="var">false</span></span>, zaś <span class="inlinecode"><span class="id" title="var">f</span></span> na <span class="inlinecode"><span class="id" title="var">negb</span></span>, to wynikiem zamiany dla <span class="inlinecode"><span class="id" title="var">tt</span></span> byłoby
    <span class="inlinecode"><span class="id" title="var">false</span></span>, zaś dla <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">tt</span></span> byłoby to <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>. To jednak
    prowadzi do sprzeczności, bo <span class="inlinecode"><span class="id" title="var">tt</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">tt</span></span>. Wyniki podmiany dla
    sznurków obliczających się do równych wartości musza być takie
    same.

<div class="paragraph"> </div>

    Oczywiście <span class="inlinecode"><span class="id" title="var">unit</span></span>, <span class="inlinecode"><span class="id" title="var">tt</span></span> i <span class="inlinecode"><span class="id" title="var">f</span></span> to bardzo patologiczna realizacja
    sznurkowego kształtu. Czy są jakieś mniej patologiczne realizacje,
    które umożliwiają podmiankę, która pozwala sprawdzić nieparzystość
    długości sznurka?

<div class="paragraph"> </div>

    Tak. Przykładem takiej realizacji jest... <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">negb</span></span>
    (a rzeczona podmianka, to w tym przypadku po prostu funkcja
    identycznościowa).

<div class="paragraph"> </div>

    Czy znaczy to, że <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> to najlepsza realizacja
    sznurkowego kształtu? Nie - da się znaleźć całą masę podmianek,
    które <span class="inlinecode"><span class="id" title="var">nat</span></span> umożliwia, a <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> - nie (joł, sprawdź
    to - wcale nie kłamię).

<div class="paragraph"> </div>

    Cóż, to by było na tyle. W ramach pożegnania z tym spojrzeniem na
    typy induktywne napiszę jeszcze tylko, że nie jest ono skuteczne
    zawsze i wszędzie. Działa jedynie dla prostych typów zrobionych
    z enumeracji, rekurencji i parametrów. Żeby myśleć w ten sposób
    np. o indeksowanych rodzinach typów trzeba mieć nieco mocniejszą
    wyobraźnię. 
<div class="paragraph"> </div>

<a id="lab343"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Rozważmy poniższe typy:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">unit</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Dla każdego z nich:
<ul class="doclist">
<li> znajdź kształt, którego jest on najlepszą realizacją

</li>
<li> napisz typ rekursora

</li>
<li> zaimplementuj rekursor

</li>
<li> zaimplementuj bezpośrednio za pomocą rekursora jakąś ciekawą
      funkcję

</li>
<li> z typu rekursora wyprowadź typ reguły indukcji (oczywiście bez
      podglądania za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Print</span></span>... nie myśl też o białym
      niedźwiedziu)

</li>
<li> zaimplementuj regułę indukcji

</li>
<li> spróbuj bezpośrednio użyć reguły indukcji, by udowodnić jakiś
      fakt na temat zaimplementowanej uprzednio za pomocą rekursora
      funkcji 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a id="lab344"></a><h1 class="section">Reguły eliminacji (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab345"></a><h1 class="section">Jak działa taktyka <span class="inlinecode"><span class="id" title="tactic">induction</span></span> (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab346"></a><h1 class="section">Rodzaje rekursji</h1>

<div class="paragraph"> </div>

 Funkcja może w swej definicji odwoływać się do samej siebie na różne
    sposoby. Najważniejszą klasyfikacją jest klasyfikacja ze względu na
    dozwolone argumenty w wywołaniu rekurencyjnym:
<ul class="doclist">
<li> Rekursja strukturalna to taka, w której funkcja wywołuje siebie
      na argumentach będących podtermami argumentów z obecnego wywołania.

</li>
<li> W szczególności rekursja prymitywna to taka, w której funkcja wywołuje
      siebie jedynie na bezpośrednich podtermach argumentu głównego z obecnego
      wywołania.

</li>
<li> Rekursja dobrze ufundowana to taka, w której funkcja wywołuje siebie
      jedynie na argumentach "mniejszych", gdzie o tym, które argumenty są
      mniejsze, a które większe, decyduje pewna relacja dobrze ufundowana.
      Intuicyjnie relacja dobrze ufundowana jest jak drabina: schodząc po
      drabinie w dół kiedyś musimy schodzenie zakończyć. Nie możemy schodzić
      w nieskończoność. 
</li>
</ul>

<div class="paragraph"> </div>

 Mniej ważną klasyfikacją jest klasyfikacja ze względu na... cóż, nie
    wiem jak to ładnie nazwać:
<ul class="doclist">
<li> Rekursja bezpośrednia to taka, w której funkcja f wywołuje siebie
      samą bezpośrednio.

</li>
<li> Rekursja pośrednia to taka, w której funkcja f wywołuje jakąś inną
      funkcję g, która wywołuje f. To, że f nie wywołuje samej
      siebie bezpośrednio nie oznacza wcale, że nie jest rekurencyjna.

</li>
<li> W szczególności, rekursja wzajemna to taka, w której funkcja f
      wywołuje funkcję g, a g wywołuje f.

</li>
<li> Rzecz jasna rekursję pośrednią oraz wzajemną można uogólnić na dowolną
      ilość funkcji. 
</li>
</ul>

<div class="paragraph"> </div>

 Oczywiście powyższe dwie klasyfikacje to tylko wierzchołek góry lodowej,
    której nie ma sensu zdobywać, gdyż naszym celem jest posługiwanie się
    rekursją w praktyce, a nie dzielenie włosa na czworo. Wobec tego
    wszystkie inne rodzaje rekursji (albo nawet wszystkie możliwe rodzaje
    w ogóle) będziemy nazywać rekursją ogólną.

<div class="paragraph"> </div>

    Z rekursją wzajemną zapoznaliśmy się już przy okazji badania indukcji
    wzajemnej w poprzednim rozdziale. W innych funkcyjnych językach
    programowania używa się jej zazwyczaj ze względów estetycznych, by móc
    elegancko i czytelnie pisać kod, ale jak widzieliśmy w Coqu jest ona
    bardzo upierdliwa, więc raczej nie będziemy jej używać. Skupmy się
    zatem na badaniu rekursji strukturalnej, dobrze ufundowanej i ogólnej. 
<div class="paragraph"> </div>

<a id="lab347"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Przypomnij sobie podrozdział o indukcji wzajemnej. Następnie wytłumacz,
    jak przetłumaczyć definicję funkcji za pomocą rekursji wzajemnej na
    definicję, która nie używa rekursji wzajemnej. 
<div class="paragraph"> </div>

<a id="lab348"></a><h1 class="section">Rekursja prymitywna (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Wiemy już, że rekursja ogólna prowadzi do sprzeczności, a jedyną legalną
    formą rekursji jest rekursja prymitywna (i niektóre formy rekursji
    strukturalnej, o czym dowiemy się później). Funkcje rekurencyjne, które
    dotychczas pisaliśmy, były prymitywnie rekurencyjne, więc potrafisz
    już całkiem sprawnie posługiwać się tym rodzajem rekursji. Pozostaje
    nam zatem jedynie zbadać techniczne detale dotyczące sposobu realizacji
    rekursji prymitywnej w Coqu. W tym celu przyjrzyjmy się ponownie
    definicji dodawania: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">plus</span>.<br/>
<span class="comment">(*&nbsp;plus&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;fix&nbsp;plus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;m<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Możemy zaobserwować parę rzeczy. Pierwsza, techniczna sprawa: po
    <span class="inlinecode">=</span> widzimy nieznany nam konstrukt <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. Pozwala on tworzyć
    anonimowe funkcje rekruencyjne, tak jak <span class="inlinecode"><span class="id" title="keyword">fun</span></span> pozwala tworzyć
    anonimowe funkcje nierekurencyjne. Funkcje zdefiniowane komendami 
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> i <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> są w jęzku termów Coqa reprezentowane
    odpowiednio za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span> i <span class="inlinecode"><span class="id" title="keyword">fun</span></span>.

<div class="paragraph"> </div>

    Po drugie: za listą argumentów, a przed zwracanym typem, występuje
    adnotacja <span class="inlinecode">{<span class="id" title="keyword">struct</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>. Wskazuje ona, który z argumentów funkcji
    jest argumentem głównym. Dotychczas gdy definiowaliśmy funkcje
    rekurencyjne nigdy nie musieliśmy jej pisać, bo Coq zawsze domyślał
    się, który argument ma być główny. W poetyckiej polszczyźnie argument
    główny możemy wskazać mówiąc np., że "funkcja plus zdefiniowana jest
    przez rekursję po pierwszym argumencie" albo "funkcja plus zdefinowana
    jest przez rekursję po n".

<div class="paragraph"> </div>

    Czym jest argument główny? Spróbuję wyjasnić to w sposób operacyjny:
<ul class="doclist">
<li> jako argument główny możemy wskazać dowolny argument, którego typ
      jest induktywny

</li>
<li> Coq wymusza na nas, aby argumentem głównym wywołania rekurencyjnego
      był podterm argumentu głównego z obecnego wywołania

</li>
</ul>

<div class="paragraph"> </div>

    Dlaczego taki zabieg chroni nas przed sprzecznością? Przypomnij sobie,
    że termy typów induktywnych muszą być skończone. Parafrazując: są to
    drzewa o skończonej wysokości. Ich podtermy są od nich mniejsze, więc
    w kolejnych wywołaniach rekurencyjnych argument główny będzie malał,
    aż w końcu jego rozmiar skurczy się do zera. Wtedy rekursja zatrzyma
    się, bo nie będzie już żadnych podtermów, na których można by zrobić
    wywołanie rekurencyjne.

<div class="paragraph"> </div>

    Żeby lepiej zrozumieć ten mechanizm, zbadajmy najpierw relację bycia
    podtermem dla typów induktywnych. Relację tę opisują dwie proste zasady:
<ul class="doclist">
<li> po pierwsze, jeżeli dany term został zrobiony jakimś konstruktorem,
      to jego podtermami są rekurencyjne argumenty tego konstruktora.
      Przykład: <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">nil</span></span> podtermem <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>.

</li>
<li> po drugie, jeżeli <span class="inlinecode"><span class="id" title="var">t1</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">t2</span></span>, a <span class="inlinecode"><span class="id" title="var">t2</span></span> podtermem <span class="inlinecode"><span class="id" title="var">t3</span></span>,
      to <span class="inlinecode"><span class="id" title="var">t1</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">t3</span></span> — własność ta nazywa się przechodniością.
      Przykład: <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>, a zatem <span class="inlinecode">0</span> jest podtermem
      <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>. Podobnie <span class="inlinecode"><span class="id" title="var">nil</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">666</span> <span class="inlinecode">(<span class="id" title="var">cons</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="var">nil</span>)</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab349"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj relacje bycia podtermem dla liczb naturalnych i list. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Udowodnij, że przytoczone wyżej przykłady nie są oszustwem.
    Komenda <span class="inlinecode"><span class="id" title="keyword">Goal</span></span> jest wygodna, gdyż używając jej nie musimy
    nadawać twierdzeniu nazwy. Użycie <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> zapisze twierdzenie
    jako <span class="inlinecode"><span class="id" title="var">Unnamed_thm</span></span>, <span class="inlinecode"><span class="id" title="var">Unnamed_thm0</span></span>, <span class="inlinecode"><span class="id" title="var">Unnamed_thm1</span></span> etc. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">subterm_nat</span> 0 (<span class="id" title="var">S</span> 0).<br/>

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">subterm_list</span> <span class="id" title="var">nil</span> (<span class="id" title="var">cons</span> 42 <span class="id" title="var">nil</span>).<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a id="lab350"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że relacje <span class="inlinecode"><span class="id" title="var">subterm_nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">subterm_list</span></span> są antyzwrotne
    i przechodnie. Uwaga: to może być całkiem trudne. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_nat_antirefl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, ~ <span class="id" title="var">subterm_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_nat_trans</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">subterm_nat</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> -&gt; <span class="id" title="var">subterm_nat</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> -&gt; <span class="id" title="var">subterm_nat</span> <span class="id" title="var">a</span> <span class="id" title="var">c</span>.<br/>

<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_list_antirefl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), ~ <span class="id" title="var">subterm_list</span> <span class="id" title="var">l</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_list_trans</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">subterm_list</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> -&gt; <span class="id" title="var">subterm_list</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">subterm_list</span> <span class="id" title="var">l1</span> <span class="id" title="var">l3</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Jak widać, podtermy liczby naturalnej to liczby naturalne, które są od
    niej mniejsze, zaś podtermy listy to jej ogon, ogon ogona i tak dalej.
    Zero i lista pusta nie mają podtermów, gdyż są to przypadki bazowe,
    pochodzące od konstruktorów, które nie mają argumentów rekurencyjnych.

<div class="paragraph"> </div>

    Dla każdego typu induktywnego możemy zdefiniować relację bycia podtermem
    podobną do tych dla liczb naturalnych i list. Zauważmy jednak, że nie
    możemy za jednym zamachem zdefiniować relacji bycia podtermem dla
    wszystkich typów induktywnych, gdyż nie możemy w Coqu powiedzieć czegoś
    w stylu "dla wszystkich typów induktywnych". Możemy powiedzieć jedynie
    "dla wszystkich typów".

<div class="paragraph"> </div>

    Coq nie generuje jednak automatycznie takiej relacji, gdy definiujemy
    nowy typ induktywny. W jaki zatem sposób Coq sprawdza, czy jeden term
    jest podtermem drugiego? Otóż... w sumie, to nie sprawdza. Rzućmy okiem
    na następujący przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">weird</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">unit</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">tt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">weird</span> 0<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja zdaje się być poprawna: <span class="inlinecode">0</span> to przypadek bazowy, a gdy <span class="inlinecode"><span class="id" title="var">n</span></span>
    jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, wywołujemy funkcję rekurencyjnie na argumencie
    <span class="inlinecode">0</span>. <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, a zatem wszystko powinno być dobrze.
    Dostajemy jednak następujący komunikat o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Recursive&nbsp;definition&nbsp;of&nbsp;weird&nbsp;is&nbsp;ill-formed.<br/>
&nbsp;&nbsp;&nbsp;In&nbsp;environment<br/>
&nbsp;&nbsp;&nbsp;weird&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;unit<br/>
&nbsp;&nbsp;&nbsp;n&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n'&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;Recursive&nbsp;call&nbsp;to&nbsp;weird&nbsp;has&nbsp;principal&nbsp;argument&nbsp;equal&nbsp;to&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"0"&nbsp;instead&nbsp;of&nbsp;"n'".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Komunikat ten głosi, że argumentem głównym wywołania rekurencyjnego jest
    <span class="inlinecode">0</span>, podczas gdy powinno być nim <span class="inlinecode"><span class="id" title="var">n'</span></span>. Wynika stąd jasno i wyraźnie, że
    jedynymi legalnymi argumentami w wywołaniu rekurencyjnym są te podtermy
    argumentu głównego, które zostają ujawnione w wyniku dopasowania do
    wzorca. Coq nie jest jednak głupi - jest głupszy, niż ci się wydaje, o
    czym świadczy poniższy przykład. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">fib</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) =&gt; <span class="id" title="var">fib</span> <span class="id" title="var">n'</span> + <span class="id" title="var">fib</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja ta próbuje policzyć n-tą liczbę Fibonacciego:
    https://en.wikipedia.org/wiki/Fibonacci_number, ale
    słabo jej to wychodzi, gdyż dostajemy następujący błąd: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Recursive&nbsp;definition&nbsp;of&nbsp;fib&nbsp;is&nbsp;ill-formed.<br/>
&nbsp;&nbsp;&nbsp;In&nbsp;environment<br/>
&nbsp;&nbsp;&nbsp;fib&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n0&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n'&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;Recursive&nbsp;call&nbsp;to&nbsp;fib&nbsp;has&nbsp;principal&nbsp;argument&nbsp;equal&nbsp;to&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"S&nbsp;n'"&nbsp;instead&nbsp;of&nbsp;one&nbsp;of&nbsp;the&nbsp;following&nbsp;variables:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"n0"&nbsp;"n'".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Mimo, że <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, który pochodzi z dopasowania
    do wzorca, to Coq nie jest w stanie zauważyć tego faktu. W komunikacie
    o błędzie pojawia się za to tajemnicza zmienna <span class="inlinecode"><span class="id" title="var">n0</span></span>, której w naszym
    kodzie nigdzie nie ma. Sposobem na poradzenie sobie z problemem jest
    pokazanie Coqowi palcem, o co nam chodzi: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">fib</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span> <span class="id" title="keyword">as</span> <span class="id" title="var">n''</span>) =&gt; <span class="id" title="var">fib</span> <span class="id" title="var">n'</span> + <span class="id" title="var">fib</span> <span class="id" title="var">n''</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem Coq widzi, że <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, gdyż explicite
    nadaliśmy temu termowi nazwę <span class="inlinecode"><span class="id" title="var">n''</span></span>, używając do tego klauzli <span class="inlinecode"><span class="id" title="keyword">as</span></span>.

<div class="paragraph"> </div>

    Ufff...  udało nam się przebrnąć przez techniczne detale działania
    rekursji strukturalnej. Mogłoby się wydawać, że jest ona mechanizmem
    bardzo upośledzonym, ale z doświadczenia wiesz już, że w praktyce
    omówione wyżej problemy występują raczej rzadko.

<div class="paragraph"> </div>

    Mogłoby się też wydawać, że skoro wywołania rekurencyjne możemy robić
    tylko na bezpośrednich podtermach dopasowanych we wzorcu, to nie da się
    zdefiniować prawie żadnej ciekawej funkcji. Jak zobaczymy w kolejnych
    podrozdziałach, wcale tak nie jest. Dzięki pewnej sztuczce za pomocą
    rekursji strukturalnej można wyrazić rekursję dobrze ufundowaną, która
    na pierwszy rzut oka jest dużo potężniejsza i daje nam wiele możliwości
    definiowania różnych ciekawych funkcji. 
<div class="paragraph"> </div>

<a id="lab351"></a><h4 class="section">Ćwiczenie (dzielenie)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">div</span></span>, która implementuje dzielenie całkowitoliczbowe.
    Żeby uniknąć problemów z dzieleniem przez <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> będziemy
    interpretować jako <span class="inlinecode"><span class="id" title="var">n</span></span> podzielone przez <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czyli np. <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">0</span>
    to n/1, <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">1</span> to n/2 etc. Uwaga: to ćwiczenie pojawia się właśnie
    w tym miejscu nieprzypadkowo. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab352"></a><h1 class="section">Rekursja monotoniczna</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">X3</span>.<br/>

<br/>
</div>

<div class="doc">
Czas na omówienie pewnej ciekawej, ale średnio użytecznej formy rekursji
    (z pamięci nie jestem w stanie przytoczyć więcej niż dwóch sztampowych
    przykładów jej użycia), a jest nią rekursja monotoniczna (zwana też
    czasem rekursją zagnieżdżoną, ale nie będziemy używać tej nazwy, gdyż
    dotychczas używaliśmy jej na określenie rekursji, w której arguemntem
    wywołania rekurencyjnego jest wynik innego wywołania rekurencyjnego).

<div class="paragraph"> </div>

    Cóż to za zwierzątko, rekursja monotoniczna? Żeby się tego dowiedzieć,
    przypomnijmy sobie najpierw, jak technicznie w Coqu zrealizowana jest
    rekursja strukturalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Tak oto definicja funkcji plus, lecz zapisana nieco inaczej, niż gdy
    widzieliśmy ją ostatnim razem. Tym razem prezentujemy ją jako funkcję
    biorącą jeden argument typu <span class="inlinecode"><span class="id" title="var">nat</span></span> i zwracającą funkcję z typu <span class="inlinecode"><span class="id" title="var">nat</span></span> w
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">plus'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Ale komenda <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> jest jedynie cukrem syntaktycznym - funkcję <span class="inlinecode"><span class="id" title="var">plus</span></span>
    możemy równie dobrze zdefiniować bez niej, posługując się jedynie komendą
    <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, a wyrażeniem, które nam to umożliwia, jest <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. <span class="inlinecode"><span class="id" title="keyword">fix</span></span>
    działa podobnie jak <span class="inlinecode"><span class="id" title="keyword">fun</span></span>, ale pozwala dodatkowo nadać definiowanej przez
    siebie funkcji nazwę, dzięki czemu możemy robić wywołania rekurencyjne.

<div class="paragraph"> </div>

    Czym więc jest rekursja monotoniczna? Z rekursją monotoniczną mamy do
    czynienia, gdy za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a (czyli przez rekursję) definiujemy
    funkcję, która zwraca inną funkcję, i ta zwracana funkcja także jest
    zdefiniowana za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a (czyli przez rekursję). Oczywiście to
    tylko pierwszy krok - wynikowa funkcja również może zwracać funkcję,
    która jest zdefiniowana za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a i tak dalej.

<div class="paragraph"> </div>

    Widać zatem jak na dłoni, że <span class="inlinecode"><span class="id" title="var">plus</span></span> ani <span class="inlinecode"><span class="id" title="var">plus'</span></span> nie są przykładami
    rekursji monotonicznej. Wprawdzie definiują one za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a
    (lub komendy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>) funkcję, która zwraca inną funkcję, ale ta
    zwracana funkcja nie jest zdefiniowana za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a, lecz za
    pomocą <span class="inlinecode"><span class="id" title="keyword">fun</span></span>, a więc nie jest rekurencyjna.

<div class="paragraph"> </div>

    Podsumowując: rekursja jest monotoniczna, jeżeli w definicji
    funkcji pojawiają się co najmniej dwa wystąpienia <span class="inlinecode"><span class="id" title="keyword">fix</span></span>, jedno
    wewnątrz drugiego (przy czym rzecz jasna <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> też liczy
    się jako <span class="inlinecode"><span class="id" title="keyword">fix</span></span>).

<div class="paragraph"> </div>

    No to skoro już wiemy, czas zobaczyć przykład jakiejś funkcji, która
    jest zdefiniowana przez rekursję monotoniczną. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ack</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">m</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cannot&nbsp;guess&nbsp;decreasing&nbsp;argument&nbsp;of&nbsp;fix.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa funkcja zwana jest funkcją Ackermanna, gdyż wymyślił ją...
    zgadnij kto. Jest ona całkiem sławna, choć z zupełnie innych powodów
    niż te, dla których my się jej przyglądamy. Nie oblicza ona niczego
    specjalnie użytecznego - jej wynikami są po prostu bardzo duże liczby.
    Jeżeli nie wierzysz, spróbuj policzyć ręcznie <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">4</span> <span class="inlinecode">2</span> - zdziwisz się.

<div class="paragraph"> </div>

    Jak widać, Coq nie akceptuje powyższej definicji. Winny temu jest rzecz
    jasna kształt rekursji. Dla <span class="inlinecode"><span class="id" title="var">n</span></span> równego <span class="inlinecode">0</span> zwracamy <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, co jest ok.
    Dla <span class="inlinecode"><span class="id" title="var">n</span></span> postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> równego <span class="inlinecode">0</span> robimy wywołanie rekurencyjne
    na <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode">1</span>, co również jest ok. Jednak jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> odpowednio
    są postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span>, to robimy wywołanie rekurencyjne postaci
    <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">(<span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span>)</span>. W wewnętrznym wywołaniu rekurencyjnym pierwszy
    argument jest taki sam jak obecny. Gdyby argumentem głównym był drugi
    argument, to jest tym bardziej źle, gdyż w zewnętrznym wywołaniu
    rekurencyjnym nie jest nim <span class="inlinecode"><span class="id" title="var">m'</span></span>, lecz <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>. Nie ma się więc
    co dziwić, że Coq nie może zgadnąć, który argument ma być argumentem
    głównym.

<div class="paragraph"> </div>

    Mimo, że Coq nie akceptuje tej definicji, to wydaje się ona być całkiem
    spoko. Żaden z argumentów nie może wprawdzie posłużyć nam za argument
    główny, ale jeżeli rozważymy ich zachowanie jako całość, to okazuje się,
    że w każdym wywołaniu rekurencyjnym mamy dwie możliwości:
<ul class="doclist">
<li> albo pierwszy argument się zmniejsza

</li>
<li> albo pierwszy argument się nie zmienia, ale drugi argument się
      zmniejsza

</li>
</ul>

<div class="paragraph"> </div>

    Możemy z tego wywnioskować, że jeżeli wywołamy <span class="inlinecode"><span class="id" title="var">ack</span></span> na argumentach
    <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span>, to w ogólności najpierw <span class="inlinecode"><span class="id" title="var">m</span></span> będzie się zmniejszał, ale
    ponieważ musi kiedyś spaść do zera, to wtedy <span class="inlinecode"><span class="id" title="var">n</span></span> będzie musiał się
    zmniejszyć. Oczywiście wtedy w kolejnym wywołaniu zaczynamy znowu z
    jakimś <span class="inlinecode"><span class="id" title="var">m</span></span>, które potem się zmniejsza, aż w końcu znowu zmniejszy
    się <span class="inlinecode"><span class="id" title="var">n</span></span> i tak dalej, aż do chwili, gdy <span class="inlinecode"><span class="id" title="var">n</span></span> spadnie do zera. Wtedy
    rekursja musi się skończyć.

<div class="paragraph"> </div>

    Jednym z typowych zastosowań rekursji zagnieżdżonej jest radzenie
    sobie z takimi właśnie przypadkami, w których mamy ciąg argumentów
    i pierwszy maleje, lub pierwszy stoi w miejscu a drugi maleje i tak
    dalej. Zobaczmy więc, jak techniki tej można użyć do zdefiniowania
    funkcji Ackermanna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ack</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">S</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">ack'</span> (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack'</span> <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy przede wszystkim, że nieco zmienia się wygląd typu naszej
    funkcji. Jest on wprawdzie dokładnie taki sam (<span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>),
    ale zapisujemy go inaczej. Robimy to by podkreslić, że wynikiem <span class="inlinecode"><span class="id" title="var">ack</span></span>
    jest funkcja. W przypadku gdy <span class="inlinecode"><span class="id" title="var">n</span></span> jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> zdefiniowana
    jest ona za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a tak, jak wyglądają dwie ostatnie klauzule
    dopasowania z oryginalnej definicji, ale z wywołaniem <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>
    zastąpionym przez <span class="inlinecode"><span class="id" title="var">ack'</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span>. Tak więc funkcja <span class="inlinecode"><span class="id" title="var">ack'</span></span> reprezentuje
    częściową aplikację <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ack</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_big</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m</span> &lt; <span class="id" title="var">ack</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">lt_trans</span> <span class="id" title="keyword">with</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHn'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">ack_eq</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_big'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n1</span> &lt;= <span class="id" title="var">n2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">m1</span> &lt;= <span class="id" title="var">m2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ack</span> <span class="id" title="var">n1</span> <span class="id" title="var">m1</span> &lt;= <span class="id" title="var">ack</span> <span class="id" title="var">n2</span> <span class="id" title="var">m2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHle</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_S</span>, <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ack_eq</span> (<span class="id" title="var">S</span> <span class="id" title="var">n1</span>) (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">ack_big</span> <span class="id" title="var">n1</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n1</span>) <span class="id" title="var">m</span>)). <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">m1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHle</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ack_eq</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) (<span class="id" title="var">S</span> <span class="id" title="var">m1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IHle</span> (<span class="id" title="var">S</span> <span class="id" title="var">m1</span>) (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ack_big</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ack_eq</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)). <span class="id" title="tactic">apply</span> <span class="id" title="var">IHle</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">S</span> <span class="id" title="var">m0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_S</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ack_big</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab353"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">merge</span></span> o typie
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">cmp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>),</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    która scala dwie listy posortowane według porządku wyznaczanego przez
    <span class="inlinecode"><span class="id" title="var">cmp</span></span> w jedną posortowaną listę. Jeżeli któraś z list posortowana nie
    jest, wynik może być dowolny.

<div class="paragraph"> </div>

    Wskazówka: dlaczego niby to ćwiczenie pojawia się w podrozdziale o
    rekursji zagnieżdżonej? 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">merge</span> <span class="id" title="var">leb</span> [1; 4; 6; 9] [2; 3; 5; 8].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">8;</span> <span class="inlinecode">9]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Obie listy są posortowane według <span class="inlinecode"><span class="id" title="var">leb</span></span>, więc wynik też jest. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">merge</span> <span class="id" title="var">leb</span> [5; 3; 1] [4; 9].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">3;</span> <span class="inlinecode">1;</span> <span class="inlinecode">9]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Pierwsza lista nie jest posortowana według <span class="inlinecode"><span class="id" title="var">leb</span></span>, więc wynik jest
    z dupy. 
<div class="paragraph"> </div>

<a id="lab354"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Skoro już udało ci się zdefiniować <span class="inlinecode"><span class="id" title="var">merge</span></span>, to udowodnij jeszcze parę
    lematów, cobyś nie miał za dużo wolnego czasu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span>, <span class="id" title="var">l2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [], <span class="id" title="var">_</span> =&gt; <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, [] =&gt; <span class="id" title="var">l1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>, <span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">h1</span> :: <span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">t1</span> <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">h2</span> :: <span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_nil_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [] <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_nil_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l</span> [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Permutation_merge</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Permutation</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_length</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l1</span> + <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_map</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">map</span> <span class="id" title="var">f</span> (<span class="id" title="var">merge</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">cmp</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)) <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_replicate</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>) (<span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> ++ <span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span> ++ <span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ins</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; [<span class="id" title="var">x</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> <span class="id" title="keyword">then</span> <span class="id" title="var">x</span> :: <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> <span class="id" title="keyword">else</span> <span class="id" title="var">h</span> :: <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [<span class="id" title="var">x</span>] <span class="id" title="var">l</span> = <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l</span> [<span class="id" title="var">x</span>] = <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_all_true</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <span class="id" title="var">l</span> = <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [<span class="id" title="var">x</span>] <span class="id" title="var">l</span> = <span class="id" title="var">x</span> :: <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> [] <span class="id" title="var">l</span> <span class="id" title="var">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> [] <span class="id" title="var">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h1</span> <span class="id" title="var">h2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">r</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> = <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t1</span> (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) <span class="id" title="var">r</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) (<span class="id" title="var">h1</span> :: <span class="id" title="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h1</span> <span class="id" title="var">h2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">r</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> = <span class="id" title="var">false</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) <span class="id" title="var">t2</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_filter</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">p</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">filter</span> <span class="id" title="var">p</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab355"></a><h1 class="section">Rekursja polimorficzna</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Nested</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Nested</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">Epsilon</span> | <span class="id" title="var">Cons</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">Nested</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>)).<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Epsilon</span> {<span class="id" title="var">A</span>}.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Cons</span>    {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Nested'</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Epsilon'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">Nested'</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Nested'</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Nested'</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Nested_ind</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Nested'_ind</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">len</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">Nested</span> <span class="id" title="var">A</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Epsilon</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">_</span> <span class="id" title="var">t</span> =&gt; 1 + <span class="id" title="var">len</span> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Nested</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Seq</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Seq</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">SNil</span> : <span class="id" title="var">Seq</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">SCons</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Seq</span> (<span class="id" title="var">A</span> * <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Seq</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">SNil</span>  {<span class="id" title="var">A</span>}.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">SCons</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">size</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">s</span> : <span class="id" title="var">Seq</span> <span class="id" title="var">A</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">s</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">SNil</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">SCons</span> <span class="id" title="var">_</span> <span class="id" title="var">t</span> =&gt; 1 + 2 * <span class="id" title="var">size</span> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Seq</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Nested2</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Nested</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Singl</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Nested</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nestd</span> : <span class="id" title="var">Nested</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Nested</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Nested2</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab356"></a><h1 class="section">Rząd rżnie głupa, czyli o pierwszym i wyższym rzędzie (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab357"></a><h1 class="section">Rekursja wyższego rzędu (TODO)</h1>

<div class="paragraph"> </div>

 Pozostaje kwestia rekursji wyższego rzędu. Co to takiego? Ano dotychczas
    wszystkie nasze wywołania rekurencyjne były konkretne, czyli zaaplikowane
    do argumentów.

<div class="paragraph"> </div>

    Mogłoby się wydawać, że jest to jedyny możliwy sposób robienia wywołań
    rekurencyjnych, jednak nie jest tak. Wywołania rekurencyjne mogą mieć
    również inną, wyższorzędową postać, a mianowicie - możemy przekazać
    funkcję, którą właśnie definiujemy, jako argument do innej funkcji.

<div class="paragraph"> </div>

    Dlaczego jest to wywołanie rekurencyjne, skoro nie wywołujemy naszej
    funkcji? Ano dlatego, że tamta funkcja, która dostaje naszą jako
    argument, dostaje niejako możliwość robienia wywołań rekurencyjnych.
    W zależności od tego, co robi ta funkcja, wszystko może być ok (np.
    gdy ignoruje ona naszą funkcję i w ogóle jej nie używa) lub śmiertelnie
    niebezpieczne (gdy próbuje zrobić wywołanie rekurencyjne na strukturalnie
    większym argumencie).

<div class="paragraph"> </div>

    Sztoby za dużo nie godoć, bajszpil: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Tree</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Node</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Tree</span></span> to typ drzew niepustych, które mogą mieć dowolną (ale skończoną)
    ilość poddrzew. Spróbujmy zdefiniować funkcję, która zwraca lustrzane
    odbicie drzewa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Guard</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mirror</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">t</span>} : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node</span> <span class="id" title="var">x</span> <span class="id" title="var">ts</span> =&gt; <span class="id" title="var">Node</span> <span class="id" title="var">x</span> (<span class="id" title="var">map</span> <span class="id" title="var">mirror</span> (<span class="id" title="var">rev</span> <span class="id" title="var">ts</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Guard</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Nie jest to zbyt trudne. Rekurencyjnie odbijamy wszystkie poddrzewa za
    pomocą <span class="inlinecode"><span class="id" title="var">map</span></span> <span class="inlinecode"><span class="id" title="var">mirror</span></span>, a następnie odwracamy kolejność poddrzew z użyciem
    <span class="inlinecode"><span class="id" title="var">rev</span></span>. Chociaż poszło gładko, to mamy tu do czynienia z czymś, czego
    wcześniej nie widzieliśmy. Nie ma tu żadnego wywołania rekurencyjnego,
    a mimo to funkcja działa ok. Dlaczego? Właśnie dlatego, że wywołania
    rekurencyjne są robione przez funkcję <span class="inlinecode"><span class="id" title="var">map</span></span>. Mamy więc do czynienia z
    rekursją wyższego rzędu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mirrorG</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Tree</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">mirrorG_0</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">ts</span> <span class="id" title="var">rs</span> : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorsG</span> <span class="id" title="var">ts</span> <span class="id" title="var">rs</span> -&gt; <span class="id" title="var">mirrorG</span> (<span class="id" title="var">Node</span> <span class="id" title="var">x</span> <span class="id" title="var">ts</span>) (<span class="id" title="var">Node</span> <span class="id" title="var">x</span> (<span class="id" title="var">rev</span> <span class="id" title="var">rs</span>))<br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">mirrorsG</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">mirrorsG_nil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorsG</span> [] []<br/>
&nbsp;&nbsp;| <span class="id" title="var">mirrorsG_cons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">t</span> <span class="id" title="var">t'</span> : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) (<span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorG</span> <span class="id" title="var">t</span> <span class="id" title="var">t'</span> -&gt; <span class="id" title="var">mirrorsG</span> <span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorsG</span> (<span class="id" title="var">t</span> :: <span class="id" title="var">ts</span>) (<span class="id" title="var">t'</span> :: <span class="id" title="var">ts'</span>).<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Equality</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mirrorG_correct</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorG</span> <span class="id" title="var">t</span> (<span class="id" title="var">mirror</span> <span class="id" title="var">t</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">IH</span> 2.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">map_rev</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">t</span> <span class="id" title="var">ts</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHts</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">mirror</span> (<span class="id" title="var">Node</span> 0 [<span class="id" title="var">Node</span> 1 [<span class="id" title="var">Node</span> 5 []; <span class="id" title="var">Node</span> 6 []; <span class="id" title="var">Node</span> 7 []]; <span class="id" title="var">Node</span> 2 []; <span class="id" title="var">Node</span> 3 []]).<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">mirror</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mirrorD</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mirrorD'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">ts</span> : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorsD</span> (<span class="id" title="var">rev</span> <span class="id" title="var">ts</span>) -&gt; <span class="id" title="var">mirrorD</span> (<span class="id" title="var">Node</span> <span class="id" title="var">x</span> <span class="id" title="var">ts</span>)<br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">mirrorsD</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mirrorsD_nil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorsD</span> []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mirrorsD_cons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">t</span> : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) (<span class="id" title="var">ts</span> : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorD</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">mirrorsD</span> <span class="id" title="var">ts</span> -&gt; <span class="id" title="var">mirrorsD</span> (<span class="id" title="var">t</span> :: <span class="id" title="var">ts</span>).<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mapG</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mapG_nil</span>  :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mapG</span> <span class="id" title="var">f</span> [] []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">mapG_cons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>) (<span class="id" title="var">la</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">lb</span> : <span class="id" title="var">list</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> -&gt; <span class="id" title="var">mapG</span> <span class="id" title="var">f</span> <span class="id" title="var">la</span> <span class="id" title="var">lb</span> -&gt; <span class="id" title="var">mapG</span> <span class="id" title="var">f</span> (<span class="id" title="var">a</span> :: <span class="id" title="var">la</span>) (<span class="id" title="var">b</span> :: <span class="id" title="var">lb</span>).<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mirrorG2</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Tree</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">mirrorG2'</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> : <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mapG</span> <span class="id" title="var">mirrorG2</span> <span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> -&gt; <span class="id" title="var">mirrorG2</span> (<span class="id" title="var">Node</span> <span class="id" title="var">x</span> <span class="id" title="var">ts</span>) (<span class="id" title="var">Node</span> <span class="id" title="var">x</span> (<span class="id" title="var">rev</span> <span class="id" title="var">ts'</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mirrorG2_correct</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mirrorG2</span> <span class="id" title="var">t</span> (<span class="id" title="var">mirror</span> <span class="id" title="var">t</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">IH</span> 2.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">map_rev</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">t</span> <span class="id" title="var">ts</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHts</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">mirror</span>.<br/>

<br/>
</div>

<div class="doc">
Inny przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Tree'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">forall</span> {<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">B</span> -&gt; <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Node'</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem mamy drzewo, które może mieć naprawdę dowolną ilość poddrzew,
    ale jego poddrzewa są nieuporządkowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mirror'</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>) : <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node'</span> <span class="id" title="var">x</span> <span class="id" title="var">B</span> <span class="id" title="var">ts</span> =&gt; <span class="id" title="var">Node'</span> <span class="id" title="var">x</span> <span class="id" title="var">B</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span> =&gt; <span class="id" title="var">mirror'</span> (<span class="id" title="var">ts</span> <span class="id" title="var">b</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab358"></a><h1 class="section">Rekursja strukturalna (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab359"></a><h1 class="section">Rekursja ogólna</h1>

<div class="paragraph"> </div>

 W Coqu rekursja ogólna nie jest dozwolona. Powód jest banalny: prowadzi
    ona do sprzeczności. W celu zobrazowania spróbujmy zdefiniować za pomocą
    taktyk następującą funkcję rekurencyjną: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">loop</span> (<span class="id" title="var">u</span> : <span class="id" title="var">unit</span>) : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">loop</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy się uważnie definicji funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Mimo, że udało
    nam się ujrzeć znajomy napis "No more subgoals", próba użycia
    komendy <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> kończy się błędem.

<div class="paragraph"> </div>

    Fakt, że konstruujemy funkcję za pomocą taktyk, nie ma tu żadnego
    znaczenia, lecz służy jedynie lepszemu zobrazowaniu, dlaczego rekursja
    ogólna jest grzechem. Dokładnie to samo stałoby się, gdybyśmy próbowali
    zdefiniować <span class="inlinecode"><span class="id" title="var">loop</span></span> ręcznie: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">loop</span> (<span class="id" title="var">u</span> : <span class="id" title="var">unit</span>) : <span class="id" title="var">False</span> := <span class="id" title="var">loop</span> <span class="id" title="var">u</span>.<br/>

<br/>
</div>

<div class="doc">
Gdyby tak się nie stało, możliwe byłoby skonstruowanie dowodu <span class="inlinecode"><span class="id" title="var">False</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">the_universe_explodes</span> : <span class="id" title="var">False</span> := <span class="id" title="var">loop</span> <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
Aby chronić nas przed tą katastrofą, Coq nakłada na rekurencję
    ograniczenie: argument główny wywołania rekurencyjnego musi być
    strukturalnym podtermem argumentu głównego obecnego wywołania.
    Innymi słowy, dozwolona jest jedynie rekursja strukturalna.

<div class="paragraph"> </div>

    To właśnie napisane jest w komunikacie o błędzie, który dostajemy,
    próbując przeforsować powyższe definicje: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Recursive&nbsp;definition&nbsp;of&nbsp;loop&nbsp;is&nbsp;ill-formed.<br/>
&nbsp;&nbsp;&nbsp;In&nbsp;environment<br/>
&nbsp;&nbsp;&nbsp;loop&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;False<br/>
&nbsp;&nbsp;&nbsp;u&nbsp;:&nbsp;unit<br/>
&nbsp;&nbsp;&nbsp;Recursive&nbsp;call&nbsp;to&nbsp;loop&nbsp;has&nbsp;principal&nbsp;argument&nbsp;equal&nbsp;to<br/>
&nbsp;&nbsp;&nbsp;"u"&nbsp;instead&nbsp;of&nbsp;a&nbsp;subterm&nbsp;of&nbsp;"u".<br/>
&nbsp;&nbsp;&nbsp;Recursive&nbsp;definition&nbsp;is:&nbsp;"fun&nbsp;u&nbsp;:&nbsp;unit&nbsp;=&gt;&nbsp;loop&nbsp;u".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Wywołanie rekurencyjne <span class="inlinecode"><span class="id" title="var">loop</span></span> jest nielegalne, gdyż jego argumentem
    jest <span class="inlinecode"><span class="id" title="var">u</span></span>, podczas gdy powinien być nim jakiś podterm <span class="inlinecode"><span class="id" title="var">u</span></span>.

<div class="paragraph"> </div>

    Zanim jednak dowiemy się, czym jest argument główny, czym są podtermy
    i jak dokładnie Coq weryfikuje poprawność naszych definicji funkcji
    rekurencyjnych, wróćmy na chwilę do indukcji. Jak się zaraz okaże,
    nielegalność rekursji ogólnej wymusza również pewne ograniczenia w
    definicjach induktywnych. 
<div class="paragraph"> </div>

<a id="lab360"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Ograniczenia nakładane przez Coqa sprawiają, że wszystkie napisane
    przez nas funkcje rekurencyjne muszą się kiedyś zatrzymać i zwrócić
    ostateczny wynik swojego działania. Tak więc nie możemy w Coqu pisać
    funkcji nieterminujących, czyli takich, które się nie zatrzymują.

<div class="paragraph"> </div>

    Rozważ bardzo interesujące pytanie filozoficzne: czy funkcje, które
    nigdy się nie zatrzymują (lub nie zatrzymują się tylko dla niektórych
    argumentów) mogą być w ogóle do czegokolwiek przydatne?

<div class="paragraph"> </div>

    Nie daj się wpuścić w maliny. 
<div class="paragraph"> </div>

<a id="lab361"></a><h1 class="section">Rekursja po paliwie</h1>

<div class="paragraph"> </div>

 Rekursja dobrze ufundowana to sirius byznys, więc zanim się nią zajmiemy
    wypadałoby nauczyć się robić robotę na odwal, byle działało. Jakkolwiek
    nie brzmi to zbyt profesjonalnie, dobrze jest mieć tego typu narzędzie
    w zanadrzu, choćby w celu szybkiego prototypowania. Czasem zdarza się
    też, że tego typu luźne podejście do problemu jest jedynym możliwym, bo
    nikt nie wie, jak to zrobić porządnie.

<div class="paragraph"> </div>

    Narzędziem, o którym mowa, jest coś, co ja nazywam "rekursją po paliwie".
    Pozwala ona zasymulować definicję dowolnej funkcji o typie
    <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">An</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> (w tym nawet częściowej czy nieterminującej, co
    już samo w sobie jest ciekawe) za pomocą funkcji o typie
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">An</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Trik jest dość banalny: argument typu <span class="inlinecode"><span class="id" title="var">nat</span></span> jest argumentem głównym,
    po którym robimy rekursję. Jest on naszym "paliwem", które spalamy
    przy każdym wywołaniu rekurencyjnym. Jeżeli paliwo się nam skończy,
    zwracamy <span class="inlinecode"><span class="id" title="var">None</span></span>. Jeżeli jeszcze starcza paliwa, możemy zdefiniować
    funkcję tak jak zamierzaliśmy, ale mamy też obowiązki biurokratyczne
    związane ze sprawdzaniem, czy wyniki wywołań rekurencyjnych to <span class="inlinecode"><span class="id" title="var">None</span></span>
    czy <span class="inlinecode"><span class="id" title="var">Some</span></span>.

<div class="paragraph"> </div>

    Coby za dużo nie godoć, przykład. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Nat</span>.<br/>

<br/>
</div>

<div class="doc">
Będą nam potrzebne notacje dla list oraz funkcja <span class="inlinecode"><span class="id" title="var">even</span></span>, która sprawdza,
    czy liczba naturalna jest parzysta. Będziemy chcieli zdefiniować funkcję
    Collatza. Gdyby Coq wspierał rekursję ogólną, jej definicja wyglądałaby
    tak: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">collatz</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">list</span> <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 | 1 =&gt; [<span class="id" title="var">n</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">n</span> :: <span class="id" title="keyword">if</span> <span class="id" title="var">even</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">collatz</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">else</span> <span class="id" title="var">collatz</span> (1 + 3 * <span class="id" title="var">n</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Jest to bardzo wesoła funkcja. Przypadki bazowe to <span class="inlinecode">0</span> i <span class="inlinecode">1</span> - zwracamy
    wtedy po prostu listę z jednym elementem, odpowiednio <span class="inlinecode">[0]</span> lub <span class="inlinecode">[1]</span>.
    Ciekawiej jest dla <span class="inlinecode"><span class="id" title="var">n</span></span> większego od 1. <span class="inlinecode"><span class="id" title="var">n</span></span> zostaje głową listy, zaś w
    kwestii ogona mamy dwa przypadki. Jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to argumentem
    wywołania rekurencyjnego jest <span class="inlinecode"><span class="id" title="var">n</span></span> podzielone przez <span class="inlinecode">2</span>, zaś w przeciwnym
    przypadku jest to <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">3</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Funkcja ta nie ma żadnego ukrytego celu. Została wymyślona dla zabawy,
    a przyświecające jej pytanie to: czy funkcja ta kończy pracę dla każdego
    argumentu, czy może jest jakiś, dla którego się ona zapętla?

<div class="paragraph"> </div>

    O ile funkcja jest prosta, o tyle odpowiedź jest bardzo skomplikowana i
    dotychczas nikt nie potrafił jej udzielić. Sprawdzono ręcznie (czyli za
    pomocą komputerów) bardzo dużo liczb i funkcja ta zawsze kończyła pracę,
    ale nikt nie umie udowodnić, że dzieje się tak dla wszystkich liczb. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">collatz</span> (<span class="id" title="var">fuel</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">option</span> (<span class="id" title="var">list</span> <span class="id" title="var">nat</span>) :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">fuel</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">fuel'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 | 1 =&gt; <span class="id" title="var">Some</span> [<span class="id" title="var">n</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">even</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">collatz</span> <span class="id" title="var">fuel'</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">l</span> =&gt; <span class="id" title="var">Some</span> (<span class="id" title="var">n</span> :: <span class="id" title="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">collatz</span> <span class="id" title="var">fuel'</span> (1 + 3 * <span class="id" title="var">n</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">l</span> =&gt; <span class="id" title="var">Some</span> (<span class="id" title="var">n</span> :: <span class="id" title="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji <span class="inlinecode"><span class="id" title="var">collatz</span></span> za pomocą rekursji po paliwie wygląda dość
    groźnie, ale tak naprawdę jest całkiem banalna.

<div class="paragraph"> </div>

    Ponieważ oryginalna funkcja była typu <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, to ta nowa musi
    być typu <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>. Tym razem zamiast dopasowywać
    <span class="inlinecode"><span class="id" title="var">n</span></span> musimy dopasować paliwo, czyli <span class="inlinecode"><span class="id" title="var">fuel</span></span>. Dla <span class="inlinecode">0</span> zwracamy <span class="inlinecode"><span class="id" title="var">None</span></span>, a gdy
    zostało jeszcze trochę paliwa, przechodzimy do właściwej części definicji.
    W przypadkach bazowych zwracamy <span class="inlinecode">[<span class="id" title="var">n</span>]</span>, ale  musimy zawinąć je w <span class="inlinecode"><span class="id" title="var">Some</span></span>. W
    pozostałych przypadkach sprawdzamy, czy <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, a następnie
    doklejamy odpowiedni ogon, ale musimy dopasować wywołania rekurencyjne
    żeby sprawdzić, czy zwracają one <span class="inlinecode"><span class="id" title="var">None</span></span> czy <span class="inlinecode"><span class="id" title="var">Some</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">collatz</span> 10 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;Some&nbsp;<span class="inlinecode">[5;</span> <span class="inlinecode">16;</span> <span class="inlinecode">8;</span> <span class="inlinecode">4;</span> <span class="inlinecode">2;</span> <span class="inlinecode">1]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;option&nbsp;(list&nbsp;nat)&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">collatz</span> 2 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;option&nbsp;(list&nbsp;nat)&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zaimplementowana za pomocą rekursji po paliwie funkcja oblicza się bez
    problemu, oczywiście o ile wystarczy jej paliwa. W powyższych przykładach
    <span class="inlinecode">10</span> jednostek paliwa wystarcza, by obliczyć wynik dla <span class="inlinecode">5</span>, ale <span class="inlinecode">2</span>
    jednostki paliwa to za mało. Jak więc widać, ilość potrzebnego paliwa
    zależy od konkretnej wartości na wejściu.

<div class="paragraph"> </div>

    Interpretacja tego, czym tak naprawdę jest paliwo, nie jest zbyt
    trudna. Jest to maksymalna głębokość rekursji, na jaką może pozwolić
    sobie funkcja. Czym jest głębokość rekursji? Możemy wyobrazić sobie
    drzewo, którego korzeniem jest obecne wywołanie, a poddrzewami są
    drzewa dla wywołań rekurencyjnych. Głębokość rekursji jest po prostu
    głębokością (czyli wysokością) takiego drzewa.

<div class="paragraph"> </div>

    W przypadku funkcji <span class="inlinecode"><span class="id" title="var">collatz</span></span> głębokość rekursji jest równa długości
    zwróconej listy (gdy funkcja zwraca <span class="inlinecode"><span class="id" title="var">Some</span></span>) lub większa niż ilość
    paliwa (gdy funkcja zwraca <span class="inlinecode"><span class="id" title="var">None</span></span>).

<div class="paragraph"> </div>

    Powyższe rozważania prowadzą nas do techniki, która pozwala z funkcji
    zrobionej rekursją po paliwie zrobić normalną, pełnoprawną funkcję.
    Wystarczy znaleźć "funkcję tankującą"
    <span class="inlinecode"><span class="id" title="var">fill_tank</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">An</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, która oblicza, ile paliwa
    potrzeba dla danych argumentów wejściowych. Funkcja ta powinna mieć
    tę własność, że gdy nalejemy tyle paliwa, ile ona każe (lub więcej),
    zawsze w wyniku dostaniemy <span class="inlinecode"><span class="id" title="var">Some</span></span>.

<div class="paragraph"> </div>

    Trudnością, z którą nikt dotychczas w przypadku funkcji <span class="inlinecode"><span class="id" title="var">collatz</span></span> nie
    potrafił się uporać, jest właśnie znalezienie funkcji tankującej. Jak
    więc widać, rekursja po paliwie nie zawsze jest fuszerką czy środkiem
    prototypowania, lecz czasem bywa faktycznie przydatna do reprezentowania
    funkcji, których inaczej zaimplementować się nie da. 
<div class="paragraph"> </div>

<a id="lab362"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj za pomocą rekursji po paliwie funkcję <span class="inlinecode"><span class="id" title="var">divFuel</span></span>, która jest
    implementacją dzielenia (takiego zwykłego, a nie sprytnego jak ostatnio,
    tzn. <span class="inlinecode"><span class="id" title="var">divFuel</span></span> <span class="inlinecode"><span class="id" title="var">fuel</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">0</span> jest niezdefiniowane). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab363"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sporą zaletą rekursji po paliwie jest to, że definicje zrobionych za
    jej pomocą funkcji są jasne i czytelne (przynajmniej w porównaniu do
    rekursji dobrze ufundowanej, o czym już niedługo się przekonamy). To
    z kolei pozwala nam w dość łatwy sposób dowodzić interesujących nas
    właściwości tych funkcji.

<div class="paragraph"> </div>

    Udowodnij kilka oczywistych właściwości dzielenia:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">divFuel</span></span> <span class="inlinecode">?</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, tzn. <span class="inlinecode"><span class="id" title="var">n</span>/1</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Ile potrzeba paliwa?

</li>
<li> <span class="inlinecode"><span class="id" title="var">divFuel</span></span> <span class="inlinecode">?</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode">1</span>, tzn. <span class="inlinecode"><span class="id" title="var">n</span>/<span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>. Ile potrzeba paliwa?

</li>
<li> przy dzieleniu przez <span class="inlinecode">0</span> nigdy nie starcza paliwa. 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab364"></a><h4 class="section">Ćwiczenie (lemat o tankowaniu)</h4>

<div class="paragraph"> </div>

 Pokaż, że jeżeli wystarcza nam paliwa do obliczenia wyniku, ale
    zatankujemy jeszcze trochę, to dalej będzie nam wystarczać.
    Wniosek: tankującemu nie dzieje się krzywda. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab365"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że funkcji <span class="inlinecode"><span class="id" title="var">collatz</span></span> dla wejść o postaci <span class="inlinecode"><span class="id" title="var">pow</span></span> <span class="inlinecode">2</span> <span class="inlinecode"><span class="id" title="var">n</span></span> (czyli
    potęg dwójki) wystarczy <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> jednostek paliwa.

<div class="paragraph"> </div>

    Uwaga (trochę złośliwa): jeśli napotkasz trudności w trakcie dowodzenia
    (a moje uwagi przecież nie biorą się znikąd), to pamiętaj, że mają one
    charakter arytmetyczny, tzn. są związane z użyciem w definicji funkcji
    takich jak <span class="inlinecode"><span class="id" title="var">pow</span></span> czy <span class="inlinecode"><span class="id" title="var">div2</span></span>, nie są zaś spowodowane jakimiś problemami
    z samą techniką, jaką jest rekursja po paliwie. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab366"></a><h1 class="section">Rekursja dobrze ufundowana</h1>

<div class="paragraph"> </div>

 Typy induktywne są jak domino - każdy term to jedna kostka, indukcja
    i rekursja odpowiadają zaś temu co tygryski lubią najbardziej, czyli
    reakcji łańcuchowej przewracającej wszystkie kostki.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">unit</span></span> to jedna biedna kostka, zaś <span class="inlinecode"><span class="id" title="var">bool</span></span> to już dwie biedne
    kostki - <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>. W obu przypadkach nie dzieje się nic
    ciekawego - żeby wszystkie kostki się przewróciły, musimy pchnąć
    palcem każdą z osobna.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">nat</span></span> jest już ciekawszy - są dwa rodzaje kostek, <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">S</span></span>,
    a jeżeli pchniemy kostkę <span class="inlinecode">0</span> i między kolejnymi kostkami jest
    odpowiedni odstęp, to równy szlaczek kolejnych kostek przewracać
    się będzie do końca świata.

<div class="paragraph"> </div>

    Podobnie dla typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> mamy dwa rodzaje kostek - <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span>,
    ale kostki rodzaju <span class="inlinecode"><span class="id" title="var">cons</span></span> mają różne kolory - są nimi elementy typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>. Podobnie jak dla <span class="inlinecode"><span class="id" title="var">nat</span></span>, jeżeli pchniemy kostkę <span class="inlinecode"><span class="id" title="var">nil</span></span> i odstępy
    między kolejnymi kostkami są odpowiednie, to kostki będą przewracać
    się w nieskończoność. Tym razem jednak zamiast jednego szaroburego
    szlaczka będzie multum kolorowych szlaczków o wspólnych początkach
    (no chyba, że <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> - wtedy dostaniemy taki sam bury szlaczek
    jak dla <span class="inlinecode"><span class="id" title="var">nat</span></span>).

<div class="paragraph"> </div>

    Powyższe malownicze opisy przewracających się kostek domina bardziej
    przywodzą na myśl indukcję, niż rekursję, chociaż wiemy już, że jest
    to w sumie to samo. Przyjmują one perspektywę "od przodu" - jeżeli
    przewrócimy początkową kostkę i niczego nie spartaczyliśmy, kolejne
    kostki będą przewracać się już same.

<div class="paragraph"> </div>

    Co to znaczy, że niczego nie spartaczyliśmy, pytasz? Tutaj przydaje
    się spojrzenie na nasze domino "od tyłu". Żeby kostka domina się
    przewróciła, muszą przewrócić się na nią wszystkie bezpośrednio
    poprzedzające ją kostki, a żeby one się przewróciły, to przewrócić
    muszą się wszystkie poprzedzające je kostki i tak dalej. W związku
    z tym możemy powiedzieć, że kostka jest dostępna, jeżeli dostępne
    są wszystkie kostki ją poprzedzające.

<div class="paragraph"> </div>

    Jeszcze jeden drobny detal: kiedy dostępne są kostki, które nie mają
    żadnych poprzedzających kostek? Odpowiedź: zawsze, a dowodem na to
    jest nasz palec, który je przewraca.

<div class="paragraph"> </div>

    W ten oto wesoły sposób udało nam się uzyskać definicję elementu
    dostępnego oraz relacji dobrze ufundowanej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Acc</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Acc_intro</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Kostki domina reprezentuje typ <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś relacja <span class="inlinecode"><span class="id" title="var">R</span></span> to sposób ułożenia
    kostek, a <span class="inlinecode"><span class="id" title="var">x</span></span> to pewna konkretna kostka domina. Konstruktor <span class="inlinecode"><span class="id" title="var">Acc_intro</span></span>
    mówi, że kostka <span class="inlinecode"><span class="id" title="var">x</span></span> jest dostępna w układzie domina <span class="inlinecode"><span class="id" title="var">R</span></span>, jezeli każda
    kostka <span class="inlinecode"><span class="id" title="var">y</span></span>, która poprzedza ją w układzie <span class="inlinecode"><span class="id" title="var">R</span></span>, również jest dostępna.

<div class="paragraph"> </div>

    Mniej poetycko: element <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest <span class="inlinecode"><span class="id" title="var">R</span></span>-dostępny, jeżeli każdy
    <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejszy od niego element <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> również jest <span class="inlinecode"><span class="id" title="var">R</span></span>-dostępny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">well_founded</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Układ kostek reprezentowany przez <span class="inlinecode"><span class="id" title="var">R</span></span> jest niespartaczony, jeżeli każda
    kostka domina jest dostępna.

<div class="paragraph"> </div>

    Mniej poetycko: relacja <span class="inlinecode"><span class="id" title="var">R</span></span> jest dobrze ufundowana, jeżeli każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest <span class="inlinecode"><span class="id" title="var">R</span></span>-dostępne.

<div class="paragraph"> </div>

    Uwaga: typem naszego układu kostek nie jest <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a zatem <span class="inlinecode"><span class="id" title="var">R</span></span> jest tak naprawdę indeksowaną rodziną
    typów, a nie relacją. Różnica między relacją i rodziną typów jest
    taka, że relacja, gdy dostanie argumenty, zwraca zdanie, czyli coś
    typu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a rodzina typów, gdy dostanie argumenty, zwraca typ,
    czyli coś typu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Tak więc pojęcie rodziny typów jest ogólniejsze
    niż pojęcie relacji. Ta ogólność przyda się nam za kilka chwil aby nie
    musieć pisać wszystkiego dwa razy. 
<div class="paragraph"> </div>

<a id="lab367"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy relacje <span class="inlinecode">&lt;=</span>, <span class="inlinecode">&lt;</span> są dobrze ufundowane. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab368"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Pokaż, że relacja dobrze ufundowana jest antyzwrotna oraz zinterpretuj
    ten fakt (tzn. powiedz, o co tak naprawdę chodzi w tym stwierdzeniu). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wf_antirefl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">well_founded</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, ~ <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab369"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy dobrze ufundowana jest następująca relacja porządku:
    wszystkie liczby parzyste są mniejsze niż wszystkie liczby nieparzyste,
    zaś dwie liczby o tej samej parzystości porównujemy według zwykłego
    porządku <span class="inlinecode">&lt;</span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab370"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy dobrze ufundowana jest następująca relacja porządku
    (mam nadzieję, że obrazek jest zrozumiały):
    0 &lt; 1 &lt; ... &lt; ω &lt; ω + 1 &lt; ... &lt; 2 * ω

<div class="paragraph"> </div>

     Oczywiście najpierw musisz wymyślić, w jaki sposób zdefiniować taką
     relację. Uwaga: istnieje bardzo sprytne rozwiązanie. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Nasza bajka powoli zbliża się do końca. Czas udowodnić ostateczne
    twierdzenie, do którego dążyliśmy: jeżeli układ kostek <span class="inlinecode"><span class="id" title="var">R</span></span> jest
    niespartaczony (czyli gdy każda kostka jest dostępna), to każda
    kostka się przewraca. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">well_founded_rect</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">wf</span> : <span class="id" title="var">well_founded</span> <span class="id" title="var">R</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">well_founded</span> <span class="id" title="tactic">in</span> <span class="id" title="keyword">wf</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="keyword">wf</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="keyword">wf</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">IH</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, <span class="inlinecode"><span class="id" title="var">A</span></span> to typ kostek domina, <span class="inlinecode"><span class="id" title="var">R</span></span> to układ kostek,
    zaś <span class="inlinecode"><span class="id" title="keyword">wf</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">well_founded</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> to dowód na to, że układ jest niespartaczony.
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> to dowolna rodzina typów indeksowana przez <span class="inlinecode"><span class="id" title="var">A</span></span>, ale
    możemy myśleć, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> znaczy "kostka x się przewraca". Mamy jeszcze
    hipotezę, która głosi, że kostka <span class="inlinecode"><span class="id" title="var">x</span></span> przewraca się, gdy przewraca się
    każda kostka, która poprzedza ją w układzie <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Dowód jest banalny. Zaczynamy od wprowadzenia zmiennych i hipotez do
    kontekstu. Następnie odwijamy definicję <span class="inlinecode"><span class="id" title="var">well_founded</span></span>. Teraz hipoteza
    <span class="inlinecode"><span class="id" title="keyword">wf</span></span> głosi, że każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest dostępne. Skoro tak, to specjalizujemy
    ją dla naszego konkretnego <span class="inlinecode"><span class="id" title="var">x</span></span>, które mamy w kontekście.

<div class="paragraph"> </div>

    Wiemy już zatem, że <span class="inlinecode"><span class="id" title="var">x</span></span> jest dostępne. Jest to kluczowy fakt, gdyż
    oznacza to, że wszystkie kostki domina poprzedzające <span class="inlinecode"><span class="id" title="var">x</span></span> również są
    dostępne. Co więcej, <span class="inlinecode"><span class="id" title="var">Acc</span></span> jest zdefiniowane induktywnie, więc możemy
    pokazać, że <span class="inlinecode"><span class="id" title="var">x</span></span> się przewraca, właśnie przez indukcję po dowodzie
    dostępności <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Przypadek jest jeden (co nie znaczy, że nie ma przypadków bazowych -
    są nimi kostki domina, których nic nie poprzedza): musimy pokazać, że
    <span class="inlinecode"><span class="id" title="var">x</span></span> się przewraca przy założeniu, że wszystkie poprzedzające je kostki
    również się przewracają. To, że <span class="inlinecode"><span class="id" title="var">x</span></span> się przewraca, wynika z hipotezy
    <span class="inlinecode"><span class="id" title="var">H</span></span>. Pozostaje nam jedynie pokazać, że przewraca się wszystko, co jest
    przed nim, ale to jest faktem na mocy hipotezy indukcyjnej <span class="inlinecode"><span class="id" title="var">IH</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">well_founded_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">wf</span> : <span class="id" title="var">well_founded</span> <span class="id" title="var">R</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Poprzednie twierdzenie, czyli <span class="inlinecode"><span class="id" title="var">well_founded_rect</span></span>, to twierdzenie o
    rekursji dobrze ufundowanej. Powyższe, czyli <span class="inlinecode"><span class="id" title="var">well_founded_ind</span></span>,
    które jest jego specjalizacją dla relacji binarnych (czyli bytów o
    typie <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), możemy nazwać twierdzeniem o indukcji dobrze
    ufundowanej.

<div class="paragraph"> </div>

    Upewnij się, że dobrze rozumiesz oba twierdzenia, a także pojęcia
    dostępności i dobrego ufundowania, gdyż są one bardzo ważne przy
    rozwiązywaniu poważniejszych problemów.

<div class="paragraph"> </div>

    Co to są "poważniejsze problemy"? Mam oczywiście na myśli dowodzenie
    twierdzeń i definiowanie funkcji, którego nie da się zrobić za pomocą
    prostej indukcji albo banalnego dopasowania do wzorca. W tego typu
    sytuacjach nieodzowne będzie skorzystanie z indukcji i rekursji
    dobrze ufundowanej, o czym przekonamy się już natychmiast zaraz. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Lia</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">div</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (@<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">nat</span> <span class="id" title="var">lt</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;2: <span class="id" title="tactic">exact</span> 0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (1 + <span class="id" title="var">IH</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">_</span> <span class="id" title="var">m</span>). <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>. <span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Poważniejszym problemem jest bowiem definicja dzielenia, z którą borykamy
    się od samiuśkiego początku niniejszego rozdziału. Powyższy kawałek kodu
    jest (nieudaną, jak się okaże) próbą uporania się z tym problemem.

<div class="paragraph"> </div>

    Definiować będziemy w trybie dowodzenia, gdyż przy posługiwaniu się
    rekursją dobrze ufundowaną zazwyczaj tak jest dużo łatwiej. Zaczynamy
    od zaaplikowania reguły rekursji dobrze ufundowanej dla typu <span class="inlinecode"><span class="id" title="var">nat</span></span> i
    porządku <span class="inlinecode">&lt;</span> (no i rzecz jasna <span class="inlinecode"><span class="id" title="var">wf_lt</span></span>, czyli dowodu na to, że <span class="inlinecode"><span class="id" title="var">lt</span></span>
    jest dobrze ufundowany - bez tego ani rusz). Po typach widać, że
    rekursja będzie się odbywać po pierwszym argumencie. Wprowadzamy też
    zmienne do kontekstu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">le_lt_dec</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;le_lt_dec&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;{n&nbsp;&lt;=&nbsp;m}&nbsp;+&nbsp;{m&nbsp;&lt;&nbsp;n}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Następnie musimy sprawdzić, czy dzielna (czyli <span class="inlinecode"><span class="id" title="var">n</span></span>) jest mniejsza od
    dzielnika (czyli <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> - zauważ, że definiujemy tutaj "sprytną" wersję
    dzielenia, tzn. <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> = <span class="inlinecode"><span class="id" title="var">n</span>/(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, żeby uniknąć problemów z
    dzieleniem przez <span class="inlinecode">0</span>). Jeżeli tak, wynikiem jest <span class="inlinecode">0</span>. Jeżeli nie,
    wynikiem jest wynik wywołania rekurencyjnego na argumencie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    powiększony o <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Na koniec musimy jeszcze tylko pokazać, że argument wywołania
    rekurencyjnego, czyli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, jest mniejszy od argumentu
    obecnego wywołania, czyli <span class="inlinecode"><span class="id" title="var">n</span></span>. Żeby za bardzo nie pobrudzić
    sobie rąk arytmetyką, zostawiamy ten cel taktyce <span class="inlinecode"><span class="id" title="var">lia</span></span>, ale
    zawijamy jej użycie w kombinator <span class="inlinecode"><span class="id" title="tactic">abstract</span></span>, który zapobiega
    "wylaniu się" rozumowania taktyki <span class="inlinecode"><span class="id" title="var">lia</span></span> do definicji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">div</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;div&nbsp;=<br/>
&nbsp;&nbsp;well_founded_rect&nbsp;nat&nbsp;lt&nbsp;wf_lt&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;(n&nbsp;:&nbsp;nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IH&nbsp;:&nbsp;forall&nbsp;y&nbsp;:&nbsp;nat,&nbsp;y&nbsp;&lt;&nbsp;n&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m&nbsp;:&nbsp;nat)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;s&nbsp;:=&nbsp;le_lt_dec&nbsp;(S&nbsp;m)&nbsp;n&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;s&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;left&nbsp;l&nbsp;=&gt;&nbsp;1&nbsp;+&nbsp;IH&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;(div_subproof&nbsp;n&nbsp;m&nbsp;l)&nbsp;m<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;right&nbsp;_&nbsp;=&gt;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">div_subproof</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div_subproof<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;m&nbsp;&lt;=&nbsp;n&nbsp;-&gt;&nbsp;n&nbsp;-&nbsp;S&nbsp;m&nbsp;&lt;&nbsp;n&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">div_subproof</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;dużo&nbsp;różnych&nbsp;głupot,&nbsp;szkoda&nbsp;pisać&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Mówiąc wprost, taktyka <span class="inlinecode"><span class="id" title="tactic">abstract</span></span> <span class="inlinecode"><span class="id" title="var">lia</span></span> zamiast wstawiać do definicji
    całe rozumowanie, tak jak zrobiłaby to taktyka <span class="inlinecode"><span class="id" title="var">lia</span></span>, dowodzi sobie
    na boku odpowiedni lemat arytmetyczny, nazywa go <span class="inlinecode"><span class="id" title="var">div_subproof</span></span> i
    dowodzi celu za jego pomocą. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">div</span> 5 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;1&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, definicja przechodzi bez problemu, a nasza funkcja elegancko
    się oblicza (pamiętaj, że <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode">5</span> <span class="inlinecode">2</span> to tak naprawdę <span class="inlinecode">5/3</span>, więc wynikiem
    faktycznie powinno być <span class="inlinecode">1</span>).

<div class="paragraph"> </div>

    Jednak nie samymi definicjami żyje człowiek - czas trochę podowodzić.
    Spodziewamy się wszakże, że nasze dzielenie spełnia wszystkie
    właściwości, których się po nim spodziewamy, prawda? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_0_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">div</span>. <span class="id" title="var">cbn</span>. <span class="comment">(*&nbsp;O&nbsp;Jezu,&nbsp;a&nbsp;cóż&nbsp;to&nbsp;za&nbsp;wojacy?&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety jednak, jak to w życiu, nie ma kolorowo.

<div class="paragraph"> </div>

    Powyższy lemat głosi, że <span class="inlinecode"><span class="id" title="var">n</span>/1</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Ponieważ <span class="inlinecode"><span class="id" title="var">div</span></span> jest zdefiniowane
    za pomocą rekursji dobrze ufundowanej, to dowodzić będziemy oczywiście
    za pomocą indukcji dobrze ufundowanej. Tak, będziemy dowodzić, hmmm...
    cóż... tylko jak?

<div class="paragraph"> </div>

    Sytuacja wygląda beznadziejnie. Nie żeby lemat był nieprawdziwy - co to,
    to nie. Po prostu próba odwinięcia definicji i policzenia czegokolwiek
    daje inny wynik, niż byśmy chcieli - część definicji ukryta dotychczas
    w <span class="inlinecode"><span class="id" title="var">div_subproof</span></span> wylewa się i zaśmieca nam ekran.

<div class="paragraph"> </div>

    Problem nie pochodzi jednak od taktyki <span class="inlinecode"><span class="id" title="var">lia</span></span> (ani od <span class="inlinecode"><span class="id" title="tactic">abstract</span></span> <span class="inlinecode"><span class="id" title="var">lia</span></span>).
    Jest on dużo ogólniejszy i polega na tym, że wewnątrz definicji funkcji
    pojawiają się dowody, które są wymagane przez <span class="inlinecode"><span class="id" title="var">well_founded_rect</span></span>, ale
    które zaorywują jej obliczeniową harmonię.

<div class="paragraph"> </div>

    Nie jesteśmy jednak (jeszcze) skazani na porażkę. Spróbujemy uporać się
    z tą przeszkodą dzięki <i>równaniu rekurencyjnemu</i>. Równanie rekurencyjne
    to lemat, którego treść wygląda dokładnie tak, jak pożądana przez nas
    definicja funkcji, ale która nie może służyć jako definicja z różnych
    powodów, np. dlatego że nie jest strukturalnie rekurencyjna. Dzięki
    równaniu rekurencyjnemu możemy użyć taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> do przepisania
    wystąpień funkcji <span class="inlinecode"><span class="id" title="var">div</span></span> do pożądanej postaci zamiast rozwijać je za
    pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> lub obliczać za pomocą <span class="inlinecode"><span class="id" title="var">cbn</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;? <span class="id" title="var">S</span> <span class="id" title="var">m</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">div</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">div</span>. <span class="id" title="var">cbn</span>. <span class="comment">(*&nbsp;O&nbsp;Jezu,&nbsp;a&nbsp;cóż&nbsp;to&nbsp;za&nbsp;hołota?&nbsp;*)</span><br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe równanie dokładnie opisuje, jak powinna zachowywać się funkcja
    <span class="inlinecode"><span class="id" title="var">div</span></span>, ale za definicję służyć nie może, gdyż Coq nie byłby w stanie
    rozpoznać, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">n</span></span>. Zauważ, że używamy tu <span class="inlinecode">&lt;?</span>
    (czyli <span class="inlinecode"><span class="id" title="var">ltb</span></span>) zamiast <span class="inlinecode"><span class="id" title="var">le_lt_dec</span></span>. Możemy sobie na to pozwolić, gdyż
    użycie <span class="inlinecode"><span class="id" title="var">le_lt_dec</span></span> w faktycznej definicji wynikało jedynie z tego, że
    potrzebowaliśmy dowodu odpowiedniego faktu arytmetycznego, żeby użyć
    go jako argumentu wywołania rekurencyjnego.

<div class="paragraph"> </div>

    Niestety próba udowodnienia tego równania rekurencyjnego musi skończyć
    się taką samą porażką, jak próba udowodnienia <span class="inlinecode"><span class="id" title="var">div_0_r</span></span>. Przyczyna jest
    taka sama jak ostatnio. Zresztą, naiwnym byłoby spodziewać się, że nam
    się uda - zarówno <span class="inlinecode"><span class="id" title="var">div_0_r</span></span>, jak i <span class="inlinecode"><span class="id" title="var">div_eq</span></span> to nietrywialne właściwości
    funkcji <span class="inlinecode"><span class="id" title="var">div</span></span>, więc gdybyśmy potrafili udowodnić równanie rekurencyjne,
    to z dowodem <span class="inlinecode"><span class="id" title="var">div_0_r</span></span> również poradzilibyśmy sobie bez problemu.

<div class="paragraph"> </div>

    Żeby jednak przekonać się o użyteczności równania rekurencyjnego, jego
    "dowód" kończymy za pomocą komendy <span class="inlinecode"><span class="id" title="var">Admitted</span></span>, która przerywa dowód i
    zamienia twierdzenie w aksjomat. Dzięki temu za chwilę zobaczymy, ile
    moglibyśmy zdziałać, mając równanie rekurencyjne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_0_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">div_eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Nat.ltb_spec</span> <span class="id" title="var">n</span> 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span>; <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać, dzięki równaniu rekurencyjnemu dowody przebiegają dość gładko.
    W powyższym zaczynamy od indukcji dobrze ufundowanej po <span class="inlinecode"><span class="id" title="var">n</span></span> (przy użyciu
    relacji <span class="inlinecode">&lt;</span> i dowodu <span class="inlinecode"><span class="id" title="var">wf_lt</span></span>), wprowadzamy zmienne do kontekstu, po czym
    przepisujemy równanie rekurencyjne. Po przeprowadzeniu analizy przypadków
    kończymy za pomocą rozumowań arytmetycznych, używając być może hipotezy
    indukcyjnej. 
<div class="paragraph"> </div>

<a id="lab371"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zgadnij, jakie jest polecenie tego ćwiczenia, a następnie wykonaj je. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_n_n</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">n</span> = 1.<br/>

<br/>
</div>

<div class="doc">
<a id="lab372"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy dobrze ufundowane są relacje <span class="inlinecode"><span class="id" title="var">le'</span></span> i <span class="inlinecode"><span class="id" title="var">lt'</span></span>. Uwaga:
    pierwsze zadanie jest bardzo łatwe, drugie jest piekielnie trudne.
    Jeżeli nie potrafisz rozwiązać go formalnie w Coqu, zrób to na
    kartce nieformalnie - będzie dużo łatwiej.
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">le'</span> (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">f</span> <span class="id" title="var">n</span> &lt;= <span class="id" title="var">g</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">lt'</span> (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">f</span> <span class="id" title="var">n</span> &lt; <span class="id" title="var">g</span> <span class="id" title="var">n</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a id="lab373"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Niech <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i niech <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> będzie relacją dobrze
    ufundowaną. Zdefiniuj po współrzędnych relację porządku na funkcjach
    o typie <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> i rozstrzygnij, czy relacja ta jest dobrze ufundowana.

<div class="paragraph"> </div>

    Uwaga: w zależności od okoliczności to zadanie może być trudne lub
    łatwe. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab374"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Pokaż, że jeżeli kodziedzina funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest dobrze ufundowana
    za pomocą relacji <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, to jej dziedzina również jest
    dobrze ufundowana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wf_inverse_image</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">well_founded</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">well_founded</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">R</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)).<br/>

<br/>
</div>

<div class="doc">
<a id="lab375"></a><h1 class="section">Indukcja wykresowa</h1>

<div class="paragraph"> </div>

 Skoro nie dla psa kiełbasa, to musimy znaleźć jakiś sposób na
    udowodnienie równania rekurencyjnego dla <span class="inlinecode"><span class="id" title="var">div</span></span>. Zamiast jednak głowić
    się nad równaniami rekurencyjnymi albo nad funkcją <span class="inlinecode"><span class="id" title="var">div</span></span>, zastanówmy
    się w pełnej ogólności: jak dowodzić właściwości funkcji rekurencyjnych?

<div class="paragraph"> </div>

    No przez indukcję, czy to nie oczywiste? Jasne, ale jak dokładnie owa
    indukcja ma wyglądać? Odpowiedź jest prostsza niż można się spodziewać.
    Otóż gdy kupujesz but, ma on pasować do twojej stopy, zaś gdy kupujesz
    gacie, mają one pasować do twojej dupy. Podobnie jest z indukcją: jej
    kształt ma pasować do kształtu rekursji, za pomocą której zdefiniowana
    została funkcja.

<div class="paragraph"> </div>

    Czym jest "kształt" rekursji (i indukcji)? Jest to raczej poetyckie
    pojęcie, które odnosi się do tego, jak zdefiniowano funkcję - ile
    jest przypadków, podprzypadków, podpodprzypadków etc., w jaki sposób
    są w sobie zagnieżdżone, gdzie są wywołania rekurencyjne, ile ich
    jest i na jakich argumentach etc.

<div class="paragraph"> </div>

    Dowiedziawszy się, czym jest kształt rekursji i indukcji, powinniśmy
    zacząć szukać sposobu na dopasowanie kształtu indukcji w naszych
    dowodach do kształtu rekursji funkcji. Dotychczas indukcję zawsze
    robiliśmy po argumencie głównym, zaś z potencjalnymi niedopasowaniami
    kształtów radziliśmy sobie robiąc ad hoc analizy przypadków, które
    uznaliśmy za stosowne.

<div class="paragraph"> </div>

    I tutaj przyda nam się nieco konceptualnej spostrzegawczości. Zauważyć
    nam bowiem trzeba, że robiąc indukcję po argumencie głównym, kształt
    indukcji odpowiada kształtowi typu argumentu głównego. Skoro zaś mamy
    dopasować go do kształtu rekursji funkcji, to nasuwa nam się oczywiste
    pytanie: czy da się zdefiniować typ, który ma taki sam kształt, jak
    definicja danej funkcji?

<div class="paragraph"> </div>

    Odpowiedź brzmi: nie, ale da się zdefiniować rodzinę typów
    (a konkretniej pisząc, rodzinę zdań, czyli relację) o takiej właściwości.
    Owa relacja zwie się wykresem funkcji. Jaki ma to związek z bazgrołami
    znanymi ci ze szkoły (zakładam, że wiesz, że wykresem funkcji liniowej
    jest prosta, wykresem funkcji kwadratowej jest parabola, a wykresy sinusa
    i cosinusa to takie wesołe szlaczki)?

<div class="paragraph"> </div>

    To, co w szkole nazywa się wykresem funkcji, jest jedynie graficznym
    przedstawieniem prawdziwego wykresu, czyli relacji. Samo słowo "wykres",
    wywodzące się w oczywisty sposób od kreślenia, sugeruje, że myślenie o
    wykresie jak o obrazku było pierwsze, a koncepcja wykresu jako relacji
    jest późniejsza.

<div class="paragraph"> </div>

    W ramach ciekawostki być może warto napisać, że w dawnych czasach
    matematycy silnie utożsamiali funkcję z jej wykresem (w sensie
    obrazka) i przez to byty, których wykresu nie dało się narysować,
    nie były uznawane za funkcje.

<div class="paragraph"> </div>

    W nieco późniejszym czasie zaszły jednak niemałe zmiany i obecnie
    panującym zabobonem jest utożsamianie funkcji z wykresem (w sensie
    relacji), przez co za funkcje uznawane są także byty, których nie
    da się obliczyć lub nikt nie potrafi pokazać, że terminują (takich
    jak np. "funkcja" Collatza).

<div class="paragraph"> </div>

    Gdybyś zgłupiał od powyższych czterech akapitów, to przypominam, że
    dla nas zawarte w nich pojęcia oznaczają to:
<ul class="doclist">
<li> Funkcja to byt, którego typem jest <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> lub <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
      Można dać jej coś na wejściu i uzyskać wynik na wyjściu, tzn. można
      ją obliczyć. W Coqu wszystkie funkcje prędzej czy później kończą się
      obliczać.

</li>
<li> Wykres funkcji to relacja opisująca związek argumentu funkcji z jej
      wynikiem. Każda funkcja ma wykres, ale nie każda relacja jest
      wykresem jakiejś funkcji.

</li>
<li> Jeżeli typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> da się jakoś sensownie narysować, to możemy
      narysować obrazek przedstawiający wykres funkcji.
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">is_graph</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> &lt;-&gt; <span class="id" title="var">f</span> <span class="id" title="var">a</span> = <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby było nam raźniej, tak wygląda formalna definicja stwierdzenia,
    że relacja <span class="inlinecode"><span class="id" title="var">R</span></span> jest wykresem funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>. Uwaga: jeżeli funkcja
    bierze więcej niż jeden argument (tzn. ma typ <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">An</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>),
    to wtedy do powyższej definicji musimy wrzucić jej zmodyfikowaną
    wersję o typie <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">*</span> <span class="inlinecode">...</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">An</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. 
<div class="paragraph"> </div>

<a id="lab376"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">graph_of</span></span>, która każdej funkcji przyporządkowuje
    jej wykres. Następnie udowodnij, że faktycznie jest to wykres tej
    funkcji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">is_graph_graph_of</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">is_graph</span> <span class="id" title="var">f</span> (<span class="id" title="var">graph_of</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab377"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Wymyśl typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> oraz relację o typie <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, która nie
    jest wykresem żadnej funkcji. Następnie udowodnij formalnie, że nie
    mylisz się. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab378"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Pokaż, że wszystkie wykresy danej funkcji są równoważne w poniższym
    sensie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">graph_unique</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">is_graph</span> <span class="id" title="var">f</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">is_graph</span> <span class="id" title="var">f</span> <span class="id" title="var">S</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> &lt;-&gt; <span class="id" title="var">S</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro już wiemy czym są wykresy funkcji, czas nauczyć się definiować
    induktywne wykresy o kształtach odpowiednich dla naszych niecnych
    celów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">div_eq</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div_eq<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div&nbsp;n&nbsp;m&nbsp;=&nbsp;if&nbsp;n&nbsp;&lt;?&nbsp;S&nbsp;m&nbsp;then&nbsp;0&nbsp;else&nbsp;S&nbsp;(div&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m)&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zwróćmy tylko uwagę na fakt, że mówiąc o kształcie rekursji (lub po
    prostu o kształcie definicji) <span class="inlinecode"><span class="id" title="var">div</span></span> nie mamy na myśli faktycznej
    definicji, która używa rekursji dobrze ufundowanej i jak już wiemy,
    jest dość problematyczna, lecz "docelowej" definicji, którą wyraża
    między innymi równanie rekurencyjne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">divG</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divG_lt</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>}, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divG_ge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divG</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">S</span> <span class="id" title="var">r</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">div</span></span> jest funkcją typu <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, więc jej wykres to relacja
    typu <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Dwa pierwsze argumenty relacji
    reprezentują wejście, zaś ostatni argument reprezentuje wyjście, tzn.
    chcemy, żeby <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> było równoważne <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">r</span></span>.

<div class="paragraph"> </div>

    Z równania rekurencyjnego widać, że mamy dwa przypadki, czyli konstruktory
    też będą dwa. Jeden odpowiada przypadkowi, gdy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, tzn. dzielna jest
    mniejsza niż dzielnik (pamiętaj, że <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oznacza <span class="inlinecode"><span class="id" title="var">n</span>/(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, żeby
    uniknąć problemów z dzieleniem przez zero). Konkluzją jest wtedy
    <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">0</span>, tzn. argumentami są <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span>, zaś wynikiem jest <span class="inlinecode">0</span>.

<div class="paragraph"> </div>

    Drugi przypadek to przyadek rekurencyjny. Jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, tzn. dzielna
    jest większa lub równa od dzielnika, to konkluzją jest <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">r</span>)</span>,
    tzn. argumentami są <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span>, zaś wynikiem dzielenia jest <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>. Czym
    jest <span class="inlinecode"><span class="id" title="var">r</span></span>? Jest ono skwantyfikowane w tym konstruktorze i pojawia się w
    przesłance <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>, która mówi, że wynikiem dzielenia
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> przez <span class="inlinecode"><span class="id" title="var">m</span></span> jest <span class="inlinecode"><span class="id" title="var">r</span></span>. Przesłanka ta jest wykresowym odpowiednikiem
    wywołania rekurencyjnego. 
<div class="paragraph"> </div>

<a id="lab379"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Mimo, że wszystkie wykresy danej funkcji są równoważne, to zdefiniować
    można je na wiele różnych sposobów. W zależności od sposobu definicja
    może być użyteczna lub nie, np. przy definicjach induktywnych dostajemy
    za darmo regułę indukcji.

<div class="paragraph"> </div>

    Podaj inną definicję wykresu funkcji <span class="inlinecode"><span class="id" title="var">div</span></span>, która nie używa typów
    induktywnych (ani nie odwołuje się do samej funkcji <span class="inlinecode"><span class="id" title="var">div</span></span> - to byłoby
    za łatwe). Użyj kwantyfikatora egzystencjalnego, mnożenia, dodawania
    oraz relacji równości (i niczego więcej). Nazwij ją <span class="inlinecode"><span class="id" title="var">divG'</span></span>.

<div class="paragraph"> </div>

    Na razie nie musisz dowodzić, że wykres faktycznie jest wykresem <span class="inlinecode"><span class="id" title="var">div</span></span>
    (póki co jest to za trudne), co oczywiście nie znaczy, że wolno ci się
    mylić - uzasadnij nieformalnie, że wykres faktycznie opisuje funkcję
    <span class="inlinecode"><span class="id" title="var">div</span></span>. Do dowodu formalnego wrócimy później. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Mamy wykres. Fajnie, ale co możemy z nim zrobić? Jeszcze ważniejsze
    pytanie brzmi zaś: co powinniśmy z nim zrobić? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_det</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r1</span> -&gt; <span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r2</span> -&gt; <span class="id" title="var">r1</span> = <span class="id" title="var">r2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="tactic">until</span> 1. <span class="id" title="var">revert</span> <span class="id" title="var">r2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">inversion</span> 1; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1-2: <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHdivG</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwsza czynność po zdefiniowaniu wykresu, którą powinniśmy wykonać,
    to sprawdzenie, czy ów wykres jest relacją deterministyczną. Relacja
    deterministyczna to taka, której ostatni argument jest zdeterminowany
    przez poprzednie.

<div class="paragraph"> </div>

    Jeżeli wykres jest deterministyczny to dobrze, a jeżeli nie, to definicja
    na pewno jest błędna, bo wykres ma opisywać funkcję, a żadna funkcja nie
    może dla tych samych argumentów dawać dwóch różnych wyników. Relacjom
    deterministycznym (i nie tylko) przyjrzymy się dokładniej w rozdziale o
    relacjach.

<div class="paragraph"> </div>

    Dowód nie jest zbyt trudny. Robimy indukcję po dowodzie hipotezy
    <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">r1</span></span>, ale musimy pamiętać, żeby wcześniej zgeneralizować
    <span class="inlinecode"><span class="id" title="var">r2</span></span>, bo w przeciwnym przypadku nasza hipoteza indukcyjna będzie
    za mało ogólna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_correct</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">div_eq</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">Nat.ltb_spec0</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejna rzecz do udowodnienia to twierdzenie o poprawności, które mówi,
    że <span class="inlinecode"><span class="id" title="var">divG</span></span> faktycznie jest wykresem <span class="inlinecode"><span class="id" title="var">div</span></span>. Zauważ, że moglibyśmy równie
    dobrze sformułować je za pomocą <span class="inlinecode"><span class="id" title="var">is_graph</span></span>, ale tak jak wyżej będzie
    praktyczniej.

<div class="paragraph"> </div>

    Dowód zaczynamy od indukcji dobrze ufundowanej, po czym wprowadzamy
    zmienne do kontekstu i... aj waj, cóż to takiego? Używamy równania
    rekurencyjnego do rozpisania <span class="inlinecode"><span class="id" title="var">div</span></span>, po czym kończymy przez rozważenie
    przypadków.

<div class="paragraph"> </div>

    Ten dowód pokazuje, że nie udało nam się osiągnąć celu, który sobie
    postawiliśmy, czyli udowodnienia <span class="inlinecode"><span class="id" title="var">div_eq</span></span> za pomocą specjalnej reguły
    indukcji. Niestety, bez równania rekurencyjnego nie da się udowodnić
    twierdzenia o poprawności. Nie powinniśmy jednak za bardzo się tym
    przejmować - uszy do góry. Póki co dokończmy poszukiwań ostatecznej
    reguły indukcji, a tym nieszczęsnym równaniem rekurencyjnym zajmiemy
    się później. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_complete</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">r</span> = <span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_det</span> <span class="id" title="keyword">with</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_correct</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną, ostatnią już rzeczą, którą powinniśmy zrobić z wykresem, jest
    udowodnienie twierdzenia o pełności, które głosi, że jeżeli argumentom
    <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> odpowiada na wykresie wynik <span class="inlinecode"><span class="id" title="var">r</span></span>, to <span class="inlinecode"><span class="id" title="var">r</span></span> jest równe <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Dowód jest banalny i wynika wprost z twierdzeń o determinizmie i
    poprawności.

<div class="paragraph"> </div>

    I po co nam to było? Ano wszystkie fikołki, które zrobiliśmy, posłużą
    nam jako lematy do udowodnienia reguły indukcji wykresowej dla <span class="inlinecode"><span class="id" title="var">div</span></span>.
    Co to za reguła, jak wygląda i skąd ją wziąć? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">divG_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;divG_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;0)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;r&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;&gt;=&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;divG&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;r&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;r&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;(S&nbsp;r))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;r&nbsp;:&nbsp;nat,&nbsp;divG&nbsp;n&nbsp;m&nbsp;r&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;r&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Pierwowzorem reguły indukcji wykresowej dla danej funkcji jest reguła
    indukcji jej wykresu. Reguła indukcji dla <span class="inlinecode"><span class="id" title="var">div</span></span> to w sumie to samo co
    powyższa reguła, ale z <span class="inlinecode"><span class="id" title="var">r</span></span> wyspecjalizowanym do <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>. Chcemy też
    pozbyć się niepotrzebnej przesłanki <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> (po podstawieniu za
    <span class="inlinecode"><span class="id" title="var">r</span></span> ma ona postać <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">(<span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>), gdyż nie jest potrzebna -
    jest zawsze prawdziwa na mocy twierdzenia <span class="inlinecode"><span class="id" title="var">divG_correct</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hlt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> (<span class="id" title="var">div</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">S</span> (<span class="id" title="var">div</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Hlt</span> <span class="id" title="var">Hge</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_complete</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hge</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_correct</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Przydałaby się jednak także i filozoficzna interpretacja reguły. Pozwoli
    nam ona dowodzić zdań, które zależą od <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> i wyniku dzielenia,
    czyli <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    Są dwa przypadki, jak w docelowej definicji <span class="inlinecode"><span class="id" title="var">div</span></span>. Gdy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czyli
    dzielna jest mniejsza od dzielnika, wystarczy udowodnić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">0</span>, bo
    wtedy <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> wynosi <span class="inlinecode">0</span>. W drugim przypadku, czyli gdy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    wystarczy udowodnić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">div</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span>))</span> (bo taki jest wynik
    <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> dla <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>) przy założeniu, że <span class="inlinecode"><span class="id" title="var">P</span></span> zachodzi dla <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    <span class="inlinecode"><span class="id" title="var">m</span></span> oraz <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, bo takie są argumenty oraz wynik wywołania
    rekurencyjnego.

<div class="paragraph"> </div>

    Dowód jest prosty. Wprowadzamy zmienne do kontekstu, a następnie za pomocą
    zwykłego <span class="inlinecode"><span class="id" title="tactic">apply</span></span> używamy reguły indukcji <span class="inlinecode"><span class="id" title="var">divG_ind</span></span> - jako rzekło się
    powyżej, reguła <span class="inlinecode"><span class="id" title="var">div_ind</span></span> nie jest niczym innym, niż lekką przeróbką
    <span class="inlinecode"><span class="id" title="var">divG_ind</span></span>.

<div class="paragraph"> </div>

    Mamy trzy podcele. Pierwszy odpowiada przesłance <span class="inlinecode"><span class="id" title="var">Hlt</span></span>. Drugi to
    przesłanka <span class="inlinecode"><span class="id" title="var">Hge</span></span>, ale musimy wszędzie podstawić <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode">(<span class="id" title="var">n'</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>
    za <span class="inlinecode"><span class="id" title="var">r</span></span> - posłuży nam do tego twierdzenie o pełności. Trzeci to zbędna
    przesłanka <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">(<span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, którą załatwiamy za pomocą twierdzenia
    o poprawności.

<div class="paragraph"> </div>

    Włala (lub bardziej wykwintnie: voilà)! Mamy regułę indukcji wykresowej
    dla <span class="inlinecode"><span class="id" title="var">div</span></span>. Zobaczmy, co i jak można za jej pomocą udowodnić. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_le</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> &lt;= <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">div_ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">r</span> &lt;= <span class="id" title="var">n</span>)); <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_0_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab380"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij twierdzenie <span class="inlinecode"><span class="id" title="var">div_le</span></span> za pomocą indukcji dobrze ufundowanej
    i równania rekurencyjnego, czyli bez użycia indukcji wykresowej. Jak
    trudny jest ten dowód w porównaniu do powyższego? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_le'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> &lt;= <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab381"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij za pomocą indukcji wykresowej, że twój alternatywny
    wykres funkcji <span class="inlinecode"><span class="id" title="var">div</span></span> z jednego z poprzednich ćwiczeń faktycznie
    jest wykresem <span class="inlinecode"><span class="id" title="var">div</span></span>.

<div class="paragraph"> </div>

    Następnie udowodnij to samo za pomocą indukcji dobrze ufundowanej i
    równania rekurencyjnego. Która metoda dowodzenia jest lepsza (nie,
    to pytanie nie jest subiektywne - masz udzielić jedynej słusznej
    odpowiedzi). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG'_div</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG'_div'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab382"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz funkcję <span class="inlinecode"><span class="id" title="tactic">split</span></span> o sygnaturze
    <span class="inlinecode"><span class="id" title="tactic">split</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>,
    która rozdziela listę <span class="inlinecode"><span class="id" title="var">l</span></span> na blok o długości <span class="inlinecode"><span class="id" title="var">n</span></span> i resztę listy, lub
    zwraca <span class="inlinecode"><span class="id" title="var">None</span></span> gdy lista jest za krótka.

<div class="paragraph"> </div>

    Następnie udowodnij dla tej funkcji regułę indukcji wykresowej i użyj
    jej do udowodnienia kilku lematów.

<div class="paragraph"> </div>

    Wszystkie te rzeczy przydadzą się nam w jednym z kolejnych zadań. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">lengthOrder</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> <span class="id" title="var">l1</span> &lt; <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wf_lengthOrder</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">well_founded</span> (@<span class="id" title="var">lengthOrder</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">wf_inverse_image</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (@<span class="id" title="var">length</span> <span class="id" title="var">A</span>)). <span class="id" title="tactic">apply</span> <span class="id" title="var">wf_lt</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">lengthOrder_split_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span> = <span class="id" title="var">Some</span> (<span class="id" title="var">l1</span>, <span class="id" title="var">l2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = 0  \/ <span class="id" title="var">lengthOrder</span> <span class="id" title="var">l2</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">lengthOrder_split</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">l</span> = <span class="id" title="var">Some</span> (<span class="id" title="var">l1</span>, <span class="id" title="var">l2</span>) -&gt; <span class="id" title="var">lengthOrder</span> <span class="id" title="var">l2</span> <span class="id" title="var">l</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab383"></a><h1 class="section">Metoda induktywnej dziedziny</h1>

<div class="paragraph"> </div>

 Póki co nie jest źle - udało nam się wszakże wymyślić jedyną słuszną
    metodę dowodzenia właściwości funkcji rekurencyjnych. Jednak nasza
    implementacja kuleje przez to nieszczęsne równanie rekurencyjne. Jak
    możemy udowodnić je bez używania indukcji wykresowej?

<div class="paragraph"> </div>

    Żeby znaleźć odpowiedź na to pytanie, znowu przyda się nam trochę
    konceptualnej jasności. Na czym tak naprawdę polega problem? Jak
    pamiętamy, problem wynika z tego, że definiując <span class="inlinecode"><span class="id" title="var">div</span></span> przez rekursję
    dobrze ufundowaną musieliśmy jednocześnie dowodzić, że wywołania
    rekurencyjne odbywają się na argumencie mniejszym od argumentu obecnego
    wywołania.

<div class="paragraph"> </div>

    Tak więc problemem jest połączenie w jednej definicji dwóch dość luźno
    powiązanych rzeczy, którymi są:
<ul class="doclist">
<li> Docelowa definicja, która określa obliczeniowe zachowanie funkcji.
      Jej manifestacją jest nasze nieszczęsne równanie rekurencyjne. Bywa
      ona czasem nazywana aspektem obliczeniowym (albo algorytmicznym)
      funkcji.

</li>
<li> Dowód terminacji, który zapewnia, że definicja docelowa jest legalna
      i nie prowadzi do sprzeczności. Jego manifestacją są występujące w
      definicji <span class="inlinecode"><span class="id" title="var">div</span></span> dowody na to, że wywołanie rekurencyjne ma argument
      mniejszy od obecnego wywołania. Bywa on czasem nazywany aspektem
      logicznym funkcji. 
</li>
</ul>

<div class="paragraph"> </div>

 Pani doktur, mamy diagnozę! Tylko co z nią zrobić? Czy jest jakaś metoda,
    żeby rozdzielić obliczeniowy i logiczny aspekt danej funkcji, a potem
    poskładać je do kupy?

<div class="paragraph"> </div>

    Pomyślmy najpierw nad aspektem obliczeniowym. Czy da się zdefiniować
    funkcję bezpośrednio za pomocą jej definicji docelowej, czyli równania
    rekurencyjnego? Żeby to zrobić, musielibyśmy mieć możliwość robienia
    rekursji o dokładnie takim kształcie, jaki ma mieć ta funkcja...

<div class="paragraph"> </div>

    Eureka! Przecież mamy coś, co pozwala nam na rekursję o dokładnie takim
    kształcie, a mianowicie induktywny wykres! Ale przecież wykres wiąże
    ze sobą argumenty i wynik, a my chcemy dopiero zdefiniować coś, co ów
    wynik obliczy... czyli nie eureka?

<div class="paragraph"> </div>

    Nie do końca. Możemy zmodyfikować definicję wykresu, wyrzucając z
    niej wszystkie wzmianki o wyniku, uzyskując w ten sposób predykat
    będący induktywną charakteryzacją dziedziny naszej funkcji. Dzięki
    niemu możemy zdefiniować zmodyfikowaną wersję funkcji, w której
    dodatkowym argumentem jest dowód na to, że argumenty należą do
    dziedziny.

<div class="paragraph"> </div>

    Logiczny aspekt funkcji, czyli dowód terminacji, sprowadza się w
    takiej sytuacji do pokazania, że wszystkie argumenty należą do
    dziedziny (czyli spełniają predykat dziedziny). Żeby zdefiniować
    oryginalną funkcję, wystarczy jedynie poskładać oba aspekty do
    kupy, czyli wstawić dowód terminacji do zmodyfikowanej funkcji.

<div class="paragraph"> </div>

    Żeby nie utonąć w ogólnościach, zobaczmy, jak nasz wspaniały
    wynalazek radzi sobie z dzieleniem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">divD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_lt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_ge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Tak wygląda predykat dziedziny dla dzielenia. Zauważmy, że tak naprawdę
    to nie jest to predykat, bo bierze dwa argumenty i co więcej nie zwraca
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Nie będziemy się tym jednak przejmować - dla nas
    <span class="inlinecode"><span class="id" title="var">divD</span></span> będzie "predykatem dziedziny". Zauważmy też, że nie jest to
    predykat dziedziny dla <span class="inlinecode"><span class="id" title="var">div</span></span>, lecz dla <span class="inlinecode"><span class="id" title="var">div'</span></span>, czyli zupełnie nowej
    funkcji, którą zamierzamy zdefiniować.

<div class="paragraph"> </div>

    Ok, przejdźmy do konkretów. <span class="inlinecode"><span class="id" title="var">div'</span></span> ma mieć typ <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    a zatem <span class="inlinecode"><span class="id" title="var">divD</span></span> ma dwa indeksy odpowiadające dwóm argumentom <span class="inlinecode"><span class="id" title="var">div'</span></span>.
    Pierwszy konstruktor głosi, że jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to oba te argumenty
    należą do dziedziny (bo będziemy chcieli w tym przypadku zwrócić <span class="inlinecode">0</span>).
    Drugi konstruktor głosi, że jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to para argumentów <span class="inlinecode"><span class="id" title="var">n</span></span>
    i <span class="inlinecode"><span class="id" title="var">m</span></span> należy do dziedziny pod warunkiem, że para argumentów <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    i <span class="inlinecode"><span class="id" title="var">m</span></span> należy do dziedziny. Jest tak, gdyż w tym przypadku będziemy
    chcieli zrobić wywołanie rekurencyjne właśnie na <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oraz <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div'_aux</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">H</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_lt</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_ge</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">div'_aux</span> <span class="id" title="var">H'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Dzięki <span class="inlinecode"><span class="id" title="var">divD</span></span> możemy zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>, której typem jest
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Jest to funkcja pomocnicza, która
    posłuży nam do zdefiniowania właściwej funkcji <span class="inlinecode"><span class="id" title="var">div'</span></span>.

<div class="paragraph"> </div>

    Ponieważ <span class="inlinecode"><span class="id" title="var">divD</span></span> jest zdefiniowane induktywnie, docelowa definicja <span class="inlinecode"><span class="id" title="var">div'</span></span>
    jest strukturalnie rekurencyjna po argumencie <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, mimo że nie
    jest strukturalnie rekurencyjna po <span class="inlinecode"><span class="id" title="var">n</span></span> ani <span class="inlinecode"><span class="id" title="var">m</span></span>. To właśnie jest magia
    stojąca za metodą induktywnej dziedziny - możemy sprawić, żeby każda (no,
    prawie), nawet najdziwniejsza rekursja była strukturalnie rekurencyjna po
    dowodzie należenia do dziedziny.

<div class="paragraph"> </div>

    Definicja jest banalna. Gdy natrafimy na konstruktor <span class="inlinecode"><span class="id" title="var">divD_lt</span></span>, zwracamy
    <span class="inlinecode">0</span> (bo wiemy, że jednym z argumentów <span class="inlinecode"><span class="id" title="var">divD_lt</span></span> jest dowód na to, że
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>). Jeżeli trafimy na <span class="inlinecode"><span class="id" title="var">divD_ge</span></span>, to wiemy, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, więc
    robimy wywołanie rekurencyjne na <span class="inlinecode"><span class="id" title="var">H'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span> i dorzucamy do
    wyniku <span class="inlinecode"><span class="id" title="var">S</span></span>.

<div class="paragraph"> </div>

    W ten sposób zdefiniowaliśmy obliczeniową część <span class="inlinecode"><span class="id" title="var">div'</span></span>, zupełnie nie
    przejmując się kwestią terminacji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divD_all</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">nat</span> <span class="id" title="var">lt</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_ge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ge</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_lt</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód terminacji jest bliźniaczo podobny do naszej pierwszej definicji
    <span class="inlinecode"><span class="id" title="var">div</span></span>. Zaczynamy przez rekursję dobrze ufundowaną z porządkiem <span class="inlinecode"><span class="id" title="var">lt</span></span> (i
    dowodem <span class="inlinecode"><span class="id" title="var">wf_lt</span></span> na to, że <span class="inlinecode"><span class="id" title="var">lt</span></span> jest dobrze ufundowany), wprowadzamy
    zmienne do kontekstu, po czym sprawdzamy, który z przypadków zachodzi.

<div class="paragraph"> </div>

    Jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, używamy konstruktora <span class="inlinecode"><span class="id" title="var">divD_ge</span></span>. <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> zachodzi
    na mocy założenia, zaś <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> należą do dziedziny na mocy
    hipotezy indukcyjnej. Gdy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> należą do dziedziny na
    mocy założenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">div'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">div'_aux</span> (<span class="id" title="var">divD_all</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
</div>

<div class="doc">
A oto i ostateczna definicja - wstawiamy dowód <span class="inlinecode"><span class="id" title="var">divD_all</span></span> do funkcji
    pomocniczej <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> i uzyskujemy pełnoprawną funkcję dzielącą
    <span class="inlinecode"><span class="id" title="var">div'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">div'</span> 666 7.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;83&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, wynik oblicza się bez problemu. Po raz kolejny przypominam,
    że <span class="inlinecode"><span class="id" title="var">div'</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oblicza <span class="inlinecode"><span class="id" title="var">n</span>/(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, nie zaś <span class="inlinecode"><span class="id" title="var">n</span>/<span class="id" title="var">m</span></span>. Przypominam też, że
    dowód <span class="inlinecode"><span class="id" title="var">divD_all</span></span> koniecznie musimy zakończyć za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>,
    a nie jak zazwyczaj <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>, gdyż w przeciwnym przypadku funkcja <span class="inlinecode"><span class="id" title="var">div'</span></span> nie
    mogłaby niczego obliczyć. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_div'_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'_aux</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_correct'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_div'_aux</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby udowodnić regułę indukcji wykresowej, będziemy potrzebowali tego
    samego co poprzednio, czyli twierdzeń o poprawności i pełności funkcji
    <span class="inlinecode"><span class="id" title="var">div'</span></span> względem wykresu <span class="inlinecode"><span class="id" title="var">divG</span></span>. Dowody są jednak dużo prostsze niż
    ostatnim razem.

<div class="paragraph"> </div>

    Najpierw dowodzimy, że funkcja pomocnicza <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> oblicza taki wynik,
    jakiego spodziewa się wykres <span class="inlinecode"><span class="id" title="var">divG</span></span>. Dowód jest banalny, bo indukcja po
    <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> ma dokładnie taki kształt, jakiego nam potrzeba. Właściwy
    dowód dla <span class="inlinecode"><span class="id" title="var">div'</span></span> uzyskujemy przez wyspecjalizowanie <span class="inlinecode"><span class="id" title="var">divG_div'_aux</span></span> do
    <span class="inlinecode"><span class="id" title="var">div'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_complete'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">r</span> = <span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_det</span> <span class="id" title="keyword">with</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_correct'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div'_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hlt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> (<span class="id" title="var">div'</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">S</span> (<span class="id" title="var">div'</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Hlt</span> <span class="id" title="var">Hge</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_complete'</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hge</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_correct'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód pełności i dowód reguły indukcji wykresowej są dokładnie takie
    same jak poprzednio. Zauważ, że tym razem zupełnie zbędne okazało się
    równanie rekurencyjne, bez którego nie mogliśmy obyć się ostatnim
    razem. Jednak jeżeli chcemy, możemy bez problemu je udowodnić, i to
    nawet na dwa sposoby. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div'_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;? <span class="id" title="var">S</span> <span class="id" title="var">m</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">div'</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">div'</span>. <span class="id" title="tactic">generalize</span> (<span class="id" title="var">divD_all</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_S_n</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct_conv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_det</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_div'_aux</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">div'_ind</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct_conv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszy, trudniejszy sposób, to zgeneralizowanie <span class="inlinecode"><span class="id" title="var">divD_all</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    do dowolnego <span class="inlinecode"><span class="id" title="var">d</span></span> oraz indukcja po <span class="inlinecode"><span class="id" title="var">d</span></span> (to tak, jakbyśmy najpierw
    udowodnili tę regułę dla <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>, a potem wyspecjalizowali do
    <span class="inlinecode"><span class="id" title="var">div'</span></span>).

<div class="paragraph"> </div>

    Drugi, łatwiejszy sposób, realizuje nasz początkowy pomysł, od którego
    wszystko się zaczęło: dowodzimy równania rekurencyjnego za pomocą reguły
    indukcji wykresowej. 
<div class="paragraph"> </div>

<a id="lab384"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">rot</span></span>, która bierze liczbę <span class="inlinecode"><span class="id" title="var">n</span></span> oraz listę i zwraca
    listę, w której bloki o długości dokładnie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> zostały odwrócone,
    np.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode">0</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span> <span class="inlinecode">=</span> <span class="inlinecode">[2;</span> <span class="inlinecode">1;</span> <span class="inlinecode">4;</span> <span class="inlinecode">3;</span> <span class="inlinecode">6;</span> <span class="inlinecode">5;</span> <span class="inlinecode">7]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span> <span class="inlinecode">=</span> <span class="inlinecode">[3;</span> <span class="inlinecode">2;</span> <span class="inlinecode">1;</span> <span class="inlinecode">6;</span> <span class="inlinecode">5;</span> <span class="inlinecode">4;</span> <span class="inlinecode">7]</span>

<div class="paragraph"> </div>

    Wskazówka: rzecz jasna użyj metody induktywnej dziedziny. Nie bez
    przyczyny także w jednym z poprzednich zadań kazałem ci zdefiniować
    funkcję <span class="inlinecode"><span class="id" title="tactic">split</span></span>, która odkraja od listy blok o odpowiedniej długości.

<div class="paragraph"> </div>

    Następnie zdefiniuj wykres funkcji <span class="inlinecode"><span class="id" title="var">rot</span></span> i udowodnij jej regułę indukcji
    wykresowej oraz równanie rekurencyjne. Użyj jej, żeby pokazać, że <span class="inlinecode"><span class="id" title="var">rot</span></span>
    jest inwolucją dla dowolnego <span class="inlinecode"><span class="id" title="var">n</span></span>, tzn. <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">rot</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l</span></span>. Uwaga:
    potrzebne będzie trochę lematów. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab385"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">Eratosthenes</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, która dla
    danego <span class="inlinecode"><span class="id" title="var">n</span></span> znajduje listę wszystkich liczb pierwszych, które są
    mniejsze lub równe <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Jako funkcję pomocniczą zaimplementuj sito Eratosthenesa. Sito
    to funkcja <span class="inlinecode"><span class="id" title="var">sieve</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, która działa tak:
<ul class="doclist">
<li> jeżeli wejście jest puste, zwróć listę pustą

</li>
<li> jeżeli wejście ma głowę <span class="inlinecode"><span class="id" title="var">h</span></span> i ogon <span class="inlinecode"><span class="id" title="var">t</span></span>, to wstaw <span class="inlinecode"><span class="id" title="var">h</span></span> na początek
      wyniku i wywołaj się rekurencyjnie na ogonie <span class="inlinecode"><span class="id" title="var">t</span></span> z odfiltrowanymi
      wszystkimi wielokrotnościami głowy <span class="inlinecode"><span class="id" title="var">h</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli jako argument <span class="inlinecode"><span class="id" title="var">sieve</span></span> podamy listę wszystkich liczb poczynając
    od pewnej liczby pierwszej <span class="inlinecode"><span class="id" title="var">p</span></span> aż do <span class="inlinecode"><span class="id" title="var">n</span></span>, to otrzymamy listę liczb
    pierwszych między <span class="inlinecode"><span class="id" title="var">p</span></span> i <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Żeby sprawnie rozwiązać to zadanie, zgeneralizuj funkcję <span class="inlinecode"><span class="id" title="var">sieve</span></span>
    na dowolny typ <span class="inlinecode"><span class="id" title="var">A</span></span> i funkcję porównującą <span class="inlinecode"><span class="id" title="var">cmp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    (tak będzie łatwiej) i użyj metody induktywnej dziedziny. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab386"></a><h1 class="section">Komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span></h1>

<div class="paragraph"> </div>

 Odkryliśmy uniwersalną metodę definiowania funkcji i dowodzenia ich
    właściwości. Czego chcieć więcej?

<div class="paragraph"> </div>

    Po pierwsze, metoda definiowania nie jest uniwersalna (jeszcze), o czym
    przekonamy się w kolejnych podrozdziałach. Po drugie, mimo że metoda
    dowodzenia faktycznie jest uniwersalna, to komu normalnemu chciałoby
    się przy każdej funkcji tyle pisać? Jakieś wykresy, dziedziny, lematy,
    reguły indukcji, co to ma być?

<div class="paragraph"> </div>

    Czy w celu sprawnego definiowania i dowodzenia właściwości funkcji trzeba
    zoutsourcować cały proces i zatrudnić milion Hindusów? Na szczęście nie,
    gdyż bóg dał nam komendę <span class="inlinecode"><span class="id" title="keyword">Function</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Recdef</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda ta żyje w module <span class="inlinecode"><span class="id" title="var">Recdef</span></span>, którego nazwa jest skrótem od słów
    "recydywista defraudator"... dobra, koniec żartów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">div''</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) {<span class="id" title="keyword">measure</span> <span class="id" title="var">id</span> <span class="id" title="var">n</span>} : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;? <span class="id" title="var">S</span> <span class="id" title="var">m</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">div''</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">id</span>. <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">teq</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">leb_complete_conv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">teq</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div''_tcc&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_terminate&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_ind&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_rec&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_rect&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_div''_correct&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_div''_complete&nbsp;is&nbsp;defined&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Definicja zaczyna się od słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Function</span></span>, następnie mamy
    nazwę funkcji i argumenty, tak jak w zwykłych definicjach za pomocą
    <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> czy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, a później tajemniczą klauzulę
    <span class="inlinecode">{<span class="id" title="keyword">measure</span></span> <span class="inlinecode"><span class="id" title="var">id</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>, do której zaraz wrócimy, i zwracany typ. Ciało
    definicji wygląda dokładnie jak docelowa definicja.

<div class="paragraph"> </div>

    Jednak po kropce definicja nie kończy się - zamiast tego Coq każe nam
    udowodnić, że wywołanie rekurencyjne <span class="inlinecode"><span class="id" title="var">div''</span></span> odbywa się na argumencie
    mniejszym niż <span class="inlinecode"><span class="id" title="var">n</span></span>. Po zakończeniu dowodu funkcja zostaje zaakceptowana
    przez Coqa.

<div class="paragraph"> </div>

    To jednak nie koniec. Komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> nie tylko pozwala bezboleśnie
    zdefiniować <span class="inlinecode"><span class="id" title="var">div''</span></span>, ale też generuje dla nas całą masę różnych rzeczy:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">div''_tcc</span></span> to lemat, który mówi, że wszystkie wywołania rekurencyjne
      są na argumencie mniejszym od obecnego

</li>
<li> <span class="inlinecode"><span class="id" title="var">div''_terminate</span></span> to dowód tego, że funkcja terminuje (czyli że się
      nie zapętla). Jeżeli przyjrzysz się jego typowi, to zobaczysz, że
      jest podobny zupełnie do niczego. Wynika to z faktu, że komenda
      <span class="inlinecode"><span class="id" title="keyword">Function</span></span> tak naprawdę nie używa metody induktywnej dziedziny, ale
      pewnej innej metody definiowania funkcji ogólnie rekurencyjnych.
      Nie powinno nas to jednak martwić - ważne, że działa.

</li>
<li> <span class="inlinecode"><span class="id" title="var">div''_ind</span></span> to reguła indukcji wykresowej dla <span class="inlinecode"><span class="id" title="var">div''</span></span>. Jest też jej
      wariant <span class="inlinecode"><span class="id" title="var">div''_rect</span></span>, czyli "rekursja wykresowa", służąca raczej do
      definiowania niż dowodzenia.

</li>
<li> <span class="inlinecode"><span class="id" title="var">R_div''</span></span> to induktywnie zdefiniowany wykres funkcji <span class="inlinecode"><span class="id" title="var">div''</span></span>. Zauważ
      jednak, że nie jest on relacją, a rodziną typów - nie wiem po co i
      nie ma co wnikać w takie detale.

</li>
<li> <span class="inlinecode"><span class="id" title="var">R_div''_correct</span></span> to twierdzenie o poprawności wykresu.

</li>
<li> <span class="inlinecode"><span class="id" title="var">R_div''_complete</span></span> to twierdzenie o pełności wykresu.

</li>
<li> <span class="inlinecode"><span class="id" title="var">div''_equation</span></span> to równanie rekurencyjne 
</li>
</ul>

<div class="paragraph"> </div>

 Jak więc widać, nastąpił cud automatyzacji i wszystko robi się samo.
    To jednak nie koniec udogodnień. Zobaczmy, jak możemy udowodnić jakiś
    fakt o <span class="inlinecode"><span class="id" title="var">div''</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div''_le</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div''</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> &lt;= <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">functional</span> <span class="id" title="tactic">induction</span> (<span class="id" title="var">div''</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_0_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">leb_complete_conv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowodzenie właściwości funkcji zdefiniowanych za pomocą <span class="inlinecode"><span class="id" title="keyword">Function</span></span>
    jest bajecznie proste. Jeżeli wszystkie argumenty funkcji znajdują
    się w kontekście, to możemy użyć taktyki <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>
    <span class="inlinecode">(<span class="id" title="var">nazwa_funkcji</span></span> <span class="inlinecode"><span class="id" title="var">argument_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">argument_n</span>)</span>, która odpala indukcję
    wykresową dla tej funkcji. Z powodu nazwy tej taktyki indukcja
    wykresowa bywa też nazywana indukcją funkcyjną.

<div class="paragraph"> </div>

    Wujek Dobra Rada: nigdy nie odwijaj definicji funkcji zdefiniowanych
    za pomocą <span class="inlinecode"><span class="id" title="keyword">Function</span></span> ani nie próbuj ręcznie aplikować reguły indukcji
    wykresowej, bo skończy się to jedynie bólem i zgrzytaniem zębów.

<div class="paragraph"> </div>

    Na koniec wypadałoby jedynie dodać, że wcale nie złapaliśmy pana boga
    za nogi i komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> nie rozwiązuje wszystkich problemów
    pierwszego świata. W szczególności niektóre funkcje mogą być tak
    upierdliwe, że komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> odmówi współpracy z nimi. Radzeniu
    sobie z takimi ciężkimi przypadkami poświęcimy kolejne podrozdziały. 
<div class="paragraph"> </div>

<a id="lab387"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">rot</span></span> (i wszystkie funkcje pomocnicze) jeszcze raz,
    tym razem za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Function</span></span>. Porównaj swoje definicje wykresu
    oraz reguły indukcji z tymi automatycznie wygenerowanymi. Użyj taktyki
    <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>, żeby jeszcze raz udowodnić, że <span class="inlinecode"><span class="id" title="var">rot</span></span> jest
    inwolucją. Policz, ile pisania udało ci się dzięki temu zaoszczędzić.

<div class="paragraph"> </div>

    Czy w twoim rozwiązaniu są lematy, w których użycie indukcji funkcyjnej
    znacznie utrudnia przeprowadzenie dowodu? W moim poprzednim rozwiązaniu
    był jeden taki, ale wynikał z głupoty i już go nie ma. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab388"></a><h1 class="section">Rekursja zagnieżdżona</h1>

<div class="paragraph"> </div>

 Jakież to diabelstwo może być tak diabelskie, by przeciwstawić się
    metodzie induktywnej dziedziny oraz komendzie <span class="inlinecode"><span class="id" title="keyword">Function</span></span>? Ano ano,
    rekursja zagnieżdżona - wywołanie rekurencyjne jest zagnieżdżone,
    jeżeli jego argumentem jest wynik innego wywołania rekurencyjnego. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">McCarthy</span>.<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> 100 &lt;? <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">n</span> - 10 <span class="id" title="keyword">else</span> <span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)).<br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Function</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="keyword">measure</span> <span class="id" title="var">id</span> <span class="id" title="var">n</span>} : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> 100 &lt;? <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">n</span> - 10 <span class="id" title="keyword">else</span> <span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)).<br/>

<br/>
</div>

<div class="doc">
Ta funkcja jest podobna zupełnie do niczego, co dotychczas widzieliśmy.
    Działa ona następująco:
<ul class="doclist">
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest większe od <span class="inlinecode">100</span>, to zwróć <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">10</span>

</li>
<li> w przeciwnym wypadku wywołaj rekurencyjnie <span class="inlinecode"><span class="id" title="var">f</span></span> na <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11</span>, a następnie
      wywołaj <span class="inlinecode"><span class="id" title="var">f</span></span> na wyniku tamtego wywołania. 
</li>
</ul>

<div class="paragraph"> </div>

 Taka rekursja jest oczywiście nielegalna: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11</span> nie jest strukturalnym
    podtermem <span class="inlinecode"><span class="id" title="var">n</span></span>, gdyż jest od niego większe, zaś <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> w ogóle nie
    wiadomo a priori, jak się ma do <span class="inlinecode"><span class="id" title="var">n</span></span>. Nie dziwota więc, że Coq odrzuca
    powyższą definicję.

<div class="paragraph"> </div>

    Być może wobec tego taka "funkcja" w ogóle nie jest funkcją, a definicja
    jest wadliwa? Otóż nie tym razem. Okazuje się bowiem, że istnieje funkcja
    zachowująca się zgodnie z zawartym w definicji równaniem. Żebyśmy mogli
    w to uwierzyć, zastanówmy się, ile wynosi <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">100</span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">100</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">111)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">101</span> <span class="inlinecode">=</span> <span class="inlinecode">101</span> <span class="inlinecode">-</span> <span class="inlinecode">10</span> <span class="inlinecode">=</span> <span class="inlinecode">91</span> - poszło gładko. A co z <span class="inlinecode">99</span>?
    Mamy <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">99</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">110)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">100</span> <span class="inlinecode">=</span> <span class="inlinecode">91</span> - znowu 91, czyżby spiseg? Dalej:
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">98</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">109)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">99</span> <span class="inlinecode">=</span> <span class="inlinecode">91</span> - tak, to na pewno spiseg. Teraz możemy
    zwerbalizować nasze domysły: jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode">100</span>, to <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">91</span>. Jak
    widać, nieprzypadkowo funkcja ta bywa też nazywana "funkcją 91
    McCarthy'ego".

<div class="paragraph"> </div>

    Czy da się tę funkcję zaimplementować w Coqu? Jeszcze jak! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f_troll</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;=? 100 <span class="id" title="keyword">then</span> 91 <span class="id" title="keyword">else</span> <span class="id" title="var">n</span> - 10.<br/>

<br/>
</div>

<div class="doc">
Ehhh... nie tego się spodziewałeś, prawda? <span class="inlinecode"><span class="id" title="var">f_troll</span></span> jest wprawdzie
    implementacją opisanej powyżej nieformalnie funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>, ale definicja
    opiera się na tym, że z góry wiemy, jaki jest wynik <span class="inlinecode"><span class="id" title="var">f</span></span> dla dowolnego
    argumentu. Nie trzeba chyba tłumaczyć, że dla żadnej ciekawej funkcji
    nie będziemy posiadać takiej wiedzy (a sama funkcja McCarthy'ego nie
    jest ciekawa, bo jest sztuczna, ot co!).

<div class="paragraph"> </div>

    Czy więc da się zaimplementować <span class="inlinecode"><span class="id" title="var">f</span></span> bezpośrednio, tzn. w sposób dokładnie
    oddający definicję nieformalną? Otóż tak, da się i to w sumie niewielkim
    kosztem: wystarczy jedynie nieco zmodyfikować naszą metodę induktywnej
    dziedziny. Zanim jednak to zrobimy, zobaczmy, dlaczego nie obejdzie się
    bez modyfikacji. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">fD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">fD_gt100</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">fD_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;= 100 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11) -&gt; <span class="id" title="var">fD</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)) -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;reference&nbsp;f&nbsp;was&nbsp;not&nbsp;found&nbsp;in&nbsp;the&nbsp;current&nbsp;environment.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
A oto i źródło całego problemu. Jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode">100</span>, to chcemy zrobić dwa
    wywołania rekurencyjne: jedno na <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11</span>, a drugie na <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span>.
    Wobec tego należenie tych dwóch argumentów do dziedziny jest warunkiem
    należenia <span class="inlinecode"><span class="id" title="var">n</span></span> do dziedziny i stąd postać całego konstruktora.

<div class="paragraph"> </div>

    Niestety, definicja jest zła - <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> nie jest poprawnym termem,
    gdyż <span class="inlinecode"><span class="id" title="var">f</span></span> nie jest jeszcze zdefiniowane. Mamy więc błędne koło: żeby
    zdefiniować <span class="inlinecode"><span class="id" title="var">f</span></span>, musimy zdefiniować predykat dziedziny <span class="inlinecode"><span class="id" title="var">fD</span></span>, ale żeby
    zdefiniować <span class="inlinecode"><span class="id" title="var">fD</span></span>, musimy zdefiniować <span class="inlinecode"><span class="id" title="var">f</span></span>.

<div class="paragraph"> </div>

    Jak wyrwać się z tego błędnego koła? Ratunek przychodzi ze strony być
    może nieoczekiwanej, ale za to już bardzo dobrze przez nas poznanej, a
    jest nim induktywna definicja wykresu. Tak tak - w definicji <span class="inlinecode"><span class="id" title="var">fD</span></span> możemy
    (a nawet musimy) zastąpić wystąpienia <span class="inlinecode"><span class="id" title="var">f</span></span> przez wystąpienia wykresu <span class="inlinecode"><span class="id" title="var">f</span></span>.

<div class="paragraph"> </div>

    Hej ho, po przykład by się szło. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">fG</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">fG_gt100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">fG</span> <span class="id" title="var">n</span> (<span class="id" title="var">n</span> - 10)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">fG_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &lt;= 100 -&gt; <span class="id" title="var">fG</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">r1</span> -&gt; <span class="id" title="var">fG</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span> -&gt; <span class="id" title="var">fG</span> <span class="id" title="var">n</span> <span class="id" title="var">r2</span>.<br/>

<br/>
</div>

<div class="doc">
Tak wygląda wykres funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>. Wywołanie rekurencyjne <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span>
    możemy zareprezentować jako dwa argumenty, mianowicie <span class="inlinecode"><span class="id" title="var">fG</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="var">r1</span></span>
    i <span class="inlinecode"><span class="id" title="var">fG</span></span> <span class="inlinecode"><span class="id" title="var">r1</span></span> <span class="inlinecode"><span class="id" title="var">r2</span></span>. Dosłownie odpowiada to wywołaniu rekurencyjnemu w stylu
    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">r1</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">r2</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">r1</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">r2</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fG_det</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fG</span> <span class="id" title="var">n</span> <span class="id" title="var">r1</span> -&gt; <span class="id" title="var">fG</span> <span class="id" title="var">n</span> <span class="id" title="var">r2</span> -&gt; <span class="id" title="var">r1</span> = <span class="id" title="var">r2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="tactic">until</span> 1. <span class="id" title="var">revert</span> <span class="id" title="var">r2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">Hr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hr</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hr</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">r1</span> = <span class="id" title="var">r0</span>) <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<span class="id" title="var">IHfG1</span> <span class="id" title="var">_</span> <span class="id" title="var">H3</span>); <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">IHfG2</span> <span class="id" title="var">_</span> <span class="id" title="var">H4</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Po zdefiniowaniu wykresu dowodzimy, podobnie łatwo jak poprzednio, że
    jest on relacją deterministyczną.
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">fD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">fD_gt100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">fD_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;= 100 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fG</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">r</span> -&gt; <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11) -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
A tak wygląda definicja predykatu dziedziny. Zamiast <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11))</span>
    mamy <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>, gdyż <span class="inlinecode"><span class="id" title="var">r</span></span> na mocy argumentu <span class="inlinecode"><span class="id" title="var">fG</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="var">r</span></span> reprezentuje
    wynik wywołania rekurencyjnego <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">f'</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">fD_gt100</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">n</span> - 10<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">fD_le100</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">d2</span> =&gt; <span class="id" title="var">f'</span> <span class="id" title="var">d2</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji pomocniczej <span class="inlinecode"><span class="id" title="var">f'</span></span> może być nieco zaskakująca: gdzie
    podziało się zagnieżdżone wywołanie rekurencyjne? Nie możemy jednak
    dać się zmylić przeciwnikowi. Ostatnią klauzulę dopasowania do wzorca
    możemy zapisać jako <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">fD_le100</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">d1</span></span> <span class="inlinecode"><span class="id" title="var">d2</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">f'</span></span> <span class="inlinecode"><span class="id" title="var">d2</span></span>. Widzimy, że
    <span class="inlinecode"><span class="id" title="var">d2</span></span> jest typu <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>, ale <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">fG</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="var">r</span></span>, więc możemy myśleć,
    że <span class="inlinecode"><span class="id" title="var">r</span></span> to tak naprawdę <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span>, a zatem <span class="inlinecode"><span class="id" title="var">d2</span></span> tak naprawdę jest
    typu <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11))</span>. Jeżeli dodatkowo napiszemy wprost domyślny
    argument <span class="inlinecode"><span class="id" title="var">f'</span></span>, to wywołanie rekurencyjne miałoby postać
    <span class="inlinecode">@<span class="id" title="var">f'</span></span> <span class="inlinecode">(@<span class="id" title="var">f'</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="var">d1</span>)</span> <span class="inlinecode"><span class="id" title="var">d2</span></span>, a więc wszystko się zgadza. Żeby jednak
    nie rzucać słów na wiatr, udowodnijmy to. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f'_correct</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>), <span class="id" title="var">fG</span> <span class="id" title="var">n</span> (<span class="id" title="var">f'</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">econstructor</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">IHd1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">r</span> = <span class="id" title="var">f'</span> <span class="id" title="var">d1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">fG_det</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span> + 11); <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód twierdzenia o poprawności jest tylko odrobinkę trudniejszy niż
    ostatnio, gdyż w przypadku wystąpienia w kontekście dwóch hipotez o
    typie <span class="inlinecode"><span class="id" title="var">fG</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="var">_</span></span> musimy użyć twierdzenia o determinizmie wykresu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f'_complete</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fG</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">f'</span> <span class="id" title="var">d</span> = <span class="id" title="var">r</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">fG_det</span> <span class="id" title="keyword">with</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f'_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód twierdzenia o pełności pozostaje bez zmian. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fG_le100_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fG</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">n</span> &lt;= 100 -&gt; <span class="id" title="var">r</span> = 91.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">n</span> = 100) <span class="id" title="tactic">by</span> <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f'_le100</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &lt;= 100 -&gt; <span class="id" title="var">f'</span> <span class="id" title="var">d</span> = 91.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">fG_le100_spec</span> <span class="id" title="keyword">with</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f'_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f'_ge100</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">f'</span> <span class="id" title="var">d</span> = <span class="id" title="var">n</span> - 10.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz następuje mały twist. Udowodnienie, że każdy argument spełnia
    <span class="inlinecode"><span class="id" title="var">fD</span></span> będzie piekielnie trudne i będziemy w związku z tym potrzebować
    charakteryzacji funkcji <span class="inlinecode"><span class="id" title="var">f'</span></span>. Zaczynamy więc od udowodnienia, że dla
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode">100</span> wynikiem jest <span class="inlinecode">91</span>. Najpierw robimy to na wykresie, bo tak
    jest łatwiej, a potem transferujemy wynik na funkcję. Charakteryzację
    dla <span class="inlinecode">100</span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> dostajemy wprost z definicji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fD_all</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">fD</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =&gt; 101 - <span class="id" title="var">n</span> &lt; 101 - <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">wf_inverse_image</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">wf_lt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> <span class="id" title="var">n</span> 100).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11)) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>; <span class="id" title="var">lia</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">fD_le100</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">f'</span> <span class="id" title="var">d</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f'_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">d</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_ge100</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_le100</span>; <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód jest przez indukcję dobrze ufundowaną po <span class="inlinecode"><span class="id" title="var">n</span></span>, a relacja dobrze
    ufundowana, której używamy, to <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">101</span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">101</span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Dlaczego akurat taka? Przypomnijmy sobie, jak dokładnie oblicza się
    funkcja <span class="inlinecode"><span class="id" title="var">f</span></span>, np. dla <span class="inlinecode">95</span>:

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">95</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">106)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">96</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">107)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">97</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">108)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">98</span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">109)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">99</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">110)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">100</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">111)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">101</span> <span class="inlinecode">=</span> <span class="inlinecode">91</span>.

<div class="paragraph"> </div>

    Jak więc widać, im dalej w las, tym bardziej zbliżamy się do magicznej
    liczby <span class="inlinecode">101</span>. Wyrażenie <span class="inlinecode">101</span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">n</span></span> mówi nam, jak blisko przekroczenia
    <span class="inlinecode">101</span> jesteśmy, a więc <span class="inlinecode">101</span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">101</span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">m</span></span> oznacza, że każde wywołanie
    rekurencyjne musi być bliżej <span class="inlinecode">101</span> niż poprzednie wywołanie. Oczywiście
    zamiast <span class="inlinecode">101</span> może być dowolna większa liczba - jeżeli zbliżamy się do
    <span class="inlinecode">101</span>, to zbliżamy się także do <span class="inlinecode">1234567890</span>.

<div class="paragraph"> </div>

    Dowód dobrego ufundowania jest banalny, ale tylko pod warunkiem, że
    zrobiłeś wcześniej odpowiednie ćwiczenie. Jeszcze jedna uwaga: jak
    wymyślić relację dobrze ufundowaną, jeżeli jest nam potrzebna przy
    dowodzie takim jak ten? Mógłbym ci tutaj naopowiadać frazesów o...
    w sumie nie wiem o czym, ale prawda jest taka, że nie wiem, jak się
    je wymyśla. Tej powyższej wcale nie wymyśliłem sam - znalazłem ją w
    świerszczyku dla bystrzaków.

<div class="paragraph"> </div>

    Dobra, teraz właściwa część dowodu. Zaczynamy od analizy przypadków.
    Drugi przypadek, gdy <span class="inlinecode">100</span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, jest bardzo łatwy. W pierwszym zaś
    przypadku z hipotezy indukcyjnej dostajemy <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span>, tzn.
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11</span> należy do dziedziny. Skoro tak, to używamy konstruktora
    <span class="inlinecode"><span class="id" title="var">fD_le100</span></span>, a jako <span class="inlinecode"><span class="id" title="var">r</span></span> (czyli wynik wywołania rekurencyjnego) dajemy
    mu <span class="inlinecode"><span class="id" title="var">f'</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span>.

<div class="paragraph"> </div>

    Dwa podcele zachodzą na mocy założenia, a jedna wynika z twierdzenia
    o poprawności. Pozostaje nam zatem pokazać, że <span class="inlinecode"><span class="id" title="var">f'</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span> także należy do
    dziedziny. W tym celu po raz kolejny używamy hipotezy indukcyjnej. Na
    zakończenie robimy analizę przypadków po <span class="inlinecode"><span class="id" title="var">d</span></span>, używamy charakteryzacji
    <span class="inlinecode"><span class="id" title="var">f'</span></span> do uproszczenia celu i kończymy rozumowaniami arytmetycznymi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">f'</span> (<span class="id" title="var">fD_all</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="comment">(*&nbsp;Compute&nbsp;f&nbsp;110.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Teraz możemy zdefiniować oryginalne <span class="inlinecode"><span class="id" title="var">f</span></span>. Niestety, funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> się nie
    oblicza i nie wiem nawet dlaczego. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_correct</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">fG</span> <span class="id" title="var">n</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f'_correct</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_complete</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fG</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">f</span> <span class="id" title="var">n</span> = <span class="id" title="var">r</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f'_complete</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_91</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &lt;= 100 -&gt; <span class="id" title="var">f</span> <span class="id" title="var">n</span> = 91.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f'_le100</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Twierdzenia o poprawności i pełności oraz charakteryzacja dla <span class="inlinecode"><span class="id" title="var">f</span></span>
    wynikają za darmo z odpowiednich twierdzeń dla <span class="inlinecode"><span class="id" title="var">f'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H_gt100</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">n</span> - 10))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;= 100 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">n</span> + 11) (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)) -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)) (<span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">fG_ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f_complete</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">f_complete</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H_le100</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f_correct</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Reguły indukcji wykresowej dowodzimy tak samo jak poprzednio, czyli za
    pomocą twierdzeń o pełności i poprawności. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">n</span> = <span class="id" title="keyword">if</span> 100 &lt;? <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">n</span> - 10 <span class="id" title="keyword">else</span> <span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">fG_det</span> <span class="id" title="keyword">with</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ltb</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">Nat.leb_spec0</span> 101 <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">econstructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f_correct</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Na koniec również mały twist, gdyż równanie rekurencyjne najprościej jest
    udowodnić za pomocą właściwości wykresu funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> - jeśli nie wierzysz,
    to sprawdź (ale będzie to bardzo bolesne sprawdzenie).

<div class="paragraph"> </div>

    Podsumowując: zarówno oryginalna metoda induktywnej dziedziny jak i
    komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> nie radzą sobie z zagnieżdżonymi wywołaniami
    rekurencyjmi, czyli takimi, w których argumentem jest wynik innego
    wywołania rekurencyjnego. Możemy jednak poradzić sobie z tym problemem
    za pomocą ulepszonej metody induktywnej dziedziny, w której funkcję w
    definicji predykatu dziedziny reprezentujemy za pomocą jej induktywnie
    zdefiniowanego wykresu. 
<div class="paragraph"> </div>

<a id="lab389"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Przyjrzyjmy się poniższej fikuśnej definicji funkcji: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">g</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">g</span> (<span class="id" title="var">g</span> <span class="id" title="var">n</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Wytłumacz, dlaczego Coq nie akceptuje tej definicji. Następnie wymyśl
    twierdzenie charakteryzujące tę funkcję, a na koniec zdefiniuj ją za
    pomocą metody zaprezentowanej w tym podrozdziale. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">McCarthy</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab390"></a><h1 class="section">Metoda induktywno-rekurencyjnej dziedziny</h1>

<div class="paragraph"> </div>

 Zapoznawszy się z metodą induktywnej dziedziny i jej ulepszoną wersją,
    która potrafi poskromić nawet rekursję zagnieżdżoną, dobrze byłoby na
    koniec podumać sobie trochę, co by było gdyby... Coq raczył wspierać
    indukcję-rekursję?

<div class="paragraph"> </div>

    Ano, trochę ułatwiłoby to nasze nędzne życie, gdyż metoda induktywnej
    dziedziny przepoczwarzyłaby się w metodę induktywno-rekurencyjnej
    dziedziny: dzięki indukcji-rekursji moglibyśmy jednocześnie zdefiniować
    funkcję (nawet taką, w której jest rekursja zagnieżdżona) jednocześnie
    z jej predykatem dziedziny, co oszczędziłoby nam nieco pisania.

<div class="paragraph"> </div>

    Zobaczmy, jak to wygląda na przykładzie funkcji McCarthy'ego. Ponieważ
    Coq jednak nie wspiera indukcji-rekursji, będziemy musieli użyć kodowania
    aksjomatycznego, co zapewne nieco umniejszy atrakcyjności tej metody. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">McCarthy'</span>.<br/>

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;fD&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;fD_gt100&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;100&nbsp;&lt;&nbsp;n&nbsp;-&gt;&nbsp;fD&nbsp;n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;fD_le100&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;100&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;d&nbsp;:&nbsp;fD&nbsp;(n&nbsp;+&nbsp;11),&nbsp;fD&nbsp;(f'&nbsp;(n&nbsp;+&nbsp;11)&nbsp;d)&nbsp;-&gt;&nbsp;fD&nbsp;n<br/>
<br/>
with&nbsp;Fixpoint&nbsp;f'&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(d&nbsp;:&nbsp;fD&nbsp;n)&nbsp;:&nbsp;nat&nbsp;:=<br/>
match&nbsp;d&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;fD_gt100&nbsp;n&nbsp;H&nbsp;=&gt;&nbsp;n&nbsp;-&nbsp;10<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;fD_le100&nbsp;n&nbsp;H&nbsp;d1&nbsp;d2&nbsp;=&gt;&nbsp;f'&nbsp;(f'&nbsp;(n&nbsp;+&nbsp;11)&nbsp;d1)&nbsp;d2<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Tak wyglądałoby induktywno-rekurencyjna definicja zmodyfikowanej funkcji
    <span class="inlinecode"><span class="id" title="var">f'</span></span> wraz z jej dziedziną. Ponieważ w definicji <span class="inlinecode"><span class="id" title="var">fD</span></span> możemy napisać po
    prostu <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">11)</span> <span class="inlinecode"><span class="id" title="var">d</span>)</span>, wykres nie jest nam do niczego potrzebny.
    Definicja funkcji wygląda dokładnie tak samo jak ostatnio. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variables</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">fD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">fD</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">fD_gt100</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">fD_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;= 100 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">d</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11), <span class="id" title="var">fD</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d</span>) -&gt; <span class="id" title="var">fD</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f'_eq1</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : 100 &lt; <span class="id" title="var">n</span>), <span class="id" title="var">f'</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_gt100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>) = <span class="id" title="var">n</span> - 10)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f'_eq2</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> &lt;= 100)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">d1</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11)) (<span class="id" title="var">d2</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f'</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_le100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span>) = <span class="id" title="var">f'</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>) <span class="id" title="var">d2</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">fD_ind</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">fD</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P_gt100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : 100 &lt; <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_gt100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> &lt;= 100)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">d1</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11)) (<span class="id" title="var">d2</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>) <span class="id" title="var">d2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_le100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>), <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">d</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : 100 &lt; <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_gt100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>) = <span class="id" title="var">P_gt100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> &lt;= 100)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">d1</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11)) (<span class="id" title="var">d2</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_le100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P_le100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">g</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">g</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>) <span class="id" title="var">d2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).<br/>

<br/>
</div>

<div class="doc">
Aksjomatyczne kodowanie tej definicji działa tak, jak nauczyliśmy się
    w poprzednim rozdziale: najpierw deklarujemy <span class="inlinecode"><span class="id" title="var">fD</span></span>, potem <span class="inlinecode"><span class="id" title="var">f</span></span>, potem
    konstruktory <span class="inlinecode"><span class="id" title="var">fD</span></span>, potem równania definiujące <span class="inlinecode"><span class="id" title="var">f</span></span>, a na samym końcu
    regułę indukcji.

<div class="paragraph"> </div>

    Reguła indukcji powstaje analogicznie jak dla <span class="inlinecode"><span class="id" title="var">slist</span></span> z poprzedniego
    rozdziału. Definiujemy tylko jedną rodzinę typów <span class="inlinecode"><span class="id" title="var">fD</span></span>, więc reguła
    da nam tylko jedną funkcję, <span class="inlinecode"><span class="id" title="var">g</span></span>, o typie <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">(<span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode"><span class="id" title="var">n</span>),</span>
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> reprezentuje
    przeciwdziedzinę <span class="inlinecode"><span class="id" title="var">g</span></span>.

<div class="paragraph"> </div>

    Mamy dwa przypadki: nieindukcyjny <span class="inlinecode"><span class="id" title="var">P_gt100</span></span> odpowiadający konstruktorowi
    <span class="inlinecode"><span class="id" title="var">fD_gt100</span></span> oraz <span class="inlinecode"><span class="id" title="var">P_le100</span></span> odpowiadający za <span class="inlinecode"><span class="id" title="var">fD_le100</span></span>, w którym mamy do
    dyspozycji dwie hipotezy indukcyjne. Otrzymana z reguły funkcja spełnia
    oczekiwane równania. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fD_inv</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">H</span> : 100 &lt; <span class="id" title="var">n</span> | <span class="id" title="var">d</span> = <span class="id" title="var">fD_gt100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>} +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">H</span> : <span class="id" title="var">n</span> &lt;= 100 &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">d1</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">d2</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">f'</span> (<span class="id" title="var">n</span> + 11) <span class="id" title="var">d1</span>) | <span class="id" title="var">d</span> = <span class="id" title="var">fD_le100</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span>}}}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">fD_ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">H</span>, <span class="id" title="var">d1</span>, <span class="id" title="var">d2</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Będziemy też chcieli używać <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> na hipotezach postaci <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    ale <span class="inlinecode"><span class="id" title="var">fD</span></span> nie jest induktywne (tylko aksjomatyczne), więc musimy
    pożądaną przez nas inwersję zamknąć w lemat. Dowodzimy go oczywiście
    za pomocą reguły indukcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &lt;= 100 -&gt; <span class="id" title="var">f'</span> <span class="id" title="var">n</span> <span class="id" title="var">d</span> = 91.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">fD_ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> <span class="id" title="var">d</span> =&gt; <span class="id" title="var">n</span> &lt;= 100 -&gt; <span class="id" title="var">f'</span> <span class="id" title="var">n</span> <span class="id" title="var">d</span> = 91)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">H'</span>. <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span> <span class="id" title="var">IH1</span> <span class="id" title="var">IH2</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">fD_inv</span> <span class="id" title="var">_</span> <span class="id" title="var">d1</span>) <span class="id" title="keyword">as</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[<span class="id" title="var">H'</span> <span class="id" title="var">eq</span>] | (<span class="id" title="var">H'</span> &amp; <span class="id" title="var">d1'</span> &amp; <span class="id" title="var">d2'</span> &amp; <span class="id" title="var">eq</span>)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">fD_inv</span> <span class="id" title="var">_</span> <span class="id" title="var">d2</span>) <span class="id" title="keyword">as</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[<span class="id" title="var">H''</span> <span class="id" title="var">eq'</span>] | (<span class="id" title="var">H''</span> &amp; <span class="id" title="var">d1''</span> &amp; <span class="id" title="var">d2''</span> &amp; <span class="id" title="var">eq'</span>)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq2</span>, <span class="id" title="var">eq'</span>, <span class="id" title="var">f'_eq1</span>, <span class="id" title="var">eq</span>, <span class="id" title="var">f'_eq1</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">IH1</span> <span class="id" title="var">eq</span> <span class="id" title="var">eq'</span> <span class="id" title="var">H'</span> <span class="id" title="var">H''</span>. <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq2</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH2</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq2</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH2</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Możemy też udowodnić charakteryzację funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>. Dowód wygląda dużo
    groźniej niż ostatnio, ale to wszystko wina narzutu związanego z
    aksjomatycznym kodowaniem.

<div class="paragraph"> </div>

    Dowód idzie tak: najpierw używamy indukcji, a potem naszego inwersjowego
    lematu na hipotezach postaci <span class="inlinecode"><span class="id" title="var">fD</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>. W kluczowych momentach obliczamy
    funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> za pomocą definiujących ją równań oraz posługujemy się
    taktyką <span class="inlinecode"><span class="id" title="var">lia</span></span> do przemielenia oczywistych, ale skomplikowanych
    formalnie faktów z zakresu arytmetyki liczb naturalnych. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fD_all</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">fD</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =&gt; 101 - <span class="id" title="var">n</span> &lt; 101 - <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">wf_inverse_image</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">wf_lt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> <span class="id" title="var">n</span> 100).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">d</span> : <span class="id" title="var">fD</span> (<span class="id" title="var">n</span> + 11)) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>; <span class="id" title="var">lia</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">fD_le100</span> <span class="id" title="keyword">with</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">fD_inv</span> <span class="id" title="var">_</span> <span class="id" title="var">d</span>) <span class="id" title="keyword">as</span> [[<span class="id" title="var">H</span> <span class="id" title="var">eq</span>] | [<span class="id" title="var">H</span> <span class="id" title="var">_</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq</span>, <span class="id" title="var">f'_eq1</span>. <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f_spec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">fD_gt100</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód tego, że wszystkie argumenty spełniają predykat dziedziny, jest
    taki sam jak ostatnio. Jedyna różnica jest taka, że zamiast <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    musimy ręcznie aplikować <span class="inlinecode"><span class="id" title="var">fD_inv</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">f'</span> <span class="id" title="var">n</span> (<span class="id" title="var">fD_all</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">f</span> 42.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;f'&nbsp;42&nbsp;(fD_all&nbsp;42)&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Mając <span class="inlinecode"><span class="id" title="var">f'</span></span> oraz dowód <span class="inlinecode"><span class="id" title="var">fD_all</span></span> możemy zdefiniować <span class="inlinecode"><span class="id" title="var">f</span></span>, które niestety
    się nie oblicza, gdyż <span class="inlinecode"><span class="id" title="var">f'</span></span> jest dane aksjomatycznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f'_ext</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d1</span> <span class="id" title="var">d2</span> : <span class="id" title="var">fD</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f'</span> <span class="id" title="var">n</span> <span class="id" title="var">d1</span> = <span class="id" title="var">f'</span> <span class="id" title="var">n</span> <span class="id" title="var">d2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">fD_ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">d1</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">d2</span>, <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq1</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">fD_inv</span> <span class="id" title="var">_</span> <span class="id" title="var">d2</span>) <span class="id" title="keyword">as</span> [[<span class="id" title="var">H'</span> <span class="id" title="var">eq</span>] | [<span class="id" title="var">H'</span> <span class="id" title="var">_</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq</span>, <span class="id" title="var">f'_eq1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq2</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">fD_inv</span> <span class="id" title="var">_</span> <span class="id" title="var">d0</span>) <span class="id" title="keyword">as</span> [[<span class="id" title="var">H'</span> <span class="id" title="var">eq</span>] | (<span class="id" title="var">H'</span> &amp; <span class="id" title="var">d1'</span> &amp; <span class="id" title="var">d2'</span> &amp; <span class="id" title="var">eq</span>)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq2</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H0</span> <span class="id" title="var">d1'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby udowodnić regułę indukcyjną, potrzebny nam będzie lemat mówiacy,
    że konkretny dowód tego, że <span class="inlinecode"><span class="id" title="var">n</span></span> spełnia predykat dziedziny <span class="inlinecode"><span class="id" title="var">fD</span></span>, nie
    wpływa na wynik obliczany przez <span class="inlinecode"><span class="id" title="var">f'</span></span>. Dowód jest prosty: używamy
    indukcji po <span class="inlinecode"><span class="id" title="var">d1</span></span>, a następnie inwersji po pozostałych hipotezach,
    przepisujemy równania definiujące <span class="inlinecode"><span class="id" title="var">f'</span></span> i kończymy za pomocą rozumowań
    arytmetycznych albo hipotezy indukcyjnej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P_gt100</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 100 &lt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">n</span> - 10))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P_le100</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;= 100 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">n</span> + 11) (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)) (<span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">f</span> (<span class="id" title="var">f</span> (<span class="id" title="var">n</span> + 11)))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">fD_ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> <span class="id" title="var">d</span> =&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">f'</span> <span class="id" title="var">n</span> <span class="id" title="var">d</span>))); <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq1</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">P_gt100</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">f'_eq2</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">P_le100</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span> <span class="id" title="tactic">in</span> <span class="id" title="var">P_le100</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> !(<span class="id" title="var">f'_ext</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">d1</span>), !(<span class="id" title="var">f'_ext</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">d2</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">P_le100</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">P_le100</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód samej reguły też jest dość prosty. Zaczynamy od indukcji po
    dowodzie faktu, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> spełnia predykat dziedziny <span class="inlinecode"><span class="id" title="var">fD</span></span> (którym
    to dowodem jest <span class="inlinecode"><span class="id" title="var">fD_all</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, a który schowany jest w definicji <span class="inlinecode"><span class="id" title="var">f</span></span>).
    W przypadku nierekurencyjnym przepisujemy równanie definiujące <span class="inlinecode"><span class="id" title="var">f'</span></span>
    i kończymy założeniem.

<div class="paragraph"> </div>

    W przypadku rekurencyjnym również zaczynamy od przepisania definicji
    <span class="inlinecode"><span class="id" title="var">f'</span></span>. Następnie korzystamy z założenia <span class="inlinecode"><span class="id" title="var">P_le100</span></span>, choć technicznie
    jest to dość skomplikowane - najpierw specjalizujemy je częściowo
    za pomocą hipotezy <span class="inlinecode"><span class="id" title="var">H</span></span>, a potem odwijamy definicję <span class="inlinecode"><span class="id" title="var">f</span></span> i dwukrotnie
    korzystamy z lematu <span class="inlinecode"><span class="id" title="var">f'_ext</span></span>, żeby typy się zgadzały. Po tej obróbce
    możemy śmiało skorzystać z <span class="inlinecode"><span class="id" title="var">P_le100</span></span> - jej przesłanki zachodzą na mocy
    założenia. 
<div class="paragraph"> </div>

<a id="lab391"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Rozwiąż jeszcze raz ćwiczenie o funkcji <span class="inlinecode"><span class="id" title="var">g</span></span> z poprzedniego podrozdziału,
    ale tym razem wykorzystaj metodę induktywno-rekurencyjnej dziedziny
    zaprezentowaną w niniejszym podrozdziale. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">g</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">g</span> (<span class="id" title="var">g</span> <span class="id" title="var">n</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">McCarthy'</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab392"></a><h1 class="section">Metoda induktywnej dziedziny 2</h1>

<div class="paragraph"> </div>

 Na koniec została nam do omówienia jeszcze jedna drobna kwestia.
    Poznając metodę induktywnej dziedziny, dowiedzieliśmy się, że
    "predykat" dziedziny tak naprawdę wcale nie jest predykatem, ale
    rodziną typów. Czas naprawić ten szkopuł.

<div class="paragraph"> </div>

    W niniejszym podrozdziale najpierw zapoznamy się (na przykładzie
    dzielenia - znowu) z wariantem metody induktywnej dziedziny, w
    którym dziedzina faktycznie jest predykatem, a na koniec podumamy,
    dlaczego powinno nas to w ogóle obchodzić. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">again</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">divD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_lt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_ge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja dziedziny jest taka sama jak ostatnio, ale z tą drobną
    różnicą, że teraz faktycznie jest to predykat.

<div class="paragraph"> </div>

    Skoro mamy dziedzinę, spróbujmy zdefiniować funkcję pomocniczą
    tak samo jak ostatnio. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div_aux</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_lt</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">divD_ge</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">d'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">div_aux</span> <span class="id" title="var">d'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incorrect&nbsp;elimination&nbsp;of&nbsp;"d"&nbsp;in&nbsp;the&nbsp;inductive&nbsp;type&nbsp;"divD":<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;return&nbsp;type&nbsp;has&nbsp;sort&nbsp;"Set"&nbsp;while&nbsp;it&nbsp;should&nbsp;be&nbsp;"Prop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elimination&nbsp;of&nbsp;an&nbsp;inductive&nbsp;object&nbsp;of&nbsp;sort&nbsp;Prop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;allowed&nbsp;on&nbsp;a&nbsp;predicate&nbsp;in&nbsp;sort&nbsp;Set<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;because&nbsp;proofs&nbsp;can&nbsp;be&nbsp;eliminated&nbsp;only&nbsp;to&nbsp;build&nbsp;proofs.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Cóż, nie da się i nie dziwota - gdyby się dało, to zrobiliśmy tak
    już na samym początku. Powód porażki jest całkiem prozaiczny -
    nie możemy definiować programów przez dopasowanie do wzorca dowodów,
    czyli parafrazując, nie możemy konstruować elementów typów sortów
    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> ani <span class="inlinecode"><span class="id" title="keyword">Type</span></span> przez eliminację elementów typów sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    Wynika to z faktu, że sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> z założenia dopuszcza możliwość
    przyjęcia aksjomatu irrelewancji dowodów (ang. proof irrelevance),
    który głosi, że wszystkie dowody danego zdania są równe. Gdybyśmy
    mogli dopasowywać do wzorca dowody zdań definiując programy,
    irrelewancja wyciekłaby do świata programów i wtedy wszystko byłoby
    równe wszystkiemu, co oczywiście daje sprzeczność.

<div class="paragraph"> </div>

    Jeżeli powyższy opis nie jest przekonujący, zobaczmy to na szybkim
    przykładzie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">proof_irrelevance_example</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool'</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true'</span> : <span class="id" title="var">bool'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false'</span> : <span class="id" title="var">bool'</span>.<br/>

<br/>
</div>

<div class="doc">
Najpierw definiujemy typ <span class="inlinecode"><span class="id" title="var">bool'</span></span>, który wygląda jak <span class="inlinecode"><span class="id" title="var">bool</span></span>, ale
    żyje w sorcie <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;<span class="id" title="var">proof_irrelevance</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">P</span>), <span class="id" title="var">p1</span> = <span class="id" title="var">p2</span>.<br/>

<br/>
</div>

<div class="doc">
Następnie przyjmujemy aksjomat irrelewancji dowodów, przez co
    <span class="inlinecode"><span class="id" title="var">bool'</span></span> staje się tym samym co zdanie <span class="inlinecode"><span class="id" title="var">True</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">bool'</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">eq1</span> : <span class="id" title="var">f</span> <span class="id" title="var">true'</span> = <span class="id" title="var">true</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">eq2</span> : <span class="id" title="var">f</span> <span class="id" title="var">false'</span> = <span class="id" title="var">false</span>).<br/>

<br/>
</div>

<div class="doc">
Załóżmy, że Coq pozwolił nam zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    która potrafi odróżnić <span class="inlinecode"><span class="id" title="var">true'</span></span> od <span class="inlinecode"><span class="id" title="var">false'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">wut</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">eq1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">proof_irrelevance</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">false'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać, <span class="inlinecode"><span class="id" title="var">true</span></span> to to samo co <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">true'</span></span>, ale <span class="inlinecode"><span class="id" title="var">true'</span></span> to <span class="inlinecode"><span class="id" title="var">false'</span></span>
    na mocy irrelewancji, a <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">false'</span></span> to przecież <span class="inlinecode"><span class="id" title="var">false</span></span>. Konkluzja:
    prawda to fałsz, a tego zdecydowanie nie chcemy. Żeby uniknąć
    sprzeczności, nie wolno definiować programów przez eliminację zdań.

<div class="paragraph"> </div>

    Od powyższej zasady są jednak wyjątki, mianowicie przy konstrukcji
    programów wolno eliminować dowody zdań, które:
<ul class="doclist">
<li> nie mają konstruktorów, np. <span class="inlinecode"><span class="id" title="var">False</span></span>

</li>
<li> mają jeden konstruktor, którego wszystkie argumenty również są
      dowodami zdań

</li>
</ul>

<div class="paragraph"> </div>

    Powyższy wyjątek od reguły nazywa się "eliminacją singletonów" i
    jest zupełnie niegroźny, gdyż dla takich zdań możemy bez żadnych
    aksjomatów udowodnić, że wszystkie ich dowody są równe. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">proof_irrelevance_example</span>.<br/>

<br/>
</div>

<div class="doc">
Dobra, koniec tej przydługiej dygresji. Wracamy do metody induktywnej
    dziedziny, gdzie dziedzina naprawdę jest predykatem. Skoro nie możemy
    zdefiniować funkcji bezpośrednio przez eliminację <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to
    jak inaczej?

<div class="paragraph"> </div>

    Tutaj ujawnia się pewna chytra sztuczka: nie możemy dopasować <span class="inlinecode"><span class="id" title="var">d</span></span> za
    pomocą <span class="inlinecode"><span class="id" title="keyword">match</span></span>a, ale wciąż możemy robić wywołania rekurencyjne na
    podtermach <span class="inlinecode"><span class="id" title="var">d</span></span>. Wystarczy więc napisać funkcję, która wyjmuje z <span class="inlinecode"><span class="id" title="var">d</span></span>
    jego podterm (oczywiście jedynie pod warunkiem, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, bo
    tylko wtedy <span class="inlinecode"><span class="id" title="var">d</span></span> będzie miało jakiś podterm). Ponieważ kodziedziną
    takiej funkcji będzie <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, dopasowanie <span class="inlinecode"><span class="id" title="var">d</span></span> do wzorca
    będzie już legalne.

<div class="paragraph"> </div>

    Brzmi... chytrze? Zobaczmy, jak wygląda to w praktyce. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divD_ge_inv</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_not_lt</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli mamy <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> i wiemy, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to <span class="inlinecode"><span class="id" title="var">d</span></span> musiało
    zostać zrobione konstruktorem <span class="inlinecode"><span class="id" title="var">divD_ge</span></span>. Możemy to udowodnić po
    prostu rozbijając <span class="inlinecode"><span class="id" title="var">d</span></span>. W pierwszym przypadkiem dostajemy sprzeczność
    arytmetyczną (bo <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> i jednocześnie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>), zaś w drugim
    wynikiem jest pożądany podterm. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div'_aux</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">right</span> <span class="id" title="var">_</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">left</span> <span class="id" title="var">H</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">div'_aux</span> (<span class="id" title="var">divD_ge_inv</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span> <span class="id" title="var">d</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby zdefiniować <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> (czyli, przypomnijmy, zmodyfikowaną wersję
    dzielenia, którego argumentem głównym jest <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, nie zaś
    samo <span class="inlinecode"><span class="id" title="var">n</span></span>), sprawdzamy najpierw, czy mamy do czynienia z przypadkiem
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czy z <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>. W pierwszym przypadku po prostu zwracamy
    <span class="inlinecode">0</span>, zaś w drugim robimy wywołanie rekurencyjne, którego argumentem
    jest <span class="inlinecode"><span class="id" title="var">divD_ge_inv</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span>.

<div class="paragraph"> </div>

    Term ten, jak się okazuje, jest uznawany przez Coqa za podterm <span class="inlinecode"><span class="id" title="var">d</span></span>,
    a więc wywołanie rekurencyjne na nim jest legalne. Dlaczego jest to
    podterm <span class="inlinecode"><span class="id" title="var">d</span></span>? Jeżeli odwiniemy definicję <span class="inlinecode"><span class="id" title="var">divD_ge_inv</span></span> i wykonamy
    występujące tam dopasowanie <span class="inlinecode"><span class="id" title="var">d</span></span> do wzorca, to wiemy, że nie może być
    ono postaci <span class="inlinecode"><span class="id" title="var">divD_lt</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>, a zatem musi być postaci
    <span class="inlinecode"><span class="id" title="var">divD_ge</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">d'</span></span> i wynikiem wykonania funkcji jest <span class="inlinecode"><span class="id" title="var">d'</span></span>, które
    faktycznie jest podtermem <span class="inlinecode"><span class="id" title="var">d</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divD_all</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">nat</span> <span class="id" title="var">lt</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_ge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ge</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_lt</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód tego, że każde <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> należą do dziedziny, jest dokładnie
    taki sam jak poprzednio. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">div'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">div'_aux</span> (<span class="id" title="var">divD_all</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">div'</span> 666 7.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;83&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Ostateczna definicja funkcji <span class="inlinecode"><span class="id" title="var">div'</span></span> również wygląda identycznie jak
    poprzednio i podobnie elegancko się oblicza, a skoro tak, to czas
    udowodnić, że wykresem <span class="inlinecode"><span class="id" title="var">div'</span></span> jest <span class="inlinecode"><span class="id" title="var">divG</span></span>. Nie musimy redefiniować
    wykresu - jest on zdefiniowany dokładnie tak samo jak ostatnio. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_div'_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'_aux</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstracting&nbsp;over&nbsp;the&nbsp;terms&nbsp;"n"&nbsp;and&nbsp;"m"&nbsp;leads&nbsp;to&nbsp;a&nbsp;term<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;n0&nbsp;m0&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;divG&nbsp;n0&nbsp;m0&nbsp;(div'_aux&nbsp;d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;is&nbsp;ill-typed.&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwsza próba dowodu kończy się zupełnie niespodziewaną porażką
    już przy pierwszym kroku, czyli próbie odpalenia indukcji po <span class="inlinecode"><span class="id" title="var">d</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">divD_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;divD_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;&gt;=&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;divD&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;divD&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;n0<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powód jest prosty: konkluzja, czyli <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">(<span class="id" title="var">div'_aux</span></span> <span class="inlinecode"><span class="id" title="var">d</span>)</span> zależy
    od <span class="inlinecode"><span class="id" title="var">d</span></span>, ale domyślna reguła indukcji wygenerowana przez Coqa, czyli
    <span class="inlinecode"><span class="id" title="var">divD_ind</span></span>, nie jest ani trochę zależna i nie dopuszcza możliwości,
    by konkluzja zależała od <span class="inlinecode"><span class="id" title="var">d</span></span>. Potrzebna jest więc nam zależna reguła
    indukcji.

<div class="paragraph"> </div>

    Na szczęście nie musimy implementować jej ręcznie - Coq potrafi
    zrobić to dla nas automatycznie (ale skoro tak, to dlaczego nie
    zrobił tego od razu? - nie pytaj, niezbadane są wyroki...). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">divD_ind'</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">divD</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Do generowania reguł indukcji służy komenda <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>. <span class="inlinecode"><span class="id" title="var">divD_ind'</span></span>
    to nazwa reguły, <span class="inlinecode"><span class="id" title="keyword">Induction</span></span> <span class="inlinecode"><span class="id" title="keyword">for</span></span> <span class="inlinecode"><span class="id" title="var">divD</span></span> mówi nam, dla jakiego typu
    lub rodziny typów chcemy regułę, zaś <span class="inlinecode"><span class="id" title="keyword">Sort</span></span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> mówi, że chcemy
    regułę, w której przeciwdziedziną motywu jest <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> (tak na
    marginesie - motyw eliminacji to typ lub rodzina typów, której
    element chcemy za pomocą eliminacji skonstruować - powinienem
    był wprowadzić tę nazwę wcześniej). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">divD_ind'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;divD_ind'&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;divD&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(l&nbsp;:&nbsp;n&nbsp;&lt;&nbsp;S&nbsp;m),&nbsp;P&nbsp;n&nbsp;m&nbsp;(divD_lt&nbsp;n&nbsp;m&nbsp;l))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(g&nbsp;:&nbsp;n&nbsp;&gt;=&nbsp;S&nbsp;m)&nbsp;(d&nbsp;:&nbsp;divD&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;d&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;(divD_ge&nbsp;n&nbsp;m&nbsp;g&nbsp;d))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(n&nbsp;n0&nbsp;:&nbsp;nat)&nbsp;(d&nbsp;:&nbsp;divD&nbsp;n&nbsp;n0),&nbsp;P&nbsp;n&nbsp;n0&nbsp;d<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, reguła wygenerowana przez komendę <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> jest zależna,
    gdyż jednym z argumentów <span class="inlinecode"><span class="id" title="var">P</span></span> jest <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n0</span></span>. Czas więc wrócić do
    dowodu faktu, że <span class="inlinecode"><span class="id" title="var">divG</span></span> jest wykresem <span class="inlinecode"><span class="id" title="var">div'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_div'_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (@<span class="id" title="var">div'_aux</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span> <span class="id" title="keyword">using</span> <span class="id" title="var">divD_ind'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">div'_aux</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">div'_aux</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">IHd</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcję z użyciem innej niż domyślna reguły możemy zrobić za
    pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">divD_ind'</span></span>. Tym razem reguła
    jest wystarczająco ogólna, więc indukcja się udaje.

<div class="paragraph"> </div>

    Następnym krokiem w obu przypadkach jest odwinięcie definicji
    <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> i sprawdzenie, czy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czy może <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Taki sposób postępowania jest kluczowy, gdyż próba użycia tu
    taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> skończyłaby się katastrofą - zamiast uprościć
    cel, wyprulibyśmy z niego flaki, które zalałyby nam ekran, a
    wtedy nawet przeczytanie celu byłoby trudne. Jeżeli nie
    wierzysz, spróbuj.

<div class="paragraph"> </div>

    Mamy więc dowód poprawności <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> względem wykresu. Wszystkie
    pozostałe dowody przechodzą bez zmian, więc nie będziemy ich tutaj
    powtarzać. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">again</span>.<br/>

<br/>
</div>

<div class="doc">
Do rozstrzygnięcia pozostaje nam ostatnia już kwestia - po cholerę
    w ogóle bawić się w coś takiego? Powyższe trudności z eliminacją
    <span class="inlinecode"><span class="id" title="var">d</span></span>, dowodzeniem lematów wyciągających z <span class="inlinecode"><span class="id" title="var">d</span></span> podtermy, dowodzeniem
    przez indukcję po <span class="inlinecode"><span class="id" title="var">d</span></span>, generowaniem lepszych reguł indukcyjnych i
    unikaniem użycia taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> powinny jako żywo uzmysłowić nam,
    że uczynienie dziedziny <span class="inlinecode"><span class="id" title="var">divD</span></span> prawdziwym predykatem było raczej
    upośledzonym pomysłem.

<div class="paragraph"> </div>

    Odpowiedź jest krótka i mało przekonująca, a jest nią mechanizm
    ekstrakcji. Cóż to takiego? Otóż Coq dobrze sprawdza się przy
    definiowaniu programów i dowodzeniu ich właściwości, ale raczej
    słabo w ich wykonywaniu (komendy <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> czy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> są dość
    kiepskie).

<div class="paragraph"> </div>

    Mechanizm ekstrakcji to coś, co nas z tej nędzy trochę ratuje: daje
    on nam możliwość przetłumaczenia naszego programu w Coqu na program
    w jakimś nieco bardziej mainstreamowym języku funkcyjnym (jak OCaml,
    Haskell czy Scheme), w których programy da się normalnie odpalać i
    działają nawet szybko.

<div class="paragraph"> </div>

    Mechanizm ten nie będzie nas interesował, ponieważ moim zdaniem jest
    on ślepą uliczką ewolucji - zamiast niego trzeba będzie po prostu
    wymyślić sposób efektywnej kompilacji Coqowych programow, ale to już
    temat na inną bajkę.

<div class="paragraph"> </div>

    Nie będziemy zatem zbytnio zagłębiać się w szczegóły ekstrakcji -
    zanim zupełnie o niej zapomnimy, zobaczmy tylko jeden przykład. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">Language</span> <span class="id" title="var">Haskell</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Extraction</span></span> <span class="inlinecode"><span class="id" title="var">Language</span></span> ustawia język, do którego chcemy
    ekstrahować. My użyjemy Haskella, gdyż pozostałych dostępnych
    języków nie lubię. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">again.div'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div'&nbsp;::&nbsp;Nat&nbsp;-&gt;&nbsp;Nat&nbsp;-&gt;&nbsp;Nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div'&nbsp;=&nbsp;div'_aux&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Extraction</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> tłumaczy Coqowy program <span class="inlinecode"><span class="id" title="var">p</span></span> na program
    Haskellowy. Mimo że nie znamy Haskella, spróbujmy przeczytać
    wynikowy program.

<div class="paragraph"> </div>

    Wynikiem ekstrakcji jest Haskellowa funkcja <span class="inlinecode"><span class="id" title="var">div'</span></span> o typie
    <span class="inlinecode"><span class="id" title="var">Nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Nat</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">Nat</span></span> to Haskellowa wersja Coqowego <span class="inlinecode"><span class="id" title="var">nat</span></span>
    (podwójny dwukropek <span class="inlinecode">::</span> oznacza w Haskellu to samo, co pojedynczy
    dwukropek <span class="inlinecode">:</span> w Coqu). Funkcja <span class="inlinecode"><span class="id" title="var">div'</span></span> jest zdefiniowana jako... i tu
    zaskoczenie... <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>. Ale jak to? Rzućmy jeszcze raz okiem na
    oryginalną, Coqową definicję. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">again.div'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;again.div'&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;n&nbsp;m&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;again.div'_aux&nbsp;(again.divD_all&nbsp;n&nbsp;m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Gdzież w wyekstrahowanym programie podział się dowód <span class="inlinecode"><span class="id" title="var">divD_all</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>?
    Otóż nie ma go, bo Haskell to zwykły język programowania, w którym
    nie można dowodzić. O to właśnie chodzi w mechanizmie ekstrakcji -
    w procesie ekstrakcji wyrzucić z Coqowego programu wszystkie dowody
    i przetłumaczyć tylko tę część programu, która jest niezbędna, by
    wyekstrahowany program się obliczał.

<div class="paragraph"> </div>

    Mogłoby się wydawać dziwne, że najpierw w pocie czoła dowodzimy czegoś
    w Coqu, a potem mechanizm ekstrakcji się tego pozbywa. Jest to jednak
    całkiem naturalne - skoro udało nam się udowodnić jakąś właściwość
    naszego programu, to wiemy, że ma on tę właściwość i dowód nie jest
    nam już do niczego potrzebny, a zatem ekstrakcja może się go pozbyć. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">again.div'_aux</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;again.div'_aux&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;div'_aux&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(d&nbsp;:&nbsp;again.divD&nbsp;n&nbsp;m)&nbsp;{struct&nbsp;d}&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;le_lt_dec&nbsp;(S&nbsp;m)&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;left&nbsp;H&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;(div'_aux&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;(again.divD_ge_inv&nbsp;n&nbsp;m&nbsp;H&nbsp;d))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;right&nbsp;_&nbsp;=&gt;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;again.divD&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">again.div'_aux</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;::&nbsp;Nat&nbsp;-&gt;&nbsp;Nat&nbsp;-&gt;&nbsp;Nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;n&nbsp;m&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;le_lt_dec&nbsp;(S&nbsp;m)&nbsp;n&nbsp;of&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;-&gt;&nbsp;S&nbsp;(div'_aux&nbsp;(sub&nbsp;n&nbsp;(S&nbsp;m))&nbsp;m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;-&gt;&nbsp;O}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
A tak wygląda wyekstrahowana funkcja <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>. Jeżeli pominiemy
    różnice składniowe między Coqiem i Haskellem (w Coqu typ jest na
    dole, po dwukropku, a w Haskellu na górze, przed definicją; w Coqu
    mamy <span class="inlinecode"><span class="id" title="keyword">match</span></span>, a w Haskellu <span class="inlinecode"><span class="id" title="tactic">case</span></span> etc.) to wygląda całkiem podobnie.
    Kluczową różnicą jest widniejący w Coqowej wersji dowód należenia do
    dziedziny <span class="inlinecode"><span class="id" title="var">again.divD_ge_inv</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span>, który w Haskellowym ekstrakcie
    został usunięty.

<div class="paragraph"> </div>

    Cały ten cyrk z przerabianiem <span class="inlinecode"><span class="id" title="var">divD</span></span> na prawdziwy predykat był po
    to, żeby dowód należenia do dziedziny mógł zostać usunięty podczas
    ekstrakcji. Dzięki temu wyekstrahowany program w Haskellu wygląda
    jak gdyby został napisany ręcznie. Jest też szybszy i krótszy, bo
    nie ma tam wzmianki o <span class="inlinecode"><span class="id" title="var">divD_all</span></span>, która musiałaby się pojawić, gdyby
    <span class="inlinecode"><span class="id" title="var">divD</span></span> było rodziną typów, a nie predykatem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">div'_aux</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;::&nbsp;Nat&nbsp;-&gt;&nbsp;Nat&nbsp;-&gt;&nbsp;DivD&nbsp;-&gt;&nbsp;Nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;_&nbsp;_&nbsp;h&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;h&nbsp;of&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DivD_lt&nbsp;_&nbsp;_&nbsp;-&gt;&nbsp;O;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DivD_ge&nbsp;n&nbsp;m&nbsp;h'&nbsp;-&gt;&nbsp;S&nbsp;(div'_aux&nbsp;(sub&nbsp;n&nbsp;(S&nbsp;m))&nbsp;m&nbsp;h')}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Tak wygląda ekstrakt oryginalnego <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>, tzn. tego, w którym <span class="inlinecode"><span class="id" title="var">divD</span></span>
    nie jest predykatem, lecz rodziną typów. W wyekstrahowanym programie, w
    typie funkcji <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> pojawia się złowieszczy typ <span class="inlinecode"><span class="id" title="var">DivD</span></span>, który jest
    zupełnie zbędny, bo Haskell (i żaden inny funkcyjny język programowania,
    który nie jest przeznaczony do dowodzenia) nie narzuca żadnych ograniczeń
    na wywołania rekurencyjne.

<div class="paragraph"> </div>

    No, to by było na tyle. Życzę ci, żebyś nigdy nie musiał stosować
    wariantu metody induktywnej dziedziny opisanej w tym podrozdziale
    ani nie musiał niczego ekstrahować. 
<div class="paragraph"> </div>

<a id="lab393"></a><h1 class="section">Plugin <span class="inlinecode"><span class="id" title="keyword">Equations</span></span></h1>

<div class="paragraph"> </div>

<a id="lab394"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zainstaluj plugin Equations:
    https://github.com/mattam82/Coq-Equations

<div class="paragraph"> </div>

    Przeczytaj tutorial:
    https://raw.githubusercontent.com/mattam82/Coq-Equations/master/doc/equations_intro.v

<div class="paragraph"> </div>

    Następnie znajdź jakiś swój dowód przez indukcję, który był skomplikowany
    i napisz prostszy dowód za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Equations</span></span> i taktyki <span class="inlinecode"><span class="id" title="var">funelim</span></span>.

<div class="paragraph"> </div>

<a id="lab395"></a><h1 class="section">Podsumowanie (TODO)</h1>

<div class="paragraph"> </div>

 Póki co nie jest źle, wszakże udało nam się odkryć indukcję wykresową,
    czyli metodę dowodzenia właściwości funkcji za pomocą specjalnie do
    niej dostosowanej reguły indukcji, wywodzącej się od reguły indukcji
    jej wykresu. 
</div>
<div class="code">
</div>
