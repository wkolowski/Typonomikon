<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">D2g: Rekursja dobrze ufundowana [TODO]</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Typonomikon</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">D5</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab583"></a><h1 class="section">Rekursja dobrze ufundowana</h1>

<div class="paragraph"> </div>

 Typy induktywne są jak domino - każdy term to jedna kostka, indukcja
    i rekursja odpowiadają zaś temu co tygryski lubią najbardziej, czyli
    reakcji łańcuchowej przewracającej wszystkie kostki.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">unit</span></span> to jedna biedna kostka, zaś <span class="inlinecode"><span class="id" title="var">bool</span></span> to już dwie biedne
    kostki - <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>. W obu przypadkach nie dzieje się nic
    ciekawego - żeby wszystkie kostki się przewróciły, musimy pchnąć
    palcem każdą z osobna.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">nat</span></span> jest już ciekawszy - są dwa rodzaje kostek, <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">S</span></span>,
    a jeżeli pchniemy kostkę <span class="inlinecode">0</span> i między kolejnymi kostkami jest
    odpowiedni odstęp, to równy szlaczek kolejnych kostek przewracać
    się będzie do końca świata.

<div class="paragraph"> </div>

    Podobnie dla typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> mamy dwa rodzaje kostek - <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span>,
    ale kostki rodzaju <span class="inlinecode"><span class="id" title="var">cons</span></span> mają różne kolory - są nimi elementy typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>. Podobnie jak dla <span class="inlinecode"><span class="id" title="var">nat</span></span>, jeżeli pchniemy kostkę <span class="inlinecode"><span class="id" title="var">nil</span></span> i odstępy
    między kolejnymi kostkami są odpowiednie, to kostki będą przewracać
    się w nieskończoność. Tym razem jednak zamiast jednego szaroburego
    szlaczka będzie multum kolorowych szlaczków o wspólnych początkach
    (no chyba, że <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> - wtedy dostaniemy taki sam bury szlaczek
    jak dla <span class="inlinecode"><span class="id" title="var">nat</span></span>).

<div class="paragraph"> </div>

    Powyższe malownicze opisy przewracających się kostek domina bardziej
    przywodzą na myśl indukcję, niż rekursję, chociaż wiemy już, że jest
    to w sumie to samo. Przyjmują one perspektywę "od przodu" - jeżeli
    przewrócimy początkową kostkę i niczego nie spartaczyliśmy, kolejne
    kostki będą przewracać się już same.

<div class="paragraph"> </div>

    Co to znaczy, że niczego nie spartaczyliśmy, pytasz? Tutaj przydaje
    się spojrzenie na nasze domino "od tyłu". Żeby kostka domina się
    przewróciła, muszą przewrócić się na nią wszystkie bezpośrednio
    poprzedzające ją kostki, a żeby one się przewróciły, to przewrócić
    muszą się wszystkie poprzedzające je kostki i tak dalej. W związku
    z tym możemy powiedzieć, że kostka jest dostępna, jeżeli dostępne
    są wszystkie kostki ją poprzedzające.

<div class="paragraph"> </div>

    Jeszcze jeden drobny detal: kiedy dostępne są kostki, które nie mają
    żadnych poprzedzających kostek? Odpowiedź: zawsze, a dowodem na to
    jest nasz palec, który je przewraca.

<div class="paragraph"> </div>

    W ten oto wesoły sposób udało nam się uzyskać definicję elementu
    dostępnego oraz relacji dobrze ufundowanej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Acc</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">Acc_intro</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Kostki domina reprezentuje typ <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś relacja <span class="inlinecode"><span class="id" title="var">R</span></span> to sposób ułożenia
    kostek, a <span class="inlinecode"><span class="id" title="var">x</span></span> to pewna konkretna kostka domina. Konstruktor <span class="inlinecode"><span class="id" title="var">Acc_intro</span></span>
    mówi, że kostka <span class="inlinecode"><span class="id" title="var">x</span></span> jest dostępna w układzie domina <span class="inlinecode"><span class="id" title="var">R</span></span>, jezeli każda
    kostka <span class="inlinecode"><span class="id" title="var">y</span></span>, która poprzedza ją w układzie <span class="inlinecode"><span class="id" title="var">R</span></span>, również jest dostępna.

<div class="paragraph"> </div>

    Mniej poetycko: element <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest <span class="inlinecode"><span class="id" title="var">R</span></span>-dostępny, jeżeli każdy
    <span class="inlinecode"><span class="id" title="var">R</span></span>-mniejszy od niego element <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> również jest <span class="inlinecode"><span class="id" title="var">R</span></span>-dostępny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">well_founded</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Układ kostek reprezentowany przez <span class="inlinecode"><span class="id" title="var">R</span></span> jest niespartaczony, jeżeli każda
    kostka domina jest dostępna.

<div class="paragraph"> </div>

    Mniej poetycko: relacja <span class="inlinecode"><span class="id" title="var">R</span></span> jest dobrze ufundowana, jeżeli każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest <span class="inlinecode"><span class="id" title="var">R</span></span>-dostępne.

<div class="paragraph"> </div>

    Uwaga: typem naszego układu kostek nie jest <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a zatem <span class="inlinecode"><span class="id" title="var">R</span></span> jest tak naprawdę indeksowaną rodziną
    typów, a nie relacją. Różnica między relacją i rodziną typów jest
    taka, że relacja, gdy dostanie argumenty, zwraca zdanie, czyli coś
    typu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a rodzina typów, gdy dostanie argumenty, zwraca typ,
    czyli coś typu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Tak więc pojęcie rodziny typów jest ogólniejsze
    niż pojęcie relacji. Ta ogólność przyda się nam za kilka chwil aby nie
    musieć pisać wszystkiego dwa razy. 
<div class="paragraph"> </div>

<a id="lab584"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy relacje <span class="inlinecode">&lt;=</span>, <span class="inlinecode">&lt;</span> są dobrze ufundowane. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab585"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Pokaż, że relacja dobrze ufundowana jest antyzwrotna oraz zinterpretuj
    ten fakt (tzn. powiedz, o co tak naprawdę chodzi w tym stwierdzeniu). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wf_antirefl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">well_founded</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, ~ <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab586"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy dobrze ufundowana jest następująca relacja porządku:
    wszystkie liczby parzyste są mniejsze niż wszystkie liczby nieparzyste,
    zaś dwie liczby o tej samej parzystości porównujemy według zwykłego
    porządku <span class="inlinecode">&lt;</span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab587"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy dobrze ufundowana jest następująca relacja porządku
    (mam nadzieję, że obrazek jest zrozumiały):
    0 &lt; 1 &lt; ... &lt; ω &lt; ω + 1 &lt; ... &lt; 2 * ω

<div class="paragraph"> </div>

     Oczywiście najpierw musisz wymyślić, w jaki sposób zdefiniować taką
     relację. Uwaga: istnieje bardzo sprytne rozwiązanie. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Nasza bajka powoli zbliża się do końca. Czas udowodnić ostateczne
    twierdzenie, do którego dążyliśmy: jeżeli układ kostek <span class="inlinecode"><span class="id" title="var">R</span></span> jest
    niespartaczony (czyli gdy każda kostka jest dostępna), to każda
    kostka się przewraca. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">well_founded_rect</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">wf</span> : <span class="id" title="var">well_founded</span> <span class="id" title="var">R</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">well_founded</span> <span class="id" title="tactic">in</span> <span class="id" title="keyword">wf</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="keyword">wf</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="keyword">wf</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">IH</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, <span class="inlinecode"><span class="id" title="var">A</span></span> to typ kostek domina, <span class="inlinecode"><span class="id" title="var">R</span></span> to układ kostek,
    zaś <span class="inlinecode"><span class="id" title="keyword">wf</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">well_founded</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> to dowód na to, że układ jest niespartaczony.
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> to dowolna rodzina typów indeksowana przez <span class="inlinecode"><span class="id" title="var">A</span></span>, ale
    możemy myśleć, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> znaczy "kostka x się przewraca". Mamy jeszcze
    hipotezę, która głosi, że kostka <span class="inlinecode"><span class="id" title="var">x</span></span> przewraca się, gdy przewraca się
    każda kostka, która poprzedza ją w układzie <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Dowód jest banalny. Zaczynamy od wprowadzenia zmiennych i hipotez do
    kontekstu. Następnie odwijamy definicję <span class="inlinecode"><span class="id" title="var">well_founded</span></span>. Teraz hipoteza
    <span class="inlinecode"><span class="id" title="keyword">wf</span></span> głosi, że każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest dostępne. Skoro tak, to specjalizujemy
    ją dla naszego konkretnego <span class="inlinecode"><span class="id" title="var">x</span></span>, które mamy w kontekście.

<div class="paragraph"> </div>

    Wiemy już zatem, że <span class="inlinecode"><span class="id" title="var">x</span></span> jest dostępne. Jest to kluczowy fakt, gdyż
    oznacza to, że wszystkie kostki domina poprzedzające <span class="inlinecode"><span class="id" title="var">x</span></span> również są
    dostępne. Co więcej, <span class="inlinecode"><span class="id" title="var">Acc</span></span> jest zdefiniowane induktywnie, więc możemy
    pokazać, że <span class="inlinecode"><span class="id" title="var">x</span></span> się przewraca, właśnie przez indukcję po dowodzie
    dostępności <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Przypadek jest jeden (co nie znaczy, że nie ma przypadków bazowych -
    są nimi kostki domina, których nic nie poprzedza): musimy pokazać, że
    <span class="inlinecode"><span class="id" title="var">x</span></span> się przewraca przy założeniu, że wszystkie poprzedzające je kostki
    również się przewracają. To, że <span class="inlinecode"><span class="id" title="var">x</span></span> się przewraca, wynika z hipotezy
    <span class="inlinecode"><span class="id" title="var">H</span></span>. Pozostaje nam jedynie pokazać, że przewraca się wszystko, co jest
    przed nim, ale to jest faktem na mocy hipotezy indukcyjnej <span class="inlinecode"><span class="id" title="var">IH</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">well_founded_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">wf</span> : <span class="id" title="var">well_founded</span> <span class="id" title="var">R</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Poprzednie twierdzenie, czyli <span class="inlinecode"><span class="id" title="var">well_founded_rect</span></span>, to twierdzenie o
    rekursji dobrze ufundowanej. Powyższe, czyli <span class="inlinecode"><span class="id" title="var">well_founded_ind</span></span>,
    które jest jego specjalizacją dla relacji binarnych (czyli bytów o
    typie <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), możemy nazwać twierdzeniem o indukcji dobrze
    ufundowanej.

<div class="paragraph"> </div>

    Upewnij się, że dobrze rozumiesz oba twierdzenia, a także pojęcia
    dostępności i dobrego ufundowania, gdyż są one bardzo ważne przy
    rozwiązywaniu poważniejszych problemów.

<div class="paragraph"> </div>

    Co to są "poważniejsze problemy"? Mam oczywiście na myśli dowodzenie
    twierdzeń i definiowanie funkcji, którego nie da się zrobić za pomocą
    prostej indukcji albo banalnego dopasowania do wzorca. W tego typu
    sytuacjach nieodzowne będzie skorzystanie z indukcji i rekursji
    dobrze ufundowanej, o czym przekonamy się już natychmiast zaraz. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">div</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (@<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">nat</span> <span class="id" title="var">lt</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;2: <span class="id" title="tactic">exact</span> 0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (1 + <span class="id" title="var">IH</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">_</span> <span class="id" title="var">m</span>). <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Poważniejszym problemem jest bowiem definicja dzielenia, z którą borykamy
    się od samiuśkiego początku niniejszego rozdziału. Powyższy kawałek kodu
    jest (nieudaną, jak się okaże) próbą uporania się z tym problemem.

<div class="paragraph"> </div>

    Definiować będziemy w trybie dowodzenia, gdyż przy posługiwaniu się
    rekursją dobrze ufundowaną zazwyczaj tak jest dużo łatwiej. Zaczynamy
    od zaaplikowania reguły rekursji dobrze ufundowanej dla typu <span class="inlinecode"><span class="id" title="var">nat</span></span> i
    porządku <span class="inlinecode">&lt;</span> (no i rzecz jasna <span class="inlinecode"><span class="id" title="var">wf_lt</span></span>, czyli dowodu na to, że <span class="inlinecode"><span class="id" title="var">lt</span></span>
    jest dobrze ufundowany - bez tego ani rusz). Po typach widać, że
    rekursja będzie się odbywać po pierwszym argumencie. Wprowadzamy też
    zmienne do kontekstu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">le_lt_dec</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;le_lt_dec&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;{n&nbsp;&lt;=&nbsp;m}&nbsp;+&nbsp;{m&nbsp;&lt;&nbsp;n}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Następnie musimy sprawdzić, czy dzielna (czyli <span class="inlinecode"><span class="id" title="var">n</span></span>) jest mniejsza od
    dzielnika (czyli <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> - zauważ, że definiujemy tutaj "sprytną" wersję
    dzielenia, tzn. <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> = <span class="inlinecode"><span class="id" title="var">n</span>/(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, żeby uniknąć problemów z
    dzieleniem przez <span class="inlinecode">0</span>). Jeżeli tak, wynikiem jest <span class="inlinecode">0</span>. Jeżeli nie,
    wynikiem jest wynik wywołania rekurencyjnego na argumencie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    powiększony o <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Na koniec musimy jeszcze tylko pokazać, że argument wywołania
    rekurencyjnego, czyli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, jest mniejszy od argumentu
    obecnego wywołania, czyli <span class="inlinecode"><span class="id" title="var">n</span></span>. Żeby za bardzo nie pobrudzić
    sobie rąk arytmetyką, zostawiamy ten cel taktyce <span class="inlinecode"><span class="id" title="var">lia</span></span>, ale
    zawijamy jej użycie w kombinator <span class="inlinecode"><span class="id" title="tactic">abstract</span></span>, który zapobiega
    "wylaniu się" rozumowania taktyki <span class="inlinecode"><span class="id" title="var">lia</span></span> do definicji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">div</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;div&nbsp;=<br/>
&nbsp;&nbsp;well_founded_rect&nbsp;nat&nbsp;lt&nbsp;wf_lt&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;(n&nbsp;:&nbsp;nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IH&nbsp;:&nbsp;forall&nbsp;y&nbsp;:&nbsp;nat,&nbsp;y&nbsp;&lt;&nbsp;n&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m&nbsp;:&nbsp;nat)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;s&nbsp;:=&nbsp;le_lt_dec&nbsp;(S&nbsp;m)&nbsp;n&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;s&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;left&nbsp;l&nbsp;=&gt;&nbsp;1&nbsp;+&nbsp;IH&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;(div_subproof&nbsp;n&nbsp;m&nbsp;l)&nbsp;m<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;right&nbsp;_&nbsp;=&gt;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">div_subproof</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div_subproof<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;m&nbsp;&lt;=&nbsp;n&nbsp;-&gt;&nbsp;n&nbsp;-&nbsp;S&nbsp;m&nbsp;&lt;&nbsp;n&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">div_subproof</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;dużo&nbsp;różnych&nbsp;głupot,&nbsp;szkoda&nbsp;pisać&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Mówiąc wprost, taktyka <span class="inlinecode"><span class="id" title="tactic">abstract</span></span> <span class="inlinecode"><span class="id" title="var">lia</span></span> zamiast wstawiać do definicji
    całe rozumowanie, tak jak zrobiłaby to taktyka <span class="inlinecode"><span class="id" title="var">lia</span></span>, dowodzi sobie
    na boku odpowiedni lemat arytmetyczny, nazywa go <span class="inlinecode"><span class="id" title="var">div_subproof</span></span> i
    dowodzi celu za jego pomocą. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">div</span> 5 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;1&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, definicja przechodzi bez problemu, a nasza funkcja elegancko
    się oblicza (pamiętaj, że <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode">5</span> <span class="inlinecode">2</span> to tak naprawdę <span class="inlinecode">5/3</span>, więc wynikiem
    faktycznie powinno być <span class="inlinecode">1</span>).

<div class="paragraph"> </div>

    Jednak nie samymi definicjami żyje człowiek - czas trochę podowodzić.
    Spodziewamy się wszakże, że nasze dzielenie spełnia wszystkie
    właściwości, których się po nim spodziewamy, prawda? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_0_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">div</span>. <span class="id" title="var">cbn</span>. <span class="comment">(*&nbsp;O&nbsp;Jezu,&nbsp;a&nbsp;cóż&nbsp;to&nbsp;za&nbsp;wojacy?&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety jednak, jak to w życiu, nie ma kolorowo.

<div class="paragraph"> </div>

    Powyższy lemat głosi, że <span class="inlinecode"><span class="id" title="var">n</span>/1</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Ponieważ <span class="inlinecode"><span class="id" title="var">div</span></span> jest zdefiniowane
    za pomocą rekursji dobrze ufundowanej, to dowodzić będziemy oczywiście
    za pomocą indukcji dobrze ufundowanej. Tak, będziemy dowodzić, hmmm...
    cóż... tylko jak?

<div class="paragraph"> </div>

    Sytuacja wygląda beznadziejnie. Nie żeby lemat był nieprawdziwy - co to,
    to nie. Po prostu próba odwinięcia definicji i policzenia czegokolwiek
    daje inny wynik, niż byśmy chcieli - część definicji ukryta dotychczas
    w <span class="inlinecode"><span class="id" title="var">div_subproof</span></span> wylewa się i zaśmieca nam ekran.

<div class="paragraph"> </div>

    Problem nie pochodzi jednak od taktyki <span class="inlinecode"><span class="id" title="var">lia</span></span> (ani od <span class="inlinecode"><span class="id" title="tactic">abstract</span></span> <span class="inlinecode"><span class="id" title="var">lia</span></span>).
    Jest on dużo ogólniejszy i polega na tym, że wewnątrz definicji funkcji
    pojawiają się dowody, które są wymagane przez <span class="inlinecode"><span class="id" title="var">well_founded_rect</span></span>, ale
    które zaorywują jej obliczeniową harmonię.

<div class="paragraph"> </div>

    Nie jesteśmy jednak (jeszcze) skazani na porażkę. Spróbujemy uporać się
    z tą przeszkodą dzięki <i>równaniu rekurencyjnemu</i>. Równanie rekurencyjne
    to lemat, którego treść wygląda dokładnie tak, jak pożądana przez nas
    definicja funkcji, ale która nie może służyć jako definicja z różnych
    powodów, np. dlatego że nie jest strukturalnie rekurencyjna. Dzięki
    równaniu rekurencyjnemu możemy użyć taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> do przepisania
    wystąpień funkcji <span class="inlinecode"><span class="id" title="var">div</span></span> do pożądanej postaci zamiast rozwijać je za
    pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> lub obliczać za pomocą <span class="inlinecode"><span class="id" title="var">cbn</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">div</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;? <span class="id" title="var">S</span> <span class="id" title="var">m</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">div</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">div</span>. <span class="id" title="var">cbn</span>. <span class="comment">(*&nbsp;O&nbsp;Jezu,&nbsp;a&nbsp;cóż&nbsp;to&nbsp;za&nbsp;hołota?&nbsp;*)</span><br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe równanie dokładnie opisuje, jak powinna zachowywać się funkcja
    <span class="inlinecode"><span class="id" title="var">div</span></span>, ale za definicję służyć nie może, gdyż Coq nie byłby w stanie
    rozpoznać, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">n</span></span>. Zauważ, że używamy tu <span class="inlinecode">&lt;?</span>
    (czyli <span class="inlinecode"><span class="id" title="var">ltb</span></span>) zamiast <span class="inlinecode"><span class="id" title="var">le_lt_dec</span></span>. Możemy sobie na to pozwolić, gdyż
    użycie <span class="inlinecode"><span class="id" title="var">le_lt_dec</span></span> w faktycznej definicji wynikało jedynie z tego, że
    potrzebowaliśmy dowodu odpowiedniego faktu arytmetycznego, żeby użyć
    go jako argumentu wywołania rekurencyjnego.

<div class="paragraph"> </div>

    Niestety próba udowodnienia tego równania rekurencyjnego musi skończyć
    się taką samą porażką, jak próba udowodnienia <span class="inlinecode"><span class="id" title="var">div_0_r</span></span>. Przyczyna jest
    taka sama jak ostatnio. Zresztą, naiwnym byłoby spodziewać się, że nam
    się uda - zarówno <span class="inlinecode"><span class="id" title="var">div_0_r</span></span>, jak i <span class="inlinecode"><span class="id" title="var">div_eq</span></span> to nietrywialne właściwości
    funkcji <span class="inlinecode"><span class="id" title="var">div</span></span>, więc gdybyśmy potrafili udowodnić równanie rekurencyjne,
    to z dowodem <span class="inlinecode"><span class="id" title="var">div_0_r</span></span> również poradzilibyśmy sobie bez problemu.

<div class="paragraph"> </div>

    Żeby jednak przekonać się o użyteczności równania rekurencyjnego, jego
    "dowód" kończymy za pomocą komendy <span class="inlinecode"><span class="id" title="var">Admitted</span></span>, która przerywa dowód i
    zamienia twierdzenie w aksjomat. Dzięki temu za chwilę zobaczymy, ile
    moglibyśmy zdziałać, mając równanie rekurencyjne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_0_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div</span> <span class="id" title="var">n</span> 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_ind</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">wf_lt</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">div_eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Nat.ltb_spec</span> <span class="id" title="var">n</span> 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span>; <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać, dzięki równaniu rekurencyjnemu dowody przebiegają dość gładko.
    W powyższym zaczynamy od indukcji dobrze ufundowanej po <span class="inlinecode"><span class="id" title="var">n</span></span> (przy użyciu
    relacji <span class="inlinecode">&lt;</span> i dowodu <span class="inlinecode"><span class="id" title="var">wf_lt</span></span>), wprowadzamy zmienne do kontekstu, po czym
    przepisujemy równanie rekurencyjne. Po przeprowadzeniu analizy przypadków
    kończymy za pomocą rozumowań arytmetycznych, używając być może hipotezy
    indukcyjnej. 
<div class="paragraph"> </div>

<a id="lab588"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zgadnij, jakie jest polecenie tego ćwiczenia, a następnie wykonaj je. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div_n_n</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">n</span> = 1.<br/>

<br/>
</div>

<div class="doc">
<a id="lab589"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sprawdź, czy dobrze ufundowane są relacje <span class="inlinecode"><span class="id" title="var">le'</span></span> i <span class="inlinecode"><span class="id" title="var">lt'</span></span>. Uwaga:
    pierwsze zadanie jest bardzo łatwe, drugie jest piekielnie trudne.
    Jeżeli nie potrafisz rozwiązać go formalnie w Coqu, zrób to na
    kartce nieformalnie - będzie dużo łatwiej.
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">le'</span> (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">f</span> <span class="id" title="var">n</span> &lt;= <span class="id" title="var">g</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">lt'</span> (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">f</span> <span class="id" title="var">n</span> &lt; <span class="id" title="var">g</span> <span class="id" title="var">n</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a id="lab590"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Niech <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i niech <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> będzie relacją dobrze
    ufundowaną. Zdefiniuj po współrzędnych relację porządku na funkcjach
    o typie <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> i rozstrzygnij, czy relacja ta jest dobrze ufundowana.

<div class="paragraph"> </div>

    Uwaga: w zależności od okoliczności to zadanie może być trudne lub
    łatwe. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab591"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Pokaż, że jeżeli kodziedzina funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest dobrze ufundowana
    za pomocą relacji <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, to jej dziedzina również jest
    dobrze ufundowana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wf_inverse_image</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">well_founded</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">well_founded</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">R</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)).<br/>
</div>
