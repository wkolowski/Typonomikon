<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">D2h: Metoda induktywnej dziedziny</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span> <span class="id" title="var">Lia</span>.<br/>

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Typonomikon</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">D5</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Typonomikon</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">D2f</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab581"></a><h1 class="section">Metoda induktywnej dziedziny</h1>

<div class="paragraph"> </div>

 Póki co nie jest źle - udało nam się wszakże wymyślić jedyną słuszną
    metodę dowodzenia właściwości funkcji rekurencyjnych. Jednak nasza
    implementacja kuleje przez to nieszczęsne równanie rekurencyjne. Jak
    możemy udowodnić je bez używania indukcji wykresowej?

<div class="paragraph"> </div>

    Żeby znaleźć odpowiedź na to pytanie, znowu przyda się nam trochę
    konceptualnej jasności. Na czym tak naprawdę polega problem? Jak
    pamiętamy, problem wynika z tego, że definiując <span class="inlinecode"><span class="id" title="var">div</span></span> przez rekursję
    dobrze ufundowaną musieliśmy jednocześnie dowodzić, że wywołania
    rekurencyjne odbywają się na argumencie mniejszym od argumentu obecnego
    wywołania.

<div class="paragraph"> </div>

    Tak więc problemem jest połączenie w jednej definicji dwóch dość luźno
    powiązanych rzeczy, którymi są:
<ul class="doclist">
<li> Docelowa definicja, która określa obliczeniowe zachowanie funkcji.
      Jej manifestacją jest nasze nieszczęsne równanie rekurencyjne. Bywa
      ona czasem nazywana aspektem obliczeniowym (albo algorytmicznym)
      funkcji.

</li>
<li> Dowód terminacji, który zapewnia, że definicja docelowa jest legalna
      i nie prowadzi do sprzeczności. Jego manifestacją są występujące w
      definicji <span class="inlinecode"><span class="id" title="var">div</span></span> dowody na to, że wywołanie rekurencyjne ma argument
      mniejszy od obecnego wywołania. Bywa on czasem nazywany aspektem
      logicznym funkcji. 
</li>
</ul>

<div class="paragraph"> </div>

 Pani doktur, mamy diagnozę! Tylko co z nią zrobić? Czy jest jakaś metoda,
    żeby rozdzielić obliczeniowy i logiczny aspekt danej funkcji, a potem
    poskładać je do kupy?

<div class="paragraph"> </div>

    Pomyślmy najpierw nad aspektem obliczeniowym. Czy da się zdefiniować
    funkcję bezpośrednio za pomocą jej definicji docelowej, czyli równania
    rekurencyjnego? Żeby to zrobić, musielibyśmy mieć możliwość robienia
    rekursji o dokładnie takim kształcie, jaki ma mieć ta funkcja...

<div class="paragraph"> </div>

    Eureka! Przecież mamy coś, co pozwala nam na rekursję o dokładnie takim
    kształcie, a mianowicie induktywny wykres! Ale przecież wykres wiąże
    ze sobą argumenty i wynik, a my chcemy dopiero zdefiniować coś, co ów
    wynik obliczy... czyli nie eureka?

<div class="paragraph"> </div>

    Nie do końca. Możemy zmodyfikować definicję wykresu, wyrzucając z
    niej wszystkie wzmianki o wyniku, uzyskując w ten sposób predykat
    będący induktywną charakteryzacją dziedziny naszej funkcji. Dzięki
    niemu możemy zdefiniować zmodyfikowaną wersję funkcji, w której
    dodatkowym argumentem jest dowód na to, że argumenty należą do
    dziedziny.

<div class="paragraph"> </div>

    Logiczny aspekt funkcji, czyli dowód terminacji, sprowadza się w
    takiej sytuacji do pokazania, że wszystkie argumenty należą do
    dziedziny (czyli spełniają predykat dziedziny). Żeby zdefiniować
    oryginalną funkcję, wystarczy jedynie poskładać oba aspekty do
    kupy, czyli wstawić dowód terminacji do zmodyfikowanej funkcji.

<div class="paragraph"> </div>

    Żeby nie utonąć w ogólnościach, zobaczmy, jak nasz wspaniały
    wynalazek radzi sobie z dzieleniem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">divD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">divD_lt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span><br/>
| <span class="id" title="var">divD_ge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Tak wygląda predykat dziedziny dla dzielenia. Zauważmy, że tak naprawdę
    to nie jest to predykat, bo bierze dwa argumenty i co więcej nie zwraca
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Nie będziemy się tym jednak przejmować - dla nas
    <span class="inlinecode"><span class="id" title="var">divD</span></span> będzie "predykatem dziedziny". Zauważmy też, że nie jest to
    predykat dziedziny dla <span class="inlinecode"><span class="id" title="var">div</span></span>, lecz dla <span class="inlinecode"><span class="id" title="var">div'</span></span>, czyli zupełnie nowej
    funkcji, którą zamierzamy zdefiniować.

<div class="paragraph"> </div>

    Ok, przejdźmy do konkretów. <span class="inlinecode"><span class="id" title="var">div'</span></span> ma mieć typ <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    a zatem <span class="inlinecode"><span class="id" title="var">divD</span></span> ma dwa indeksy odpowiadające dwóm argumentom <span class="inlinecode"><span class="id" title="var">div'</span></span>.
    Pierwszy konstruktor głosi, że jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to oba te argumenty
    należą do dziedziny (bo będziemy chcieli w tym przypadku zwrócić <span class="inlinecode">0</span>).
    Drugi konstruktor głosi, że jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to para argumentów <span class="inlinecode"><span class="id" title="var">n</span></span>
    i <span class="inlinecode"><span class="id" title="var">m</span></span> należy do dziedziny pod warunkiem, że para argumentów <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    i <span class="inlinecode"><span class="id" title="var">m</span></span> należy do dziedziny. Jest tak, gdyż w tym przypadku będziemy
    chcieli zrobić wywołanie rekurencyjne właśnie na <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oraz <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div'_aux</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">H</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">divD_lt</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; 0<br/>
| <span class="id" title="var">divD_ge</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">div'_aux</span> <span class="id" title="var">H'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Dzięki <span class="inlinecode"><span class="id" title="var">divD</span></span> możemy zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>, której typem jest
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Jest to funkcja pomocnicza, która
    posłuży nam do zdefiniowania właściwej funkcji <span class="inlinecode"><span class="id" title="var">div'</span></span>.

<div class="paragraph"> </div>

    Ponieważ <span class="inlinecode"><span class="id" title="var">divD</span></span> jest zdefiniowane induktywnie, docelowa definicja <span class="inlinecode"><span class="id" title="var">div'</span></span>
    jest strukturalnie rekurencyjna po argumencie <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, mimo że nie
    jest strukturalnie rekurencyjna po <span class="inlinecode"><span class="id" title="var">n</span></span> ani <span class="inlinecode"><span class="id" title="var">m</span></span>. To właśnie jest magia
    stojąca za metodą induktywnej dziedziny - możemy sprawić, żeby każda (no,
    prawie), nawet najdziwniejsza rekursja była strukturalnie rekurencyjna po
    dowodzie należenia do dziedziny.

<div class="paragraph"> </div>

    Definicja jest banalna. Gdy natrafimy na konstruktor <span class="inlinecode"><span class="id" title="var">divD_lt</span></span>, zwracamy
    <span class="inlinecode">0</span> (bo wiemy, że jednym z argumentów <span class="inlinecode"><span class="id" title="var">divD_lt</span></span> jest dowód na to, że
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>). Jeżeli trafimy na <span class="inlinecode"><span class="id" title="var">divD_ge</span></span>, to wiemy, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, więc
    robimy wywołanie rekurencyjne na <span class="inlinecode"><span class="id" title="var">H'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span> i dorzucamy do
    wyniku <span class="inlinecode"><span class="id" title="var">S</span></span>.

<div class="paragraph"> </div>

    W ten sposób zdefiniowaliśmy obliczeniową część <span class="inlinecode"><span class="id" title="var">div'</span></span>, zupełnie nie
    przejmując się kwestią terminacji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divD_all</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">nat</span> <span class="id" title="var">lt</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_ge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ge</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_lt</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód terminacji jest bliźniaczo podobny do naszej pierwszej definicji
    <span class="inlinecode"><span class="id" title="var">div</span></span>. Zaczynamy przez rekursję dobrze ufundowaną z porządkiem <span class="inlinecode"><span class="id" title="var">lt</span></span> (i
    dowodem <span class="inlinecode"><span class="id" title="var">wf_lt</span></span> na to, że <span class="inlinecode"><span class="id" title="var">lt</span></span> jest dobrze ufundowany), wprowadzamy
    zmienne do kontekstu, po czym sprawdzamy, który z przypadków zachodzi.

<div class="paragraph"> </div>

    Jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, używamy konstruktora <span class="inlinecode"><span class="id" title="var">divD_ge</span></span>. <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> zachodzi
    na mocy założenia, zaś <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> należą do dziedziny na mocy
    hipotezy indukcyjnej. Gdy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> należą do dziedziny na
    mocy założenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">div'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">div'_aux</span> (<span class="id" title="var">divD_all</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
</div>

<div class="doc">
A oto i ostateczna definicja - wstawiamy dowód <span class="inlinecode"><span class="id" title="var">divD_all</span></span> do funkcji
    pomocniczej <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> i uzyskujemy pełnoprawną funkcję dzielącą
    <span class="inlinecode"><span class="id" title="var">div'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">div'</span> 666 7.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;83&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, wynik oblicza się bez problemu. Po raz kolejny przypominam,
    że <span class="inlinecode"><span class="id" title="var">div'</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oblicza <span class="inlinecode"><span class="id" title="var">n</span>/(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, nie zaś <span class="inlinecode"><span class="id" title="var">n</span>/<span class="id" title="var">m</span></span>. Przypominam też, że
    dowód <span class="inlinecode"><span class="id" title="var">divD_all</span></span> koniecznie musimy zakończyć za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>,
    a nie jak zazwyczaj <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>, gdyż w przeciwnym przypadku funkcja <span class="inlinecode"><span class="id" title="var">div'</span></span> nie
    mogłaby niczego obliczyć. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_div'_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'_aux</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_correct'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_div'_aux</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby udowodnić regułę indukcji wykresowej, będziemy potrzebowali tego
    samego co poprzednio, czyli twierdzeń o poprawności i pełności funkcji
    <span class="inlinecode"><span class="id" title="var">div'</span></span> względem wykresu <span class="inlinecode"><span class="id" title="var">divG</span></span>. Dowody są jednak dużo prostsze niż
    ostatnim razem.

<div class="paragraph"> </div>

    Najpierw dowodzimy, że funkcja pomocnicza <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> oblicza taki wynik,
    jakiego spodziewa się wykres <span class="inlinecode"><span class="id" title="var">divG</span></span>. Dowód jest banalny, bo indukcja po
    <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> ma dokładnie taki kształt, jakiego nam potrzeba. Właściwy
    dowód dla <span class="inlinecode"><span class="id" title="var">div'</span></span> uzyskujemy przez wyspecjalizowanie <span class="inlinecode"><span class="id" title="var">divG_div'_aux</span></span> do
    <span class="inlinecode"><span class="id" title="var">div'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_complete'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">r</span> = <span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_det</span> <span class="id" title="keyword">with</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_correct'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div'_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hlt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> (<span class="id" title="var">div'</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">S</span> (<span class="id" title="var">div'</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Hlt</span> <span class="id" title="var">Hge</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_complete'</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hge</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divG_correct'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód pełności i dowód reguły indukcji wykresowej są dokładnie takie
    same jak poprzednio. Zauważ, że tym razem zupełnie zbędne okazało się
    równanie rekurencyjne, bez którego nie mogliśmy obyć się ostatnim
    razem. Jednak jeżeli chcemy, możemy bez problemu je udowodnić, i to
    nawet na dwa sposoby. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div'_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">div'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;? <span class="id" title="var">S</span> <span class="id" title="var">m</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">div'</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">div'</span>. <span class="id" title="tactic">generalize</span> (<span class="id" title="var">divD_all</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_S_n</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct_conv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_det</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">divG_div'_aux</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">div'_ind</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">leb_correct_conv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszy, trudniejszy sposób, to zgeneralizowanie <span class="inlinecode"><span class="id" title="var">divD_all</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    do dowolnego <span class="inlinecode"><span class="id" title="var">d</span></span> oraz indukcja po <span class="inlinecode"><span class="id" title="var">d</span></span> (to tak, jakbyśmy najpierw
    udowodnili tę regułę dla <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>, a potem wyspecjalizowali do
    <span class="inlinecode"><span class="id" title="var">div'</span></span>).

<div class="paragraph"> </div>

    Drugi, łatwiejszy sposób, realizuje nasz początkowy pomysł, od którego
    wszystko się zaczęło: dowodzimy równania rekurencyjnego za pomocą reguły
    indukcji wykresowej. 
<div class="paragraph"> </div>

<a id="lab582"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">rot</span></span>, która bierze liczbę <span class="inlinecode"><span class="id" title="var">n</span></span> oraz listę i zwraca
    listę, w której bloki o długości dokładnie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> zostały odwrócone,
    np.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode">0</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span> <span class="inlinecode">=</span> <span class="inlinecode">[2;</span> <span class="inlinecode">1;</span> <span class="inlinecode">4;</span> <span class="inlinecode">3;</span> <span class="inlinecode">6;</span> <span class="inlinecode">5;</span> <span class="inlinecode">7]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">7]</span> <span class="inlinecode">=</span> <span class="inlinecode">[3;</span> <span class="inlinecode">2;</span> <span class="inlinecode">1;</span> <span class="inlinecode">6;</span> <span class="inlinecode">5;</span> <span class="inlinecode">4;</span> <span class="inlinecode">7]</span>

<div class="paragraph"> </div>

    Wskazówka: rzecz jasna użyj metody induktywnej dziedziny. Nie bez
    przyczyny także w jednym z poprzednich zadań kazałem ci zdefiniować
    funkcję <span class="inlinecode"><span class="id" title="tactic">split</span></span>, która odkraja od listy blok o odpowiedniej długości.

<div class="paragraph"> </div>

    Następnie zdefiniuj wykres funkcji <span class="inlinecode"><span class="id" title="var">rot</span></span> i udowodnij jej regułę indukcji
    wykresowej oraz równanie rekurencyjne. Użyj jej, żeby pokazać, że <span class="inlinecode"><span class="id" title="var">rot</span></span>
    jest inwolucją dla dowolnego <span class="inlinecode"><span class="id" title="var">n</span></span>, tzn. <span class="inlinecode"><span class="id" title="var">rot</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">rot</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l</span></span>. Uwaga:
    potrzebne będzie trochę lematów. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab583"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">Eratosthenes</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, która dla
    danego <span class="inlinecode"><span class="id" title="var">n</span></span> znajduje listę wszystkich liczb pierwszych, które są
    mniejsze lub równe <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Jako funkcję pomocniczą zaimplementuj sito Eratosthenesa. Sito
    to funkcja <span class="inlinecode"><span class="id" title="var">sieve</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, która działa tak:
<ul class="doclist">
<li> jeżeli wejście jest puste, zwróć listę pustą

</li>
<li> jeżeli wejście ma głowę <span class="inlinecode"><span class="id" title="var">h</span></span> i ogon <span class="inlinecode"><span class="id" title="var">t</span></span>, to wstaw <span class="inlinecode"><span class="id" title="var">h</span></span> na początek
      wyniku i wywołaj się rekurencyjnie na ogonie <span class="inlinecode"><span class="id" title="var">t</span></span> z odfiltrowanymi
      wszystkimi wielokrotnościami głowy <span class="inlinecode"><span class="id" title="var">h</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli jako argument <span class="inlinecode"><span class="id" title="var">sieve</span></span> podamy listę wszystkich liczb poczynając
    od pewnej liczby pierwszej <span class="inlinecode"><span class="id" title="var">p</span></span> aż do <span class="inlinecode"><span class="id" title="var">n</span></span>, to otrzymamy listę liczb
    pierwszych między <span class="inlinecode"><span class="id" title="var">p</span></span> i <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Żeby sprawnie rozwiązać to zadanie, zgeneralizuj funkcję <span class="inlinecode"><span class="id" title="var">sieve</span></span>
    na dowolny typ <span class="inlinecode"><span class="id" title="var">A</span></span> i funkcję porównującą <span class="inlinecode"><span class="id" title="var">cmp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    (tak będzie łatwiej) i użyj metody induktywnej dziedziny. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab584"></a><h1 class="section">Porządny predykat dziedziny</h1>

<div class="paragraph"> </div>

 Na koniec została nam do omówienia jeszcze jedna drobna kwestia.
    Poznając metodę induktywnej dziedziny, dowiedzieliśmy się, że
    "predykat" dziedziny tak naprawdę wcale nie jest predykatem, ale
    rodziną typów. Czas naprawić ten szkopuł.

<div class="paragraph"> </div>

    W niniejszym podrozdziale najpierw zapoznamy się (na przykładzie
    dzielenia - znowu) z wariantem metody induktywnej dziedziny, w
    którym dziedzina faktycznie jest predykatem, a na koniec podumamy,
    dlaczego powinno nas to w ogóle obchodzić. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">again</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">divD</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">divD_lt</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span><br/>
| <span class="id" title="var">divD_ge</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja dziedziny jest taka sama jak ostatnio, ale z tą drobną
    różnicą, że teraz faktycznie jest to predykat.

<div class="paragraph"> </div>

    Skoro mamy dziedzinę, spróbujmy zdefiniować funkcję pomocniczą
    tak samo jak ostatnio. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div_aux</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">divD_lt</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; 0<br/>
| <span class="id" title="var">divD_ge</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">d'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">div_aux</span> <span class="id" title="var">d'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incorrect&nbsp;elimination&nbsp;of&nbsp;"d"&nbsp;in&nbsp;the&nbsp;inductive&nbsp;type&nbsp;"divD":<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;return&nbsp;type&nbsp;has&nbsp;sort&nbsp;"Set"&nbsp;while&nbsp;it&nbsp;should&nbsp;be&nbsp;"Prop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elimination&nbsp;of&nbsp;an&nbsp;inductive&nbsp;object&nbsp;of&nbsp;sort&nbsp;Prop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;allowed&nbsp;on&nbsp;a&nbsp;predicate&nbsp;in&nbsp;sort&nbsp;Set<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;because&nbsp;proofs&nbsp;can&nbsp;be&nbsp;eliminated&nbsp;only&nbsp;to&nbsp;build&nbsp;proofs.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a id="lab585"></a><h2 class="section">Eliminacja zdań i irrelewancja dowodów</h2>

<div class="paragraph"> </div>

 Cóż, nie da się i nie dziwota - gdyby się dało, to zrobiliśmy tak
    już na samym początku. Powód porażki jest całkiem prozaiczny -
    nie możemy definiować programów przez dopasowanie do wzorca dowodów,
    czyli parafrazując, nie możemy konstruować elementów typów żyjących
    w sortach <span class="inlinecode"><span class="id" title="keyword">Set</span></span> ani <span class="inlinecode"><span class="id" title="keyword">Type</span></span> przez eliminację dowodów zdań, czyli
    elementów typów żyjących w sorcie <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    Wynika to z faktu, że sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> z założenia dopuszcza możliwość
    przyjęcia aksjomatu irrelewancji dowodów (ang. proof irrelevance),
    który głosi, że wszystkie dowody danego zdania są równe. Gdybyśmy
    mogli dopasowywać do wzorca dowody zdań definiując programy,
    irrelewancja wyciekłaby do świata programów i wtedy wszystko byłoby
    równe wszystkiemu, co oczywiście daje sprzeczność.

<div class="paragraph"> </div>

    Jeżeli powyższy opis nie jest przekonujący, zobaczmy to na szybkim
    przykładzie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">proof_irrelevance_example</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool'</span> : <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">true'</span> : <span class="id" title="var">bool'</span><br/>
| <span class="id" title="var">false'</span> : <span class="id" title="var">bool'</span>.<br/>

<br/>
</div>

<div class="doc">
Najpierw definiujemy typ <span class="inlinecode"><span class="id" title="var">bool'</span></span>, który wygląda jak <span class="inlinecode"><span class="id" title="var">bool</span></span>, ale
    żyje w sorcie <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;<span class="id" title="var">proof_irrelevance</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">P</span>), <span class="id" title="var">p1</span> = <span class="id" title="var">p2</span>.<br/>

<br/>
</div>

<div class="doc">
Następnie przyjmujemy aksjomat irrelewancji dowodów, przez co
    <span class="inlinecode"><span class="id" title="var">bool'</span></span> staje się tym samym co zdanie <span class="inlinecode"><span class="id" title="var">True</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">bool'</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">eq1</span> : <span class="id" title="var">f</span> <span class="id" title="var">true'</span> = <span class="id" title="var">true</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">eq2</span> : <span class="id" title="var">f</span> <span class="id" title="var">false'</span> = <span class="id" title="var">false</span>).<br/>

<br/>
</div>

<div class="doc">
Załóżmy, że Coq pozwolił nam zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    która potrafi odróżnić <span class="inlinecode"><span class="id" title="var">true'</span></span> od <span class="inlinecode"><span class="id" title="var">false'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">eq1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">proof_irrelevance</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">false'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać, <span class="inlinecode"><span class="id" title="var">true</span></span> to to samo co <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">true'</span></span>, ale <span class="inlinecode"><span class="id" title="var">true'</span></span> to <span class="inlinecode"><span class="id" title="var">false'</span></span>
    na mocy irrelewancji, a <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">false'</span></span> to przecież <span class="inlinecode"><span class="id" title="var">false</span></span>. Konkluzja:
    prawda to fałsz, a tego zdecydowanie nie chcemy. Żeby uniknąć
    sprzeczności, nie wolno definiować programów przez eliminację zdań.

<div class="paragraph"> </div>

    Od powyższej zasady są jednak wyjątki, mianowicie przy konstrukcji
    programów wolno eliminować dowody zdań, które:
<ul class="doclist">
<li> nie mają konstruktorów, np. <span class="inlinecode"><span class="id" title="var">False</span></span>

</li>
<li> mają jeden konstruktor, którego wszystkie argumenty również są
      dowodami zdań

</li>
</ul>

<div class="paragraph"> </div>

    Powyższy wyjątek od reguły nazywa się "eliminacją singletonów" i
    jest zupełnie niegroźny, gdyż dla takich zdań możemy bez żadnych
    aksjomatów udowodnić, że wszystkie ich dowody są równe. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">proof_irrelevance_example</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab586"></a><h2 class="section">Inwersja na predykacie dziedziny</h2>

<div class="paragraph"> </div>

 Dobra, koniec tej przydługiej dygresji. Wracamy do metody induktywnej
    dziedziny, gdzie dziedzina naprawdę jest predykatem. Skoro nie możemy
    zdefiniować funkcji bezpośrednio przez eliminację <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to
    jak inaczej?

<div class="paragraph"> </div>

    Tutaj ujawnia się pewna chytra sztuczka: nie możemy dopasować <span class="inlinecode"><span class="id" title="var">d</span></span> za
    pomocą <span class="inlinecode"><span class="id" title="keyword">match</span></span>a, ale wciąż możemy robić wywołania rekurencyjne na
    podtermach <span class="inlinecode"><span class="id" title="var">d</span></span>. Wystarczy więc napisać funkcję, która wyjmuje z <span class="inlinecode"><span class="id" title="var">d</span></span>
    jego podterm (oczywiście jedynie pod warunkiem, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, bo
    tylko wtedy <span class="inlinecode"><span class="id" title="var">d</span></span> będzie miało jakiś podterm). Ponieważ kodziedziną
    takiej funkcji będzie <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, dopasowanie <span class="inlinecode"><span class="id" title="var">d</span></span> do wzorca
    będzie już legalne.

<div class="paragraph"> </div>

    Brzmi... chytrze? Zobaczmy, jak wygląda to w praktyce. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divD_ge_inv</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt;= <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">divD</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Nat.le_ngt</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli mamy <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> i wiemy, że <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to <span class="inlinecode"><span class="id" title="var">d</span></span> musiało
    zostać zrobione konstruktorem <span class="inlinecode"><span class="id" title="var">divD_ge</span></span>. Możemy to udowodnić po
    prostu rozbijając <span class="inlinecode"><span class="id" title="var">d</span></span>. W pierwszym przypadkiem dostajemy sprzeczność
    arytmetyczną (bo <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> i jednocześnie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>), zaś w drugim
    wynikiem jest pożądany podterm. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div'_aux</span> {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="tactic">right</span> <span class="id" title="var">_</span> =&gt; 0<br/>
| <span class="id" title="tactic">left</span> <span class="id" title="var">H</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">div'_aux</span> (<span class="id" title="var">divD_ge_inv</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span> <span class="id" title="var">d</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby zdefiniować <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> (czyli, przypomnijmy, zmodyfikowaną wersję
    dzielenia, którego argumentem głównym jest <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, nie zaś
    samo <span class="inlinecode"><span class="id" title="var">n</span></span>), sprawdzamy najpierw, czy mamy do czynienia z przypadkiem
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czy z <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>. W pierwszym przypadku po prostu zwracamy
    <span class="inlinecode">0</span>, zaś w drugim robimy wywołanie rekurencyjne, którego argumentem
    jest <span class="inlinecode"><span class="id" title="var">divD_ge_inv</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span>.

<div class="paragraph"> </div>

    Term ten, jak się okazuje, jest uznawany przez Coqa za podterm <span class="inlinecode"><span class="id" title="var">d</span></span>,
    a więc wywołanie rekurencyjne na nim jest legalne. Dlaczego jest to
    podterm <span class="inlinecode"><span class="id" title="var">d</span></span>? Jeżeli odwiniemy definicję <span class="inlinecode"><span class="id" title="var">divD_ge_inv</span></span> i wykonamy
    występujące tam dopasowanie <span class="inlinecode"><span class="id" title="var">d</span></span> do wzorca, to wiemy, że nie może być
    ono postaci <span class="inlinecode"><span class="id" title="var">divD_lt</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>, a zatem musi być postaci
    <span class="inlinecode"><span class="id" title="var">divD_ge</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">d'</span></span> i wynikiem wykonania funkcji jest <span class="inlinecode"><span class="id" title="var">d'</span></span>, które
    faktycznie jest podtermem <span class="inlinecode"><span class="id" title="var">d</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divD_all</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">well_founded_rect</span> <span class="id" title="var">nat</span> <span class="id" title="var">lt</span> <span class="id" title="var">wf_lt</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IH</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_ge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ge</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">abstract</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">divD_lt</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód tego, że każde <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> należą do dziedziny, jest dokładnie
    taki sam jak poprzednio. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">div'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">div'_aux</span> (<span class="id" title="var">divD_all</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">div'</span> 666 7.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;83&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Ostateczna definicja funkcji <span class="inlinecode"><span class="id" title="var">div'</span></span> również wygląda identycznie jak
    poprzednio i podobnie elegancko się oblicza, a skoro tak, to czas
    udowodnić, że wykresem <span class="inlinecode"><span class="id" title="var">div'</span></span> jest <span class="inlinecode"><span class="id" title="var">divG</span></span>. Nie musimy redefiniować
    wykresu - jest on zdefiniowany dokładnie tak samo jak ostatnio. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_div'_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">div'_aux</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstracting&nbsp;over&nbsp;the&nbsp;terms&nbsp;"n"&nbsp;and&nbsp;"m"&nbsp;leads&nbsp;to&nbsp;a&nbsp;term<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;n0&nbsp;m0&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;divG&nbsp;n0&nbsp;m0&nbsp;(div'_aux&nbsp;d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;is&nbsp;ill-typed.&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwsza próba dowodu kończy się zupełnie niespodziewaną porażką
    już przy pierwszym kroku, czyli próbie odpalenia indukcji po <span class="inlinecode"><span class="id" title="var">d</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">divD_ind</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;divD_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;&gt;=&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;divD&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;divD&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;n0<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powód jest prosty: konkluzja, czyli <span class="inlinecode"><span class="id" title="var">divG</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">(<span class="id" title="var">div'_aux</span></span> <span class="inlinecode"><span class="id" title="var">d</span>)</span> zależy
    od <span class="inlinecode"><span class="id" title="var">d</span></span>, ale domyślna reguła indukcji wygenerowana przez Coqa, czyli
    <span class="inlinecode"><span class="id" title="var">divD_ind</span></span>, nie jest ani trochę zależna i nie dopuszcza możliwości,
    by konkluzja zależała od <span class="inlinecode"><span class="id" title="var">d</span></span>. Potrzebna jest więc nam zależna reguła
    indukcji.

<div class="paragraph"> </div>

    Na szczęście nie musimy implementować jej ręcznie - Coq potrafi
    zrobić to dla nas automatycznie (ale skoro tak, to dlaczego nie
    zrobił tego od razu? - nie pytaj, niezbadane są wyroki...). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">divD_ind'</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">divD</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Do generowania reguł indukcji służy komenda <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>. <span class="inlinecode"><span class="id" title="var">divD_ind'</span></span>
    to nazwa reguły, <span class="inlinecode"><span class="id" title="keyword">Induction</span></span> <span class="inlinecode"><span class="id" title="keyword">for</span></span> <span class="inlinecode"><span class="id" title="var">divD</span></span> mówi nam, dla jakiego typu
    lub rodziny typów chcemy regułę, zaś <span class="inlinecode"><span class="id" title="keyword">Sort</span></span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> mówi, że chcemy
    regułę, w której przeciwdziedziną motywu jest <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> (tak na
    marginesie - motyw eliminacji to typ lub rodzina typów, której
    element chcemy za pomocą eliminacji skonstruować - powinienem
    był wprowadzić tę nazwę wcześniej). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">divD_ind'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;divD_ind'&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;divD&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(l&nbsp;:&nbsp;n&nbsp;&lt;&nbsp;S&nbsp;m),&nbsp;P&nbsp;n&nbsp;m&nbsp;(divD_lt&nbsp;n&nbsp;m&nbsp;l))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(g&nbsp;:&nbsp;n&nbsp;&gt;=&nbsp;S&nbsp;m)&nbsp;(d&nbsp;:&nbsp;divD&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;d&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;(divD_ge&nbsp;n&nbsp;m&nbsp;g&nbsp;d))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(n&nbsp;n0&nbsp;:&nbsp;nat)&nbsp;(d&nbsp;:&nbsp;divD&nbsp;n&nbsp;n0),&nbsp;P&nbsp;n&nbsp;n0&nbsp;d<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, reguła wygenerowana przez komendę <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> jest zależna,
    gdyż jednym z argumentów <span class="inlinecode"><span class="id" title="var">P</span></span> jest <span class="inlinecode"><span class="id" title="var">divD</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n0</span></span>. Czas więc wrócić do
    dowodu faktu, że <span class="inlinecode"><span class="id" title="var">divG</span></span> jest wykresem <span class="inlinecode"><span class="id" title="var">div'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">divG_div'_aux</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">divD</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">divG</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (@<span class="id" title="var">div'_aux</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">d</span> <span class="id" title="keyword">using</span> <span class="id" title="var">divD_ind'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">div'_aux</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">div'_aux</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">IHd</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcję z użyciem innej niż domyślna reguły możemy zrobić za
    pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">divD_ind'</span></span>. Tym razem reguła
    jest wystarczająco ogólna, więc indukcja się udaje.

<div class="paragraph"> </div>

    Następnym krokiem w obu przypadkach jest odwinięcie definicji
    <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> i sprawdzenie, czy <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czy może <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Taki sposób postępowania jest kluczowy, gdyż próba użycia tu
    taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> skończyłaby się katastrofą - zamiast uprościć
    cel, wyprulibyśmy z niego flaki, które zalałyby nam ekran, a
    wtedy nawet przeczytanie celu byłoby trudne. Jeżeli nie
    wierzysz, spróbuj.

<div class="paragraph"> </div>

    Mamy więc dowód poprawności <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> względem wykresu. Wszystkie
    pozostałe dowody przechodzą bez zmian, więc nie będziemy ich tutaj
    powtarzać. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">again</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab587"></a><h2 class="section">Ekstrakcja</h2>

<div class="paragraph"> </div>

 Do rozstrzygnięcia pozostaje nam ostatnia już kwestia - po cholerę
    w ogóle bawić się w coś takiego? Powyższe trudności z eliminacją
    <span class="inlinecode"><span class="id" title="var">d</span></span>, dowodzeniem lematów wyciągających z <span class="inlinecode"><span class="id" title="var">d</span></span> podtermy, dowodzeniem
    przez indukcję po <span class="inlinecode"><span class="id" title="var">d</span></span>, generowaniem lepszych reguł indukcyjnych i
    unikaniem użycia taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> powinny jako żywo uzmysłowić nam,
    że uczynienie dziedziny <span class="inlinecode"><span class="id" title="var">divD</span></span> prawdziwym predykatem było raczej
    upośledzonym pomysłem.

<div class="paragraph"> </div>

    Odpowiedź jest krótka i mało przekonująca, a jest nią mechanizm
    ekstrakcji. Cóż to takiego? Otóż Coq dobrze sprawdza się przy
    definiowaniu programów i dowodzeniu ich właściwości, ale raczej
    słabo w ich wykonywaniu (komendy <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> czy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> są dość
    kiepskie).

<div class="paragraph"> </div>

    Mechanizm ekstrakcji to coś, co nas z tej nędzy trochę ratuje: daje
    on nam możliwość przetłumaczenia naszego programu w Coqu na program
    w jakimś nieco bardziej mainstreamowym języku funkcyjnym (jak OCaml,
    Haskell czy Scheme), w których programy da się normalnie odpalać i
    działają nawet szybko.

<div class="paragraph"> </div>

    Mechanizm ten nie będzie nas interesował, ponieważ moim zdaniem jest
    on ślepą uliczką ewolucji - zamiast niego trzeba będzie po prostu
    wymyślić sposób efektywnej kompilacji Coqowych programow, ale to już
    temat na inną bajkę.

<div class="paragraph"> </div>

    Nie będziemy zatem zbytnio zagłębiać się w szczegóły ekstrakcji -
    zanim zupełnie o niej zapomnimy, zobaczmy tylko jeden przykład. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">Language</span> <span class="id" title="var">Haskell</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Extraction</span></span> <span class="inlinecode"><span class="id" title="var">Language</span></span> ustawia język, do którego chcemy
    ekstrahować. My użyjemy Haskella, gdyż pozostałych dostępnych
    języków nie lubię. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">again.div'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div'&nbsp;::&nbsp;Nat&nbsp;-&gt;&nbsp;Nat&nbsp;-&gt;&nbsp;Nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div'&nbsp;=&nbsp;div'_aux&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Extraction</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> tłumaczy Coqowy program <span class="inlinecode"><span class="id" title="var">p</span></span> na program
    Haskellowy. Mimo że nie znamy Haskella, spróbujmy przeczytać
    wynikowy program.

<div class="paragraph"> </div>

    Wynikiem ekstrakcji jest Haskellowa funkcja <span class="inlinecode"><span class="id" title="var">div'</span></span> o typie
    <span class="inlinecode"><span class="id" title="var">Nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Nat</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">Nat</span></span> to Haskellowa wersja Coqowego <span class="inlinecode"><span class="id" title="var">nat</span></span>
    (podwójny dwukropek <span class="inlinecode">::</span> oznacza w Haskellu to samo, co pojedynczy
    dwukropek <span class="inlinecode">:</span> w Coqu). Funkcja <span class="inlinecode"><span class="id" title="var">div'</span></span> jest zdefiniowana jako... i tu
    zaskoczenie... <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>. Ale jak to? Rzućmy jeszcze raz okiem na
    oryginalną, Coqową definicję. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">again.div'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;again.div'&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;n&nbsp;m&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;again.div'_aux&nbsp;(again.divD_all&nbsp;n&nbsp;m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Gdzież w wyekstrahowanym programie podział się dowód <span class="inlinecode"><span class="id" title="var">divD_all</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>?
    Otóż nie ma go, bo Haskell to zwykły język programowania, w którym
    nie można dowodzić. O to właśnie chodzi w mechanizmie ekstrakcji -
    w procesie ekstrakcji wyrzucić z Coqowego programu wszystkie dowody
    i przetłumaczyć tylko tę część programu, która jest niezbędna, by
    wyekstrahowany program się obliczał.

<div class="paragraph"> </div>

    Mogłoby się wydawać dziwne, że najpierw w pocie czoła dowodzimy czegoś
    w Coqu, a potem mechanizm ekstrakcji się tego pozbywa. Jest to jednak
    całkiem naturalne - skoro udało nam się udowodnić jakąś właściwość
    naszego programu, to wiemy, że ma on tę właściwość i dowód nie jest
    nam już do niczego potrzebny, a zatem ekstrakcja może się go pozbyć. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">again.div'_aux</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;again.div'_aux&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;div'_aux&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(d&nbsp;:&nbsp;again.divD&nbsp;n&nbsp;m)&nbsp;{struct&nbsp;d}&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;le_lt_dec&nbsp;(S&nbsp;m)&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;left&nbsp;H&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;(div'_aux&nbsp;(n&nbsp;-&nbsp;S&nbsp;m)&nbsp;m&nbsp;(again.divD_ge_inv&nbsp;n&nbsp;m&nbsp;H&nbsp;d))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;right&nbsp;_&nbsp;=&gt;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;again.divD&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">again.div'_aux</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;::&nbsp;Nat&nbsp;-&gt;&nbsp;Nat&nbsp;-&gt;&nbsp;Nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;n&nbsp;m&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;le_lt_dec&nbsp;(S&nbsp;m)&nbsp;n&nbsp;of&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;-&gt;&nbsp;S&nbsp;(div'_aux&nbsp;(sub&nbsp;n&nbsp;(S&nbsp;m))&nbsp;m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;-&gt;&nbsp;O}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
A tak wygląda wyekstrahowana funkcja <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>. Jeżeli pominiemy
    różnice składniowe między Coqiem i Haskellem (w Coqu typ jest na
    dole, po dwukropku, a w Haskellu na górze, przed definicją; w Coqu
    mamy <span class="inlinecode"><span class="id" title="keyword">match</span></span>, a w Haskellu <span class="inlinecode"><span class="id" title="tactic">case</span></span> etc.) to wygląda całkiem podobnie.
    Kluczową różnicą jest widniejący w Coqowej wersji dowód należenia do
    dziedziny <span class="inlinecode"><span class="id" title="var">again.divD_ge_inv</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">d</span></span>, który w Haskellowym ekstrakcie
    został usunięty.

<div class="paragraph"> </div>

    Cały ten cyrk z przerabianiem <span class="inlinecode"><span class="id" title="var">divD</span></span> na prawdziwy predykat był po
    to, żeby dowód należenia do dziedziny mógł zostać usunięty podczas
    ekstrakcji. Dzięki temu wyekstrahowany program w Haskellu wygląda
    jak gdyby został napisany ręcznie. Jest też szybszy i krótszy, bo
    nie ma tam wzmianki o <span class="inlinecode"><span class="id" title="var">divD_all</span></span>, która musiałaby się pojawić, gdyby
    <span class="inlinecode"><span class="id" title="var">divD</span></span> było rodziną typów, a nie predykatem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">div'_aux</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;::&nbsp;Nat&nbsp;-&gt;&nbsp;Nat&nbsp;-&gt;&nbsp;DivD&nbsp;-&gt;&nbsp;Nat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;div'_aux&nbsp;_&nbsp;_&nbsp;h&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;h&nbsp;of&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DivD_lt&nbsp;_&nbsp;_&nbsp;-&gt;&nbsp;O;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DivD_ge&nbsp;n&nbsp;m&nbsp;h'&nbsp;-&gt;&nbsp;S&nbsp;(div'_aux&nbsp;(sub&nbsp;n&nbsp;(S&nbsp;m))&nbsp;m&nbsp;h')}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Tak wygląda ekstrakt oryginalnego <span class="inlinecode"><span class="id" title="var">div'_aux</span></span>, tzn. tego, w którym <span class="inlinecode"><span class="id" title="var">divD</span></span>
    nie jest predykatem, lecz rodziną typów. W wyekstrahowanym programie, w
    typie funkcji <span class="inlinecode"><span class="id" title="var">div'_aux</span></span> pojawia się złowieszczy typ <span class="inlinecode"><span class="id" title="var">DivD</span></span>, który jest
    zupełnie zbędny, bo Haskell (i żaden inny funkcyjny język programowania,
    który nie jest przeznaczony do dowodzenia) nie narzuca żadnych ograniczeń
    na wywołania rekurencyjne.

<div class="paragraph"> </div>

    No, to by było na tyle. Życzę ci, żebyś nigdy nie musiał stosować
    wariantu metody induktywnej dziedziny opisanej w tym podrozdziale
    ani nie musiał niczego ekstrahować. 
<div class="paragraph"> </div>

<a id="lab588"></a><h1 class="section">Komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span></h1>

<div class="paragraph"> </div>

 Odkryliśmy uniwersalną metodę definiowania funkcji i dowodzenia ich
    właściwości. Czego chcieć więcej?

<div class="paragraph"> </div>

    Po pierwsze, metoda definiowania nie jest uniwersalna (jeszcze), o czym
    przekonamy się w kolejnych podrozdziałach. Po drugie, mimo że metoda
    dowodzenia faktycznie jest uniwersalna, to komu normalnemu chciałoby
    się przy każdej funkcji tyle pisać? Jakieś wykresy, dziedziny, lematy,
    reguły indukcji, co to ma być?

<div class="paragraph"> </div>

    Czy w celu sprawnego definiowania i dowodzenia właściwości funkcji trzeba
    zoutsourcować cały proces i zatrudnić milion Hindusów? Na szczęście nie,
    gdyż bóg dał nam komendę <span class="inlinecode"><span class="id" title="keyword">Function</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Recdef</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda ta żyje w module <span class="inlinecode"><span class="id" title="var">Recdef</span></span>, którego nazwa jest skrótem od słów
    "recydywista defraudator"... dobra, koniec żartów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">div''</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) {<span class="id" title="keyword">measure</span> <span class="id" title="var">id</span> <span class="id" title="var">n</span>} : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> &lt;? <span class="id" title="var">S</span> <span class="id" title="var">m</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">div''</span> (<span class="id" title="var">n</span> - <span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">id</span>. <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">teq</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">leb_complete_conv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">teq</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div''_tcc&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_terminate&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_ind&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_rec&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div''_rect&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_div''_correct&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_div''_complete&nbsp;is&nbsp;defined&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Definicja zaczyna się od słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Function</span></span>, następnie mamy
    nazwę funkcji i argumenty, tak jak w zwykłych definicjach za pomocą
    <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> czy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, a później tajemniczą klauzulę
    <span class="inlinecode">{<span class="id" title="keyword">measure</span></span> <span class="inlinecode"><span class="id" title="var">id</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>, do której zaraz wrócimy, i zwracany typ. Ciało
    definicji wygląda dokładnie jak docelowa definicja.

<div class="paragraph"> </div>

    Jednak po kropce definicja nie kończy się - zamiast tego Coq każe nam
    udowodnić, że wywołanie rekurencyjne <span class="inlinecode"><span class="id" title="var">div''</span></span> odbywa się na argumencie
    mniejszym niż <span class="inlinecode"><span class="id" title="var">n</span></span>. Po zakończeniu dowodu funkcja zostaje zaakceptowana
    przez Coqa.

<div class="paragraph"> </div>

    To jednak nie koniec. Komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> nie tylko pozwala bezboleśnie
    zdefiniować <span class="inlinecode"><span class="id" title="var">div''</span></span>, ale też generuje dla nas całą masę różnych rzeczy:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">div''_tcc</span></span> to lemat, który mówi, że wszystkie wywołania rekurencyjne
      są na argumencie mniejszym od obecnego

</li>
<li> <span class="inlinecode"><span class="id" title="var">div''_terminate</span></span> to dowód tego, że funkcja terminuje (czyli że się
      nie zapętla). Jeżeli przyjrzysz się jego typowi, to zobaczysz, że
      jest podobny zupełnie do niczego. Wynika to z faktu, że komenda
      <span class="inlinecode"><span class="id" title="keyword">Function</span></span> tak naprawdę nie używa metody induktywnej dziedziny, ale
      pewnej innej metody definiowania funkcji ogólnie rekurencyjnych.
      Nie powinno nas to jednak martwić - ważne, że działa.

</li>
<li> <span class="inlinecode"><span class="id" title="var">div''_ind</span></span> to reguła indukcji wykresowej dla <span class="inlinecode"><span class="id" title="var">div''</span></span>. Jest też jej
      wariant <span class="inlinecode"><span class="id" title="var">div''_rect</span></span>, czyli "rekursja wykresowa", służąca raczej do
      definiowania niż dowodzenia.

</li>
<li> <span class="inlinecode"><span class="id" title="var">R_div''</span></span> to induktywnie zdefiniowany wykres funkcji <span class="inlinecode"><span class="id" title="var">div''</span></span>. Zauważ
      jednak, że nie jest on relacją, a rodziną typów - nie wiem po co i
      nie ma co wnikać w takie detale.

</li>
<li> <span class="inlinecode"><span class="id" title="var">R_div''_correct</span></span> to twierdzenie o poprawności wykresu.

</li>
<li> <span class="inlinecode"><span class="id" title="var">R_div''_complete</span></span> to twierdzenie o pełności wykresu.

</li>
<li> <span class="inlinecode"><span class="id" title="var">div''_equation</span></span> to równanie rekurencyjne 
</li>
</ul>

<div class="paragraph"> </div>

 Jak więc widać, nastąpił cud automatyzacji i wszystko robi się samo.
    To jednak nie koniec udogodnień. Zobaczmy, jak możemy udowodnić jakiś
    fakt o <span class="inlinecode"><span class="id" title="var">div''</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">div''_le</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">div''</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> &lt;= <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">functional</span> <span class="id" title="tactic">induction</span> (<span class="id" title="var">div''</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Nat.le_0_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">leb_complete_conv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dowodzenie właściwości funkcji zdefiniowanych za pomocą <span class="inlinecode"><span class="id" title="keyword">Function</span></span>
    jest bajecznie proste. Jeżeli wszystkie argumenty funkcji znajdują
    się w kontekście, to możemy użyć taktyki <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>
    <span class="inlinecode">(<span class="id" title="var">nazwa_funkcji</span></span> <span class="inlinecode"><span class="id" title="var">argument_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">argument_n</span>)</span>, która odpala indukcję
    wykresową dla tej funkcji. Z powodu nazwy tej taktyki indukcja
    wykresowa bywa też nazywana indukcją funkcyjną.

<div class="paragraph"> </div>

    Wujek Dobra Rada: nigdy nie odwijaj definicji funkcji zdefiniowanych
    za pomocą <span class="inlinecode"><span class="id" title="keyword">Function</span></span> ani nie próbuj ręcznie aplikować reguły indukcji
    wykresowej, bo skończy się to jedynie bólem i zgrzytaniem zębów.

<div class="paragraph"> </div>

    Na koniec wypadałoby jedynie dodać, że wcale nie złapaliśmy pana boga
    za nogi i komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> nie rozwiązuje wszystkich problemów
    pierwszego świata. W szczególności niektóre funkcje mogą być tak
    upierdliwe, że komenda <span class="inlinecode"><span class="id" title="keyword">Function</span></span> odmówi współpracy z nimi. Radzeniu
    sobie z takimi ciężkimi przypadkami poświęcimy kolejne podrozdziały. 
<div class="paragraph"> </div>

<a id="lab589"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">rot</span></span> (i wszystkie funkcje pomocnicze) jeszcze raz,
    tym razem za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Function</span></span>. Porównaj swoje definicje wykresu
    oraz reguły indukcji z tymi automatycznie wygenerowanymi. Użyj taktyki
    <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>, żeby jeszcze raz udowodnić, że <span class="inlinecode"><span class="id" title="var">rot</span></span> jest
    inwolucją. Policz, ile pisania udało ci się dzięki temu zaoszczędzić.

<div class="paragraph"> </div>

    Czy w twoim rozwiązaniu są lematy, w których użycie indukcji funkcyjnej
    znacznie utrudnia przeprowadzenie dowodu? W moim poprzednim rozwiązaniu
    był jeden taki, ale wynikał z głupoty i już go nie ma. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab590"></a><h1 class="section">Plugin <span class="inlinecode"><span class="id" title="keyword">Equations</span></span></h1>

<div class="paragraph"> </div>

<a id="lab591"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zainstaluj plugin
    <a class='link' href='https://github.com/mattam82/Coq-Equations'>Equations</a>.
    Przeczytaj
    <a class='link'
    href='https://raw.githubusercontent.com/mattam82/Coq-Equations/master/doc/equations_intro.v'>
    tutorial</a>.

<div class="paragraph"> </div>

    Następnie znajdź jakiś swój dowód przez indukcję, który był skomplikowany
    i napisz prostszy dowód za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Equations</span></span> i taktyki <span class="inlinecode"><span class="id" title="var">funelim</span></span>.

<div class="paragraph"> </div>

<a id="lab592"></a><h1 class="section">Podsumowanie (TODO)</h1>
</div>
<div class="code">
</div>
