<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">D2z: Dobre, złe i podejrzane typy induktywne</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Typonomikon</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">D1</span>.<br/>

<br/>
</div>

<div class="doc">
Poznana przez nas dotychczas definicja typów induktywnych (oraz wszelkich
    ich ulepszeń, jak indukcja-indukcja, indukcja-rekursja etc.) jest
    niepełna. Tak jak świat pełen jest złoczyńców oszukujących starszych
    ludzi metodą "na wnuczka", tak nie każdy typ podający się za induktywny
    faktycznie jest praworządnym obywatelem krainy typów induktywnych.

<div class="paragraph"> </div>

    Na szczęście typy induktywne to istoty bardzo prostolinijne, zaś te złe
    można odróżnić od tych dobrych gołym okiem, za pomocą bardzo prostego
    kryterium: złe typy induktywne to te, które nie są ściśle pozytywne.
    Zanim jednak dowiemy się, jak rozpoznawać złe typy induktywne, poznajmy
    najpierw dwa powody, przez które złe typy induktywne są złe.

<div class="paragraph"> </div>

    Przyjrzyjmy się poniższemu typowemu przypadkowi negatywnego typu
    induktywnego (co dokładnie znaczy w tym kontekście słowo "negatywny"
    i jak takie typy rozpoznawać zobaczymy później): 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;"(wut&nbsp;A&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;wut&nbsp;A".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Uwaga: poprzedzenie komendą <span class="inlinecode"><span class="id" title="var">Fail</span></span> innej komendy oznajmia Coqowi, że
    spodziewamy się, iż komenda zawiedzie. Coq akceptuje komendę <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>,
    jeżeli komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zawodzi, i wypisuje jej komunikat o błędzie. Jeżeli
    komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zakończy się sukcesem, komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> zwróci błąd.
    Komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> jest przydatna w sytuacjach takich jak obecna, gdy
    chcemy zilustrować fakt, że jakaś komenda zawodzi.

<div class="paragraph"> </div>

    W naszym przypadku komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> kończy się sukcesem, a zatem próba
    zdefiniowania powyższego typu induktywnego się nie powiodła. Wiadomość
    o błędzie podaje nam, jak na tacy, powód tej sytuacji: typ konstruktora
    <span class="inlinecode"><span class="id" title="var">C</span></span> zawiera nie-ściśle-pozytywne wystąpienie definiowanego typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> ma też jednak pewne wady: poza poświadczeniem rezultatu
    wykonania komendy <span class="inlinecode"><span class="id" title="var">c</span></span>, nie ma ona żadnych innych skutków. To sprawia, że
    użycie <span class="inlinecode"><span class="id" title="var">Fail</span></span> zmusiłoby nas, w dalszej części podrozdziału, do zaledwie
    udawania, że mamy jakiś typ i coś z nim robimy. To zaś jest bardzo złe,
    bo bez czujnego Coqowego oka bardzo łatwo jest napisać coś głupiego lub
    popełnić jakiś inny błąd. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">wut</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Na szczęście jest sposób na to, byśmy mogli pobawić się nie-ściśle-pozytywnymi
    typami induktywnymi pod czujnym okiem Coqa: posługując się komendą <span class="inlinecode"><span class="id" title="keyword">Unset</span></span>
    <span class="inlinecode"><span class="id" title="var">Positivity</span></span> <span class="inlinecode"><span class="id" title="var">Checking</span></span> możemy wyłączyć positivity checker (czyli po polsku
    "sprawdzacz pozytywności"), co sprawi, że Coq zaakceptuje definicję typu <span class="inlinecode"><span class="id" title="var">wut</span></span>.
    Dzięki temu będziemy mogli posługiwać się tym typem jak gdyby nigdy nic.

<div class="paragraph"> </div>

    Oczywiście takie rozwiązanie również niesie za sobą negatywne konsekwencje:
    jak za chwilę zobaczymy, z istnienia typu <span class="inlinecode"><span class="id" title="var">wut</span></span> można wywnioskować dowód
    fałszu, a zatem od teraz możemy udowodnić w Coqu dosłownie wszystko, więc
    teoretycznie wszystkie nasze dowody stają się bezwartościowe. W praktyce
    rzecz jasna nie będziemy tej sprzeczności wykorzystywać w niecnych celach,
    a istnienie typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dopuszczamy tylko w celach ilustracyjnych. 
<div class="paragraph"> </div>

<a id="lab469"></a><h1 class="section">Nieterminacja jako źródło zła na świecie</h1>

<div class="paragraph"> </div>

 Pierwszym powodem nielegalności nie-ściśle-pozytywnych typów induktywnych
    jest to, że unieważniają one filozoficzną interpretację teorii typów i
    pozwalają łamać reguły dzięki którym to co robimy w Coqu ma jakikolwiek
    sens (co jednak tylko czasami prowadzi do sprzeczności bezpośrednio).
    Przyjrzyjmy się poniższemu programowi: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> (<span class="id" title="var">w</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">w</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">C</span> <span class="id" title="var">_</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">g</span> <span class="id" title="var">w</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">in</span> <span class="id" title="var">f</span> (<span class="id" title="var">C</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
Już sam typ tego programu wygląda złowrogo: dla każdego typu <span class="inlinecode"><span class="id" title="var">A</span></span> program
    zwraca element typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Nie dziwota więc, że możemy uzyskać z niego dowód
    fałszu wstawiając <span class="inlinecode"><span class="id" title="var">False</span></span> za <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">santa_is_a_pedophile</span> : <span class="id" title="var">False</span> := <span class="id" title="var">loop</span> <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
Paradoksalnie jednak to nie ta rażąca sprzeczność jest naszym największym
    problemem - nie z każdego złego typu induktywnego da się tak łatwo dostać
    sprzeczność (systematyczny sposób dostawania sprzeczności z istnienia
    takich typów zobaczymy później). W rzeczywistości jest nim nieterminacja.

<div class="paragraph"> </div>

    Nieterminacja (ang. nontermination) lub kolokwialniej zapętlenie to sytuacja,
    w której program nigdy nie skończy się wykonywać. Ta właśnie bolączka jest
    przypadłością <span class="inlinecode"><span class="id" title="var">loop</span></span>, czego nietrudno domyślić się po nazwie.

<div class="paragraph"> </div>

    Dlaczego <span class="inlinecode"><span class="id" title="var">loop</span></span> nie terminuje? Przyjrzyjmy się definicji: za pomocą <span class="inlinecode"><span class="id" title="keyword">let</span></span>a
    definiujemy funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, która odpakowuje swój argument <span class="inlinecode"><span class="id" title="var">w</span></span>,
    wyciąga z niego funkcję <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> i aplikuje <span class="inlinecode"><span class="id" title="var">g</span></span> do <span class="inlinecode"><span class="id" title="var">w</span></span>, czyli do
    oryginalnego argumentu <span class="inlinecode"><span class="id" title="var">f</span></span>. Wynikiem całego programu jest <span class="inlinecode"><span class="id" title="var">f</span></span> zaaplikowane
    do siebie samego zawiniętego w konstruktor <span class="inlinecode"><span class="id" title="var">C</span></span> (żeby typy się zgadzały).

<div class="paragraph"> </div>

    Ta aplikacja czegoś do samego siebie to kolejny sygnał ostrzegawczy, który
    powinien wzbudzić naszą czujność. Ogólniej sytuacja, w której coś odnosi
    się samo do siebie, nazywa się autoreferencją i często prowadzi do różnych
    wesołych paradoksów.

<div class="paragraph"> </div>

    Żeby jeszcze lepiej zrozumieć nieterminację <span class="inlinecode"><span class="id" title="var">loop</span></span>, spróbujmy interaktywnie
    prześledzić, w jaki sposób program ten się oblicza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">loop</span> <span class="id" title="var">unit</span> = <span class="id" title="var">tt</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> [<span class="id" title="var">loop</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">zeta</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>. <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>. <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>; <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli jesteś leniwy i nie masz włączonego CoqIDE, sprowadza się to do czegoś
    w tym stylu:

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode">=</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span>

<div class="paragraph"> </div>

    i tak dalej.

<div class="paragraph"> </div>

    To natomiast, co powinno nas tu zdziwić, to fakt, że <span class="inlinecode"><span class="id" title="var">loop</span></span> jest funkcją
    w pewnym sensie rekurencyjną (bo funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> wywołuje sama siebie), mimo
    że przecież nie użyliśmy komendy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>!

<div class="paragraph"> </div>

    To jest właśnie jeden z przejawów zamętu, jaki wprowadzają negatywny typy
    induktywne - zmieniają reguły gry. Dotychczas <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (i <span class="inlinecode"><span class="id" title="keyword">fix</span></span>) dawały
    nam możliwość użycia rekursji (a w praktyce oznaczały, że rekursji faktycznie
    użyliśmy), zaś <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> (i <span class="inlinecode"><span class="id" title="keyword">fun</span></span>) świadczyło o tym, że funkcja nie jest
    rekurencyjna. Od kiedy tylko Coq zaakceptował definicję typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, regułę
    tę można bez przeszkód łamać, z opłakanymi konsekwencjami.

<div class="paragraph"> </div>

    Przyjrzyjmy się teraz problemom filozoficznym powodowanym przez
    nieterminację. W skrócie: zmienia ona fundamentalne właściwości
    obliczeń, co prowadzi do zmiany interpretacji pojęcia typu, zaś
    to pociąga za sobą kolejne przykre skutki, takie jak np. to, że
    reguły eliminacji tracą swoje uzasadnienie. Brzmi mega groźnie,
    prawda?

<div class="paragraph"> </div>

    Na szczęście tak naprawdę, to sprawa jest prosta. W Coqu wymagamy,
    aby każde obliczenie się kończyło. Końcowe wyniki obliczeń (zwane też
    wartościami, postaciami kanonicznymi lub postaciami normalnymi) możemy
    utożsamiać z elementami danego typu. Dla przykładu wynikami obliczania
    termów typu <span class="inlinecode"><span class="id" title="var">bool</span></span> są <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>, więc możemy myśleć, że są to
    elementy typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> składa się tylko z nich. To z kolei daje
    nam uzasadnienie reguły eliminacji (czyli indukcji) dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span>:
    żeby udowodnić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> dla każdego <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, wystarczy
    udowodnić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>, gdyż <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span> są jedynymi
    elementami typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    Nieterminacja obraca tę jakże piękną filozoficzną wizję w perzynę:
    nie każde obliczenie się kończy, a przez to powstają nowe, "dziwne"
    elementy różnych typów. <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> nigdy nie obliczy się do <span class="inlinecode"><span class="id" title="var">true</span></span> ani
    do <span class="inlinecode"><span class="id" title="var">false</span></span>, więc możemy traktować je jako nowy element typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. To
    sprawia, że <span class="inlinecode"><span class="id" title="var">bool</span></span>, typ z założenia dwuelementowy, ma teraz co najmniej
    trzy elementy - <span class="inlinecode"><span class="id" title="var">true</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Z tego też powodu reguła
    eliminacji przestaje obowiązywać, bo wymaga ona dowodów jedynie dla
    <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">false</span></span>, ale milczy na temat <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Moglibyśmy próbować
    naiwnie ją załatać, uwzględniając ten dodatkowy przypadek, ale tak po
    prawdzie, to nie wiadomo nawet za bardzo jakie jeszcze paskudztwa
    rozpanoszyły się w typie <span class="inlinecode"><span class="id" title="var">bool</span></span> z powodu nieterminacji.

<div class="paragraph"> </div>

    Morał jest prosty: nieterminacja to wynalazek szatana, a negatywne
    typy induktywne to też wynalazek szatana. 
<div class="paragraph"> </div>

<a id="lab470"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Użyj typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> żeby zdefiniować nieskończoną liczbę naturalną <span class="inlinecode"><span class="id" title="var">omega</span></span>
    (jeżeli szukasz inspiracji, zerknij na definicję <span class="inlinecode"><span class="id" title="var">loop</span></span>). Następnie udowodnij,
    że <span class="inlinecode"><span class="id" title="var">omega</span></span> jest większa od każdej innej liczby naturalnej. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">lt_n_omega</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">omega</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab471"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Jakie elementy ma typ <span class="inlinecode"><span class="id" title="var">nat</span></span>? Wypisz kilka początkowych, a potem opisz
    ogólną zasadę ich powstawania.

<div class="paragraph"> </div>

    Napisz jakiś term <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, który nie jest wartością, ale terminuje.
    Jaki jest wynik obliczenia tego termu?

<div class="paragraph"> </div>

    Następnie przyjrzyj się termowi <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Czy term ten terminuje?
    Pobaw się nim w trybie dowodzenia, żeby się przekonać (że nie, bo
    niby czego innego się spodziewałeś?).

<div class="paragraph"> </div>

    Przypomnij sobie regułę indukcji dla <span class="inlinecode"><span class="id" title="var">nat</span></span>. Gdyby udowodnić przez
    indukcję <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, jak wygląda dowód <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">t</span></span>
    to term, który napisałeś powyżej? A jak wygląda dowód <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">loop</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>? 
<div class="paragraph"> </div>

<a id="lab472"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Spróbujmy lepiej zrozumieć, o co chodzi z tym, że reguły eliminacji "tracą
    swoje uzasadnienie": udowodnij, że dla każdej liczby naturalnej istnieje
    liczba od niej większa (zdaje się, że już to przerabialiśmy). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">no_greatest</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Jak to możliwe, że udało nam się udowodnić to twierdzenie, skoro przecież
    w poprzedinm ćwiczeniu udowodniliśmy, że największą liczbą naturalną jest
    <span class="inlinecode"><span class="id" title="var">omega</span></span>?

<div class="paragraph"> </div>

    Ano, <span class="inlinecode"><span class="id" title="var">omega</span></span> jest niestandardową liczbą naturalną - pomiotem szatana
    powstałym w wyniku nieterminacji - i w związku z tym indukcja milczy
    na jej temat. Parafrazując: żeby udowodnić coś dla wszystkich liczb
    naturalnych przez indukcję, w ogóle nie musimy przejmować się omegą.
    Chyba nie trzeba dodawać, że to kolejna droga prowadząca prosto do
    sprzeczności? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">yes_and_no</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">no_greatest</span> <span class="id" title="var">omega</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">H1</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H2</span> := <span class="id" title="var">lt_n_omega</span> <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Nat.lt_asymm</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">wut</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby przez przypadek nie użyć żadnej ze sprzeczności, które daje nam typ
    <span class="inlinecode"><span class="id" title="var">wut</span></span>, schowaliśmy je w osobnym module, też nazwanym <span class="inlinecode"><span class="id" title="var">wut</span></span>. Oczywiście
    wciąż mamy do nich dostęp, ale teraz ciężej będzie nam się pomylić. 
<div class="paragraph"> </div>

<a id="lab473"></a><h1 class="section">Twierdzenie Cantora</h1>

<div class="paragraph"> </div>

 Zanim zaczniemy ten podrozdział na poważnie, mam dla ciebie wesoły
    łamaniec językowy:

<div class="paragraph"> </div>

    Cantor - kanciarz, który skradł zza kurtyny kantoru z Kantonu kontury
    kartonu Koranicznemu kanarowi, który czasem karał karczystych kafarów
    czarami za karę za kantowanie i za zakatowanie zza kontuaru konarem
    kontrkulturowych kuluarowych karłów.

<div class="paragraph"> </div>

    Dobra, wystarczy. Reszta tego podrozdziału będzie śmiertelnie poważna,
    a przyjrzymy się w niej jednemu z mega klasycznych twierdzeń z końca
    XIX w. głoszącemu mniej więcej, że "zbiór potęgowy zbioru liczb
    naturalnych ma większą moc od zbioru liczb naturalnych".

<div class="paragraph"> </div>

    Co za bełkot, pomyślisz zapewne. Ten podrozdział poświęcimy właśnie temu,
    żeby ów bełkot nieco wyklarować. Jeżeli zaś zastanawiasz się, po co nam
    to, to odpowiedź jest prosta - na (uogólnionym) twierdzeniu Cantora
    opierać się będzie nasza systematyczna metoda dowodzenia nielegalności
    negatywnych typów induktywnych.

<div class="paragraph"> </div>

    Oczywiście oryginalne sformułowanie twierdzenia powstało na długo przed
    powstaniem teorii typów czy Coqa, co objawia się np. w tym, że mówi ono
    o <i>zbiorze</i> liczb naturalnych, podczas gdy my dysponujemy <i>typem</i> liczb
    naturalnych. Musimy więc oryginalne sformułowanie lekko przeformułować,
    a także wprowadzić wszystkie niezbędne nam pojęcia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">surjective</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="tactic">exists</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">a</span> = <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszym niezbędnym pojęciem jest pojęcie surjekcji. Powyższa definicja
    głosi, że funkcja jest surjektywna, gdy każdy element przeciwdziedziny
    jest wynikiem funkcji dla pewnego elementu dziedziny. Surjekcja to
    funkcja, która jest surjektywna.

<div class="paragraph"> </div>

    O co chodzi w tej definicji? Samo słowo "surjekcja" pochodzi od fr.
    "sur" - "na" oraz łac. "iacere" - "rzucać". Ubogim tłumaczeniem na
    polski może być słowo "narzut".

<div class="paragraph"> </div>

    Idea jest taka, że surjekcja <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> "narzuca" swoją dziedzinę
    <span class="inlinecode"><span class="id" title="var">A</span></span> na przeciwdziedzinę <span class="inlinecode"><span class="id" title="var">B</span></span> tak, że <span class="inlinecode"><span class="id" title="var">A</span></span> "pokrywa" całe <span class="inlinecode"><span class="id" title="var">B</span></span>. Innymi
    słowy, każdy element <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest pokryty przez jakiś element <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    co wyraża równość <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>. Oczywiście to <span class="inlinecode"><span class="id" title="var">a</span></span> nie musi być unikalne -
    <span class="inlinecode"><span class="id" title="var">b</span></span> może być pokrywane przez dużo różnych <span class="inlinecode"><span class="id" title="var">a</span></span>. Jak widać, dokładnie to
    jest napisane w powyższej definicji.

<div class="paragraph"> </div>

    Mówiąc jeszcze prościej: jeżeli <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest surjekcją, to typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> jest większy (a precyzyjniej mówiący, nie mniejszy) niż typ <span class="inlinecode"><span class="id" title="var">B</span></span>.
    Oczywiście nie znaczy to, że jeżeli <span class="inlinecode"><span class="id" title="var">f</span></span> nie jest surjekcją, to typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> jest mniejszy niż <span class="inlinecode"><span class="id" title="var">B</span></span> - mogą przecież istnieć inne surjekcje.
    Powiemy, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest mniejszy od <span class="inlinecode"><span class="id" title="var">B</span></span>, jeżeli nie istnieje żadna
    surjekcja między nimi.

<div class="paragraph"> </div>

    Spróbujmy rozrysować to niczym Jacek Gmoch... albo nie, bo nie umiem
    jeszcze rysować, więc zamiast tego będzie przykład i ćwiczenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isZero</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
| 0 =&gt; <span class="id" title="var">true</span><br/>
| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_isZero</span> : <span class="id" title="var">surjective</span> <span class="id" title="var">isZero</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 42. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">isZero</span></span>, która sprawdza, czy jej argument jest zerem, jest
    surjekcją, bo każdy element typu <span class="inlinecode"><span class="id" title="var">bool</span></span> może być jej wynikiem -
    <span class="inlinecode"><span class="id" title="var">true</span></span> jest wynikiem dla <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">false</span></span> jest jej wynikiem dla
    wszystkich innych argumentów. Wobec tego możemy skonkludować, że
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span> jest większy niż typ <span class="inlinecode"><span class="id" title="var">bool</span></span> i w rzeczywistości faktycznie
    tak jest: <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dwa elementy, a <span class="inlinecode"><span class="id" title="var">nat</span></span> nieskończenie wiele.

<div class="paragraph"> </div>

    Do kwestii tego, który typ ma ile elementów wrócimy jeszcze w rozdziale
    o typach i funkcjach. Tam też zapoznamy się lepiej z surjekcjami i
    innymi rodzajami funkcji. Tymczasem: 
<div class="paragraph"> </div>

<a id="lab474"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Czy funkcja <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">5</span> jest surjekcją? A funkcja <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">minus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">5</span>?
    Sprawdź swoje odpowiedzi w Coqu. Na koniec filozoficznie zinterpretuj
    otrzymany wynik.

<div class="paragraph"> </div>

    Wskazówka: <span class="inlinecode"><span class="id" title="var">minus</span></span> to funkcja z biblioteki standardowej, która
    implementuje odejmowanie liczb naturalnych z obcięciem, czyli np.
    <span class="inlinecode">2</span> <span class="inlinecode">-</span> <span class="inlinecode">5</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. Użyj <span class="inlinecode"><span class="id" title="keyword">Print</span></span>a, żeby dokładnie zbadać jej definicję. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Pozostaje jeszcze kwestia tego, czym jest "zbiór potęgowy zbioru liczb
    naturalnych". Mimo groźnej nazwy sprawa jest prosta: jest to archaiczne
    określenie na typ funkcji <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Każdą funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    możemy interpretować jako pewną kolekcję (czyli właśnie zbiór) elementów
    typu <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaś <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, czyli wynik <span class="inlinecode"><span class="id" title="var">f</span></span> na konkretnym <span class="inlinecode"><span class="id" title="var">n</span></span>, mówi nam, czy
    <span class="inlinecode"><span class="id" title="var">n</span></span> znajduje się w tej kolekcji, czy nie.

<div class="paragraph"> </div>

    To w zasadzie wyczerpuje zestaw pojęć potrzebnych nam do sformułowania
    twierdzenia. Pojawiająca się w oryginalnej wersji "większa moc" to po
    prostu synonim określenia "większy", które potrafimy już wyrażać za
    pomocą pojęcia surjekcji. Tak więc nowszą (czyli bardziej postępową)
    wersję twierdzenia Cantora możemy sformułować następująco: nie istnieje
    surjekcja z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Lub jeszcze bardziej obrazowo: <span class="inlinecode"><span class="id" title="var">nat</span></span>
    jest mniejsze niż <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Cantor</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <span class="id" title="var">nat</span> -&gt; (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">bool</span>), ~ <span class="id" title="var">surjective</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">Hf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">diagonal</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">negb</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hf</span> <span class="id" title="var">diagonal</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">Hn</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">bool</span> =&gt; <span class="id" title="var">h</span> <span class="id" title="var">n</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">diagonal</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">inversion</span> <span class="id" title="var">Hn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Dowód twierdzenia jest równie legendarny jak samo twierdzenie, a na
    dodatek bajecznie prosty i niesamowicie użyteczny - jeżeli będziesz
    zajmował się w życiu matematyką i informatyką, spotkasz go w jeszcze
    wielu odsłonach. Metoda stojąca za dowodem nazywana bywa argumentem
    przekątniowym - choć nazwa ta może się wydawać dziwna, to za chwilę
    stanie się zupełnia jasna.

<div class="paragraph"> </div>

    O co więc chodzi w powyższym dowodzie? Po pierwsze zauważmy, że
    mamy do czynienia z funkcją <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>, czyli
    funkcją, która bierze liczbę naturalną i zwraca funkcję z liczb
    naturalnych w <span class="inlinecode"><span class="id" title="var">bool</span></span>. Pamiętajmy jednak, że <span class="inlinecode">-&gt;</span> łączy w prawo
    i wobec tego typ <span class="inlinecode"><span class="id" title="var">f</span></span> możemy zapisać też jako <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    Tak więc <span class="inlinecode"><span class="id" title="var">f</span></span> jest funkcją, która bierze dwie liczby naturalne i
    zwraca element typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    Dzięki temu zabiegowi możemy wyobrażać sobie <span class="inlinecode"><span class="id" title="var">f</span></span> jako dwuwymiarową
    tabelkę, której wiersze i kolumny są indeksowane liczbami naturalnymi,
    a komórki w tabelce wypełnione są wartościami typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. Przyjmijmy,
    że pierwszy argument <span class="inlinecode"><span class="id" title="var">f</span></span> to indeks wiersza, zaś drugi to indeks kolumny.
    W takim układzie <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> to wartość <span class="inlinecode"><span class="id" title="var">n</span></span>-tej funkcji na argumencie <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Wobec tego twierdzenie możemy sparafrazować mówiąc, że każda funkcja
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> znajduje się w którymś wierszu tabelki.

<div class="paragraph"> </div>

    To tyle wyobraźni - możemy już udowodnić twierdzenie. Na początku
    oczywiście bierzemy dowolne <span class="inlinecode"><span class="id" title="var">f</span></span> oraz zakładamy, że jest surjekcją,
    uprzednio odwijając definicję bycia surjekcją.

<div class="paragraph"> </div>

    Teraz musimy jakoś wyciągnąć sprzeczność z hipotezy <span class="inlinecode"><span class="id" title="var">Hf</span></span>, czyli,
    używając naszej tabelkowej parafrazy, znaleźć funkcję z <span class="inlinecode"><span class="id" title="var">nat</span></span> w
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, która nie znajduje się w tabelce. A nie znajdować się w
    tabelce, panie Ferdku, to znaczy: różnić się od każdej funkcji z
    tabelki na jakimś argumencie.

<div class="paragraph"> </div>

    Zamiast jednak szukać takiej funkcji po omacku, skonstruujmy ją
    z tego, co mamy pod ręką - czyli z naszej tabelki. Jak przerobić
    funkcje z tabelki na nową, której w nie ma w tabelce? Tu właśnie
    ujawnia się geniuszalność Cantora: użyjemy metody przekątniowej,
    czyli spojrzymy na przekątną naszej tabelki.

<div class="paragraph"> </div>

    Definiujemy więc nową funkcję <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> następująco:
    dla argumentu <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> bierzemy funkcję z <span class="inlinecode"><span class="id" title="var">n</span></span>-tego wiersza w tabelce,
    patrzymy na <span class="inlinecode"><span class="id" title="var">n</span></span>-tą kolumnę, czyli na wartość funkcji na argumencie
    <span class="inlinecode"><span class="id" title="var">n</span></span>, i zwracamy negację tego, co tam znajdziemy. Czujesz sprzeczność?

<div class="paragraph"> </div>

    Nasze założenie mówi, że <span class="inlinecode"><span class="id" title="var">diagonal</span></span> znajduje się w którymś wierszu
    tabelki - niech ma on numer <span class="inlinecode"><span class="id" title="var">n</span></span>. Wiemy jednak, że <span class="inlinecode"><span class="id" title="var">diagonal</span></span> różni
    się od <span class="inlinecode"><span class="id" title="var">n</span></span>-tej funkcji z tabelki na argumencie <span class="inlinecode"><span class="id" title="var">n</span></span>, gdyż zdefiniowaliśmy
    <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> jako negację tej właśnie komórki w tabelce. Dostajemy stąd
    równość <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">diagonal</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, co po analizie przypadków daje
    ostatecznie <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span> lub <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>.

<div class="paragraph"> </div>

    Voilà! Sprzeczność osiągnięta, a zatem początkowe założenie było
    błędne i nie istnieje żadna surjekcja z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
<div class="paragraph"> </div>

<a id="lab475"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że nie ma surjekcji z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Czy jest surjekcja
    z <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>? A w <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>? 
<div class="paragraph"> </div>

 Poznawszy twierdzenie Cantora, możemy powrócić do ścisłej pozytywności,
    czyż nie? Otóż nie, bo twierdzenie Cantora jest biedne. Żeby móc czerpać
    z niego niebotyczne profity, musimy najpierw uogólnić je na dowolne
    dwa typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> znajdując kryterium mówiące, kiedy nie istnieje
    surjekcja z <span class="inlinecode"><span class="id" title="var">A</span></span> w <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Cantor'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">modify</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">modify</span> <span class="id" title="var">b</span> &lt;&gt; <span class="id" title="var">b</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id" title="var">surjective</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">modify</span> <span class="id" title="var">H</span> <span class="id" title="var">Hf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">modify</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hf</span> <span class="id" title="var">g</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">Hx</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> =&gt; <span class="id" title="var">h</span> <span class="id" title="var">x</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">H</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Uogólnienie jest dość banalne. Najpierw zastępujemy <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> przez
    dowolne typy <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. W oryginalnym twierdzeniu nie użyliśmy żadnej
    właściwości liczb naturalnych, więc nie musimy szukać żadnych kryteriów
    dla typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Nasza tabelka może równie dobrze być indeksowana elementami
    dowolnego typu - dalej jest to tabelka i dalej ma przekątną.

<div class="paragraph"> </div>

    Twierdzenie było jednak zależne od pewnej właściwości <span class="inlinecode"><span class="id" title="var">bool</span></span>, mianowicie
    funkcja <span class="inlinecode"><span class="id" title="var">diagonal</span></span> była zdefiniowana jako negacja przekątnej. Było nam
    jednak potrzeba po prostu funkcji, która dla każdego elementu z przekątnej
    zwraca element <span class="inlinecode"><span class="id" title="var">bool</span></span> od niego różny. Ponieważ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dokładnie dwa
    elementy, to negacja jest jedyną taką funkcją.

<div class="paragraph"> </div>

    Jednak w ogólnym przypadku dobra będzie dowolna <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja bez
    punktów stałych. Ha! Nagły atak żargonu bezzębnych ryb, co? Zróbmy
    krótką przerwę, żeby zbadać sposób komunikacji tych czarodziejskich
    zwierząt pływających po uczelnianych korytarzach.

<div class="paragraph"> </div>

    Endofunkcja to funkcja, która ma taką samą dziedzinę i przeciwdziedzinę.
    Można się zatem domyślać, że <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja to funkcja o typie <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.
    Punkt stały zaś to takie <span class="inlinecode"><span class="id" title="var">x</span></span>, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Jest to więc dokładnie ta
    własność, której chcemy, żeby pożądana przez nas funkcja nie miała dla
    żadnego <span class="inlinecode"><span class="id" title="var">x</span></span>. Jak widać, żargon bezzębnych ryb jest równie zwięzły jak
    niepenetrowalny dla zwykłych śmiertelników.

<div class="paragraph"> </div>

    Podsumowując: w uogólnionym twierdzeniu Cantora nie wymagamy niczego od
    <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś od <span class="inlinecode"><span class="id" title="var">B</span></span> wymagamy tylko, żeby istniała funkcja <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>,
    która spełnia <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">b</span></span>. Dowód twierdzenia jest taki
    jak poprzednio, przy czym zastępujemy użycie <span class="inlinecode"><span class="id" title="var">negb</span></span> przez <span class="inlinecode"><span class="id" title="var">modify</span></span>. 
<div class="paragraph"> </div>

<a id="lab476"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Znajdź jedyny słuszny typ <span class="inlinecode"><span class="id" title="var">B</span></span>, dla którego nie istnieje żadna
    <span class="inlinecode"><span class="id" title="var">B</span></span>-endofunkcja bez punktów stałych.

<div class="paragraph"> </div>

    Podpowiedź: to zadanie jest naprawdę proste i naprawdę istnieje jedyny
    słuszny typ o tej właściwości.

<div class="paragraph"> </div>

    Pytanie (bardzo trudne): czy da się udowodnić w Coqu, że istnieje
    dokładnie jeden taki typ? Jeżeli tak, to w jakim sensie typ ten
    jest unikalny i jakich aksjomatów potrzeba do przepchnięcia dowodu? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab477"></a><h1 class="section">Twierdzenie Cantora jako młot na negatywność</h1>

<div class="paragraph"> </div>

 Z Cantorem po naszej stronie możemy wreszcie kupić ruble... ekhem,
    możemy wreszcie zaprezentować ogólną metodę dowodzenia, że negatywne
    typy induktywne prowadzą do sprzeczności. Mimo szumnej nazwy ogólna
    metoda nie jest aż taka ogólna i czasem będziemy musieli się bonusowo
    napracować. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Example1</span>.<br/>

<br/>
</div>

<div class="doc">
Otworzymy sobie nowy moduł, żeby nie zaśmiecać globalnej przestrzeni
    nazw - wszystkie nasze złe typy będą się nazywały <span class="inlinecode"><span class="id" title="var">wut</span></span>. Przy okazji,
    zdecydowanie powinieneś nabrać podejrzeń do tej nazwy - jeżeli coś w
    tej książce nazywa się <span class="inlinecode"><span class="id" title="var">wut</span></span>, to musi to być złowrogie, podejrzane
    paskudztwo. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">C</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak poprzednio, żeby Coq pozwolił nam zdefiniować <span class="inlinecode"><span class="id" title="var">wut</span></span> musimy
    na czas definicji wyłączyć sprawdzanie kryterium ścisłej pozytywności.
    Dlaczego bez wykonania tego zabiegu typ <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest nielegalny, a jego
    definicja zostałaby przez Coqa odrzucona? Poza wspomnianymi w poprzednim
    podrozdziale problemami filozoficznymi wynikającymi z nieterminacji,
    jest też drugi, bardziej namacalny powód: istnienie typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest
    sprzeczne z (uogólnionym) twierdzeniem Cantora. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">w</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span>) : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">w</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">C</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Powód tej sprzeczności jest dość prozaiczny: za pomocą konstruktora <span class="inlinecode"><span class="id" title="var">C</span></span>
    możemy z dowolnej funkcji <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> zrobić element <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a skoro
    tak, to dowolny element typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> możemy odpakować i wyjąć z niego
    funkcję o typie <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">surjective</span> (@<span class="id" title="var">extract</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">C</span> <span class="id" title="var">f</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro możemy włożyć dowolną funkcję, to znaczy, że dla każdej funkcji
    istnieje element, z którego możemy ją wyjąć, a zatem mamy do czynienia
    z surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> (@<span class="id" title="var">extract</span> <span class="id" title="var">bool</span>) <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W połączeniu zaś z twierdzeniem Cantora surjekcja <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>
    prowadzi do sprzeczności - wystarczy za <span class="inlinecode"><span class="id" title="var">A</span></span> wstawić <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Example1</span>.<br/>

<br/>
</div>

<div class="doc">
Przykład może ci się jednak wydać niezadowalający - typ <span class="inlinecode"><span class="id" title="var">wut</span></span> jest
    przecież dość nietypowy, bo ma tylko jeden konstruktor. A co, gdy
    konstruktorów jest więcej?

<div class="paragraph"> </div>

    Początkowo miałem opisać kilka przypadków z większą liczbą konstruktorów,
    ale stwierdziłem, że jednak mi się nie chce. W ćwiczeniach zobaczymy, czy
    będziesz w stanie sam wykombinować, jak się z nimi uporać (wskazówka: jest
    to bardzo łatwe, wystarczy chcieć i nie być leniwym jak ja). 
<div class="paragraph"> </div>

<a id="lab478"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższe paskudztwo łamie prawo ścisłej pozytywności nie jednym, lecz
    aż dwoma swoimi konstruktorami. Udowodnij, że jego istnienie prowadzi
    do sprzeczności. Metoda jest podobna jak w naszym przykładzie, ale
    trzeba ją troszkę dostosować do zastanej sytuacji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise1</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">C0</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">wut</span><br/>
| <span class="id" title="var">C1</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise1</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab479"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższe paskudztwo ma jeden konstruktor negatywny, a drugi pozytywny,
    niczym typowa panienka z borderlajnem...

<div class="paragraph"> </div>

    Polecenie jak w poprzednim ćwiczeniu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise2</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">C0</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">wut</span>) -&gt; <span class="id" title="var">wut</span><br/>
| <span class="id" title="var">C1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise2</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab480"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższy typ reprezentuje termy beztypowego rachunku lambda, gdzie <span class="inlinecode"><span class="id" title="var">V</span></span>
    to typ reprezentujący zmienne. Co to za zwierzątko ten rachunek lambda
    to my się jeszcze przekonamy... chyba, oby.

<div class="paragraph"> </div>

    Taki sposób reprezentowania rachunku lambda (i ogólnie składni języków
    programowania) nazywa się HOAS, co jest skrótem od ang. Higher Order
    Abstract Syntax. W wielu językach funkcyjnych jest to popularna technika,
    ale w Coqu, jak zaraz udowodnisz, jest ona nielegalna. Ława oburzonych
    jest rzecz jasna oburzona! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise3</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Term</span> (<span class="id" title="var">V</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Var</span> : <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span><br/>
| <span class="id" title="var">Lam</span> : (<span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span>) -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span><br/>
| <span class="id" title="var">App</span> : <span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span> -&gt; <span class="id" title="var">Term</span> <span class="id" title="var">V</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Var</span> {<span class="id" title="var">V</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Lam</span> {<span class="id" title="var">V</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">App</span> {<span class="id" title="var">V</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Term_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise3</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab481"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Poniższe bydle jeszcze do niedawna wydawało mi się całkiem trudne i problematyczne,
    ale oczywiście jest bardzo proste. Uszy do góry i do dzieła! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Exercise4</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">C</span> : (<span class="id" title="var">wut</span> -&gt; <span class="id" title="var">wut</span>) -&gt; <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wut_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise4</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab482"></a><h1 class="section">Poradnik rozpoznawania negatywnych typów induktywnych</h1>

<div class="paragraph"> </div>

 Skoro już wiemy, że negatywne typy induktywne są wynalazkiem szatana,
    to czas podać proste kryterium na ich rozpoznawanie. Jeżeli jesteś
    sprytny, to pewnie sam zdążyłeś już zauważyć ogólną regułę. Jednak aby
    nie dyskryminować osób mało sprytnych, trzeba napisać ją wprost.

<div class="paragraph"> </div>

    Kryterium jest banalne. Mając dany typ <span class="inlinecode"><span class="id" title="var">T</span></span> musimy rzucić okiem na jego
    konstruktory, a konkretniej na ich argumenty. Argumenty nieindukcyjne
    (czyli o typach, w których nie występuje <span class="inlinecode"><span class="id" title="var">T</span></span>) są zupełnie niegroźne i
    wobec tego powinniśmy je zignorować. Interesować nas będą wyłącznie
    argumenty indukcyjne, czyli takie, w których występuje typ <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Najbardziej podstawowy typ argumentu indukcyjnego, czyli samo <span class="inlinecode"><span class="id" title="var">T</span></span>, jest
    rzecz jasna niegroźny. To samo dotyczy argumentu indukcyjnego o typie
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Wprawdzie jest on typu funkcyjnego, co, jak się zaraz przekonamy,
    jest groźne, ale <span class="inlinecode"><span class="id" title="var">T</span></span> występuje po prawej stronie strzałki, więc wszystko jest
    w porządku. W ogólności w porządku są też argumenty typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest znanym typem niezależącym od <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Niektóre typy argumentów indukcyjnych również są niegroźne, np. <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> albo <span class="inlinecode">{<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>}</span>, ale ich użycie sprawia, że Coq nie
    potrafi wygenerować dla definiowanego typu odpowiedniej reguły indukcji,
    więc generuje jedynie regułę analizy przypadków. Te typy argumentów nie
    prowadzą do sprzeczności, ale powinniśmy ich unikać, bo są upierdliwe i
    każde takie wystąpienie argumentu indukcyjnego można łatwo zrefaktoryzować.

<div class="paragraph"> </div>

    Argument typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span> można zastąpić dwoma argumentami typu <span class="inlinecode"><span class="id" title="var">T</span></span>
    i podobnie dla <span class="inlinecode">{<span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>}</span>. Konstruktor z argumentem typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    możemy rozbić na dwa konstruktory (i powinniśmy, bo jest to bardziej
    czytelne). Konstruktor z wystąpieniem <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> możemy przerobić na
    definicję przez indukcję wzajemną (ćwiczenie: sprawdź jak), ale lepiej
    chyba po prostu zaimplementować regułę indukcji ręcznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T0</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c2</span> : <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c3</span> : <span class="id" title="var">nat</span> * <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c4</span> : <span class="id" title="var">T0</span> * <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c5</span> : <span class="id" title="var">T0</span> + <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c6</span> : <span class="id" title="var">list</span> <span class="id" title="var">T0</span> -&gt; <span class="id" title="var">T0</span><br/>
| <span class="id" title="var">c7</span> : (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">T0</span>) -&gt; <span class="id" title="var">T0</span>.<br/>

<br/>
</div>

<div class="doc">
Rodzaje nieszkodliwych typów argumentów widać na powyższym przykładzie.
    Konstruktory <span class="inlinecode"><span class="id" title="var">c0</span></span> i <span class="inlinecode"><span class="id" title="var">c1</span></span> są nieindukcyjne, więc są ok. Konstruktor <span class="inlinecode"><span class="id" title="var">c2</span></span>
    jest indukcyjny - jest jeden argument typu <span class="inlinecode"><span class="id" title="var">T0</span></span>. Zauważ, że typem
    konstruktora <span class="inlinecode"><span class="id" title="var">c2</span></span> jest <span class="inlinecode"><span class="id" title="var">T0</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T0</span></span>, ale nie oznacza to, że <span class="inlinecode"><span class="id" title="var">T0</span></span>
    występuje po lewej stronie strzałki!

<div class="paragraph"> </div>

    Jest tak, gdyż ostatnie wystąpienie <span class="inlinecode"><span class="id" title="var">T0</span></span> jest konkluzją konstruktora
    <span class="inlinecode"><span class="id" title="var">c2</span></span>. Ważne są tylko wystąpienia po lewej stronie strzałki w argumentach
    (gdyby konstruktor <span class="inlinecode"><span class="id" title="var">c2</span></span> nie był legalny, to jedynymi legalnymi typami
    induktywnymi byłyby enumeracje).

<div class="paragraph"> </div>

    Konstruktory <span class="inlinecode"><span class="id" title="var">c3</span></span>, <span class="inlinecode"><span class="id" title="var">c4</span></span>, <span class="inlinecode"><span class="id" title="var">c5</span></span> i <span class="inlinecode"><span class="id" title="var">c6</span></span> są induktywne i również w pełni
    legalne, ale są one powodem tego, że Coq nie generuje dla <span class="inlinecode"><span class="id" title="var">T0</span></span> reguły
    indukcji, a jedynie regułę analizy przypadków (choć nazywa się ona
    <span class="inlinecode"><span class="id" title="var">T0_ind</span></span>). Konstruktor <span class="inlinecode"><span class="id" title="var">c7</span></span> również jest w pełni legalny. 
<div class="paragraph"> </div>

<a id="lab483"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zrefaktoryzuj powyższy upośledzony typ. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Problem pojawia się dopiero wtedy, gdy typ <span class="inlinecode"><span class="id" title="var">T</span></span> występuje po lewej
    stronie strzałki, np. <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, lub
    gdy jest skwantyfikowany uniwersalnie, np. <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> (typ
    <span class="inlinecode"><span class="id" title="var">T</span></span> jest dziedziną kwantyfikacji) lub <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span>),</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span>
    (tym razem <span class="inlinecode"><span class="id" title="var">T</span></span> jest dziedziną dziedziny kwantyfikacji).

<div class="paragraph"> </div>

    W trzech poprzednich podrozdziałach mierzyliśmy się z sytuacjami, gdy
    typ <span class="inlinecode"><span class="id" title="var">T</span></span> występował bezpośrednio na lewo od strzałki, ale oczywiście
    może on być dowolnie zagnieżdżony. Dla każdego wystąpienia <span class="inlinecode"><span class="id" title="var">T</span></span> w
    argumentach możemy policzyć, na lewo od ilu strzałek się ono znajduje
    (czyli jak mocno zagnieżdżona jest dziedzina kwantyfikacji). Liczbę tę
    nazywać będziemy niedobrością. W zależności od niedobrości,
    wystąpienie nazywamy:
<ul class="doclist">
<li> 0 - wystąpienie ściśle pozytywne

</li>
<li> liczba nieparzysta - wystąpienie negatywne

</li>
<li> liczba parzysta (poza 0) - wystąpienie pozytywne

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli w definicji mamy wystąpienie negatywne, to typ możemy nazywać
    negatywnym typem induktywnym (choć oczywiście nie jest to legalny typ
    induktywny). Jeżeli nie ma wystąpień negatywnych, ale są wystąpienia
    pozytywne, to typ nazywamy pozytywnym typem induktywnym (lub
    nie-ściśle-pozytywnym typem induktywnym), choć oczywiście również nie
    jest to legalny typ induktywny. Jeżeli wszystkie wystąpienia są ściśle
    pozytywne, to mamy do czynienia po prostu z typem induktywnym.
    Parafrazując: każdy typ induktywny jest ściśle pozytywny.

<div class="paragraph"> </div>

    Podobne nazewnictwo możemy sobie wprowadzić dla konstruktorów
    (konstruktory negatywne, pozytywne i ściśle pozytywne), ale nie
    ma sensu, bo za tydzień i tak zapomnisz o tych mało istotnych detalach.
    Ważne, żebyś zapamiętał najważniejsze, czyli ideę. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;T1&nbsp;:&nbsp;Type&nbsp;:=<br/>
|&nbsp;T1_0&nbsp;:&nbsp;T1&nbsp;-&gt;&nbsp;T1<br/>
|&nbsp;T1_1&nbsp;:&nbsp;(T1&nbsp;-&gt;&nbsp;T1)&nbsp;-&gt;&nbsp;T1<br/>
|&nbsp;T1_2&nbsp;:&nbsp;((T1&nbsp;-&gt;&nbsp;T1)&nbsp;-&gt;&nbsp;T1)&nbsp;-&gt;&nbsp;T1<br/>
|&nbsp;T1_3&nbsp;:&nbsp;forall&nbsp;(t&nbsp;:&nbsp;T1)&nbsp;(P&nbsp;:&nbsp;T1&nbsp;-&gt;&nbsp;Prop),&nbsp;P&nbsp;t&nbsp;-&gt;&nbsp;T1.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
W powyższym przykładzie wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w pierwszym argumencie
    <span class="inlinecode"><span class="id" title="var">T1_0</span></span> jest ściśle pozytywne (na lewo od 0 strzałek). Pierwsze
    wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w <span class="inlinecode"><span class="id" title="var">T1_1</span></span> jest negatywne (na lewo od 1 strzałki),
    a drugie ściśle pozytywne (na lewo od 0 strzałek). Pierwsze
    wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w <span class="inlinecode"><span class="id" title="var">T1_2</span></span> jest pozytywne (na lewo od 2 strzałek),
    drugie negatywne (na lewo od 1 strzałki), trzecie zaś ściśle
    pozytywne (na lewo od 0 strzałek). Pierwsze wystąpienie <span class="inlinecode"><span class="id" title="var">T1</span></span> w
    <span class="inlinecode"><span class="id" title="var">T1_3</span></span> jest negatywne (dziedzina kwantyfikacji), drugie zaś
    pozytywne (na lewo od jednej strzałki, ale ta strzałka jest w
    typie, po którym kwantyfikujemy).

<div class="paragraph"> </div>

    Konstruktor <span class="inlinecode"><span class="id" title="var">T1_0</span></span> jest ściśle pozytywny, zaś konstruktory <span class="inlinecode"><span class="id" title="var">T1_1</span></span>,
    <span class="inlinecode"><span class="id" title="var">T1_2</span></span> oraz <span class="inlinecode"><span class="id" title="var">T1_3</span></span> są negatywne. Wobec tego typ <span class="inlinecode"><span class="id" title="var">T1</span></span> jest negatywnym
    typem induktywnym (czyli nie jest legalnym typem induktywnym i dlatego
    właśnie Coq odrzuca jego definicję). 
<div class="paragraph"> </div>

<a id="lab484"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;T2&nbsp;:&nbsp;Type&nbsp;:=<br/>
|&nbsp;T2_0&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;f&nbsp;:&nbsp;(forall&nbsp;g&nbsp;:&nbsp;(forall&nbsp;t&nbsp;:&nbsp;T2,&nbsp;nat),&nbsp;Prop),&nbsp;T2<br/>
|&nbsp;T2_1&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(((((T2&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2<br/>
|&nbsp;T2_2&nbsp;:<br/>
&nbsp;&nbsp;((forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;T2&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;t&nbsp;:&nbsp;T2,&nbsp;nat))&nbsp;-&gt;&nbsp;T2)&nbsp;-&gt;&nbsp;T2&nbsp;-&gt;&nbsp;T2&nbsp;-&gt;&nbsp;T2.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Policz niedobrość każdego wystąpienia <span class="inlinecode"><span class="id" title="var">T2</span></span> w powyższej definicji.
    Sklasyfikuj konstruktory jako negatywne, pozytywne lub ściśle
    pozytywne. Następnie sklasyfikuj sam typ jako negatywny, pozytywny
    lub ściśle pozytywny. 
<div class="paragraph"> </div>

<a id="lab485"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Inductive&nbsp;T&nbsp;:&nbsp;Type&nbsp;:=&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Rozstrzygnij, czy następujące konstruktory spełniają kryterium ścisłej
    pozytywności. Jeżeli tak, narysuj wesołego jeża. Jeżeli nie, napisz
    zapętlającą się funkcję podobną do <span class="inlinecode"><span class="id" title="var">loop</span></span> (zakładamy, że typ <span class="inlinecode"><span class="id" title="var">T</span></span> ma
    tylko ten jeden konstruktor). Następnie sprawdź w Coqu, czy udzieliłeś
    poprawnej odpowiedzi.
<ul class="doclist">
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C3</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C4</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C5</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C6</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C7</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C8</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C9</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C10</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>),</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C11</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span>
                  <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab486"></a><h1 class="section">Kilka bonusowych pułapek</h1>

<div class="paragraph"> </div>

 Wiemy już, że niektóre typy argumentów indukcyjnych są ok (<span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>),
    inne problematyczne (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>), a jeszcze inne nielegalne (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">...</span>). Uważny i żądny wiedzy czytelnik (daj boże, żeby tacy
    istnieli) zeche zapewne postawić sobie pytanie: które dokładnie typy argumentów
    indukcyjnych są ok, a które są wynalazkiem szatana? 
<div class="paragraph"> </div>

<a id="lab487"></a><h2 class="section">Zabawy z parametrami</h2>

<div class="paragraph"> </div>

 Najprościej będzie sprawę zbadać empirycznie, czyli na przykładzie.
    Żeby zaś przykład był reprezentatywny, niech parametrem definicji
    będzie dowolna funkcja <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">wut</span> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">wut_0</span> : <span class="id" title="var">F</span> (<span class="id" title="var">wut</span> <span class="id" title="var">F</span>) -&gt; <span class="id" title="var">wut</span> <span class="id" title="var">F</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"F&nbsp;(wut&nbsp;F)&nbsp;-&gt;&nbsp;wut&nbsp;F".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, jeżeli zaaplikujemy <span class="inlinecode"><span class="id" title="var">F</span></span> do argumentu indukcyjnego, to Coq
    krzyczy, że to wystąpienie nie jest ściśle pozytywne. Dlaczego tak
    jest, skoro <span class="inlinecode"><span class="id" title="var">F</span></span> nie jest ani strzałką, ani kwantyfikatorem uniwersalnym?
    Dlatego, że choć nie jest nimi, to może nimi zostać. Jeżeli zdefiniujemy
    sobie gdzieś na boku <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, to wtedy
    <span class="inlinecode"><span class="id" title="var">wut_0</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span>, a z takim diabelstwem już się
    mierzyliśmy i wiemy, że nie wróży ono niczego dobrego.

<div class="paragraph"> </div>

    Morał z tej historii jest dość banalny: gdy definiujemy typ induktywny
    <span class="inlinecode"><span class="id" title="var">T</span></span>, jedynymi prawilnymi typami dla argumentu indukcyjnego są <span class="inlinecode"><span class="id" title="var">T</span></span> oraz
    typy funkcji, które mają <span class="inlinecode"><span class="id" title="var">T</span></span> jako konkluzję (<span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    etc.). Wszystkie inne albo rodzą problemy z automatyczną generacją
    reguł indukcji (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>), albo prowadzą do sprzeczności
    (<span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">...</span>), albo mogą prowadzić do sprzeczności,
    jeżeli wstawi się za nie coś niedobrego (<span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>). 
<div class="paragraph"> </div>

<a id="lab488"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj rodzinę typów z powyższego przykładu (wyłączając sprawdzanie
    kryterium ścisłej pozytywności) i udowodnij, że jej istnienie prowadzi
    do sprzeczności. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab489"></a><h2 class="section">Pułapki dla indukcji wzajemnej</h2>

<div class="paragraph"> </div>

 To jeszcze nie koniec wrażeń na dziś - póki co omówiliśmy wszakże
    kryterium ścisłej pozytywności jedynie dla bardzo prostych typów
    induktywnych. Słowem nie zająknęliśmy się nawet na temat typów
    wzajemnie induktywnych czy indeksowanych typów induktywnych. Nie
    trudno będzie nam jednak uzupełnić naszą wiedzę, gdyż w przypadku
    oby tych mechanizmów kryterium ścisłej pozytywności wygląda podobnie
    jak w znanych nam już przypadkach (choć jest kilka kruczków, na które
    trzeba uważać). Spójrzmy na poniższy przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">X0</span> : <span class="id" title="var">X</span><br/>
| <span class="id" title="var">X1</span> : (<span class="id" title="var">Y</span> -&gt; <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">Y</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Y0</span> : <span class="id" title="var">Y</span><br/>
| <span class="id" title="var">Y1</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">Y</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"Y"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;"(Y&nbsp;-&gt;&nbsp;X)&nbsp;-&gt;&nbsp;X".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, powyższa definicja <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> przez wzajemną indukcję jest
    nielegalna, gdyż jedyny argument konstruktora <span class="inlinecode"><span class="id" title="var">X1</span></span> ma typ <span class="inlinecode"><span class="id" title="var">Y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span>.
    Mogłoby wydawać się, że wszystko jest w porządku, wszakże <span class="inlinecode"><span class="id" title="var">X</span></span> występuje
    tutaj na pozycji ściśle pozytywnej. Jednak ponieważ jest to definicja
    przez indukcję wzajemną, kryterium ścisłej pozytywności stosuje się nie
    tylko do wystąpień <span class="inlinecode"><span class="id" title="var">X</span></span>, ale także do wystąpień <span class="inlinecode"><span class="id" title="var">Y</span></span> - wszystkie wystąpienia
    <span class="inlinecode"><span class="id" title="var">X</span></span> oraz <span class="inlinecode"><span class="id" title="var">Y</span></span> muszą być ściśle pozytywne zarówno w konstruktorach typu <span class="inlinecode"><span class="id" title="var">X</span></span>,
    jak i w konstruktorach typu <span class="inlinecode"><span class="id" title="var">Y</span></span>. 
<div class="paragraph"> </div>

<a id="lab490"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj typy <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> wyłączając positivity checker. Udowodnij za
    pomocą twierdzenia Cantora, że typy <span class="inlinecode"><span class="id" title="var">X</span></span> i <span class="inlinecode"><span class="id" title="var">Y</span></span> są nielegalne. Zdefiniuj
    też nieterminujące elementy <span class="inlinecode"><span class="id" title="var">loopx</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span> oraz <span class="inlinecode"><span class="id" title="var">loopy</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Y</span></span> i pobaw się
    nimi w trybie dowodzenia, żeby upewnić się, że faktyzcnie nie terminują.
    Pytanie bonusowe: czy do zdefiniowania <span class="inlinecode"><span class="id" title="var">loopx</span></span> i <span class="inlinecode"><span class="id" title="var">loopy</span></span> konieczna jest
    rekursja wzajemna? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab491"></a><h1 class="section">Jeszcze więcej pułapek</h1>

<div class="paragraph"> </div>

 To już prawie koniec naszej wędrówki przez świat nielegalnych typów
    "induktywnych". Dowiedzieliśmy się, że negatywne typy induktywne
    prowadzą do nieterminacji i nauczyliśmy się wykorzystywać twierdzenie
    Cantora do dowodzenia nielegalności takich typów.

<div class="paragraph"> </div>

    Poznaliśmy też jednak klasyfikację typów wyglądających na induktywne
    (ściśle pozytywne, pozytywne, negatywne), a w szczególności pojęcie
    "niedobrości" indukcyjnego wystąpienia definiowanego typu w konstruktorze
    (upraszczając, na lewo od ilu strzałek znajduje się to wystąpienie).

<div class="paragraph"> </div>

    Piszę "jednak", gdyż z jej powodu możemy czuć pewien niedosyt - wszystkie
    dotychczasowe przykłady były typami negatywnymi o niedobrości równej 1.
    Podczas naszej intelektualnej wędrówki zwiedziliśmy mniej miejscówek,
    niż moglibyśmy chcieć. W tym podrozdziale spróbujemy ten przykry niedosyt
    załatać, rozważając (nie ściśle) pozytywne typy induktywne. Zobaczymy
    formalny dowód na to, że nie są one legalne (lub, precyzyjniej pisząc,
    dowód na to, że conajmniej jeden z nich nie jest legalny). Zanim jednak
    to się stanie, zobaczmy, czy wypracowane przez nas techniki działają na
    negatywne typy induktywne o niedobrości innej niż 1. 
<div class="paragraph"> </div>

<a id="lab492"></a><h2 class="section">Większa niedobrość</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T3</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T3</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">T3_0</span> : (((<span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">T3</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy się powyższej definicji. Występienie indukcyjne typu <span class="inlinecode"><span class="id" title="var">T3</span></span>
    ma współczynnik niedobrości równy 3, gdyż znajduje się na lewo od 3
    strzałek. Prawe strony wszystkich z nich to <span class="inlinecode"><span class="id" title="var">bool</span></span>. Zanim zobaczymy,
    jak pokazać nielegalność tego typu metodą Cantora, przypomnijmy sobie
    pewien kluczowy fakt dotyczący negacji i jego banalne uogólnienie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_negation</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ ~ ~ <span class="id" title="var">P</span> -&gt; ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_arrow</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, (((<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>).<br/>

<br/>
</div>

<div class="doc">
Fakt ten przypomina nam, że jeżeli chodzi o spamowanie negacją, to
    są w zasadzie tylko trzy sytuacje:
<ul class="doclist">
<li> brak negacji

</li>
<li> pojedyncza negacja

</li>
<li> podwójna negacja

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli mamy do czynienia z większą liczbą negacji, to możemy zdejmować
    po dwie aż dojdziemy do któregoś z powyższych przypadków. Ponieważ
    negacja to tylko implikacja, której kodziedziną jest <span class="inlinecode"><span class="id" title="var">False</span></span>, a nie
    korzystamy w dowodzie z żadnych specjalnych właściwości <span class="inlinecode"><span class="id" title="var">False</span></span>,
    analogiczna właściwość zachodzi także dla dowolnego innego <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T3</span>) : <span class="id" title="var">T3</span> -&gt; <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">T3_0</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">T3</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">g</span> <span class="id" title="var">y</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Wobec powyższych rozważań definicja funkcji <span class="inlinecode"><span class="id" title="var">extract</span></span> zupełnie nie powinna
    cię zaskakiwać (a jeżeli cię zaskakuje, to sprawdź jak wygląda term, który
    skonstruowałeś dowodząc <span class="inlinecode"><span class="id" title="var">triple_arrow</span></span> - jeżeli zrobiłeś to dobrze, to
    powinien wyglądać podobnie do definicji <span class="inlinecode"><span class="id" title="var">extract</span></span>). Szczerze pisząc, reszta
    dowodu również nie jest jakoś specjalnie wymagająca czy oświecająca. 
<div class="paragraph"> </div>

<a id="lab493"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Dokończ dowód. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">T3_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab494"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisanie zapętlającej się funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T3</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> też nie
    jest jakoś wybitnie trudne. Napisz ją i pobaw się nią w trybie
    dowodzenia, żeby przekonać się, że faktycznie nie terminuje
    (dla jakiegoś argumentu <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T3</span></span>, który musisz sam wymyślić -
    to również nie jest specjalnie trudne). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T3</span>.<br/>

<br/>
</div>

<div class="doc">
Morał z powyższych rozważań jest prosty: nasze techniki działają także
    na negatywne typy induktywne o niedobrości równej 3. Myślę, że jesteś
    całkiem skłonny uwierzyć też, że zadziałają na te o niedobrości równej
    5, 7 i tak dalej. 
<div class="paragraph"> </div>

<a id="lab495"></a><h2 class="section">Upierdliwe kodziedziny</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
</div>

<div class="doc">
To wszystko jest prawdą jednak tylko wtedy, gdy wszystkie typy po prawych
    stronach strzałek będą takie same. A co, gdy będą różne? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T4</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T4</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T4</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższy przykład jest podobny do poprzedniego, ale tym razem zamiast
    trzech wystąpień <span class="inlinecode"><span class="id" title="var">bool</span></span> mamy <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">Color</span></span> (to ostatnie
    to typ, który zdefiniowaliśmy na samym początku tego rozdziału, gdy
    uczyliśmy się o enumeracjach). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T4</span>) : <span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Nasz modus operandi będzie taki jak poprzednio: spróbujemy wyjąć z
    elementu <span class="inlinecode"><span class="id" title="var">T4</span></span> funkcję typu <span class="inlinecode"><span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. W tym celu rozbijamy <span class="inlinecode"><span class="id" title="var">x</span></span>
    i wprowadzamy <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T4</span></span> do kontekstu.

<div class="paragraph"> </div>

    Tym razem nie możemy jednak bezpośrednio zaaplikować <span class="inlinecode"><span class="id" title="var">f</span></span>, gdyż jej
    kodziedziną jest <span class="inlinecode"><span class="id" title="var">Color</span></span>, a my musimy skonstruować coś typu <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    Możemy temu jednak zaradzić aplikując do celu skonstruowaną naprędce
    funkcję typu <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Ta funkcja powinna być surjekcją (jeśli
    nie wierzysz, sprawdź, co się stanie, jeżeli zamienimy ją na funckję
    stałą albo inną nie-surjekcję).

<div class="paragraph"> </div>

    Możemy już zaaplikować <span class="inlinecode"><span class="id" title="var">f</span></span> i wprowadzić <span class="inlinecode"><span class="id" title="var">g</span></span> do kontekstu. Chcielibyśmy
    teraz zaaplikować <span class="inlinecode"><span class="id" title="var">g</span></span>, ale nie możemy, bo typy się nie zgadzają - <span class="inlinecode"><span class="id" title="var">g</span></span>
    zwraca <span class="inlinecode"><span class="id" title="var">bool</span></span>, a my musimy skonstruować liczbę naturalną. Robimy tutaj
    to samo co poprzednio - aplikujemy do celu jakąś funkcję <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>.
    Tym razem nie musi ona być surjekcją (nie jest to nawet możliwe, gdyż
    nie ma surjekcji z <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span>). Dzięki temu możemy zaaplikować <span class="inlinecode"><span class="id" title="var">g</span></span>
    i zakończyć, używając <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

    Żeby pokazać, że <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, będziemy potrzebować aksjomatu
    ekstensjonalności dla funkcji (ang. functional extensionality axiom,
    w skrócie funext). Głosi on, że dwie funkcje <span class="inlinecode"><span class="id" title="var">f</span>,</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> są równe,
    jeżeli uda nam się pokazać, że dają równe wyniki dla każdego argumentu
    (czyli <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).

<div class="paragraph"> </div>

    Importując moduł <span class="inlinecode"><span class="id" title="var">FunctionalExtensionality</span></span> zakładamy prawdziwość tego
    aksjomatu oraz uzyskujemy dostęp do taktyki <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span>, która ułatwia
    dowody wymagające użycia ekstensjonalności. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód jest prawie taki jak zawsze: odwijamy definicję surjektywności i
    wprowadzamy hipotezy do kontekstu, a następnie odwijamy definicję <span class="inlinecode"><span class="id" title="var">extract</span></span>
    i rozbijamy ją dla czytelności na właściwą funkcję <span class="inlinecode"><span class="id" title="var">extract</span></span> oraz równanie
    <span class="inlinecode"><span class="id" title="var">eq</span></span>.

<div class="paragraph"> </div>

    Następnie musimy znaleźć <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T4</span></span>, które <span class="inlinecode"><span class="id" title="var">extract</span></span> mapuje na <span class="inlinecode"><span class="id" title="var">f</span></span>. Zaczynamy
    od <span class="inlinecode"><span class="id" title="var">c0</span></span>, bo jest to jedyny konstruktor <span class="inlinecode"><span class="id" title="var">T4</span></span>. Bierze on jako argument
    funkcję typu <span class="inlinecode">((<span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span></span>. Żeby ją wyprodukować,
    bierzemy na wejściu funkcję <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> i musimy zrobić
    coś typu <span class="inlinecode"><span class="id" title="var">Color</span></span>.

<div class="paragraph"> </div>

    Nie może to być jednak byle co - musimy użyć <span class="inlinecode"><span class="id" title="var">f</span></span>, a jedynym sensownym
    sposobem, żeby to zrobić, jest zaaplikować <span class="inlinecode"><span class="id" title="var">g</span></span> do <span class="inlinecode"><span class="id" title="var">f</span></span>. Musimy zadbać
    też o to, żeby odwrócić funkcje konwertujące <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, których użyliśmy w definicji <span class="inlinecode"><span class="id" title="var">extract</span></span>. Pierwsza z nich
    konwertowała <span class="inlinecode"><span class="id" title="var">R</span></span> (czyli kolor czerwony) na <span class="inlinecode"><span class="id" title="var">true</span></span>, a inne kolory na
    <span class="inlinecode"><span class="id" title="var">false</span></span>, zaś druga konwertowała <span class="inlinecode"><span class="id" title="var">true</span></span> na <span class="inlinecode">0</span>, a <span class="inlinecode"><span class="id" title="var">false</span></span> na <span class="inlinecode">1</span>.
    Wobec tego dopasowując <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> musimy przekonwertować <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">R</span></span>,
    zaś <span class="inlinecode">1</span> na coś innego niż <span class="inlinecode"><span class="id" title="var">R</span></span>, np. na <span class="inlinecode"><span class="id" title="var">G</span></span> (czyli kolor zielony).

<div class="paragraph"> </div>

    Znalazłszy odpowiedni argument, możemy przepisać równanie definiujące
    <span class="inlinecode"><span class="id" title="var">extract</span></span>. To już prawie koniec, ale próba użycia taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> w
    tym momencie skończyłaby się porażką. Na ratunek przychodzi nam
    aksjomat ekstensjonalności, którego używamy pisząc <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.
    Dzięki temu pozostaje nam pokazać jedynie, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> jest równe tej
    drugie funkcji dla argumentu <span class="inlinecode"><span class="id" title="var">y</span></span>. W tym celu rozbijamy <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a oba
    wyrażenia okazują się być konwertowalne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">T4_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> <span class="id" title="var">extract</span> <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro mamy surjekcję z <span class="inlinecode"><span class="id" title="var">T4</span></span> w <span class="inlinecode"><span class="id" title="var">T4</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, katastrofy nie da się
    uniknąć.

<div class="paragraph"> </div>

    Moglibyśmy się też zastanowić nad napisaniem zapętlającej się funkcji
    <span class="inlinecode"><span class="id" title="var">loop</span></span>, ale coś czuję, że ty coś czujesz, że byłoby to babranie się
    w niepotrzebnym problemie. Wobec tego (oczywiście o ile dotychczas
    się nie skapnąłeś) poczuj się oświecony! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T4</span>) : <span class="id" title="var">bool</span> := <span class="id" title="var">extract</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Ha! Tak tak, <span class="inlinecode"><span class="id" title="var">loop</span></span> nie jest niczym innym niż lekko rozmnożoną wersją
    <span class="inlinecode"><span class="id" title="var">extract</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract_c0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : ((<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">Color</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extract</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">g</span> <span class="id" title="var">y</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">loop</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T4</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">loop</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 5!<span class="id" title="var">extract_c0</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
A skoro <span class="inlinecode"><span class="id" title="var">loop</span></span> to tylko inne <span class="inlinecode"><span class="id" title="var">extract</span></span>, to nie powinno cię też wcale a
    wcale zdziwić, że najbardziej oczywisty argument, dla którego <span class="inlinecode"><span class="id" title="var">loop</span></span>
    się zapętla, jest żywcem wzięty z dowodu <span class="inlinecode"><span class="id" title="var">surjective_extract</span></span> (choć
    oczywiście musimy zastąpić <span class="inlinecode"><span class="id" title="var">f</span></span> przez <span class="inlinecode"><span class="id" title="var">loop</span></span>).

<div class="paragraph"> </div>

    Oczywiście niemożliwe jest, żeby formalnie udowodnić w Coqu, że coś
    się zapętla. Powyższy lemat ma być jedynie demonstracją - ręczne
    rozpisanie tego przykładu byłoby zbyt karkołomne. Jak widać z dowodu,
    przepisywanie równania definiującego <span class="inlinecode"><span class="id" title="var">extract</span></span> tworzy wesołą piramidkę
    zrobioną z <span class="inlinecode"><span class="id" title="keyword">match</span></span>ów i <span class="inlinecode"><span class="id" title="keyword">if</span></span>ów. Jeżeli chcesz poczuć pełnię zapętlenia,
    wypbróuj taktykę <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">!<span class="id" title="var">eq</span></span> - zapętli się ona, gdyż równanie <span class="inlinecode"><span class="id" title="var">eq</span></span>
    można przepisywać w nieskończoność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T4</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby się wydawać, że teraz to już na pewno nasze metody działają na
    wszystkie możliwe negatywne typy induktywne. Cytując Tadeusza Sznuka:
    "Nic bardziej mylnego!". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T5</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T5</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T5</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Rzućmy okiem na powyższy typ. Wygląda podobnie do poprzedniego, ale jest
    nieco inny - typy <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">bool</span></span> zamieniły się miejscami. Jakie rodzi to
    konsekwencje? Sprawdźmy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span>] <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">G</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">B</span> =&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isZero</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja <span class="inlinecode"><span class="id" title="var">extract</span></span> jest podobna jak poprzednio, ale tym razem konwertujemy
    <span class="inlinecode"><span class="id" title="var">Color</span></span> na <span class="inlinecode"><span class="id" title="var">nat</span></span> za pomocą funkcji, która nie jest surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód również przebiega podobnie jak poprzednio. Załamuje się on dopiero,
    gdy na samym końcu rozbijamy wyrażenie <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> i upraszczamy używając <span class="inlinecode"><span class="id" title="var">cbn</span></span>.
    W pierwszym podcelu <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> jeszcze jakoś udaje się nam udowodnić, ale w
    drugim naszym oczom ukazuje się cel <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Problem polega na tym, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> może być dowolną liczbą naturalną, ale
    zastosowana przez nas funkcja konwertująca <span class="inlinecode"><span class="id" title="var">Color</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> może zwracać
    jedynie <span class="inlinecode">0</span>, <span class="inlinecode">1</span> lub <span class="inlinecode">2</span>. Teraz widzimy jak na dłoni, skąd wziął się
    wymóg, by funkcja konwertująca była surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T5</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">extract</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">f</span> : ((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">T5</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extract</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>) <span class="id" title="var">y</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">isZero</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">G</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">B</span> =&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;42 = <span class="id" title="var">loop</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> <span class="id" title="var">loop</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">extract_eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">extract_eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Co ciekawe, mimo że nie jesteśmy w stanie pokazać surjektywności <span class="inlinecode"><span class="id" title="var">extract</span></span>,
    to wciąż możemy użyć tej funkcji do zdefiniowania zapętlającej się
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>, zupełnie jak w poprzednim przykładzie.

<div class="paragraph"> </div>

    Niesmak jednak pozostaje, gdyż szczytem naszych ambicji nie powinno być
    ograniczanie się do zdefiniowania <span class="inlinecode"><span class="id" title="var">loop</span></span>, lecz do formalnego udowodnienia
    nielegalności <span class="inlinecode"><span class="id" title="var">T5</span></span>. Czy wszystko stracone? Czy umrzemy? Tu dramatyczna
    pauza.

<div class="paragraph"> </div>

    Nie (w sensie że nie stracone, chociaż oczywiście umrzemy jak każdy).

<div class="paragraph"> </div>

    Okazuje się, że jest pewien trikowy sposób na rozwiązanie tego problemu,
    a mianowicie: zamiast próbować wyjąć z <span class="inlinecode"><span class="id" title="var">T5</span></span> funkcję <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, wyjmiemy
    stamtąd po prostu funckję <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> i to mimo tego, że jej tam nie ma! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract'</span> : <span class="id" title="var">T5</span> -&gt; (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span>] <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> : <span class="id" title="var">Color</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isZero</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
W kluczowych momentach najpierw konwertujemy <span class="inlinecode"><span class="id" title="var">Color</span></span> na <span class="inlinecode"><span class="id" title="var">bool</span></span> tak jak
    w jednym z poprzednich przykładów, a potem konwertujemy <span class="inlinecode"><span class="id" title="var">nat</span></span> na <span class="inlinecode"><span class="id" title="var">bool</span></span>
    za pomocą funkcji <span class="inlinecode"><span class="id" title="var">isZero</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> : <span class="id" title="var">T5</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">f</span> <span class="id" title="var">t</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">then</span> <span class="id" title="var">R</span> <span class="id" title="keyword">else</span> <span class="id" title="var">G</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>); <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Ponieważ obydwie nasze funkcję konwertujące były surjekcjami, możemy je
    teraz odwrócić i wykazać ponad wszelką wątpliwość, że <span class="inlinecode"><span class="id" title="var">extract'</span></span> faktycznie
    jest surjekcją. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">T5_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Cantor'</span> <span class="id" title="var">extract'</span> <span class="id" title="var">negb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Spróbujmy podsumować, co tak naprawdę stało się w tym przykładzie.

<div class="paragraph"> </div>

    Tym razem, mimo że do <span class="inlinecode"><span class="id" title="var">T5</span></span> możemy włożyć dowolną funkcję <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    to nie możemy jej potem wyjąć, uzyskując surjekcję, gdyż zawadzają
    nam w tym typy po prawych stronach strzałek (<span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">Color</span></span>), które
    mają za mało elementów, żeby móc surjektywnie przekonwertować je na
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    Jednak jeżeli mamy wszystkie możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, to
    możemy przerobić je (w locie, podczas "wyciągania") na wszystkie
    możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, składając je z odpowiednią
    surjekcją (np. <span class="inlinecode"><span class="id" title="var">isZero</span></span>). Ponieważ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> i <span class="inlinecode"><span class="id" title="var">Color</span></span> jesteśmy
    w stanie surjektywnie przekonwertować na <span class="inlinecode"><span class="id" title="var">bool</span></span>, reszta procesu
    działa podobnie jak w poprzednich przykładach. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">loop'</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T5</span>) : <span class="id" title="var">bool</span> := <span class="id" title="var">extract'</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract'_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">f</span> : ((<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">T5</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extract'</span> (<span class="id" title="var">c0</span> <span class="id" title="var">f</span>) <span class="id" title="var">y</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : <span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">isZero</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">R</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">loop_nontermination</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">loop'</span> (<span class="id" title="var">c0</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> : (<span class="id" title="var">T5</span> -&gt; <span class="id" title="var">nat</span>) -&gt; <span class="id" title="var">bool</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> : <span class="id" title="var">T5</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">loop'</span> <span class="id" title="var">t</span> <span class="id" title="keyword">then</span> 0 <span class="id" title="keyword">else</span> 1) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">loop'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 3!<span class="id" title="var">extract'_eq</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Takie trikowe <span class="inlinecode"><span class="id" title="var">extract'</span></span> wciąż pozwala nam bez większych przeszkód
    zdefiniować zapętlającą się funkcję <span class="inlinecode"><span class="id" title="var">loop'</span></span>. Osiągnęliśmy więc
    pełen sukces.

<div class="paragraph"> </div>

    W ogólności nasz trik możnaby sformułować tak: jeżeli mamy konstruktor
    negatywny typu <span class="inlinecode"><span class="id" title="var">T</span></span>, to możemy wyjąć z niego funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest najmniejszym z typów występujących po prawych stronach strzałek. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T5</span>.<br/>

<br/>
</div>

<div class="doc">
No, teraz to już na pewno mamy obcykane wszystkie przypadki, prawda?
    Tadeuszu Sznuku przybywaj: "Otóż nie tym razem!". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T6</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T6</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T6</span> -&gt; <span class="id" title="var">unit</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T6</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejnym upierdliwym przypadkiem, burzącym nawet nasz ostateczny
    trik, jest sytuacja, w której po prawej stronie strzałki wystąpi
    typ <span class="inlinecode"><span class="id" title="var">unit</span></span>. Oczywiście zgodnie z trikiem możemy z <span class="inlinecode"><span class="id" title="var">T6</span></span> wyciągnąć
    surjekcję <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, ale jest ona oczywiście bezużyteczna, bo
    taką samą możemy zrobić za darmo, stale zwracając po prostu <span class="inlinecode"><span class="id" title="var">tt</span></span>.
    Surjekcja z <span class="inlinecode"><span class="id" title="var">T6</span></span> w <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> nie wystarczy rzecz jasna, żeby
    odpalić twierdzenie Cantora.

<div class="paragraph"> </div>

    Tym razem jednak nie powinniśmy spodziewać się, że upierdliwość tę
    będzie dało się jakoś obejść. Typ <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> jest jednoelementowy
    (jedynym elementem jest <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">tt</span></span>) podobnie jak <span class="inlinecode"><span class="id" title="var">unit</span></span>. Bardziej
    poetycko możemy powiedzieć, że <span class="inlinecode"><span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> i <span class="inlinecode"><span class="id" title="var">unit</span></span> są izomorficzne,
    czyli możemy bez żadnych strat konwertować elementy jednego z tych
    typów na elementy drugiego i z powrotem.

<div class="paragraph"> </div>

    Skoro tak, to typ konstruktora <span class="inlinecode"><span class="id" title="var">c0</span></span>, czyli
    <span class="inlinecode">(((<span class="id" title="var">T6</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span>)</span>, możemy równie dobrze
    zapisać jako <span class="inlinecode">((<span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span>)</span>. Zauważmy teraz,
    że <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> jest izomorficzne z <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdyż ma tylko dwa
    elementy, a mianowicie <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">false</span></span>.
    Tak więc typ <span class="inlinecode"><span class="id" title="var">c0</span></span> możemy jeszcze prościej zapisać jako
    <span class="inlinecode">(<span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T6</span></span>, a to oznacza, że typ <span class="inlinecode"><span class="id" title="var">T6</span></span> jest jedynie
    owijką na funkcje typu <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Color</span></span>. Twierdzenie Cantora nie
    pozwala tutaj uzyskać sprzeczności.

<div class="paragraph"> </div>

    Czy zatem typy takie jak <span class="inlinecode"><span class="id" title="var">T6</span></span> sa legalne? Syntaktycznie nie - Coq
    odrzuca je podobnie jak wszystkie inne negatywne typy induktywne.
    Semantycznie również nie - o ile nie możemy tutaj uzyskać jawnej
    sprzeczności, to nasze rozważania o nieterminacji wciąż są w mocy.

<div class="paragraph"> </div>

    Przypomnij sobie poprzedni przykład i nieudaną próbę wyłuskania z
    <span class="inlinecode"><span class="id" title="var">T5</span></span> surjekcji <span class="inlinecode"><span class="id" title="var">T5</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Udało nam się zaimplementować funkcję
    <span class="inlinecode"><span class="id" title="var">extract</span></span>, której surjektywności nie potrafiliśmy pokazać, ale pomimo
    tego bez problemu udało nam się użyć jej do napisania funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>.
    W obecnym przykładzie jest podobnie i nieterminacja to najlepsze, na
    co możemy liczyć. 
<div class="paragraph"> </div>

<a id="lab496"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">extract</span></span>, a następnie użyj jej do zdefiniowania
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Zademonstruj w sposób podobny jak poprzednio, że
    <span class="inlinecode"><span class="id" title="var">loop</span></span> się zapętla. Wskazówka: wszystko działa tak samo jak w
    poprzednim przykładzie. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T6</span>.<br/>

<br/>
</div>

<div class="doc">
No, teraz to już na pewno wiemy wszystko... 
<div class="paragraph"> </div>

<a id="lab497"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Otóż nie do końca. Ostatnim hamulcowym, groźniejszym nawet niż <span class="inlinecode"><span class="id" title="var">unit</span></span>,
    jest wystąpienie po prawej stronie strzałki typu (czy raczej zdania)
    <span class="inlinecode"><span class="id" title="var">False</span></span>. W tym przypadku nie tylko nie pomaga nam Cantor, ale nie
    pomaga też nieterminacja, gdyż najzwyczajniej w świecie nie da się
    zdefiniować żadnej funkcji.

<div class="paragraph"> </div>

    Jako, że za cholerę nie wiem, co z tym fantem zrobić, zostawiam go tobie
    jako ćwiczenie: wymyśl metodę pokazywania nielegalności negatywnych typów
    induktywnych, w których po prawej stronie strzałki jest co najmniej
    jedno wystąpienie <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">T7</span>.<br/>

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">T7</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">c0</span> : (((<span class="id" title="var">T7</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">False</span>) -&gt; <span class="id" title="var">Color</span>) -&gt; <span class="id" title="var">T7</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">T7</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab498"></a><h1 class="section">Pozytywne typy induktywne</h1>

<div class="paragraph"> </div>

 Na koniec rozprawimy się z pozytywnymi typami "induktywnymi" (ale tylko
    do pewnego stopnia; tak po prawdzie, to raczej one rozprawią się z
    nami). 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Pos0</span> : ((<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Pos</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"Pos"&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"((Pos&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;Pos".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coq odrzuca powyższą definicję typu <span class="inlinecode"><span class="id" title="var">Pos</span></span>, gdyż pierwsze wystąpienie <span class="inlinecode"><span class="id" title="var">Pos</span></span>
    w typie konstruktora <span class="inlinecode"><span class="id" title="var">Pos0</span></span> nie jest ściśle pozytywne. I faktycznie - gdy
    policzymy niedobrość tego wystąpienia zgodnie z naszym wzorem, to wyjdzie,
    że wynosi ona 2, gdyż <span class="inlinecode"><span class="id" title="var">Pos</span></span> występuje na lewo od dwóch strzałek (pamiętaj,
    że najbardziej zewnętrzna strzałka, czyli ta, na prawo od której też jest
    <span class="inlinecode"><span class="id" title="var">Pos</span></span>, nie liczy się - wzór dotyczy tylko argumentów konstruktora, a nie
    całego konstruktora). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Pos0</span> : ((<span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">Pos</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Spróbujmy zawalczyć z typem <span class="inlinecode"><span class="id" title="var">Pos</span></span> naszą metodą opartą o twierdzenie
    Cantora. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> (<span class="id" title="var">p</span> : <span class="id" title="var">Pos</span>) : <span class="id" title="var">Pos</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f</span>]. <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;ad&nbsp;infinitum&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby się wydawać, że wyciągnięcie z <span class="inlinecode"><span class="id" title="var">Pos</span></span> funkcji <span class="inlinecode"><span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    nie może być trudniejsze, niż zabranie dziecku cukierka. Niestety
    jednak nie jest tak, gdyż w <span class="inlinecode"><span class="id" title="var">Pos</span></span> tak naprawdę nie ma żadnej takiej
    funkcji - jest funkcja <span class="inlinecode">(<span class="id" title="var">Pos</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a to już zupełnie
    coś innego.

<div class="paragraph"> </div>

    Żeby lepiej zrozumieć tę materię, musimy metaforycznie zinterpretować
    znany nam już współczynnik niedobrości i wynikający z niego podział
    na wystąpienia ściśle pozytywne, pozytywne i negatywne. Dzięki tej
    interpretacji dowiemy się też, dlaczego nieparzysta niedobrość jest
    negatywna, a niezerowa parzysta jest pozytywna.

<div class="paragraph"> </div>

    Najprościej jest zinterpretować wystąpienia ściśle pozytywne, gdyż
    mieliśmy już z nimi sporo do czynienia. Weźmy konstruktor
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Jest tutaj jedno ściśle pozytywne
    wystąpienie typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, które możemy interpretować tak: gdy
    używamy dopasowania do wzorca i dopasuje się <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, to "mamy"
    element <span class="inlinecode"><span class="id" title="var">t</span></span> typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Ot i cała filozofia.

<div class="paragraph"> </div>

    Załóżmy teraz na chwilę, że Coq akceptuje negatywne i pozytywne
    typy induktywne. Co by było, gdybyśmy dopasowali konstruktor postaci
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>? Tym razem nie mamy elementu typu <span class="inlinecode"><span class="id" title="var">T</span></span>, lecz
    funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. Parafrazując: musimy "dać" funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>
    element typu <span class="inlinecode"><span class="id" title="var">T</span></span>, żeby dostać <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

    A co by było, gdybyśmy dopasowali konstruktor postaci
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode">((<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>? Tym razem również nie mamy żadnego
    elementu typu <span class="inlinecode"><span class="id" title="var">T</span></span>, lecz funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode">((<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>.
    Parafrazując: musimy dać funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> jakąś funkcję typu <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    żeby dostać <span class="inlinecode"><span class="id" title="var">bool</span></span>. Ale gdy konstruujemy funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, to na
    wejściu dostajemy <span class="inlinecode"><span class="id" title="var">T</span></span>. Tak więc początkowo nie mamy żadnego <span class="inlinecode"><span class="id" title="var">T</span></span>, ale
    gdy o nie poprosimy, to możemy je dostać. Ba! Jak pokazuje przykład,
    możemy dostać bardzo dużo <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Taka właśnie jest różnica między ścisłą pozytywnością (mamy coś),
    negatywnością (musimy coś dać) i pozytywnością (możemy coś dostać,
    i to nawet w dużej liczbie sztuk). Zauważmy, że jedynie w przypadku
    negatywnym możemy wyjąć z <span class="inlinecode"><span class="id" title="var">T</span></span> funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">co</span>ś</span> (chyba, że zawadza
    nam <span class="inlinecode"><span class="id" title="var">unit</span></span> lub <span class="inlinecode"><span class="id" title="var">False</span></span>), bo to jedyny przypadek, gdy żądają od nas
    <span class="inlinecode"><span class="id" title="var">T</span></span> (a skoro żądają <span class="inlinecode"><span class="id" title="var">T</span></span>, to muszą mieć funkcję, która coś z tym <span class="inlinecode"><span class="id" title="var">T</span></span>
    zrobi). W przypadku pozytywnym nie ma żadnej takiej funkcji - to my
    dostajemy <span class="inlinecode"><span class="id" title="var">T</span></span> i musimy coś z niego wyprodukować, więc to my jesteśmy
    tą funkcją!

<div class="paragraph"> </div>

    Ufff... mam nadzieję, że powyższa bajeczka jest sformułowana zrozumiale,
    bo lepszego wytłumaczenia nie udało mi się wymyślić.

<div class="paragraph"> </div>

    Moglibyśmy w tym miejscu zastanowić się, czy nie uda nam się pokazać
    sprzeczności choć na metapoziomie, poprzez napisanie nieterminującej
    funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Szczerze pisząc, to niezbyt w to wierzę. Przypomnij
    sobie, że okazało się, że funkcja <span class="inlinecode"><span class="id" title="var">loop</span></span> jest bardzo ściśle powiązana
    z funkcją <span class="inlinecode"><span class="id" title="var">extract</span></span>, zaś esencja nieterminacji polegała na przekazaniu
    do <span class="inlinecode"><span class="id" title="var">loop</span></span> jako argument czegoś, co zawierało <span class="inlinecode"><span class="id" title="var">loop</span></span> jako podterm
    (jeżeli nie zauważyłeś, to wszystkie nasze nieterminujące funkcje
    udało nam się zdefiniować bez użycia rekursji!). To daje nam jako taką
    podstawę by wierzyć, że nawet nieterminacja nie jest w tym przypadku
    osiągalna. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
W tym momencie należy sobie zadać zasadnicze pytanie: dlaczego w ogóle
    pozytywne typy induktywne są nielegalne? Przecież odróżnienie wystąpienia
    pozytywnego od negatywnego nie jest czymś trudnym, więc Coq nie może ich
    od tak po prostu nie rozróżniać - musi mieć jakiś powód!

<div class="paragraph"> </div>

    I faktycznie, powód jest. Nie ma on jednak wiele wspólnego z mechanizmem
    (pozytywnych) typów induktywnych samym w sobie, a z impredykatywnością
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Trudne słowo, co? Nie pamiętam, czy już to wyjaśniałem,
    więc wyjaśnię jeszcze raz.

<div class="paragraph"> </div>

    Impredykatywność (lub też impredykatywizm) to pewna forma autoreferencji,
    która czasem jest nieszkodliwa, a czasem bardzo mordercza. Przyjrzyjmy
    się następującej definicji: "wujek Janusz to najbardziej wąsata osoba w
    tym pokoju". Definicja ta jest impredykatywna, gdyż definiuje ona wujka
    Janusza poprzez wyróżnienie go z pewnej kolekcji osób, ale definicja tej
    kolekcji osób musi odwoływać się do wujka Janusza ("w pokoju są wujek
    Janusz, ciocia Grażynka, Sebastianek i Karynka"). W Coqu impredykatywny
    jest sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, co ilustruje przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja zdania <span class="inlinecode"><span class="id" title="var">X</span></span> jest impredykatywna, gdyż kwantyfikujemy w niej po
    wszystkich zdaniach (<span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), a zatem kwantyfikujemy także
    po zdaniu <span class="inlinecode"><span class="id" title="var">X</span></span>, które właśnie definiujemy.

<div class="paragraph"> </div>

    Impredykatywność sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest niegroźna (no chyba, że pragniemy
    pozytywnych typów induktywnych, to wtedy jest), ale impredykatywność
    dla <span class="inlinecode"><span class="id" title="keyword">Type</span></span> byłaby zabójcza, co zresztą powinien nam był uświadomić
    paradoks Russella.

<div class="paragraph"> </div>

    Dobra, koniec gadania. Poniższy przykład pośrednio pochodzi z sekcji
    3.1 pracy "Inductively defined types", której autorami są Thierry
    Coquand oraz Christine Paulin-Mohring, zaś bezpośrednio jest przeróbką
    kodu wziętego z
    vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Pos'</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Pos'0</span> : ((<span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="keyword">Prop</span>) -&gt; <span class="id" title="var">Pos'</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Positivity</span> <span class="id" title="var">Checking</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać, podejrzanym typem jest <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, bliźniaczo podobne do <span class="inlinecode"><span class="id" title="var">Pos</span></span>,
    ale zamiast <span class="inlinecode"><span class="id" title="var">bool</span></span> występuje tutaj <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    Tym razem jednak dowód sprzeczności będzie przebiegał nieco inaczej niż
    dotychczas. Poprzednio nasze plany sprowadzały się do tego, żeby wyjąć
    z nielegalnego typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> jakąś funkcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, co daje nam
    surjekcję <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, a to jest sprzeczne z twierdzeniem Cantora.

<div class="paragraph"> </div>

    Intuicja zaś stojąca za tym twierdzeniem (przynajmniej dla <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>)
    była taka, że funkcje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> są zbiorami elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span> i
    jest ich przez to "więcej" niż elementów <span class="inlinecode"><span class="id" title="var">T</span></span>, czyli <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> jest
    większa niż <span class="inlinecode"><span class="id" title="var">T</span></span>. Surjekcją z <span class="inlinecode"><span class="id" title="var">T</span></span> w <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> oznacza jednak, że to
    <span class="inlinecode"><span class="id" title="var">T</span></span> jest większe niż <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, co prowadzi do sprzeczności.

<div class="paragraph"> </div>

    Tym razem nie jesteśmy w stanie zrobić żadnej surjekcji, ale możemy za
    to zrobić injekcję. Intuicyjnie injekcja z <span class="inlinecode"><span class="id" title="var">A</span></span> w <span class="inlinecode"><span class="id" title="var">B</span></span> oznacza, że każdemu
    elementowi <span class="inlinecode"><span class="id" title="var">A</span></span> można przypisać unikalny element <span class="inlinecode"><span class="id" title="var">B</span></span>. Jeszcze intuicyjniej:
    typ <span class="inlinecode"><span class="id" title="var">A</span></span> jest w jakimś sensie "mniejszy" niż typ <span class="inlinecode"><span class="id" title="var">B</span></span>, czyli jeszcze inaczej
    pisząc, typ <span class="inlinecode"><span class="id" title="var">A</span></span> można "włożyć" lub "wstrzyknąć" (i stąd nazwa) do typu <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Nasz plan polega więc na tym, żeby zdefiniować injekcję
    <span class="inlinecode">(<span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, co powinno jakoś prowadzić do sprzeczności:
    istnienie takiej injekcji oznacza, że <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest "mniejszy"
    niż <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, ale z twierdzenia Cantora powinniśmy intuicyjnie czuć, że
    <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> jest większe niż <span class="inlinecode"><span class="id" title="var">Pos'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">Pos'</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">Pos'0</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">Q</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span> =&gt; <span class="id" title="var">P</span> = <span class="id" title="var">Q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">injective_f</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">P</span> = <span class="id" title="var">f</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span> = <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">Q</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja naszej injekcji jest dość prosta. Żeby przerobić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    na <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, używamy konstruktora <span class="inlinecode"><span class="id" title="var">Pos'0</span></span>, a jego argumentem jest po prostu
    funkcja, która porównuje swój argument do <span class="inlinecode"><span class="id" title="var">P</span></span> używając relacji równości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wut</span> (<span class="id" title="var">x</span> : <span class="id" title="var">Pos'</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">P</span> : <span class="id" title="var">Pos'</span> -&gt; <span class="id" title="keyword">Prop</span>, <span class="id" title="var">f</span> <span class="id" title="var">P</span> = <span class="id" title="var">x</span> /\ ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Tutaj następują czary, które używają impredykatywności.

<div class="paragraph"> </div>

    Definiujemy predykat <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, który głosi, że funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> jest
    surjekcją (czyli <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">P</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>), która ma dodatkowo tę właściwość, że
    predykat <span class="inlinecode"><span class="id" title="var">P</span></span>, któremu <span class="inlinecode"><span class="id" title="var">f</span></span> przyporządkowuje <span class="inlinecode"><span class="id" title="var">x</span></span>, nie jest spełniony przez <span class="inlinecode"><span class="id" title="var">x</span></span>
    (czyli <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).

<div class="paragraph"> </div>

    Parafrazując: <span class="inlinecode"><span class="id" title="var">wut</span></span> to coś w stylu zbioru wszystkich <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Pos'</span></span>, które nie
    należą same same do siebie. Paradoks Russella jak malowany! Wielka zła
    autoreferencja czai się tuż za rogiem - ciekawe co by się stało, gdybyśmy
    rozważyli zdanie <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">paradox</span> : <span class="id" title="var">wut</span> (<span class="id" title="var">f</span> <span class="id" title="var">wut</span>) &lt;-&gt; ~ <span class="id" title="var">wut</span> (<span class="id" title="var">f</span> <span class="id" title="var">wut</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> (<span class="id" title="var">P</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>). <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">injective_f</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">red</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">wut</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Ano, wszystko wybucha. Z lewa na prawo rozbijamy dowód <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span> i
    dostajemy predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Wiemy, że <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span>, ale <span class="inlinecode"><span class="id" title="var">f</span></span> jest injekcją,
    więc <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">wut</span></span>. To jednak kończy się sprzecznością, bo z jednej strony
    <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>, ale z drugiej strony <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>, czyli <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>.

<div class="paragraph"> </div>

    Z prawa na lewo jest łatwiej. Mamy <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span> i musimy udowodnić
    <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>. Wystarczy, że istnieje pewien predykat <span class="inlinecode"><span class="id" title="var">P</span></span>, który spełnia
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> i <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span>. Na <span class="inlinecode"><span class="id" title="var">P</span></span> wybieramy oczywiście <span class="inlinecode"><span class="id" title="var">wut</span></span>. Równość
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span></span> zachodzi trywialnie, zaś <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">wut</span>)</span> zachodzi na mocy
    założenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Pos'_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">paradox</span>. <span class="id" title="tactic">firstorder</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
No i bum. Jak widać, pozytywne typy induktywne prowadzą do sprzeczności,
    ale nie ma to z nimi wiele wspólnego, za to ma wiele wspólnego z sortem
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i jego impredykatywnością. 
<div class="paragraph"> </div>

<a id="lab499"></a><h1 class="section">Podsumowanie (TODO)</h1>

<div class="paragraph"> </div>

 W tym rozdziale poznaliśmy kryterium ścisłej pozytywności, które obowiązuje
    wszystkie definicje typów induktywnych. Dowiedzieliśmy się, że negatywne
    typy induktywne prowadzą do nieterminacji, która jest złem wcielonym.
    Poznaliśmy pojęcie surjekcji oraz twierdzenie Cantora, które również
    zabrania negatywnym typom induktywnym istnienia.

<div class="paragraph"> </div>

    Ostatecznie dowiedzieliśmy się, że pozytywne typy induktywne także są
    nielegalne, choć jesteśmy wobec nich raczej bezsilni, no chyba że
    chodzi o impredykatywny (tego słowa też się nauczyliśmy) sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. </div>
<div class="code">
</div>
