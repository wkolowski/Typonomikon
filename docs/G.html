<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">G: Inne spojrzenia na typy induktywne i koinduktywne</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab401"></a><h1 class="section">W-typy (TODO)</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">W</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">sup</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, (<span class="id" title="var">B</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">W</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) -&gt; <span class="id" title="var">W</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">sup</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
W-typy (ang. W-types) to typy dobrze ufundowanych drzew (ang.
    well-founded trees - W to skrót od well-founded), tzn. skończonych drzew
    o niemal dowolnych kształtach wyznaczanych przez parametry <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Nie są one zbyt przydatne w praktyce, gdyż wszystko, co można za ich
    pomocą osiągnąć, można też osiągnąć bez nich zwykłymi typami induktywnymi
    i będzie to dużo bardziej czytelne oraz prostsze w implementacji. Ba!
    W-typy są nawet nieco słabsze, gdyż go udowodnienia reguły indukcji
    wymagają aksjomatu ekstensjonalności dla funkcji.

<div class="paragraph"> </div>

    Jednak z tego samego powodu są bardzo ciekawe pod względem teoretycznym -
    wszystko, co można zrobić za pomocą parametryzowanych typów induktywnych,
    można też zrobić za pomocą samych W-typów. Dzięki temu możemy badanie
    parametryzowanych typów induktywnych, których jest mniej więcej
    nieskończoność i jeszcze trochę, sprowadzić do badania jednego tylko <span class="inlinecode"><span class="id" title="var">W</span></span>
    (o ile godzimy się na aksjomat ekstensjonalności dla funkcji).

<div class="paragraph"> </div>

    Zanim jednak zobaczymy przykłady ich wykorzystania, zastanówmy się przez
    kilka chwil, dlaczego są one tak ogólne.

<div class="paragraph"> </div>

    Sprawa jest dość prosta. Rozważmy typ induktywny <span class="inlinecode"><span class="id" title="var">T</span></span> i dowolny z jego
    konstruktorów <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Xn</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Argumenty <span class="inlinecode"><span class="id" title="var">Xi</span></span> możemy podzielić
    na dwie grupy: argumenty nieindukcyjne (oznaczmy je literą <span class="inlinecode"><span class="id" title="var">A</span></span>) oraz
    indukcyjne (które są postaci <span class="inlinecode"><span class="id" title="var">T</span></span>). Wobec tego typ <span class="inlinecode"><span class="id" title="var">c</span></span> możemy zapisać jako
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Ak</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    W kolejnym kroku łączymy argumenty za pomocą produktu:
    niech <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">*</span> <span class="inlinecode">...</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">Ak</span></span>. Wtedy typ <span class="inlinecode"><span class="id" title="var">c</span></span> wygląda tak:
    <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode">...</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Zauważmy, że <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode">...</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span> możemy zapisać
    równoważnie jako <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">B</span></span> to typ mający tyle elementów, ile
    razy <span class="inlinecode"><span class="id" title="var">T</span></span> występuje w produkcie <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode">...</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Zatem typ <span class="inlinecode"><span class="id" title="var">c</span></span> przedstawia
    się tak: <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Teraz poczynimy kilka uogólnień. Po pierwsze, na początku założyliśmy,
    że <span class="inlinecode"><span class="id" title="var">c</span></span> ma skończenie wiele argumentów indukcyjnych, ale postać <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>
    uwzględnia także przypadek, gdy jest ich nieskończenie wiele (tzn. gdy
    <span class="inlinecode"><span class="id" title="var">c</span></span> miał oryginalnie jakiś argument postaci <span class="inlinecode"><span class="id" title="var">Y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> dla nieskończonego
    <span class="inlinecode"><span class="id" title="var">Y</span></span>).

<div class="paragraph"> </div>

    Po drugie, założyliśmy, że <span class="inlinecode"><span class="id" title="var">c</span></span> jest funkcją niezależną. Przypadek, gdy
    <span class="inlinecode"><span class="id" title="var">c</span></span> jest funkcją zależną możemy pokryć, pozwalając naszemu <span class="inlinecode"><span class="id" title="var">B</span></span> zależeć
    od <span class="inlinecode"><span class="id" title="var">A</span></span>, tzn. <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Typ konstruktora <span class="inlinecode"><span class="id" title="var">c</span></span> zyskuje wtedy postać
    sumy zależnej <span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>}</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. W ostatnim kroku odpakowujemy
    sumę i <span class="inlinecode"><span class="id" title="var">c</span></span> zyskuje postać <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Jak więc widać, typ każdego konstruktora można przekształcić tak, żeby
    móc zapisać go jako <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Zauważmy też, że jeżeli
    mamy dwa konstruktory <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>,</span> <span class="inlinecode"><span class="id" title="var">B1</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A2</span>,</span> <span class="inlinecode"><span class="id" title="var">B2</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, to możemy równie dobrze zapisać je
    za pomocą jednego konstruktora <span class="inlinecode"><span class="id" title="var">c</span></span>: niech <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">A2</span></span> i niech
    <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">(<span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">a1</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">B1</span></span> <span class="inlinecode"><span class="id" title="var">a1</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">(<span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">a2</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">B2</span></span> <span class="inlinecode"><span class="id" title="var">a2</span></span>. Wtedy konstruktory <span class="inlinecode"><span class="id" title="var">c1</span></span> i
    <span class="inlinecode"><span class="id" title="var">c2</span></span> są równoważne konstruktorowi <span class="inlinecode"><span class="id" title="var">c</span></span>.

<div class="paragraph"> </div>

    Stosując powyższe przekształcenia możemy sprowadzić każdy typ induktywny
    do równoważnej postaci z jednym konstruktorem o typie
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>. Skoro tak, to definiujemy nowy typ, w którym
    <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> są parametrami... i bum, tak właśnie powstało <span class="inlinecode"><span class="id" title="var">W</span></span>!

<div class="paragraph"> </div>

    Podejrzewam, że powyższy opis przyprawia cię o niemały ból głowy. Rzućmy
    więc okiem na przykład, który powinien być wystarczająco ogólny, żeby
    wszystko stało się jasne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">list</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;list&nbsp;(X&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;nil&nbsp;:&nbsp;list&nbsp;X<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;cons&nbsp;:&nbsp;X&nbsp;-&gt;&nbsp;list&nbsp;X&nbsp;-&gt;&nbsp;list&nbsp;X&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Spróbujmy zastosować powyższe przekształcenia na typie <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>, żeby
    otrzymać reprezentację <span class="inlinecode"><span class="id" title="var">list</span></span> za pomocą <span class="inlinecode"><span class="id" title="var">W</span></span>.

<div class="paragraph"> </div>

    Zajmijmy się najpierw konstruktorem <span class="inlinecode"><span class="id" title="var">nil</span></span>. Nie ma on ani argumentów
    indukcyjnych, ani nieindukcyjnych, co zdaje się nie pasować do naszej
    ogólnej metody. Jest to jednak jedynie złudzenie: brak argumentów
    nieindukcyjnych możemy zareprezentować za pomocą argumenu o typie
    <span class="inlinecode"><span class="id" title="var">unit</span></span>, zaś brak argumentów indukcyjnych możemy zareprezentować
    argumentem o typie <span class="inlinecode"><span class="id" title="var">False</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>. Wobec tego typ konstruktora
    <span class="inlinecode"><span class="id" title="var">nil</span></span> możemy zapisać jako <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">False</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>.

<div class="paragraph"> </div>

    Dla <span class="inlinecode"><span class="id" title="var">cons</span></span>a jest już prościej: argument nieindukcyjny to po prostu <span class="inlinecode"><span class="id" title="var">X</span></span>,
    zaś jeden argument indukcyjny możemy przedstawić jako <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>.
    Nowy typ <span class="inlinecode"><span class="id" title="var">cons</span></span>a możemy zapisać jako <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>.

<div class="paragraph"> </div>

    Pozostaje nam skleić obydwa konstruktory w jeden. Niech <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>
    i niech <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">(<span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">False</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">(<span class="id" title="var">inr</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>. W ten sposób dostajemy
    poniższe kodowanie <span class="inlinecode"><span class="id" title="var">list</span></span> za pomocą <span class="inlinecode"><span class="id" title="var">W</span></span> (oczywiście nie jest to jedyne
    możliwe kodowanie - równie dobrze zamiast <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span> moglibyśmy użyć
    typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">listW</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">listW</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W</span> (<span class="id" title="var">unit</span> + <span class="id" title="var">X</span>) (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">ux</span> : <span class="id" title="var">unit</span> + <span class="id" title="var">X</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ux</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inl</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inr</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
Wartą zauważenia różnicą konceptualną jest to, że jeżeli myślimy
    Coqowymi typami induktywnymi, to <span class="inlinecode"><span class="id" title="var">list</span></span> ma dwa konstruktory - <span class="inlinecode"><span class="id" title="var">nil</span></span>
    i <span class="inlinecode"><span class="id" title="var">cons</span></span>, ale gdy myślimy za pomocą <span class="inlinecode"><span class="id" title="var">W</span></span>, to sprawa ma się inaczej.
    Formalnie <span class="inlinecode"><span class="id" title="var">listW</span></span> ma jeden konstruktor <span class="inlinecode"><span class="id" title="var">sup</span></span>, ale w praktyce jest
    aż <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">|<span class="id" title="var">X</span>|</span> konstruktorów, gdzie <span class="inlinecode">|<span class="id" title="var">X</span>|</span> oznacza liczbę elementów
    typu <span class="inlinecode"><span class="id" title="var">X</span></span>. Jeden z nich opdowiada <span class="inlinecode"><span class="id" title="var">nil</span></span>, a każdy z pozostałych <span class="inlinecode">|<span class="id" title="var">X</span>|</span>
    konstruktorów odpowiada <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> dla pewnego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span>. Jedyną
    pozostałością po oryginalnej liczbie konstruktorów jest liczba
    składników, które pojawiają się w sumie <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>.

<div class="paragraph"> </div>

    Oczywiście posługiwanie się <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span> jest dużo wygodniejsze niż
    używanie <span class="inlinecode"><span class="id" title="var">sup</span></span>, więc czas odzyskać utracone konstruktory! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nilW</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> (<span class="id" title="var">inl</span> <span class="id" title="var">tt</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">e</span> : <span class="id" title="var">False</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">consW</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>) : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> (<span class="id" title="var">inr</span> <span class="id" title="var">h</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">unit</span> =&gt; <span class="id" title="var">t</span>).<br/>

<br/>
</div>

<div class="doc">
Zauważ, że <span class="inlinecode"><span class="id" title="var">consW</span></span> jest jedynie jednym z wielu możliwych kodowań
    konstruktora <span class="inlinecode"><span class="id" title="var">cons</span></span>. Inaczej możemy go zakodować np. tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">consW'</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>) : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> (<span class="id" title="var">inr</span> <span class="id" title="var">h</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">unit</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">u</span> <span class="id" title="keyword">with</span> | <span class="id" title="var">tt</span> =&gt; <span class="id" title="var">t</span> <span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
Kodowania te nie są konwertowalne, ale jeżeli użyjemy aksjomatu
    ekstensjonalności dla funkcji, to możemy pokazać, że są równe. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Check</span> <span class="id" title="var">eq_refl</span> : <span class="id" title="var">consW</span> = <span class="id" title="var">consW'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;term&nbsp;"eq_refl"&nbsp;has&nbsp;type&nbsp;"consW&nbsp;=&nbsp;consW"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;it&nbsp;is&nbsp;expected&nbsp;to&nbsp;have&nbsp;type&nbsp;"consW&nbsp;=&nbsp;consW'".&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">consW_consW'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">consW</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">consW'</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">consW</span>, <span class="id" title="var">consW'</span>. <span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnym mykiem musimy posłużyć się, żeby udowodnić regułę indukcji.
    Dowód zaczynamy od indukcji po <span class="inlinecode"><span class="id" title="var">l</span></span> (musimy pamiętać, że nasze <span class="inlinecode"><span class="id" title="var">W</span></span> jest
    typem induktywnym, więc ma regułę indukcji), ale nie możemy bezpośrednio
    użyć hipotez <span class="inlinecode"><span class="id" title="var">PnilW</span></span> ani <span class="inlinecode"><span class="id" title="var">PconsW</span></span>, gdyż dotyczą one innych kodowań <span class="inlinecode"><span class="id" title="var">nil</span></span>
    i <span class="inlinecode"><span class="id" title="var">cons</span></span> niż te, które pojawiają się w celu. Żeby uporać się z problemem,
    używamy taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span>, a następnie dowodzimy, że obydwa kodowania są
    ekstensjoalnie równe. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">listW_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PnilW</span> : <span class="id" title="var">P</span> (<span class="id" title="var">nilW</span> <span class="id" title="var">X</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PconsW</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">consW</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [[[] | <span class="id" title="var">x</span>] <span class="id" title="var">b</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">replace</span> (<span class="id" title="var">P</span> (<span class="id" title="var">sup</span> (<span class="id" title="var">inl</span> <span class="id" title="var">tt</span>) <span class="id" title="var">b</span>)) <span class="id" title="keyword">with</span> (<span class="id" title="var">P</span> (<span class="id" title="var">nilW</span> <span class="id" title="var">X</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">nilW</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">e</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">replace</span> <span class="id" title="var">_</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">P</span> (<span class="id" title="var">consW</span> <span class="id" title="var">x</span> (<span class="id" title="var">b</span> <span class="id" title="var">tt</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">PconsW</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">consW</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">W_ind</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">listW_ind'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PnilW</span> : <span class="id" title="var">P</span> (<span class="id" title="var">nilW</span> <span class="id" title="var">X</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PconsW</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">consW</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">nilW</span> <span class="id" title="var">X</span>) = <span class="id" title="var">PnilW</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>), <span class="id" title="var">f</span> (<span class="id" title="var">consW</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>) = <span class="id" title="var">PconsW</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>)}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">esplit</span>. <span class="id" title="var">Unshelve</span>. <span class="id" title="var">Focus</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [[[] | <span class="id" title="var">x</span>] <span class="id" title="var">b</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="var">nilW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">replace</span> (<span class="id" title="var">P</span> (<span class="id" title="var">sup</span> (<span class="id" title="var">inl</span> <span class="id" title="var">tt</span>) <span class="id" title="var">b</span>)) <span class="id" title="keyword">with</span> (<span class="id" title="var">P</span> (<span class="id" title="var">nilW</span> <span class="id" title="var">X</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">nilW</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">e</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">replace</span> <span class="id" title="var">_</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">P</span> (<span class="id" title="var">consW</span> <span class="id" title="var">x</span> (<span class="id" title="var">b</span> <span class="id" title="var">tt</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">PconsW</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">consW</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">compute</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro mamy regułę indukcji, to bez problemu jesteśmy w stanie pokazać,
    że typy <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> oraz <span class="inlinecode"><span class="id" title="var">listW</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> są izomorficzne, tzn. istnieją funkcje
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">listW</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> oraz <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">listW</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>, które są swoimi
    odwrotnościami. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">f</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">nilW</span> <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">consW</span> <span class="id" title="var">h</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">g</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">listW</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">listW_ind'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">nil</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> <span class="id" title="var">t</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fg</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span> <span class="id" title="tactic">in</span> *. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">listW_ind'</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">g</span> &amp; <span class="id" title="var">eq1</span> &amp; <span class="id" title="var">eq2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eq1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">destruct</span> (<span class="id" title="var">listW_ind'</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">g</span> &amp; <span class="id" title="var">eq1</span> &amp; <span class="id" title="var">eq2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq2</span>, <span class="id" title="var">IHt</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">gf</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">listW</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">listW_ind'</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span>; <span class="id" title="tactic">destruct</span> (<span class="id" title="var">listW_ind'</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">g</span> &amp; <span class="id" title="var">eq1</span> &amp; <span class="id" title="var">eq2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq1</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eq2</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">boolW</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W</span> <span class="id" title="var">bool</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Empty_set</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">trueW</span> : <span class="id" title="var">boolW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> <span class="id" title="var">true</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">e</span> : <span class="id" title="var">Empty_set</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">falseW</span> : <span class="id" title="var">boolW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> <span class="id" title="var">false</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">e</span> : <span class="id" title="var">Empty_set</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">notW</span> : <span class="id" title="var">boolW</span> -&gt; <span class="id" title="var">boolW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W_rect</span> <span class="id" title="var">bool</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Empty_set</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">boolW</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">falseW</span> <span class="id" title="keyword">else</span> <span class="id" title="var">trueW</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bool_boolW</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">boolW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">trueW</span> <span class="id" title="keyword">else</span> <span class="id" title="var">falseW</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">boolW_bool</span> : <span class="id" title="var">boolW</span> -&gt; <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W_rect</span> <span class="id" title="var">bool</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Empty_set</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">bool</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">b</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">boolW_bool_notW</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">boolW</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">boolW_bool</span> (<span class="id" title="var">notW</span> <span class="id" title="var">b</span>) = <span class="id" title="var">negb</span> (<span class="id" title="var">boolW_bool</span> <span class="id" title="var">b</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">boolW_bool__bool_boolW</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">boolW_bool</span> (<span class="id" title="var">bool_boolW</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bool_boolW__bool_boolW</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">boolW</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">bool_boolW</span> (<span class="id" title="var">boolW_bool</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">natW</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W</span> <span class="id" title="var">bool</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Empty_set</span> <span class="id" title="keyword">else</span> <span class="id" title="var">unit</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">zeroW</span> : <span class="id" title="var">natW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> <span class="id" title="var">true</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">e</span> : <span class="id" title="var">Empty_set</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">succW</span> (<span class="id" title="var">n</span> : <span class="id" title="var">natW</span>) : <span class="id" title="var">natW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sup</span> <span class="id" title="var">false</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">unit</span> =&gt; <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">doubleW</span> : <span class="id" title="var">natW</span> -&gt; <span class="id" title="var">natW</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W_rect</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Empty_set</span> <span class="id" title="keyword">else</span> <span class="id" title="var">unit</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">natW</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">a</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">zeroW</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">succW</span> (<span class="id" title="var">succW</span> (<span class="id" title="var">g</span> <span class="id" title="var">tt</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">natW_nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">W_rect</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Empty_set</span> <span class="id" title="keyword">else</span> <span class="id" title="var">unit</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">a</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">g</span> <span class="id" title="var">tt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_natW</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">natW</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">zeroW</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">succW</span> (<span class="id" title="var">nat_natW</span> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">natW_nat_doubleW</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">natW</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">natW_nat</span> (<span class="id" title="var">doubleW</span> <span class="id" title="var">n</span>) = 2 * <span class="id" title="var">natW_nat</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">natW_nat__nat_natW</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">natW_nat</span> (<span class="id" title="var">nat_natW</span> <span class="id" title="var">n</span>) = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_natW__nat_natW</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">natW</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nat_natW</span> (<span class="id" title="var">natW_nat</span> <span class="id" title="var">n</span>) = <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">listW</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab402"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisałem we wstępie, że W-typy umożliwiają reprezentowanie dowolnych
    typów induktywnych, ale czy to prawda? Przekonajmy się!

<div class="paragraph"> </div>

    Zdefiniuj za pomocą <span class="inlinecode"><span class="id" title="var">W</span></span> następujące typy i udowodnij, że są one
    izomorficzne z ich odpowiednikami:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">False</span></span> (czyli <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>)

</li>
<li> <span class="inlinecode"><span class="id" title="var">unit</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> typ o <span class="inlinecode"><span class="id" title="var">n</span></span> elementach

</li>
<li> liczby naturalne

</li>
<li> produkt

</li>
<li> sumę

</li>
</ul>

<div class="paragraph"> </div>

    Załóżmy teraz, że żyjemy w świecie, w którym nie ma typów induktywnych.
    Jakich typów, oprócz <span class="inlinecode"><span class="id" title="var">W</span></span>, potrzebujemy, by móc zdefiniować wszystkie
    powyższe typy? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab403"></a><h1 class="section">Indeksowane W-typy</h1>

<div class="paragraph"> </div>

 Jak głosi pewna stara książka z Palestyny, nie samymi W-typami żyje
    człowiek. W szczególności, W-typy mogą uchwycić jedynie dość proste
    typy induktywne, czyli takie, które wspierają jedynie parametry oraz
    argumenty indukcyjne. Na chwilę obecną wydaje mi się też, że <span class="inlinecode"><span class="id" title="var">W</span></span> nie
    jest w stanie reprezentować typów wzajemnie induktywnych, lecz pewny
    nie jest jestem.

<div class="paragraph"> </div>

    Trochę to smutne, gdyż naszą główną motywacją ku poznawaniu <span class="inlinecode"><span class="id" title="var">W</span></span>-typów
    jest teoretyczne zrozumienie mechanizmu działania typów induktywnych,
    a skoro <span class="inlinecode"><span class="id" title="var">W</span></span> jest biedne, to nie możemy za jego pomocą zrozumieć
    wszystkich typów induktywnych. Jednak uszy do góry, gdyż na ratunek w
    naszej misji przychodzą nam indeksowane W-typy!

<div class="paragraph"> </div>

    Co to za zwierzę, te indeksowane W-typy? Ano coś prawie jak oryginalne
    W, ale trochę na sterydach. Definicja wygląda tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">IW</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">I</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>), <span class="id" title="var">S</span> <span class="id" title="var">i</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">r</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) (<span class="id" title="var">s</span> : <span class="id" title="var">S</span> <span class="id" title="var">i</span>), <span class="id" title="var">P</span> <span class="id" title="var">i</span> <span class="id" title="var">s</span> -&gt; <span class="id" title="var">I</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">I</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">isup</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">i</span> : <span class="id" title="var">I</span>) (<span class="id" title="var">s</span> : <span class="id" title="var">S</span> <span class="id" title="var">i</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">p</span> : <span class="id" title="var">P</span> <span class="id" title="var">i</span> <span class="id" title="var">s</span>, <span class="id" title="var">IW</span> <span class="id" title="var">I</span> <span class="id" title="var">S</span> <span class="id" title="var">P</span> <span class="id" title="var">r</span> (<span class="id" title="var">r</span> <span class="id" title="var">i</span> <span class="id" title="var">s</span> <span class="id" title="var">p</span>)) -&gt; <span class="id" title="var">IW</span> <span class="id" title="var">I</span> <span class="id" title="var">S</span> <span class="id" title="var">P</span> <span class="id" title="var">r</span> <span class="id" title="var">i</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">isup</span> {<span class="id" title="var">I</span> <span class="id" title="var">S</span> <span class="id" title="var">P</span> <span class="id" title="var">r</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Prawdopodobnie odczuwasz w tej chwili wielką grozę, co najmniej jakbyś
    zobaczył samego Cthulhu. Nie martw się - zaraz dokładnie wyjasnimy, co
    tu się dzieje, a potem rozpracujemy indeksowane W typy na przykładach
    rodzin typów induktywnych, które powinieneś już dobrze znać.

<div class="paragraph"> </div>

    Objaśnienia:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> to typ indeksów

</li>
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> to typ kształtów o indeksie <span class="inlinecode"><span class="id" title="var">i</span></span>. Kształt to konstruktor wraz ze
      swoimi argumentami nieindukcyjnymi.

</li>
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> to typ mówiący, ile jest argumentów indukcyjnych o kształcie <span class="inlinecode"><span class="id" title="var">s</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> mówi, jak jest indeks argumentu indukcyjnego <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Konstruktor <span class="inlinecode"><span class="id" title="var">isup</span></span> mówi, że jeżeli mamy indeks i kształt dla tego
    indeksu, to jeżeli uda nam się zapchać wszystkie argumenty indukcyjne
    rzeczami o odpowiednim indeksie, to dostajemy element <span class="inlinecode"><span class="id" title="var">IW</span></span> <span class="inlinecode">...</span> o takim
    indeksie jak chcieliśmy.

<div class="paragraph"> </div>

    Czas na przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Vec</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">vnil</span> : <span class="id" title="var">Vec</span> <span class="id" title="var">A</span> 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">vcons</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Vec</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">Vec</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">vcons</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Na pierwszy ogień idzie <span class="inlinecode"><span class="id" title="var">Vec</span></span>, czyli listy indeksowane długością. Jak
    wygląda jego reprezentacja za pomocą <span class="inlinecode"><span class="id" title="var">IW</span></span>? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">I_Vec</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> := <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
Przede wszystkim musimy zauważyć, że typem indeksów <span class="inlinecode"><span class="id" title="var">I</span></span> jest <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">S_Vec</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">i</span> : <span class="id" title="var">I_Vec</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Type</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">A</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Typ kształtów definiujemy przez dopasowanie indeksu do wzorca, bo dla
    różnych indeksów mamy różne możliwe kształty. Konstruktor <span class="inlinecode"><span class="id" title="var">vnil</span></span> jest
    jedynym konstruktorem o indeksie <span class="inlinecode">0</span> i nie bierze on żadnych argumentów
    nieindukcyjnych, stąd w powyższej definicji klauzula <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>.
    Konstruktor <span class="inlinecode"><span class="id" title="var">vcons</span></span> jest jedynym konstruktorem o indeksie niezerowym i
    niezależnie od indeksu bierze on jeden argument nieindukcyjny typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    stąd klauzula <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">P_Vec</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">i</span> : <span class="id" title="var">I_Vec</span> <span class="id" title="var">A</span>} (<span class="id" title="var">s</span> : <span class="id" title="var">S_Vec</span> <span class="id" title="var">i</span>) : <span class="id" title="keyword">Type</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">unit</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Typ pozycji różwnież definiujemy przez dopasowanie indeksu do wzorca,
    bo różne kształty będą miały różne pozycje, a przecież kształty też są
    zdefiniowane przez dopasowanie indeksu. Konstruktor <span class="inlinecode"><span class="id" title="var">vnil</span></span> nie bierze
    argumentów indukcyjnych i stąd klauzula <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. Konstruktor
    <span class="inlinecode"><span class="id" title="var">vcons</span></span> bierze jeden argument indukcyjny i stąd klauzula <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>.

<div class="paragraph"> </div>

    Zauważmy, że niebranie argumentu nieindukcyjnego reprezentujemy inaczej
    niż niebranie argumentu indukcyjnego.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">vnil</span></span> nie bierze argumentów nieindukcyjnych, co w typie kształtów <span class="inlinecode"><span class="id" title="var">S_Vec</span></span>
    reprezentujemy za pomocą typu <span class="inlinecode"><span class="id" title="var">unit</span></span>. Możemy myśleć o tym tak, że <span class="inlinecode"><span class="id" title="var">vnil</span></span>
    bierze jeden argument typu <span class="inlinecode"><span class="id" title="var">unit</span></span>. Ponieważ <span class="inlinecode"><span class="id" title="var">unit</span></span> ma tylko jeden element,
    to i tak z góry wiadomo, że będziemy musieli jako ten argument wstawić
    <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">vnil</span></span> nie bierze też argumentów indukcyjnych, co w typue pozycji <span class="inlinecode"><span class="id" title="var">P_Vec</span></span>
    reprezentujemy za pomocą typu <span class="inlinecode"><span class="id" title="var">False</span></span>. Możemy myśleć o tym tak, że jest
    tyle samo argumentów indukcyjnych, co dowodów <span class="inlinecode"><span class="id" title="var">False</span></span>, czyli zero.

<div class="paragraph"> </div>

    Podsumowując, różnica jest taka, że dla argumentów nieindukcyjnych typ
    <span class="inlinecode"><span class="id" title="var">X</span></span> oznacza "weź element typu X", zaś dla argumentów indukcyjnych typ
    <span class="inlinecode"><span class="id" title="var">X</span></span> oznacza "weź tyle elementów typu, który właśnie definiujemy, ile
    jest elementów typu X". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">r_Vec</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">i</span> : <span class="id" title="var">I_Vec</span> <span class="id" title="var">A</span>} {<span class="id" title="var">s</span> : <span class="id" title="var">S_Vec</span> <span class="id" title="var">i</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">P_Vec</span> <span class="id" title="var">s</span>) : <span class="id" title="var">I_Vec</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">i</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">i'</span>]; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">i'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Pozostaje nam tylko zdefiniować funkcję, która pozycjom argumentów
    indukcyjnym w poszczególnych kształtach przyporządkowuje ich indeksy.
    Definiujemy tę funkcję przez dowód, gdyż Coq dość słabo rodzi sobie z
    dopasowaniem do wzorca przy typach zależnych.

<div class="paragraph"> </div>

    Ponieważ kształty są zdefiniowane przez dopasowanie indeksu do wzorca,
    to zaczynamy od rozbicia indeksu na przypadki. Gdy indeks wynosi zero,
    to mamy do czynienia z reprezentacją konstruktora <span class="inlinecode"><span class="id" title="var">vnil</span></span>, który nie
    bierze żadnych argumentów indukcyjnych, co ujawnia się pod postacią
    sprzeczności. Gdy indeks wynosi <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">i'</span></span>, mamy do czynienia z konstruktorem
    <span class="inlinecode"><span class="id" title="var">vcons</span></span> <span class="inlinecode"><span class="id" title="var">i'</span></span>, który tworzy element typu <span class="inlinecode"><span class="id" title="var">Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">i'</span>)</span>, zaś bierze element
    typu <span class="inlinecode"><span class="id" title="var">Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">i'</span></span>. Wobec tego w tym przypadku zwracamy <span class="inlinecode"><span class="id" title="var">i'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Vec'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">IW</span> (<span class="id" title="var">I_Vec</span> <span class="id" title="var">A</span>) (@<span class="id" title="var">S_Vec</span> <span class="id" title="var">A</span>) (@<span class="id" title="var">P_Vec</span> <span class="id" title="var">A</span>) (@<span class="id" title="var">r_Vec</span> <span class="id" title="var">A</span>).<br/>

<br/>
</div>

<div class="doc">
Tak wygląda ostateczna definicja <span class="inlinecode"><span class="id" title="var">Vec'</span></span> - wrzucamy do <span class="inlinecode"><span class="id" title="var">IW</span></span> odpowiednie
    indeksy, kształty, pozycje oraz funkcję przypisującą indeksy pozycjom.

<div class="paragraph"> </div>

    Spróbujmy przekonać się, że typy <span class="inlinecode"><span class="id" title="var">Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">Vec'</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> są
    izomorficzne. W tym celu musimy zdefiniować funkcje
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Vec'</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Vec'</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, które są
    swoimi odwrotnościami. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">f</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">Vec</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) : <span class="id" title="var">Vec'</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">isup</span> 0 <span class="id" title="var">tt</span>). <span class="id" title="var">cbn</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (@<span class="id" title="var">isup</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (@<span class="id" title="var">r_Vec</span> <span class="id" title="var">A</span>) (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">a</span>). <span class="id" title="var">cbn</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">f</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">v</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Najłatwiej definiować nam będzie za pomocą taktyk. Definicja <span class="inlinecode"><span class="id" title="var">f</span></span> idzie
    przez rekursję strukturalną po <span class="inlinecode"><span class="id" title="var">v</span></span>. <span class="inlinecode"><span class="id" title="var">isup</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">tt</span></span> to reprezentacja <span class="inlinecode"><span class="id" title="var">vnil</span></span>,
    zaś <span class="inlinecode">@<span class="id" title="var">isup</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">(@<span class="id" title="var">r_Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">a</span></span> to reprezentacja <span class="inlinecode"><span class="id" title="var">vcons</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span>. Dość
    nieczytelne, prawda? Dlatego właśnie nikt w praktyce nie używa
    indeksowanych W-typów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">g</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">Vec'</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) : <span class="id" title="var">Vec</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">v</span> <span class="id" title="keyword">as</span> [[| <span class="id" title="var">i'</span>] <span class="id" title="var">s</span> <span class="id" title="var">p</span>]; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">vnil</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">vcons</span> <span class="id" title="var">s</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">g</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">p</span> <span class="id" title="var">tt</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
W drugą stronę jest łatwiej. Definicja idzie oczywiście przez rekursję
    po <span class="inlinecode"><span class="id" title="var">v</span></span> (pamiętajmy, że <span class="inlinecode"><span class="id" title="var">Vec'</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> to tylko specjalny przypadek <span class="inlinecode"><span class="id" title="var">IW</span></span>,
    zaś <span class="inlinecode"><span class="id" title="var">IW</span></span> jest induktywne). Po rozbiciu <span class="inlinecode"><span class="id" title="var">v</span></span> na komponenty sprawdzamy,
    jaki ma ono indeks. Jeżeli <span class="inlinecode">0</span>, zwracamy <span class="inlinecode"><span class="id" title="var">vnil</span></span>. Jeżeli niezerowy, to
    zwracamy <span class="inlinecode"><span class="id" title="var">vcons</span></span> z głową <span class="inlinecode"><span class="id" title="var">s</span></span> rekurencyjnie obliczonym ogonem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_g</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">Vec</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">v</span>) = <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">v</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHv</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód odwrotności w jedną stronę jest banalny - indukcja po <span class="inlinecode"><span class="id" title="var">v</span></span> idzie
    gładko, bo <span class="inlinecode"><span class="id" title="var">v</span></span> jest typu <span class="inlinecode"><span class="id" title="var">Vec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">g_f</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">Vec'</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">v</span>) = <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">v</span> <span class="id" title="keyword">as</span> [[| <span class="id" title="var">i'</span>] <span class="id" title="var">s</span> <span class="id" title="var">p</span> <span class="id" title="var">IH</span>]; <span class="id" title="tactic">unfold</span> <span class="id" title="var">I_Vec</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W drugę stronę dowód jest nieco trudniejszy. Przede wszystkim, musimy
    posłużyć się aksjomatem ekstensjonalności dla funkcji. Wynika to z faktu,
    że w <span class="inlinecode"><span class="id" title="var">IW</span></span> reprezentujemy argumenty indukcyjne wszystkie na raz za pomocą
    pojedynczej funkcji.

<div class="paragraph"> </div>

    Zaczynamy przez indukcję po <span class="inlinecode"><span class="id" title="var">v</span></span> i rozbijamy indeks żeby sprawdzić, z
    którym kształtem mamy do czynienia. Kluczowym krokime jest odwinięcie
    definicji <span class="inlinecode"><span class="id" title="var">I_Vec</span></span> - bez tego taktyka <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> nie zadziała tak jak
    powinna. W obu przypadkach kończymy przez użycie ekstensjonalności
    do udowodnienia, że argumenty indukcyjne są równe. 
<div class="paragraph"> </div>

<a name="lab404"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj za pomocą <span class="inlinecode"><span class="id" title="var">IW</span></span> następujące predykaty/relacje/rodziny typów:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span>

</li>
<li> typ drzew binarnych trzymających wartości w węzłach, indeksowany
      wysokością

</li>
<li> to samo co wyżej, ale indeksowany ilością elementów

</li>
<li> porządek <span class="inlinecode">&lt;=</span> dla liczb naturalnych

</li>
<li> relację <span class="inlinecode"><span class="id" title="var">Perm</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> mówiącą, że <span class="inlinecode"><span class="id" title="var">l1</span></span> i <span class="inlinecode"><span class="id" title="var">l2</span></span>
      są swoimi permutacjami 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab405"></a><h1 class="section">M-typy (TODO)</h1>

<div class="paragraph"> </div>

 M-typy to to samo co W-typy, tylko że dualne. Pozdro dla kumatych. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">F1</span>.<br/>

<br/>
</div>

<div class="doc">
Naszą motywacją do badania W-typów było to, że są one jedynym
    pierścieniem, tj. pozwalają uchwycić wszystkie typy induktywne
    za pomocą jednego (oczywiście o ile mamy też <span class="inlinecode"><span class="id" title="var">False</span></span>, <span class="inlinecode"><span class="id" title="var">unit</span></span>,
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">prod</span></span> i <span class="inlinecode"><span class="id" title="var">sum</span></span>).

<div class="paragraph"> </div>

    Podobnie możemy postawić sobie zadanie zbadania wszystkich typów
    koinduktywnych. Odpowiedź na to pytanie jest (zupełnie nieprzypadkowo)
    analogiczna do tej dla typów induktywnych, a są nią M-typy. Skąd nazwa?
    Zauważ, że M to nic innego jak W postawione na głowie - podobnie esencja
    M-typów jest taka sama jak W-typów, ale interpretacja jest postawiona
    na głowie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoInductive</span> <span class="id" title="var">M</span> (<span class="id" title="var">S</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">S</span> -&gt; <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">shape</span> : <span class="id" title="var">S</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">position</span> : <span class="id" title="var">P</span> <span class="id" title="var">shape</span> -&gt; <span class="id" title="var">M</span> <span class="id" title="var">S</span> <span class="id" title="var">P</span><br/>
}.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">shape</span> {<span class="id" title="var">S</span> <span class="id" title="var">P</span>}.<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">position</span> {<span class="id" title="var">S</span> <span class="id" title="var">P</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Zastanówmy się przez chwilę, dlaczego definicja <span class="inlinecode"><span class="id" title="var">M</span></span> wygląda właśnie tak.
    W tym celu rozważmy dowolny typ koinduktywny <span class="inlinecode"><span class="id" title="var">C</span></span> i przyjmijmy, że ma on
    pola <span class="inlinecode"><span class="id" title="var">f1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">fn</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Xn</span></span>. Argumenty możemy podzielić na dwie grupy:
    koindukcyjne (których typem jest <span class="inlinecode"><span class="id" title="var">C</span></span> lub funkcje postaci <span class="inlinecode"><span class="id" title="var">Y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">C</span></span>) oraz
    niekoindukcyjne (oznaczmy ich typy przez <span class="inlinecode"><span class="id" title="var">A</span></span>).

<div class="paragraph"> </div>

    Oczywiście wszystkie niekoindukcyjne pola o typach <span class="inlinecode"><span class="id" title="var">A1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">Ak</span></span> możemy
    połączyć w jedno wielgachne pole o typie <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">*</span> <span class="inlinecode">...</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">Ak</span></span> i tym właśnie
    jest występujące w <span class="inlinecode"><span class="id" title="var">M</span></span> pole <span class="inlinecode"><span class="id" title="var">shape</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    TODO 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">transport</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">y</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">eq_refl</span> =&gt; <span class="id" title="var">u</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">CoInductive</span> <span class="id" title="var">siM</span> {<span class="id" title="var">S</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">S</span> -&gt; <span class="id" title="keyword">Type</span>} (<span class="id" title="var">m1</span> <span class="id" title="var">m2</span> : <span class="id" title="var">M</span> <span class="id" title="var">S</span> <span class="id" title="var">P</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">shapes</span> : <span class="id" title="var">shape</span> <span class="id" title="var">m1</span> = <span class="id" title="var">shape</span> <span class="id" title="var">m2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">positions</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">p</span> : <span class="id" title="var">P</span> (<span class="id" title="var">shape</span> <span class="id" title="var">m1</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">siM</span> (<span class="id" title="var">position</span> <span class="id" title="var">m1</span> <span class="id" title="var">p</span>) (<span class="id" title="var">position</span> <span class="id" title="var">m2</span> (<span class="id" title="var">transport</span> <span class="id" title="var">shapes</span> <span class="id" title="var">p</span>))<br/>
}.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">P_Stream</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">unit</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Stream'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> := <span class="id" title="var">M</span> <span class="id" title="var">A</span> (<span class="id" title="var">P_Stream</span> <span class="id" title="var">A</span>).<br/>

<br/>
<span class="id" title="keyword">CoFixpoint</span> <span class="id" title="var">ff</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">s</span> : <span class="id" title="var">Stream</span> <span class="id" title="var">A</span>) : <span class="id" title="var">Stream'</span> <span class="id" title="var">A</span> :=<br/>
{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">shape</span> := <span class="id" title="var">hd</span> <span class="id" title="var">s</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">position</span> <span class="id" title="var">_</span> := <span class="id" title="var">ff</span> (<span class="id" title="var">tl</span> <span class="id" title="var">s</span>);<br/>
|}.<br/>

<br/>
<span class="id" title="keyword">CoFixpoint</span> <span class="id" title="var">gg</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">s</span> : <span class="id" title="var">Stream'</span> <span class="id" title="var">A</span>) : <span class="id" title="var">Stream</span> <span class="id" title="var">A</span> :=<br/>
{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">hd</span> := <span class="id" title="var">shape</span> <span class="id" title="var">s</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">tl</span> := <span class="id" title="var">gg</span> (<span class="id" title="var">position</span> <span class="id" title="var">s</span> <span class="id" title="var">tt</span>);<br/>
|}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ff_gg</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">s</span> : <span class="id" title="var">Stream</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">bisim</span> (<span class="id" title="var">gg</span> (<span class="id" title="var">ff</span> <span class="id" title="var">s</span>)) <span class="id" title="var">s</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">cofix</span> <span class="id" title="var">CH</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">CH</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">gg_ff</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">s</span> : <span class="id" title="var">Stream'</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">siM</span> (<span class="id" title="var">ff</span> (<span class="id" title="var">gg</span> <span class="id" title="var">s</span>)) <span class="id" title="var">s</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">cofix</span> <span class="id" title="var">CH</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">econstructor</span>. <span class="id" title="var">Unshelve</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Focus</span> 2. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">CH</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">coListM</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">M</span> (<span class="id" title="var">option</span> <span class="id" title="var">A</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
<span class="id" title="keyword">CoFixpoint</span> <span class="id" title="var">fff</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">coList</span> <span class="id" title="var">A</span>) : <span class="id" title="var">coListM</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">uncons</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; {| <span class="id" title="var">shape</span> := <span class="id" title="var">None</span>; <span class="id" title="var">position</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">e</span> : <span class="id" title="var">False</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span> |}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> (<span class="id" title="var">h</span>, <span class="id" title="var">t</span>) =&gt; {| <span class="id" title="var">shape</span> := <span class="id" title="var">Some</span> <span class="id" title="var">h</span>; <span class="id" title="var">position</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; @<span class="id" title="var">fff</span> <span class="id" title="var">_</span> <span class="id" title="var">t</span> |}<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab406"></a><h1 class="section">Indeksowane M-typy?</h1>

<div class="paragraph"> </div>

 Nie dla psa kiełbasa. 
<div class="paragraph"> </div>

<a name="lab407"></a><h1 class="section">Kodowanie Churcha (TODO)</h1>

<div class="paragraph"> </div>

 Achtung: póki co wisi tu kod roboczy 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">clist</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">X</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">cnil</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">clist</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span> =&gt; <span class="id" title="var">nil</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ccons</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">clist</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">clist</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span> =&gt; <span class="id" title="var">cons</span> <span class="id" title="var">h</span> (<span class="id" title="var">t</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;c[]" := <span class="id" title="var">cnil</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x :c: y" := (<span class="id" title="var">ccons</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;c[ x ; .. ; y ]" := (<span class="id" title="var">ccons</span> <span class="id" title="var">x</span> .. (<span class="id" title="var">ccons</span> <span class="id" title="var">y</span> <span class="id" title="var">cnil</span>) ..).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">head</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) : <span class="id" title="var">option</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> (<span class="id" title="var">option</span> <span class="id" title="var">A</span>) <span class="id" title="var">None</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Some</span> <span class="id" title="var">h</span>).<br/>

<br/>
<span class="comment">(*<br/>
Definition&nbsp;tail&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(l&nbsp;:&nbsp;clist&nbsp;A)&nbsp;:&nbsp;option&nbsp;(clist&nbsp;A)&nbsp;:=<br/>
&nbsp;&nbsp;l&nbsp;_&nbsp;None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;h&nbsp;t&nbsp;=&gt;&nbsp;t).<br/>
<br/>
Compute&nbsp;tail&nbsp;c<span class="inlinecode">1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3</span>.<br/>
*)</span><br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">null</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> <span class="id" title="var">_</span> <span class="id" title="var">true</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">clen</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> <span class="id" title="var">nat</span> 0 (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">S</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snoc</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">clist</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span> =&gt; <span class="id" title="var">l</span> <span class="id" title="var">_</span> (<span class="id" title="var">c</span>[<span class="id" title="var">x</span>] <span class="id" title="var">_</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span>) <span class="id" title="var">cons</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">rev</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">clist</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">capp</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) : <span class="id" title="var">clist</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span> =&gt; <span class="id" title="var">l1</span> <span class="id" title="var">X</span> (<span class="id" title="var">l2</span> <span class="id" title="var">X</span> <span class="id" title="var">nil</span> <span class="id" title="var">cons</span>) <span class="id" title="var">cons</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">fromList</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">clist</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; <span class="id" title="var">cnil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> =&gt; <span class="id" title="var">ccons</span> <span class="id" title="var">h</span> (<span class="id" title="var">fromList</span> <span class="id" title="var">t</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) [] (@<span class="id" title="var">cons</span> <span class="id" title="var">A</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">toList_fromList</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">toList</span> (<span class="id" title="var">fromList</span> <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>]; <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">rewrite</span> ?<span class="id" title="var">IHt</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fromList_toList</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">cl</span> : <span class="id" title="var">clist</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fromList</span> (<span class="id" title="var">toList</span> <span class="id" title="var">cl</span>) = <span class="id" title="var">cl</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">clist</span> <span class="id" title="tactic">in</span> *. <span class="id" title="tactic">compute</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wut</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span>.<br/>
</div>
