<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<title>Typonomikon</title>
</head>
<h1 class="libtitle">G5: Indukcja-rekursja</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab728"></a><h1 class="section">Wstęp (TODO)</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">ind_rec</span>.<br/>

<br/>
</div>

<div class="doc">
A oto kolejny potfur do naszej kolekcji: indukcja-rekursja. Nazwa, choć
    brzmi tak głupio, jak "indukcja-indukcja", niesie ze sobą jednak dużo
    więcej wyobraźni: indukcja-rekursja pozwala nam jednocześnie definiować
    typy induktywne oraz operujące na nich funkcje rekurencyjne.

<div class="paragraph"> </div>

    Co to dokładnie znaczy? Dotychczas nasz modus operandi wyglądał tak, że
    najpierw definiowaliśmy jakiś typ induktywny, a potem przez rekursję
    definiowaliśmy operujące na nim funkcje, np:
<ul class="doclist">
<li> najpierw zdefiniowaliśmy typ <span class="inlinecode"><span class="id" title="var">nat</span></span>, a potem dodawanie, mnożenie etc.

</li>
<li> najpierw zdefiniowaliśmy typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a potem <span class="inlinecode"><span class="id" title="var">app</span></span>, <span class="inlinecode"><span class="id" title="var">rev</span></span> etc. 
</li>
</ul>

<div class="paragraph"> </div>

 Dlaczego mielibyśmy chcieć definiować typ i funkcję jednocześnie? Dla
    tego samego, co zawsze, czyli zależności - indukcja-rekursja pozwala,
    żeby definicja typu odnosiła się do funkcji, która to z kolei jest
    zdefiniowana przez rekursję strukturalną po argumencie o tym typie.

<div class="paragraph"> </div>

    Zobaczmy dobrze nam już znany bezsensowny przykład, czyli listy
    posortowane, tym razem zaimplementowane za pomocą indukcji-rekursji. 
<div class="paragraph"> </div>

<a id="lab729"></a><h1 class="section">Listy posortowane, znowu (TODO)</h1>

</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Inductive&nbsp;slist&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;bool)&nbsp;:&nbsp;Type&nbsp;:=<br/>
|&nbsp;snil&nbsp;:&nbsp;slist&nbsp;R<br/>
|&nbsp;scons&nbsp;:&nbsp;forall&nbsp;(h&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;slist&nbsp;R),&nbsp;ok&nbsp;h&nbsp;t&nbsp;=&nbsp;true&nbsp;-&gt;&nbsp;slist&nbsp;R<br/>
<br/>
with<br/>
<br/>
Definition&nbsp;ok<br/>
&nbsp;&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;{R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;bool}&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;slist&nbsp;R)&nbsp;:&nbsp;bool&nbsp;:=<br/>
match&nbsp;t&nbsp;with<br/>
|&nbsp;snil&nbsp;=&gt;&nbsp;true<br/>
|&nbsp;scons&nbsp;h&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;R&nbsp;x&nbsp;h<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Coq niestety nie wspiera indukcji-rekursji, a próba napisania powyższej
    definicji kończy się błędem składni, przy którym nie pomaga nawet komenda
    <span class="inlinecode"><span class="id" title="var">Fail</span></span>. Podobnie jak poprzednio, pomożemy sobie za pomocą aksjomatów,
    jednak najpierw prześledźmy definicję.

<div class="paragraph"> </div>

    Typ <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> działa następująco:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> to jakiś porządek. Zauważ, że tym razem <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a
      więc porządek jest reprezentowany przez funkcję, która go rozstrzyga

</li>
<li> <span class="inlinecode"><span class="id" title="var">snil</span></span> to lista pusta

</li>
<li> <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> to lista z głową <span class="inlinecode"><span class="id" title="var">h</span></span> i ogonem <span class="inlinecode"><span class="id" title="var">t</span></span>, zaś <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>
      to dowód na to, że dostawienie <span class="inlinecode"><span class="id" title="var">h</span></span> przed <span class="inlinecode"><span class="id" title="var">t</span></span> daje listę posortowaną. 
</li>
</ul>

<div class="paragraph"> </div>

 Tym razem jednak <span class="inlinecode"><span class="id" title="var">ok</span></span> nie jest relacją, lecz funkcją zwracającą <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    która działa następująco:
<ul class="doclist">
<li> dla <span class="inlinecode"><span class="id" title="var">snil</span></span> zwróć <span class="inlinecode"><span class="id" title="var">true</span></span> - każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> można dostawić do listy pustej

</li>
<li> dla <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> zwróć wynik porównania <span class="inlinecode"><span class="id" title="var">x</span></span> z <span class="inlinecode"><span class="id" title="var">h</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Istotą mechanizmu indukcji-rekursji w tym przykładzie jest to, że <span class="inlinecode"><span class="id" title="var">scons</span></span>
    wymaga dowodu na to, że funkcja <span class="inlinecode"><span class="id" title="var">ok</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span>, podczas gdy funkcja
    ta jest zdefiniowana przez rekursję strukturalną po argumencie typu
    <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Użycie indukkcji-rekursji do zaimplementowania <span class="inlinecode"><span class="id" title="var">slist</span></span> ma swoje zalety:
    dla konkretnych list (złożonych ze stałych, a nie ze zmiennych) dowody
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> będą postaci <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>, bo <span class="inlinecode"><span class="id" title="var">ok</span></span> po prostu obliczy się
    do <span class="inlinecode"><span class="id" title="var">true</span></span>. W przypadku indukcji-indukcji dowody na <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> były całkiem
    sporych rozmiarów drzewami. Innymi słowy, udało nam się zastąpić część
    termu obliczeniami. Ten intrygujący motyw jeszcze się w przyszłości
    pojawi, gdy omawiać będziemy dowód przez reflekcję.

<div class="paragraph"> </div>

    Dosyć gadania! Zobaczmy, jak zakodować powyższą definicję za pomocą
    aksjomatów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">slist</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}, <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">slist</span> <span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">x</span> (@<span class="id" title="var">snil</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span>) = <span class="id" title="var">true</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> <span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ok</span> <span class="id" title="var">x</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>).<br/>

<br/>
</div>

<div class="doc">
Najpierw musimy zadeklarować <span class="inlinecode"><span class="id" title="var">slist</span></span>, a następnie <span class="inlinecode"><span class="id" title="var">ok</span></span>, gdyż typ <span class="inlinecode"><span class="id" title="var">ok</span></span>
    zależy od <span class="inlinecode"><span class="id" title="var">slist</span></span>. Następnym krokiem jest zadeklarowanie konstruktorów
    <span class="inlinecode"><span class="id" title="var">slist</span></span>, a później równań definiujących funkcję <span class="inlinecode"><span class="id" title="var">ok</span></span> - koniecznie w tej
    kolejności, gdyż równania zależą od konstruktorów.

<div class="paragraph"> </div>

    Jak widać, aksjomaty są bardzo proste i sprowadzają się do przepisania
    powyższej definicji odrzuconej przez Coqa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Psnil</span> : <span class="id" title="var">P</span> <span class="id" title="var">snil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Pscons</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = <span class="id" title="var">Psnil</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">Pscons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span> (<span class="id" title="var">f</span> <span class="id" title="var">t</span>))}.<br/>

<br/>
</div>

<div class="doc">
Innym zyskiem z użycia indukcji-rekursji jest postać reguły indukcyjnej.
    Jest ona dużo prostsza, niż w przypadku indukcji-indukcji, gdyż teraz
    definiujemy tylko jeden typ, zaś towarzysząca mu funkcja nie wymaga w
    regule niczego specjalnego - po prostu pojawia się w niej tam, gdzie
    spodziewamy się jej po definicji <span class="inlinecode"><span class="id" title="var">slist</span></span>, ale nie robi niczego
    ponad to. Może to sugerować, że zamiast indukcji-indukcji, o ile to
    możliwe, lepiej jest używać indukcji-rekursji, a predykaty i relacje
    definiować przez rekursję.

<div class="paragraph"> </div>

    Powyższą regułę możemy odczytać następująco:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> to parametry <span class="inlinecode"><span class="id" title="var">slist</span></span>, więc muszą się
      pojawić

</li>
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> to przeciwdziedzina funkcji definiowanej za
      pomocą reguły

</li>
<li> <span class="inlinecode"><span class="id" title="var">Psnil</span></span> to wynik funkcji dla <span class="inlinecode"><span class="id" title="var">snil</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">Pscons</span></span> produkuje wynik funkcji dla <span class="inlinecode"><span class="id" title="var">scons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> z hipotezy
      indukcyjnej/wywołania rekurencyjnego dla <span class="inlinecode"><span class="id" title="var">t</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> to funkcja zdefiniowana przez regułę,
      zaś równania formalizują to, co zostało napisane powyżej o <span class="inlinecode"><span class="id" title="var">Psnil</span></span>
      i <span class="inlinecode"><span class="id" title="var">Pscons</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Termy induktywno-rekurencyjnego <span class="inlinecode"><span class="id" title="var">slist</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> wyglądają następująco
    (najpierw definiujemy sobie funkcję rozstrzygającą standardowy
    porządek na liczbach naturalnych): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">leb</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
| 0, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">true</span><br/>
| <span class="id" title="var">_</span>, 0 =&gt; <span class="id" title="var">false</span><br/>
| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">leb</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">leb</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">scons</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_snil</span> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ok_scons</span> 0 1 <span class="id" title="var">snil</span> (<span class="id" title="var">ok_snil</span> 1)).<br/>

<br/>
</div>

<div class="doc">
Nie wygląda wiele lepiej od poprzedniej, induktywno-induktywnej wersji,
    prawda? Ta rażąca kiepskość nie jest jednak zasługą indukcji-rekursji,
    lecz kodowania za pomocą aksjomatów - funkcja <span class="inlinecode"><span class="id" title="var">ok</span></span> się nie oblicza,
    więc zamiast <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> musimy używać aksjomatów <span class="inlinecode"><span class="id" title="var">ok_snil</span></span> i <span class="inlinecode"><span class="id" title="var">ok_scons</span></span>.

<div class="paragraph"> </div>

    W tym momencie znów wkracza ława oburzonych i wyraża swoje oburzenie na
    fakt, że Coq nie wspiera indukcji-rekursji (ale Agda już tak). Gdyby
    <span class="inlinecode"><span class="id" title="var">Coq</span></span> wspierał indukcję-rekursję, to ten term wyglądałby tak: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">slist_01</span> : <span class="id" title="var">slist</span> <span class="id" title="var">leb</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">scons</span> 0 (<span class="id" title="var">scons</span> 1 <span class="id" title="var">snil</span> <span class="id" title="var">eq_refl</span>) <span class="id" title="var">eq_refl</span>.<br/>

<br/>
</div>

<div class="doc">
Dużo lepiej, prawda? Na koniec zobaczmy, jak zdefiniować funkcję
    zapominającą o fakcie, że lista jest posortowana. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">snil</span> = [] /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">slist</span> <span class="id" title="var">R</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">ok</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> = <span class="id" title="var">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">scons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> <span class="id" title="var">p</span>) = <span class="id" title="var">h</span> :: <span class="id" title="var">f</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ind</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>) [] (<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> =&gt; <span class="id" title="var">h</span> :: <span class="id" title="var">r</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">toList</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} : <span class="id" title="var">slist</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">proj1_sig</span> <span class="id" title="var">toList'</span>.<br/>

<br/>
</div>

<div class="doc">
Ponownie jest to dużo prostsze, niż w przypadku indukcji-indukcji -
    wprawdzie wciąż musimy ręcznie wpisywać termy do reguły indukcji,
    ale dzięki prostocie reguły jest to znacznie łatwiejsze. Alternatywnie:
    udało nam się zaoszczędzić trochę czasu na definiowaniu reguły rekursji,
    co w przypadku indukcji-indukcji było niemal konieczne, żeby nie
    zwariować. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">toList_slist_01_result</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">toList</span> <span class="id" title="var">slist_01</span> = [0; 1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">toList</span>, <span class="id" title="var">slist_01</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">toList'</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">f</span> &amp; <span class="id" title="var">H1</span> &amp; <span class="id" title="var">H2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> 2!<span class="id" title="var">H2</span>, <span class="id" title="var">H1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Udowodnienie, że nasza funkcja daje taki wynik jak chcieliśmy, jest
    równie proste jak poprzednio. 
<div class="paragraph"> </div>

<a id="lab730"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj dla list posortowanych funkcję <span class="inlinecode"><span class="id" title="var">slen</span></span>, która liczy ich długość.
    Udowodnij oczywiste twierdzenie wiążące ze sobą <span class="inlinecode"><span class="id" title="var">slen</span></span>, <span class="inlinecode"><span class="id" title="var">toList</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">length</span></span>. Czy było łatwiej, niż w przypadku indukcji-indukcji? 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ind_rec</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab731"></a><h1 class="section">Sterty binarne (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab732"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 No cóż, jeszcze raz to samo. Zdefiniuj za pomocą indukcji-rekursji
    jednocześnie typ stert binarnych <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    rozstrzyga porządek, i funkcję <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">ok</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, gdy stertę <span class="inlinecode"><span class="id" title="var">h</span></span> można podczepić pod element <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicję, a potem przetłumacz ją na odpowiedni
    zestaw aksjomatów.

<div class="paragraph"> </div>

    Następnie użyj swojej aksjomatycznej definicji, aby zdefiniować funkcję
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, która tworzy lustrzane odbicie sterty <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. Wskazówka:
    tym razem powinno ci się udać.

<div class="paragraph"> </div>

    Porównaj induktywno-rekurencyjną implementację <span class="inlinecode"><span class="id" title="var">BHeap</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">ok</span></span> z
    implementacją przez indukcję-indukcję. Która jest bardziej ogólna?
    Która jest "lżejsza"? Która jest lepsza? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab733"></a><h1 class="section">Drzewa wyszukiwań binarnych (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab734"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 No cóż, jeszcze raz to samo. Zdefiniuj za pomocą indukcji-rekursji
    jednocześnie typ drzew wyszukiwań binarnych <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> rozstrzyga porządek, oraz funkcje
    <span class="inlinecode"><span class="id" title="var">oklr</span></span>/<span class="inlinecode"><span class="id" title="var">okl</span></span> i <span class="inlinecode"><span class="id" title="var">okr</span></span>/<span class="inlinecode"><span class="id" title="var">ok</span></span>, które dbają o odpowiednie warunki (wybierz
    tylko jeden wariant z trzech, które testowałeś w tamtym zadaniu).

<div class="paragraph"> </div>

    Najpierw napisz pseudodefinicję, a potem przetłumacz ją na odpowiedni
    zestaw aksjomatów.

<div class="paragraph"> </div>

    Następnie użyj swojej aksjomatycznej definicji, aby zdefiniować funkcję
    <span class="inlinecode"><span class="id" title="var">mirror</span></span>, która tworzy lustrzane odbicie drzewa <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span>. Wskazówka:
    tym razem powinno ci się udać.

<div class="paragraph"> </div>

    Porównaj induktywno-rekurencyjną implementację <span class="inlinecode"><span class="id" title="var">BST</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> z implementacją
    przez indukcję-indukcję. Która jest bardziej ogólna? Która jest
    "lżejsza"? Która jest lepsza? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab735"></a><h1 class="section">Uniwersa (TODO)</h1>

<div class="paragraph"> </div>

 Podobnie jak poprzednio, pojawia się pytanie: do czego w praktyce
    można użyć indukcji-rekursji (poza rzecz jasna głupimi strukturami
    danych, jak listy posortowane)? W świerszczykach dla bystrzaków
    (czyli tzw. "literaturze naukowej") przewija się głównie jeden (ale
    jakże użyteczny) pomysł: uniwersa.

<div class="paragraph"> </div>

    Czym są uniwersa i co mają wspólnego z indukcją-rekursją? Najlepiej
    będzie przekonać się na przykładzie programowania generycznego: 
<div class="paragraph"> </div>

<a id="lab736"></a><h4 class="section">Ćwiczenie (zdecydowanie za trudne)</h4>

<div class="paragraph"> </div>

 Zaimplementuj generyczną funkcję <span class="inlinecode"><span class="id" title="var">flatten</span></span>, która spłaszcza dowolnie
    zagnieżdżone listy list do jednej, płaskiej listy.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">5</span> <span class="inlinecode">=</span> <span class="inlinecode">[5]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[[1];</span> <span class="inlinecode">[2];</span> <span class="inlinecode">[3]]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">flatten</span></span> <span class="inlinecode">[[[1;</span> <span class="inlinecode">2]];</span> <span class="inlinecode">[[3]];</span> <span class="inlinecode">[[4;</span> <span class="inlinecode">5];</span> <span class="inlinecode">[6]]]</span> <span class="inlinecode">=</span> <span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6]</span> 
<div class="paragraph"> </div>

 Trudne, prawda? Ale robialne, a robi się to tak.

<div class="paragraph"> </div>

    W typach argumentów <span class="inlinecode"><span class="id" title="var">flatten</span></span> na powyższym przykładzie widać pewien
    wzorzec: są to kolejno <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>,
    <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>))</span> i tak dalej. Możemy ten "wzorzec" bez problemu
    opisać za pomocą następującego typu: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">FlattenType</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Nat</span> : <span class="id" title="var">FlattenType</span><br/>
| <span class="id" title="var">List</span> : <span class="id" title="var">FlattenType</span> -&gt; <span class="id" title="var">FlattenType</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby było śmieszniej, <span class="inlinecode"><span class="id" title="var">FlattenType</span></span> to dokładnie to samo co <span class="inlinecode"><span class="id" title="var">nat</span></span>, ale
    przemilczmy to. Co dalej? Możemy myśleć o elementach <span class="inlinecode"><span class="id" title="var">FlattenType</span></span> jak
    o kodach prawdziwych typów, a skoro są to kody, to można też napisać
    funkcję dekodującą: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">decode</span> (<span class="id" title="var">t</span> : <span class="id" title="var">FlattenType</span>) : <span class="id" title="keyword">Type</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">Nat</span> =&gt; <span class="id" title="var">nat</span><br/>
| <span class="id" title="var">List</span> <span class="id" title="var">t'</span> =&gt; <span class="id" title="var">list</span> (<span class="id" title="var">decode</span> <span class="id" title="var">t'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">decode</span></span> każdemu kodowi przyporządkowuje odpowiadający mu typ. O
    kodach możemy myśleć jak o nazwach - <span class="inlinecode"><span class="id" title="var">Nat</span></span> to nazwa <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaś
    <span class="inlinecode"><span class="id" title="var">List</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> to nazwa typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">decode</span></span> <span class="inlinecode"><span class="id" title="var">t'</span>)</span>, np. <span class="inlinecode"><span class="id" title="var">List</span></span> <span class="inlinecode">(<span class="id" title="var">List</span></span> <span class="inlinecode"><span class="id" title="var">Nat</span>)</span>
    to nazwa typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>.

<div class="paragraph"> </div>

    Para <span class="inlinecode">(<span class="id" title="var">FlattenType</span>,</span> <span class="inlinecode"><span class="id" title="var">decode</span>)</span> jest przykładem uniwersum.

<div class="paragraph"> </div>

    Uniwersum to, najprościej pisząc, worek, który zawiera jakieś typy.
    Formalnie uniwersum składa się z typu kodów (czyli "nazw" typów) oraz
    funkcji dekodującej, która przyporządkowuje kodom prawdziwe typy.

<div class="paragraph"> </div>

    Programowanie generyczne to programowanie funkcji, które operują na
    kolekcjach typów o dowolnych kształtach, czyli na uniwersach właśnie.
    Generyczność od polimorfizmu różni się tym, że funkcja polimorficzna
    działa dla dowolnego typu, zaś generyczna - tylko dla typu o pasującym
    kształcie.

<div class="paragraph"> </div>

    Jak dokończyć implementację funkcji <span class="inlinecode"><span class="id" title="var">flatten</span></span>? Kluczowe jest zauważenie,
    że możemy zdefiniować <span class="inlinecode"><span class="id" title="var">flatten</span></span> przez rekursję strutkuralną po argumencie
    domyślnym typu <span class="inlinecode"><span class="id" title="var">FlattenType</span></span>. Ostatni problem to jak zrobić, żeby Coq sam
    zgadywał kod danego typu - dowiemy się tego w rozdziale o klasach.

<div class="paragraph"> </div>

    Co to wszystko ma wspólnego z uniwersami? Ano, jeżeli chcemy definiować
    bardzo zaawansowane funkcje generyczne, musimy mieć do dyspozycji bardzo
    potężne uniwersa i to właśnie je zapewnia nam indukcja-rekursja. Ponieważ
    w powyższym przykładzie generyczność nie była zbyt wyrafinowana, nie było
    potrzeby używania indukcji-rekursji, jednak uszy do góry: przykład nieco
    bardziej skomplikowanego uniwersum pojawi się jeszcze w tym rozdziale. 
<div class="paragraph"> </div>

<a id="lab737"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Nieco podchwytliwe zadanie: zdefiniuj uniwersum funkcji <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>, <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> i tak dalej, dowolnie zagnieżdżonych.

<div class="paragraph"> </div>

    Zagadka: czy potrzebna jest nam indukcja-rekursja? 
<div class="paragraph"> </div>

<a id="lab738"></a><h1 class="section">Indeksowana indukcja-rekursja</h1>

<div class="paragraph"> </div>

 Za siedmioma górami, za siedmioma lasami, za siedmioma rzekami, za
    siedmioma budkami telefonicznymi, nawet za indukcją-rekursją (choć
    tylko o kroczek) leży indeksowana indukcja-rekursja, czyli połączenie
    indukcji-rekursji oraz indeksowanych rodzin typów.

<div class="paragraph"> </div>

    Jako, że w porównaniu do zwykłej indukcji-rekursji nie ma tu za wiele
    innowacyjności, przejdźmy od razu do przykładu przydatnej techniki,
    którą nasza tytułowa bohaterka umożliwia, a zwie się on metodą
    induktywnej dziedziny.

<div class="paragraph"> </div>

    Pod tą nazwą kryje się sposób definiowania funkcji, pozwalający oddzielić
    samą definicję od dowodu jej terminacji. Jeżeli ten opis nic ci nie mówi,
    nie martw się: dotychczas definiowaliśmy tylko tak prymitywne funkcje, że
    tego typu fikołki nie były nam potrzebne.

<div class="paragraph"> </div>

    Metoda induktywnej dziedziny polega na tym, żeby zamiast funkcji
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, która nie jest strukturalnie rekurencyjna (na co Coq
    nie pozwala) napisać funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, gdzie
    <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest "predykatem dziedziny", który sprawia, że dziwna
    rekursja z oryginalnej definicji <span class="inlinecode"><span class="id" title="var">f</span></span> staje się rekursją strukturalną
    po dowodzie <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Żeby zdefiniować oryginalne <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wystarczy
    udowodnić, że każde <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> spełnia predykat dziedziny.

<div class="paragraph"> </div>

    Co to wszystko ma wspólnego z indeksowaną indukcją-rekursją? Już piszę.
    Otóż metoda ta nie wymaga w ogólności indukcji-rekursji - ta staje się
    potrzebna dopiero, gdy walczymy z bardzo złośliwymi funkcjami, czyli
    takimi, w których rekursja jest zagnieżdżona, tzn. robimy wywołanie
    rekurencyjne na wyniku poprzedniego wywołania rekurencyjnego.

<div class="paragraph"> </div>

    Predykat dziedziny dla takiej funkcji musi zawierać konstruktor w stylu
    "jeżeli wynik wywołania rekurencyjnego na x należy do dziedziny, to x też
    należy do dziedziny".To właśnie tu ujawnia się indukcja-rekursja: żeby
    zdefiniować predykat dziedziny, musimy odwołać się do funkcji (żeby móc
    powiedzieć coś o wyniku wywołania rekurencyjnego), a żeby zdefiniować
    funkcję, musimy mieć predykat dziedziny.

<div class="paragraph"> </div>

    Brzmi skomplikowanie? Jeżeli czegoś nie rozumiesz, to jesteś debi...
    a nie, czekaj. Jeżeli czegoś nie rozumiesz, to nie martw się: powyższy
    przykład miał na celu jedynie zilustrować jakieś praktyczne zastosowanie
    indeksowanej indukcji-rekursji. Do metody induktywnej dziedziny powrócimy
    w kolejnym rozdziale. Pokażemy, jak wyeliminować z niej indukcję-rekursję,
    tak żeby uzyskane za jej pomocą definicje można było odpalać w Coqu.
    Zobaczymy też, jakimi sposobami dowodzić, że każdy element dziedziny
    spełnia predykat dziedziny, co pozwoli nam odzyskać oryginalną definicję
    funkcji, a także dowiemy się, jak z "predykatu" o typie <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    zrobić prawdziwy predykat <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
<div class="paragraph"> </div>

<a id="lab739"></a><h1 class="section">Indukcja-indukcja-rekursja</h1>

<div class="paragraph"> </div>

 Ufff... przebrnęliśmy przez indukcję-indukcję i (indeksowaną)
    indukcję-rekursję. Czy mogą istnieć jeszcze potężniejsze i bardziej
    innowacyjne sposoby definiowania typów przez indukcję?

<div class="paragraph"> </div>

    Ależ oczywiście. Jest nim... uwaga uwaga, niespodzianka...
    indukcja-indukcja-rekursja, która jest nie tylko strasznym
    potfurem, ale też powinna dostać Oskara za najlepszą nazwę.

<div class="paragraph"> </div>

    Chodzi tu oczywiście o połączenie indukcji-indukcji i indukcji-rekursji:
    możemy jednocześnie zdefiniować jakiś typ <span class="inlinecode"><span class="id" title="var">A</span></span>, rodzinę typów <span class="inlinecode"><span class="id" title="var">B</span></span>
    indeksowaną przez <span class="inlinecode"><span class="id" title="var">A</span></span> oraz operujące na nich funkcje, do których
    konstruktory <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> mogą się odwoływać.

<div class="paragraph"> </div>

    Nie ma tu jakiejś wielkiej filozofii: wszystkiego, co powinieneś wiedzieć
    o indukcji-indukcji-rekursji, dowiedziałeś się już z dwóch poprzednich
    podrozdziałów. Nie muszę chyba dodawać, że ława oburzonych jest oburzona
    faktem, że Coq nie wspiera indukcji-indukcji-rekursji.

<div class="paragraph"> </div>

    Rodzi się jednak to samo super poważne pytanie co zawsze, czyli do czego
    można tego tałatajstwa użyć? Przez całkiem długi czas nie miałem pomysłu,
    ale okazuje się, że jest jedno takie zastosowanie i w sumie narzuca się
    ono samo.

<div class="paragraph"> </div>

    Przypomnij sobie metodę induktywno-rekurencyjnej dziedziny, czyli jedno
    ze sztandarowych zastosowań indeksowanej indukcji-rekursji. Zaczynamy od
    typu <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, na którym chcemy zdefiniować funkcję o niestandardowym
    kształcie rekursji. W tym celu definiujemy dziedzinę <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    wraz z funkcją <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span>,</span> <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Zauważmy jaki jest związek typu <span class="inlinecode"><span class="id" title="var">I</span></span> z funkcją <span class="inlinecode"><span class="id" title="var">f</span></span>: najpierw jest typ,
    potem funkcja. Co jednak, gdy musimy <span class="inlinecode"><span class="id" title="var">I</span></span> oraz <span class="inlinecode"><span class="id" title="var">f</span></span> zdefiniować razem za
    pomocą indukcji-rekursji? Wtedy <span class="inlinecode"><span class="id" title="var">f</span></span> może być zdefiniowane jedynie za
    pomocą rekursji strukturalnej po <span class="inlinecode"><span class="id" title="var">I</span></span>, co wyklucza rekursję o fikuśnym
    kształcie...

<div class="paragraph"> </div>

    I tu wchodzi indukcja-indukcja-rekursja, cała na biało. Możemy użyć
    jej w taki sposób, że definiujemy jednocześnie:
<ul class="doclist">
<li> typ <span class="inlinecode"><span class="id" title="var">I</span></span>, który odnosi się do funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>

</li>
<li> predykat dziedziny <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, który jest indeksowany przez <span class="inlinecode"><span class="id" title="var">I</span></span>

</li>
<li> funkcję <span class="inlinecode"><span class="id" title="var">f</span></span>, która zdefiniowana jest przez rekursję strukturalną po
      dowodzie należenia do dziedziny

</li>
</ul>

<div class="paragraph"> </div>

    Jak widać, typ zależy od funkcji, funkcja od predykatu, a predykat od
    typu i koło się zamyka.

<div class="paragraph"> </div>

    Następuje jednak skądinąd uzasadnione pytanie: czy faktycznie istnieje
    jakaś sytuacja, w której powyższy schemat działania jest tym słusznym?
    Odpowiedź póki co może być tylko jedna: nie wiem, ale się domyślam. 
<div class="paragraph"> </div>

<a id="lab740"></a><h1 class="section">Promocja 2 w 1 czyli paradoksy Russella i Girarda</h1>

<div class="paragraph"> </div>

 <i>Istnieje teoria, że jeśli kiedyś ktoś się dowie, dlaczego powstało i
    czemu służy uniwersum, to zniknie ono i zostanie zastąpione czymś
    znacznie dziwaczniejszym i jeszcze bardziej pozbawionym sensu</i>. 
<div class="paragraph"> </div>

 <i>Istnieje także teoria, że dawno już tak się stało</i>. 
<div class="paragraph"> </div>

 Douglas Adams, <i>Restauracja na końcu wszechświata</i> 
<div class="paragraph"> </div>

 W poprzednich podrozdziałach poznaliśmy twierdzenie Cantora oraz
    nauczyliśmy się używać go jako młota na negatywne typy induktywne.

<div class="paragraph"> </div>

    W tym podrozdziale zapoznamy się z dwoma paradoksami (a precyzyjniej
    pisząc, z dwoma wersjami tego samego paradoksu), które okażą się być
    ściśle powiązane z twierdzeniem Cantora, a które będą służyć nam gdy
    staniemy w szranki z negatwynymi typami induktywno-rekurencyjnymi
    (czyli tymi, które definiuje się przez indukcję-rekursję). O tak: w
    tym podrozdziale, niczym Thanos, staniemy do walki przeciw uniwersum! 
<div class="paragraph"> </div>

<a id="lab741"></a><h2 class="section">Paradoks Russella</h2>

<div class="paragraph"> </div>

 Zacznijmy od paradoksu Russella. Jest to bardzo stary paradoks, odkryty
    w roku 1901 przez... zgadnij kogo... gdy ów człek szukał dziury w całym
    w naiwnej teorii zbiorów (która to teoria, dzięki temu właśnie odkryciu,
    jest już od bardzo dawna dość mocno martwa).

<div class="paragraph"> </div>

    Sformułowanie paradoksu brzmi następująco: niech V będzie zbiorem
    wszystkich zbiorów, które nie należą same do siebie. Pytanie: czy
    V należy do V?

<div class="paragraph"> </div>

    Gdzie tu paradoks? Otóż jeżeli V należy do V, to na mocy definicji V,
    V nie należy do V. Jeżeli zaś V nie należy do V, to na mocy definicji V,
    V należy do V. Nie trzeba chyba dodawać, że jednoczesne należenie i
    nienależenie prowadzi do sprzeczności.

<div class="paragraph"> </div>

    Na czym tak naprawdę polega paradoks? Jakiś mądry (czyli przemądrzały)
    filozof mógłby rzec, że na nadużyciu pojęcia zbioru... albo czymś
    równie absurdalnym. Otóż nie! Paradoks Russella polega na tym samym,
    co cała masa innych paradoksów, czyli na autoreferencji.

<div class="paragraph"> </div>

    Z autoreferencją spotkaliśmy się już co najmniej raz, w rozdziale
    pierwszym. Przypomnij sobie, że golibroda goli tych i tylko tych,
    którzy sami siebie nie golą. Czy golibroda goli sam siebie? Takie
    postawienie sprawy daje paradoks. Podobnie z Russellem: V zawiera
    te i tylko te zbiory, które nie zawierają same siebie. Czy V zawiera
    V? Wot, paradoks. Żeby lepiej wczuć się w ten klimat, czas na więcej
    ćwiczeń. 
<div class="paragraph"> </div>

<a id="lab742"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 To genialne ćwiczenie wymyśliłem dzięki zabłądzeniu na esperanckiej
    Wikipedii (ha! nikt nie spodziewał się esperanckiej Wikipedii w
    ćwiczeniu dotyczącym paradoksu Russella). Ćwiczenie brzmi tak:

<div class="paragraph"> </div>

    W Wikipedii niektóre artykuły są listami (nie, nie w sensie typu
    induktywnego :)), np. lista krajów według PKB per capita. Pytanie:
    czy można stworzyć w Wikipedii listę wszystkich list? Czy na liście
    wszystkich list ona sama jest wymieniona? Czy można w Wikipedii
    stworzyć listę wszystkich list, które nie wymieniają same siebie? 
<div class="paragraph"> </div>

<a id="lab743"></a><h2 class="section">Paradoks Girarda</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Typonomikon</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">D1z</span>.<br/>

<br/>
</div>

<div class="doc">
Dobra, wystarczy już tych paradoksów... a nie, czekaj. Przecież został
    nam do omówienia jeszcze paradoks Girarda. Jednak poznawszy już tajniki
    autoreferencji, powinno pójść jak z płatka.

<div class="paragraph"> </div>

    Paradoks Girarda to paradoks, który może zaistnieć w wielu systemach
    formalnych, takich jak teorie typów, języki programowania, logiki i
    inne takie. Źródłem całego zła jest zazwyczaj stwierdzenie w stylu
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
O nie! Czyżbyśmy właśnie zostali zaatakowani przez paradoks Girarda?
    W tym miejscu należy przypomnieć (albo obwieścić - niestety nie pamiętam,
    czy już o tym wspominałem), że <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest w Coqu jedynie synonimem dla
    czegoś w stylu <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">i</span></span> jest "poziomem" sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, zaś
    każde <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span> żyje tak naprawdę w jakimś <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">j</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">j</span></span> jest
    większe od <span class="inlinecode"><span class="id" title="var">i</span></span> - typy niższego poziomu żyją w typach wyższego poziomu.
    Będziesz mógł ów fakt ujrzeć na własne oczy, gdy w CoqIDE zaznaczysz
    opcję <span class="inlinecode"><span class="id" title="var">View</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode"><span class="id" title="var">Display</span></span> <span class="inlinecode"><span class="id" title="var">universe</span></span> <span class="inlinecode"><span class="id" title="var">levels</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type@{Top.590}&nbsp;:&nbsp;Type@{Top.590+1}&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, jest mniej więcej tak jak napisałem wyżej. Nie przejmuj się
    tym tajemniczym <span class="inlinecode"><span class="id" title="var">Top</span></span> - to tylko nic nieznaczący bibelocik. W twoim
    przypadku również poziom uniwersum może być inny niż <span class="inlinecode">590</span>. Co więcej,
    poziom ten będzie się zwiększał wraz z każdym odpaleniem komendy <span class="inlinecode"><span class="id" title="keyword">Check</span></span>
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> (czyżbyś pomyślał właśnie o doliczeniu w ten sposób do zyliona?).

<div class="paragraph"> </div>

    Skoro już wiemy, że NIE zostaliśmy zaatakowani przez paradoks Girarda,
    to w czym problem z tym całym <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>? Jakiś przemądrzały (czyli
    mądry) adept informatyki teoretycznej mógłby odpowiedzieć, że to zależy
    od konkretnego systemu formalnego albo coś w tym stylu. Otóż niet! Jak
    zawsze, chodzi oczywiście o autoreferencję.

<div class="paragraph"> </div>

    Gdyby ktoś był zainteresowany, to najlepsze dotychczas sformułowanie
    paradoksu znalazłem (zupełnie przez przypadek, wcale nie szukając) w
    pracy "An intuitionistic theory of types" Martina-Löfa (swoją drogą,
    ten koleś wymyślił podstawy dużej części wszystkiego, czym się tutaj
    zajmujemy). Można ją przeczytać tu (paradoks Girarda jest pod koniec
    pierwszej sekcji):
    archive-pml.github.io/martin-lof/pdfs/An-Intuitionistic-Theory-of-Types-1972.pdf

<div class="paragraph"> </div>

    Nasze sformułowanie paradoksu będzie podobne do tego z powyższej pracy
    (co jest w sumie ciekawe, bo wymyśliłem je samodzielnie i to przez
    przypadek), ale dowód sprzeczności będzie inny - na szczęście dużo
    prostszy (albo i nie...).

<div class="paragraph"> </div>

    Dobra, koniec tego ględzenia. Czas na konkrety. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Fail&nbsp;Inductive&nbsp;U&nbsp;:&nbsp;Type&nbsp;:=<br/>
|&nbsp;Pi&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
|&nbsp;UU&nbsp;:&nbsp;U<br/>
<br/>
with&nbsp;El&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;Type&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
|&nbsp;Pi&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;forall&nbsp;x&nbsp;:&nbsp;El&nbsp;A,&nbsp;B&nbsp;x<br/>
|&nbsp;UU&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa induktywno-rekurencyjna definicja typu <span class="inlinecode"><span class="id" title="var">U</span></span> (i interpretującej
    go funkcji <span class="inlinecode"><span class="id" title="var">El</span></span>), którą Coq rzecz jasna odrzuca (uczcijmy ławę oburzonych
    minutą oburzenia) to definicja pewnego uniwersum.

<div class="paragraph"> </div>

    W tym miejscu wypadałoby wytłumaczyć, czym są uniwersa. Otóż odpowiedź
    jest dość prosta: uniwersum składa się z typu <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> oraz funkcji
    <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Intuicja w tym wszystkim jest taka, że elementami
    typu <span class="inlinecode"><span class="id" title="var">U</span></span> są nazwy typów (czyli bytów sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), zaś fukncja <span class="inlinecode"><span class="id" title="var">El</span></span>
    zwraca typ, którego nazwę dostanie.

<div class="paragraph"> </div>

    Choć z definicji widać to na pierwszy rzut oka, to zaskakujący może
    wydać ci się fakt, że w zasadzie każdy typ można zinterpretować jako
    uniwersum i to zazwyczaj na bardzo wiele różnych sposobów (tyle ile
    różnych interpretacji <span class="inlinecode"><span class="id" title="var">El</span></span> jesteśmy w stanie wymyślić). Najlepiej
    będzie, jeżeli przemyślisz to wszystko w ramach ćwiczenia. 
<div class="paragraph"> </div>

<a id="lab744"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Ćwiczenie będzie konceptualne, a składa się na nie kilka łamigłówek:
<ul class="doclist">
<li> zinterpretuj <span class="inlinecode"><span class="id" title="var">False</span></span> jako uniwersum

</li>
<li> zinterpretuj <span class="inlinecode"><span class="id" title="var">unit</span></span> jako uniwersum (ile jest możliwych sposobów?)

</li>
<li> czy istnieje uniwersum, które zawiera nazwę samego siebie? Uwaga:
      to nie jest tak proste, jak może się wydawać na pierwszy rzut oka.

</li>
<li> wymyśl ideologicznie słuszną interpretację typu <span class="inlinecode"><span class="id" title="var">nat</span></span> jako uniwersum
      (tak, jest taka). Następnie wymyśl jakąś głupią interpretację <span class="inlinecode"><span class="id" title="var">nat</span></span>
      jako uniwersum. Dlaczego ta interpretacja jest głupia?

</li>
<li> zdefiniuj uniwersum, którego elementami są nazwy typów funkcji z
      n-krotek liczb naturalnych w liczby naturalne. Uwaga: rozwiązanie
      jest bardzo eleganckie i możesz się go nie spodziewać.

</li>
<li> czy istnieje uniwersum, którego interpretacja jest surjekcją? Czy
      da się w Coqu udowodnić, że tak jest albo nie jest? Uwaga: tak
      bardzo podchwytliwe, że aż sam się złapałem. 

</li>
</ul>
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Skoro wiemy już, czym są uniwersa, przyjrzyjmy się temu, które właśnie
    zdefiniowaliśmy. Żebyś nie musiał w rozpaczy przewijać do góry, tak
    wygląda aksjomatyczne kodowanie tego uniwersum: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">PoorUniverse</span>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">U</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">El</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">Pi</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>), <span class="id" title="var">U</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">UU</span> : <span class="id" title="var">U</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">El_Pi</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">El</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) = <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span>), <span class="id" title="var">El</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">El_UU</span> : <span class="id" title="var">El</span> <span class="id" title="var">UU</span> = <span class="id" title="var">U</span>)<br/>
<br/>
&nbsp;&nbsp;(<span class="id" title="var">ind</span> : <span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PPi</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">A</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">PUU</span> : <span class="id" title="var">P</span> <span class="id" title="var">UU</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span>, <span class="id" title="var">P</span> <span class="id" title="var">u</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">U</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">PPi</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> <span class="id" title="var">A</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">El</span> <span class="id" title="var">A</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">B</span> <span class="id" title="var">x</span>))) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> <span class="id" title="var">UU</span> = <span class="id" title="var">PUU</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">U</span></span> to typ, którego elementami są nazwy typów, zaś <span class="inlinecode"><span class="id" title="var">El</span></span> jest jego
    interpretacją. Nazwy możemy tworzyć tylko na dwa sposoby: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    jest nazwą typu, zaś <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> jest rodziną nazw typów indeksowaną
    przez elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>, to <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest nazwą typu
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span>. Drugim konstruktorem jest <span class="inlinecode"><span class="id" title="var">UU</span></span>, które
    oznacza nazwę samego uniwersum, tzn. <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>.

<div class="paragraph"> </div>

    Reguła indukcji jest dość prosta: jeżeli <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest rodziną
    typów (tych prawdziwych) indeksowaną przez <span class="inlinecode"><span class="id" title="var">U</span></span> (czyli nazwy typów), to
    żeby zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> musimy mieć dwie rzeczy:
    po pierwsze, musimy pokazać, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> zachodzi, gdy zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> dla każdego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Po drugie, musi zachodzić <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>.

<div class="paragraph"> </div>

    Mimo, że uniwersum wydaje się biedne, jest ono śmiertelnie sprzeczne,
    gdyż zawiera nazwę samego siebie. Jeżeli rozwiązałeś (poprawnie, a nie
    na odwal!) ostatnie ćwiczenie, to powinieneś wiedzieć, że niektóre
    uniwersa mogą zawierać nazwy samego siebie i wcale to a wcale nie daje
    to żadnych problemów.

<div class="paragraph"> </div>

    Dlaczego więc w tym przypadku jest inaczej? Skoro <span class="inlinecode"><span class="id" title="var">UU</span></span> nie jest złe samo
    w sobie, to problem musi leżeć w <span class="inlinecode"><span class="id" title="var">Pi</span></span>, bo niby gdzie indziej? Zobaczmy
    więc, gdzie kryje się sprzeczność. W tym celu posłużymy się twierdzeniem
    Cantora: najpierw zdefiniujemy surjekcję <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span>)</span>, a potem pokażemy,
    za pomocą metody przekątniowej, że taka surjekcja nie może istnieć. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Definition&nbsp;extract&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
|&nbsp;Pi&nbsp;UU&nbsp;B&nbsp;=&gt;&nbsp;B<br/>
|&nbsp;_&nbsp;=&gt;&nbsp;fun&nbsp;u&nbsp;:&nbsp;U&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Jeżeli dostajemy <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">A</span></span> to <span class="inlinecode"><span class="id" title="var">UU</span></span>, to wtedy <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    tak naprawdę jest typu <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> (bo <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>). W innych przypadkach
    wystarczy po prostu zwrócić funkcję identycznościową. Niestety Coq nie
    wspiera indukcji-rekursji (ława oburzonych), więc funkcję <span class="inlinecode"><span class="id" title="var">extract</span></span> musimy
    zdefiniować ręcznie: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">extract</span> : <span class="id" title="var">U</span> -&gt; (<span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. <span class="id" title="var">revert</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> : <span class="id" title="var">U</span> =&gt; (<span class="id" title="var">El</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">U</span>) -&gt; (<span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">El_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span> =&gt; <span class="id" title="var">u</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższa definicja za pomocą taktyk działa dokładnie tak samo jak
    nieformalna definicja <span class="inlinecode"><span class="id" title="var">extract</span></span> za pomocą dopasowania do wzorca. Jedyna
    różnica jest taka, że <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> nie jest definicyjnie równe <span class="inlinecode"><span class="id" title="var">U</span></span>, lecz
    są one jedynie zdaniowo równe na mocy aksjomatu <span class="inlinecode"><span class="id" title="var">El_UU</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">U</span></span>.
    Musimy więc przepisać go w <span class="inlinecode"><span class="id" title="var">B</span></span>, żeby typy się zgadzały.

<div class="paragraph"> </div>

    Zanim będziemy mogli pokazać, że <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, czeka nas kilka
    niemiłych detali technicznych (gdyby <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> i <span class="inlinecode"><span class="id" title="var">U</span></span> były definicyjnie
    równe, wszystkie te problemy by zniknęły). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">eq_rect</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">eq_rect_r</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;y&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">eq_rect</span></span> oraz <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> to groźnie wyglądające lematy, ale sprawa tak
    na prawdę jest dość prosta: to one wykonują całą pracę za każdym razem,
    kiedy używasz taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. Jeżeli cel jest postaci <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> i użyjemy
    na nim <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, to <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> zamienia cel na
    <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">cel</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, które jest już typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> działa
    podobnie, ale tym razem równość jest postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> (czyli obrócona).

<div class="paragraph"> </div>

    Ponieważ w definicji <span class="inlinecode"><span class="id" title="var">extract</span></span> używaliśmy <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>'a, to przy dowodzeniu,
    że <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, będziemy musieli zmierzyć się właśnie z
    <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> i <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span>. Stąd poniższy lemat, który mówi mniej więcej,
    że jeżeli przepiszemy z prawa na lewo, a potem z lewa na prawo, to tak,
    jakby nic się nie stało. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">right_to_left_to_right</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">y</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_rect</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> (@<span class="id" title="var">eq_rect_r</span> <span class="id" title="var">A</span> <span class="id" title="var">y</span> <span class="id" title="var">P</span> <span class="id" title="var">u</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>) <span class="id" title="var">y</span> <span class="id" title="var">p</span> = <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód jest banalny. Ponieważ <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> i <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> są zdefiniowane
    przez dopasowanie do wzorca <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, to wystarczy <span class="inlinecode"><span class="id" title="var">p</span></span> potraktować
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>em, a dalej wszystko już ładnie się oblicza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">surjective_extract</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>, <span class="id" title="var">extract</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">extract</span> [<span class="id" title="var">extract_Pi</span> <span class="id" title="var">extract_UU</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">extract'</span> [<span class="id" title="var">extract'_Pi</span> <span class="id" title="var">extract'_UU</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">f'</span> := <span class="id" title="var">eq_rect_r</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span> =&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="var">U</span>) <span class="id" title="var">f</span> <span class="id" title="var">El_UU</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">UU</span> <span class="id" title="var">f'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">f'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">extract_Pi</span>, <span class="id" title="var">extract'_UU</span>, <span class="id" title="var">right_to_left_to_right</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dlaczego <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją? Intuicyjnie pisząc, każdą funkcję
    <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> możemy włożyć do konstruktora <span class="inlinecode"><span class="id" title="var">Pi</span></span> jako jego drugi argument,
    jeżeli tylko zamienimy pierwsze <span class="inlinecode"><span class="id" title="var">U</span></span> na <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>. Skoro każdą możemy
    tam włożyć, to każdą możemy wyjąć. Ot i cały sekret.

<div class="paragraph"> </div>

    Technicznie dowód realizujemy tak: odwijamy definicje i wprowadzamy do
    kontekstu funkcję <span class="inlinecode"><span class="id" title="var">f</span></span>. Następnie rozbijamy <span class="inlinecode"><span class="id" title="var">ind</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> pochodzące z definicji
    <span class="inlinecode"><span class="id" title="var">extract</span></span>, rozkładając w ten sposób definicję <span class="inlinecode"><span class="id" title="var">extract</span></span> na właściwe
    <span class="inlinecode"><span class="id" title="var">extract</span></span> (sama funkcja), <span class="inlinecode"><span class="id" title="var">extract'</span></span> (wewnętrzna funkcja pomocnicza) oraz
    równania dla <span class="inlinecode"><span class="id" title="var">extract</span></span> i <span class="inlinecode"><span class="id" title="var">extract'</span></span> dla poszczególnych przypadków.

<div class="paragraph"> </div>

    Następnie musimy znaleźć takie <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>, że <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span>. Robimy to, co
    zasugerowałem wyżej, czyli w <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span> pierwsze <span class="inlinecode"><span class="id" title="var">U</span></span> zamieniamy na
    <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span>, uzyskując w ten sposób <span class="inlinecode"><span class="id" title="var">f'</span></span>. Temu właśnie służy użycie
    <span class="inlinecode"><span class="id" title="var">eq_rect_r</span></span> (nie używamy <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, bo potrzeba nam większej precyzji).

<div class="paragraph"> </div>

    Wobec tego szukanym przez nas elementem <span class="inlinecode"><span class="id" title="var">U</span></span>, któremu <span class="inlinecode"><span class="id" title="var">extract</span></span> przyporządkuje
    <span class="inlinecode"><span class="id" title="var">f</span></span>, jest <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode"><span class="id" title="var">f'</span></span>. Możemy w tym miejscu odwinąć definicję <span class="inlinecode"><span class="id" title="var">f'</span></span>. Gdyby
    Coq wspierał indukcję-rekursję, to w tym miejscu wystarczyłoby użyć tylko
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> - <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode"><span class="id" title="var">f'</span>)</span> obliczyłoby się do <span class="inlinecode"><span class="id" title="var">f</span></span> na mocy definicji
    <span class="inlinecode"><span class="id" title="var">extract</span></span> oraz dzięki temu, że <span class="inlinecode"><span class="id" title="var">El</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> obliczyłoby się do <span class="inlinecode"><span class="id" title="var">U</span></span>. Niestety Coq
    nie wspiera indukcji rekursji (ława oburzonych), więc musimy wszystkie
    te trzy kroki obliczeń wykonać ręcznie za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    Ufff, udało się! Jeżeli przeraża cię ten dowód - nie martw się. Chodzi
    w nim o to samo, o co chodziło w poprzednich dowodach bycia surjekcją.
    Ten jest po prostu trochę bardziej skomplikowany, bo indukcja-rekursja
    jest nieco bardziej skomplikowana do użycia w Coqu niż prymitywniejsze
    formy indukcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">modify</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="var">U</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">UU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">UU</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">UU</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz czas udowodnić, że <span class="inlinecode"><span class="id" title="var">extract</span></span> nie jest surjekcją. Zrobimy to metodą
    przekątniową, a w tym celu potrzebować będziemy funkcji <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>, która
    dla każdego argumentu zwraca coś, co jest od niego różne.

<div class="paragraph"> </div>

    Na szczęście sprawa jest prosta: jeżeli argumentem jest <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, to
    zwracamy <span class="inlinecode"><span class="id" title="var">UU</span></span>, zaś jeżeli <span class="inlinecode"><span class="id" title="var">UU</span></span>, to zwracamy <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">UU</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">UU</span>)</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">discern</span> : <span class="id" title="var">U</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">true</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Przydałaby się też funkcja, która pozwoli nam rozróżnić konstruktory
    typu <span class="inlinecode"><span class="id" title="var">U</span></span>. Normalnie użylibyśmy do tego taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, ale
    używamy kodowania aksjomatycznego, więc <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> nie zadziała i
    musimy ręcznie zaimplementować sobie coś w jej stylu.

<div class="paragraph"> </div>

    Nasza funkcja dla <span class="inlinecode"><span class="id" title="var">Pi</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span>, a dla <span class="inlinecode"><span class="id" title="var">UU</span></span> daje <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">modify_neq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span>, <span class="id" title="var">modify</span> <span class="id" title="var">u</span> &lt;&gt; <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">H1</span> <span class="id" title="var">H2</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">discern</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">modify</span>, <span class="id" title="var">discern</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">d</span> [<span class="id" title="var">d_Pi</span> <span class="id" title="var">d_UU</span>]],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">ch</span> [<span class="id" title="var">ch_Pi</span> <span class="id" title="var">ch_UU</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">d_Pi</span>, <span class="id" title="var">ch_Pi</span>, <span class="id" title="var">d_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">discern</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">modify</span>, <span class="id" title="var">discern</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">d</span> [<span class="id" title="var">d_Pi</span> <span class="id" title="var">d_UU</span>]],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ind</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">ch</span> [<span class="id" title="var">ch_Pi</span> <span class="id" title="var">ch_UU</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">ch_UU</span>, <span class="id" title="var">d_Pi</span>, <span class="id" title="var">d_UU</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">eq</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Wypadałoby też pokazać, ża nasza funkcja działa tak, jak sobie tego
    życzymy. Dowód jest bardzo prosty, ale aksjomatyczne kodowanie znacznie
    go zaciemnia.

<div class="paragraph"> </div>

    Zaczynamy od indukcji po <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>. W pierwszym przypadku mamy hipotezę
    <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, a skoro tak, to po zaaplikowaniu
    <span class="inlinecode"><span class="id" title="var">discern</span></span> musi być także <span class="inlinecode"><span class="id" title="var">discern</span></span> <span class="inlinecode">(<span class="id" title="var">modify</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">discern</span></span> <span class="inlinecode">(<span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>)</span>.

<div class="paragraph"> </div>

    Następnie rozkładamy definicje <span class="inlinecode"><span class="id" title="var">modify</span></span> i <span class="inlinecode"><span class="id" title="var">discern</span></span> na atomy (<span class="inlinecode"><span class="id" title="var">modify</span></span>
    nazywa się teraz <span class="inlinecode"><span class="id" title="var">ch</span></span>, a <span class="inlinecode"><span class="id" title="var">discern</span></span> nazywa się <span class="inlinecode"><span class="id" title="var">d</span></span>). Przepisujemy
    odpowiednie równania w hipotezie <span class="inlinecode"><span class="id" title="var">eq</span></span>, dzięki czemu uzyskujemy
    <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, co jest sprzeczne. Drugi przypadek jest analogiczny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">extract_not_sur</span> :<br/>
&nbsp;&nbsp;~ <span class="id" title="var">surjective</span> <span class="id" title="var">extract</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">surjective</span>. <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">H</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> : <span class="id" title="var">U</span> =&gt; <span class="id" title="var">modify</span> (<span class="id" title="var">extract</span> <span class="id" title="var">u</span> <span class="id" title="var">u</span>))) <span class="id" title="keyword">as</span> [<span class="id" title="var">u</span> <span class="id" title="var">eq</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="tactic">f_equal</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">u</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">modify_neq</span> (<span class="id" title="var">extract</span> <span class="id" title="var">u</span> <span class="id" title="var">u</span>)). <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Teraz możemy już pokazać, że <span class="inlinecode"><span class="id" title="var">extract</span></span> nie jest surjekcją. W tym celu
    wyobraźmy sobie <span class="inlinecode"><span class="id" title="var">extract</span></span> jako kwadratową tabelkę, której wiersze i
    kolumny są indeksowane przez <span class="inlinecode"><span class="id" title="var">U</span></span>. Tworzymy nową funkcję <span class="inlinecode"><span class="id" title="var">U</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">U</span></span>
    biorąc elementy z przekątnej i modyfikując je za pomocą <span class="inlinecode"><span class="id" title="var">modify</span></span>.

<div class="paragraph"> </div>

    Skoro <span class="inlinecode"><span class="id" title="var">extract</span></span> jest surjekcją, to ta nowa funkcja musi być postaci
    <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> dla jakiegoś <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">U</span></span>. Aplikując obie strony jeszcze raz
    do <span class="inlinecode"><span class="id" title="var">u</span></span> dostajemy równanie <span class="inlinecode"><span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">modify</span></span> <span class="inlinecode">(<span class="id" title="var">extract</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">u</span>)</span>, które
    jest sprzeczne na mocy lematu <span class="inlinecode"><span class="id" title="var">modify_neq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">U_illegal</span> : <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">extract_not_sur</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">surjective_extract</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Ponieważ <span class="inlinecode"><span class="id" title="var">extract</span></span> jednocześnie jest i nie jest surjekcją, nastepuje nagły
    atak sprzeczności. Definicja uniwersum <span class="inlinecode"><span class="id" title="var">U</span></span> przez indukcję-rekursję jest
    nielegalna. Tak właśnie prezentuje się paradoks Girarda w Coqowym wydaniu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PoorUniverse</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab745"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Tak naprawdę, to w tym podrozdziale byliśmy co najwyżej bieda-Thanosem,
    gdyż uniwersum, z którym się ścieraliśmy, samo było biedne. W niniejszym
    ćwiczeniu zmierzysz się z uniwersum, które zawiera też nazwy typu pustego,
    typu <span class="inlinecode"><span class="id" title="var">unit</span></span> i liczb naturalnych, nazwy produktów, sum i funkcji, a także
    sum zależnych.

<div class="paragraph"> </div>

    Mówiąc wprost: zakoduj aksjomatycznie poniższą definicję uniwersum <span class="inlinecode"><span class="id" title="var">U</span></span>,
    a następnie udowodnij, że jest ona nielegalna. Nie powinno to być
    trudne - metoda jest podobna jak w przypadku biednego uniwersum. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NonPoorUniverse</span>.<br/>

<br/>
<span class="comment">(*<br/>
Fail&nbsp;Inductive&nbsp;U&nbsp;:&nbsp;Type&nbsp;:=<br/>
|&nbsp;Empty&nbsp;:&nbsp;U<br/>
|&nbsp;Unit&nbsp;:&nbsp;U<br/>
|&nbsp;Nat&nbsp;:&nbsp;U<br/>
|&nbsp;Prod&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
|&nbsp;Sum&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
|&nbsp;Arr&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U<br/>
|&nbsp;Pi&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
|&nbsp;Sigma:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;U)&nbsp;(B&nbsp;:&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;U),&nbsp;U<br/>
|&nbsp;UU&nbsp;:&nbsp;U<br/>
<br/>
with&nbsp;El&nbsp;(u&nbsp;:&nbsp;U)&nbsp;:&nbsp;Type&nbsp;:=<br/>
match&nbsp;u&nbsp;with<br/>
|&nbsp;Empty&nbsp;=&gt;&nbsp;Empty_set<br/>
|&nbsp;Unit&nbsp;=&gt;&nbsp;unit<br/>
|&nbsp;Nat&nbsp;=&gt;&nbsp;nat<br/>
|&nbsp;Prod&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;*&nbsp;El&nbsp;B<br/>
|&nbsp;Sum&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;+&nbsp;El&nbsp;B<br/>
|&nbsp;Arr&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;El&nbsp;A&nbsp;-&gt;&nbsp;El&nbsp;B<br/>
|&nbsp;Pi&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;forall&nbsp;x&nbsp;:&nbsp;El&nbsp;A,&nbsp;B&nbsp;x<br/>
|&nbsp;Sigma&nbsp;A&nbsp;B&nbsp;=&gt;&nbsp;{x&nbsp;:&nbsp;El&nbsp;A&nbsp;&amp;&nbsp;El&nbsp;(B&nbsp;x)}<br/>
|&nbsp;UU&nbsp;=&gt;&nbsp;U<br/>
end.<br/>
*)</span><br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">U_illegal</span> : <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NonPoorUniverse</span>.<br/>
</div>
