<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
</head>
<h1 class="libtitle">I2: Spis przydatnych taktyk</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 Stare powiedzenie głosi: nie wymyślaj koła na nowo. Aby uczynić zadość
    duchom przodków, którzy je wymyślili (zarówno koło, jak i powiedzenie),
    w niniejszym rozdziale zapoznamy się z różnymi przydatnymi taktykami,
    które prędzej czy później i tak sami byśmy wymyślili, gdyby zaszła taka
    potrzeba.

<div class="paragraph"> </div>

    Aby jednak nie popaść w inny grzech i nie posługiwać się czarami, których
    nie rozumiemy, część z poniżej omówionych taktyk zaimplementujemy jako
    ćwiczenie.

<div class="paragraph"> </div>

    Omówimy kolejno:
<ul class="doclist">
<li> taktykę <span class="inlinecode"><span class="id" title="tactic">refine</span></span>

</li>
<li> drobne taktyki służące głównie do kontrolowania tego, co dzieje się
      w kontekście

</li>
<li> "średnie" taktyki, wcielające w życie pewien konkretny sposób
      rozumowania

</li>
<li> taktyki służące do rozumowania na temat relacji równoważności

</li>
<li> taktyki służące do przeprowadzania obliczeń

</li>
<li> procedury decyzyjne

</li>
<li> ogólne taktyki służące do automatyzacji 
</li>
</ul>

<div class="paragraph"> </div>

 Uwaga: przykłady użycia taktyk, których reimplementacja będzie
    ćwiczeniem, zostały połączone z testami w ćwiczeniach żeby nie pisać dwa
    razy tego samego. 
<div class="paragraph"> </div>

<a id="lab721"></a><h1 class="section"><span class="inlinecode"><span class="id" title="tactic">refine</span></span> — matka wszystkich taktyk</h1>

<div class="paragraph"> </div>

 Fama głosi, że w zamierzchłych czasach, gdy nie było jeszcze taktyk,
    a światem Coqa rządził Chaos (objawiający się dowodzeniem przez ręczne
    wpisywanie termów), jeden z Coqowych bogów imieniem He-fait-le-stos, w
    przebłysku kreatywnego geniuszu wymyślił dedukcję naturalną i stworzył
    pierwszą taktykę, której nadał imię <span class="inlinecode"><span class="id" title="tactic">refine</span></span>. Pomysł przyjał się i od
    tej pory Coqowi bogowie poczęli używać jej do tworzenia coraz to innych
    taktyk. Tak <span class="inlinecode"><span class="id" title="tactic">refine</span></span> stała się matką wszystkich taktyk.

<div class="paragraph"> </div>

    Oczywiście legenda ta jest nieprawdziwa — deduckcję naturalną wymyślił
    Gerhard Gentzen, a podstawowe taktyki są zaimplementowane w Ocamlu. Nie
    umniejsza to jednak mocy taktyki <span class="inlinecode"><span class="id" title="tactic">refine</span></span>. Jej działanie podobne jest
    do taktyki <span class="inlinecode"><span class="id" title="tactic">exact</span></span>, z tym że term będący jej argumentem może też zawierać
    dziury <span class="inlinecode"><span class="id" title="var">_</span></span>. Jeżeli naszym celem jest <span class="inlinecode"><span class="id" title="var">G</span></span>, to taktyka <span class="inlinecode"><span class="id" title="tactic">refine</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> rozwiązuje
    cel, jeżeli <span class="inlinecode"><span class="id" title="var">g</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">G</span></span>, i generuje taką ilość podcelów, ile
    <span class="inlinecode"><span class="id" title="var">g</span></span> zawiera dziur, albo zawodzi, jeżeli <span class="inlinecode"><span class="id" title="var">g</span></span> nie jest typu <span class="inlinecode"><span class="id" title="var">G</span></span>.

<div class="paragraph"> </div>

    Zobaczmy działanie taktyki <span class="inlinecode"><span class="id" title="tactic">refine</span></span> na przykładach. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">refine_0</span> : 42 = 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W powyższym przykładzie używamy <span class="inlinecode"><span class="id" title="tactic">refine</span></span> tak jak użylibyśmy <span class="inlinecode"><span class="id" title="tactic">exact</span></span>a.
    <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> jest typu <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>, gdyż Coq domyśla się, że tak naprawdę
    chodzi nam o <span class="inlinecode">@<span class="id" title="var">eq_refl</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">42</span>. Ponieważ <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> zawiera 0 dziur,
    <span class="inlinecode"><span class="id" title="tactic">refine</span></span> <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> rozwiązuje cel i nie generuje podcelów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">refine_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">Q</span> /\ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span> =&gt; <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">H</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span> | <span class="id" title="var">conj</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> =&gt; <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">p</span> <span class="id" title="var">q</span>]. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W tym przykładzie chcemy pokazać przemienność konunkcji. Ponieważ nasz
    cel jest kwantyfikacją uniwersalną, jego dowodem musi być jakaś funkcja
    zależna. Funkcję tę konstruujemy taktyką <span class="inlinecode"><span class="id" title="tactic">refine</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">_</span>)</span>.
    Nie podajemy jednak ciała funkcji, zastępując je dzurą <span class="inlinecode"><span class="id" title="var">_</span></span>, bo chcemy
    podać je później. W związku z tym nasz obecny cel zostaje rozwiązany, a
    w zamian dostajemy nowy cel postaci <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, gdyż takiego
    typu jest ciało naszej funkcji. To jednak nie wszystko: w kontekście
    pojawiają się <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Wynika to z tego, że <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> mogą zostać
    użyte w definicji ciała naszej funkcji.

<div class="paragraph"> </div>

    Jako, że naszym celem jest implikacja, jej dowodem musi być funkcja.
    Taktyka <span class="inlinecode"><span class="id" title="tactic">refine</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">conj</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span>)</span> pozwala
    nam tę funkcję skonstruować. Ciałem naszej funkcji jest dopasowanie
    zawierające dziurę. Wypełnienie jej będzie naszym kolejnym celem. Przy
    jego rozwiązywaniu będziemy mogli skorzystać z <span class="inlinecode"><span class="id" title="var">H</span></span>, <span class="inlinecode"><span class="id" title="var">p</span></span> i <span class="inlinecode"><span class="id" title="var">q</span></span>. Pierwsza
    z tych hipotez pochodzi o wiązania <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>, zaś <span class="inlinecode"><span class="id" title="var">p</span></span> i <span class="inlinecode"><span class="id" title="var">q</span></span> znajdą
    się w kontekście dzięki temu, że zostały związane podczas dopasowania
    <span class="inlinecode"><span class="id" title="var">conj</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span>.

<div class="paragraph"> </div>

    Teraz naszym celem jest <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Ponieważ dowody koniunkcji są postaci
    <span class="inlinecode"><span class="id" title="var">conj</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">l</span></span> jest dowodem pierwszego członu, a <span class="inlinecode"><span class="id" title="var">r</span></span> drugiego,
    używamy taktyki <span class="inlinecode"><span class="id" title="tactic">refine</span></span> <span class="inlinecode">(<span class="id" title="var">conj</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span>)</span>, by osobno skonstruować oba człony.
    Tym razem nasz proofterm zawiera dwie dziury, więc wygenerowane zostaną
    dwa podcele. Obydwa zachodzą na mocy założenia, a rozwiązujemy je także
    za pomocą <span class="inlinecode"><span class="id" title="tactic">refine</span></span>.

<div class="paragraph"> </div>

    Powyższy przykład pokazuje, że <span class="inlinecode"><span class="id" title="tactic">refine</span></span> potrafi zastąpić cała gamę
    przeróżnych taktyk, które dotychczas uważaliśmy za podstawowe: <span class="inlinecode"><span class="id" title="tactic">intros</span></span>,
    <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, <span class="inlinecode"><span class="id" title="tactic">split</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">exact</span></span>. Określenie "matka wszystkich
    taktyk" wydaje się całkiem uzasadnione. 
<div class="paragraph"> </div>

<a id="lab722"></a><h4 class="section">Ćwiczenie (my_exact)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_exact</span></span>, która działa tak, jak <span class="inlinecode"><span class="id" title="tactic">exact</span></span>. Użyj taktyki
    <span class="inlinecode"><span class="id" title="tactic">refine</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_exact_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab723"></a><h4 class="section">Ćwiczenie (my_intro)</h4>

<div class="paragraph"> </div>

 Zaimplementuj taktykę <span class="inlinecode"><span class="id" title="var">my_intro1</span></span>, która działa tak, jak <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, czyli
    próbuje wprowadzić do kontekstu zmienną o domyślnej nazwie. Zaimplementuj
    też taktykę <span class="inlinecode"><span class="id" title="var">my_intro2</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, która działa tak jak <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, czyli próbuje
    wprowadzić do kontekstu zmienną o nazwie <span class="inlinecode"><span class="id" title="var">x</span></span>. Użyj taktyki <span class="inlinecode"><span class="id" title="tactic">refine</span></span>.

<div class="paragraph"> </div>

    Bonus: przeczytaj dokumentację na temat notacji dla taktyk (komenda
    <span class="inlinecode"><span class="id" title="keyword">Tactic</span></span> <span class="inlinecode"><span class="id" title="keyword">Notation</span></span>) i napisz taktykę <span class="inlinecode"><span class="id" title="var">my_intro</span></span>, która działa tak jak
    <span class="inlinecode"><span class="id" title="var">my_intro1</span></span>, gdy nie dostanie argumentu, a tak jak <span class="inlinecode"><span class="id" title="var">my_intro2</span></span>, gdy
    dostanie argument. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_intro_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro1</span>. <span class="id" title="var">my_intro2</span> <span class="id" title="var">H</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span>. <span class="id" title="var">my_intro</span> <span class="id" title="var">H</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab724"></a><h4 class="section">Ćwiczenie (my_apply)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_apply</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, która działa tak jak <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. Użyj taktyki
    <span class="inlinecode"><span class="id" title="tactic">refine</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_apply_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) -&gt; <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span> <span class="id" title="var">P</span>. <span class="id" title="var">my_intro</span> <span class="id" title="var">Q</span>. <span class="id" title="var">my_intro</span> <span class="id" title="var">p</span>. <span class="id" title="var">my_intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_apply</span> <span class="id" title="var">H</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab725"></a><h4 class="section">Ćwiczenie (taktyki dla konstruktorów 1)</h4>

<div class="paragraph"> </div>

 Napisz taktyki:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">my_split</span></span>, która działa tak samo jak <span class="inlinecode"><span class="id" title="tactic">split</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">my_left</span></span> i <span class="inlinecode"><span class="id" title="var">my_right</span></span>, które działają tak jak <span class="inlinecode"><span class="id" title="tactic">left</span></span> i <span class="inlinecode"><span class="id" title="tactic">right</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">my_exists</span></span>, która działa tak samo jak <span class="inlinecode"><span class="id" title="tactic">exists</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Użyj taktyki <span class="inlinecode"><span class="id" title="tactic">refine</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_split_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span> <span class="id" title="var">P</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">Q</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">p</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">my_exact</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">my_exact</span> <span class="id" title="var">q</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_left_right_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span> \/ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span> <span class="id" title="var">P</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">p</span>. <span class="id" title="var">my_left</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span> <span class="id" title="var">P</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">p</span>. <span class="id" title="var">my_right</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_exists_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_exists</span> 42. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab726"></a><h1 class="section">Drobne taktyki</h1>

<div class="paragraph"> </div>

<a id="lab727"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">clear</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">x</span> -&gt; <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">Fail</span> <span class="id" title="tactic">clear</span> <span class="id" title="var">x</span>. <span class="id" title="var">Fail</span> <span class="id" title="tactic">clear</span> <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">clear</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">clear</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">z</span> := 42).<br/>
&nbsp;&nbsp;<span class="id" title="var">clearbody</span> <span class="id" title="var">z</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">clear</span></span> to niesamowicie użyteczna taktyka, dzięki której możemy zrobić
    porządek w kontekście. Można używać jej na nastepujące sposoby:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> usuwa <span class="inlinecode"><span class="id" title="var">x</span></span> z kontekstu. Jeżeli <span class="inlinecode"><span class="id" title="var">x</span></span> nie ma w kontekście lub są
      w nim jakieś rzeczy zależne od <span class="inlinecode"><span class="id" title="var">x</span></span>, taktyka zawodzi. Można usunąć wiele
      rzeczy na raz: <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="var">x_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">x_N</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode">-<span class="id" title="var">x</span></span> usuwa z kontekstu wszystko poza <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> usuwa z kontekstu <span class="inlinecode"><span class="id" title="var">x</span></span> i wszystkie rzeczy, które od
      niego zależą. Taktyka ta zawodzi jedynie gdy <span class="inlinecode"><span class="id" title="var">x</span></span> nie ma w kontekście.

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> usuwa z kontekstu absolutnie wszystko. Serdecznie nie polecam.

</li>
<li> <span class="inlinecode"><span class="id" title="var">clearbody</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> usuwa definicję <span class="inlinecode"><span class="id" title="var">x</span></span> (jeżeli <span class="inlinecode"><span class="id" title="var">x</span></span> jakąś posiada). 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab728"></a><h4 class="section">Ćwiczenie (tru)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">tru</span></span>, która czyści kontekst z dowodów na <span class="inlinecode"><span class="id" title="var">True</span></span> oraz
    potrafi udowodnić cel <span class="inlinecode"><span class="id" title="var">True</span></span>.

<div class="paragraph"> </div>

    Dla przykładu, taktyka ta powinna przekształcać kontekst
    <span class="inlinecode"><span class="id" title="var">a</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>,</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">True</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">_</span></span> w <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">_</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">tru</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">tru_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">True</span> -&gt; <span class="id" title="var">True</span> -&gt; <span class="id" title="var">True</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">tru</span>. <span class="comment">(*&nbsp;Kontekst:&nbsp;<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">P</span></span>&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">tru_1</span> : <span class="id" title="var">True</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">tru</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">tru</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab729"></a><h4 class="section">Ćwiczenie (satans_neighbour_not_even)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">even0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">evenSS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">even</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
Napisz taktykę <span class="inlinecode"><span class="id" title="var">even</span></span>, która potrafi udowodnić poniższy cel. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">satans_neighbour_not_even</span> :<br/>
&nbsp;&nbsp;~ <span class="id" title="var">even</span> 667.<br/>

<br/>
</div>

<div class="doc">
<a id="lab730"></a><h4 class="section">Ćwiczenie (my_destruct_and)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span>, która działa jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span>]</span>,
    gdzie <span class="inlinecode"><span class="id" title="var">H</span></span> jest dowodem koniunkcji. Użyj taktyk <span class="inlinecode"><span class="id" title="tactic">refine</span></span> i <span class="inlinecode"><span class="id" title="tactic">clear</span></span>.

<div class="paragraph"> </div>

    Bonus 1: zaimplementuj taktykę <span class="inlinecode"><span class="id" title="var">my_destruct_and</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, która działa tak jak
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, gdy <span class="inlinecode"><span class="id" title="var">H</span></span> jest dowodem koniunkcji.

<div class="paragraph"> </div>

    Bonus 2: zastanów się, jak (albo czy) można zaimplementować taktykę
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">x</span></span> jest dowolnego typu induktywnego. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_destruct_and_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span> <span class="id" title="var">P</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">Q</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_destruct_and</span> <span class="id" title="var">H</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_intro</span> <span class="id" title="var">P</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">Q</span>; <span class="id" title="var">my_intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_destruct_and</span> <span class="id" title="var">H</span>. <span class="id" title="var">my_exact</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab731"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">fold</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">fold</span></span> to taktyka służąca do zwijania definicji. Jej działanie jest
    odwrotne do działania taktyki <span class="inlinecode"><span class="id" title="tactic">unfold</span></span>. Niestety, z nieznanych mi
    bliżej powodów bardzo często jest ona nieskuteczna. 
<div class="paragraph"> </div>

<a id="lab732"></a><h4 class="section">Ćwiczenie (my_fold)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_fold</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, która działa tak jak <span class="inlinecode"><span class="id" title="tactic">fold</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, tj. zastępuje
    we wszystkich miejscach w celu term powstały po rozwinięciu <span class="inlinecode"><span class="id" title="var">x</span></span> przez <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Wskazówka: zapoznaj się z konstruktem <span class="inlinecode"><span class="id" title="tactic">eval</span></span> — zajrzyj do 9 rozdziału
    manuala. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">fold_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">plus</span>. <span class="id" title="tactic">fold</span> <span class="id" title="var">plus</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">plus</span>. <span class="id" title="var">my_fold</span> <span class="id" title="var">plus</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab733"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">move</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">move_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span> /\ <span class="id" title="var">R</span> /\ <span class="id" title="var">S</span> /\ <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> [<span class="id" title="var">p</span> [<span class="id" title="var">q</span> [<span class="id" title="var">r</span> [<span class="id" title="var">s</span> <span class="id" title="var">t</span>]]]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">move</span> <span class="id" title="var">p</span> <span class="id" title="keyword">after</span> <span class="id" title="var">t</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">move</span> <span class="id" title="var">p</span> <span class="id" title="keyword">before</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">move</span> <span class="id" title="var">p</span> <span class="id" title="tactic">at</span> <span class="id" title="var">top</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">move</span> <span class="id" title="var">p</span> <span class="id" title="tactic">at</span> <span class="id" title="var">bottom</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">move</span></span> to taktyka służąca do zmieniania kolejności obiektów w kontekście.
    Jej działanie jest tak ewidentnie oczywiste, ż nie ma zbytniego sensu,
    aby je opisywać. 
<div class="paragraph"> </div>

<a id="lab734"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Przeczytaj dokładny opis działania taktyki <span class="inlinecode"><span class="id" title="tactic">move</span></span> w manualu. 
<div class="paragraph"> </div>

<a id="lab735"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">pose</span></span> i <span class="inlinecode"><span class="id" title="var">remember</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> 2 + 2 = 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">a</span> := 2 + 2).<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (2 + 2) <span class="id" title="keyword">as</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">t</span>)</span> dodaje do kontekstu zmienną <span class="inlinecode"><span class="id" title="var">x</span></span> (pod warunkiem,
    że nazwa ta nie jest zajęta), która zostaje zdefiniowana za pomocą termu
    <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" title="var">remember</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zastępuje wszystkie wystąpienia termu <span class="inlinecode"><span class="id" title="var">t</span></span>
    w kontekście zmienną <span class="inlinecode"><span class="id" title="var">x</span></span> (pod warunkiem, że nazwa ta nie jest zajęta) i
    dodaje do kontekstu równanie postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    W powyższym przykładzie działają one następująco: <span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span>
    dodaje do kontekstu wiązanie <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span>, zaś <span class="inlinecode"><span class="id" title="var">remember</span></span> <span class="inlinecode">(2</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>
    dodaje do kontekstu równanie <span class="inlinecode"><span class="id" title="var">Heqb</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> i zastępuje przez <span class="inlinecode"><span class="id" title="var">b</span></span>
    wszystkie wystąpienia <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> — także to w definicji <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

    Taktyki te przydają się w tak wielu różnych sytuacjach, że nie ma co
    próbować ich tu wymieniać. Użyjesz ich jeszcze nie raz. 
<div class="paragraph"> </div>

<a id="lab736"></a><h4 class="section">Ćwiczenie (set)</h4>

<div class="paragraph"> </div>

 Taktyki te są jedynie wariantami bardziej ogólnej taktyki <span class="inlinecode"><span class="id" title="tactic">set</span></span>.
    Przeczytaj jej dokumentację w manualu. 
<div class="paragraph"> </div>

<a id="lab737"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">rename</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rename</span> <span class="id" title="var">H</span> <span class="id" title="var">into</span> <span class="id" title="var">wut</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">rename</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">into</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> zmienia nazwę <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span> lub zawodzi, gdy <span class="inlinecode"><span class="id" title="var">x</span></span> nie ma
    w kontekście albo nazwa <span class="inlinecode"><span class="id" title="var">y</span></span> jest już zajęta 
<div class="paragraph"> </div>

<a id="lab738"></a><h4 class="section">Ćwiczenie (satans_neighbour_not_even')</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">even'</span></span>, która potrafi udowodnić poniższy cel. Nie używaj
    <span class="inlinecode"><span class="id" title="keyword">match</span></span>a, a jedynie kombinatora <span class="inlinecode"><span class="id" title="tactic">repeat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">satans_neighbour_not_even'</span> : ~ <span class="id" title="var">even</span> 667.<br/>

<br/>
</div>

<div class="doc">
<a id="lab739"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">admit</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">forgery</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> /\ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">admit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">forgery</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;***&nbsp;<span class="inlinecode">[</span> <span class="inlinecode"><span class="id" title="var">forgery</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">]</span>&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">admit</span></span> to taktyka-oszustwo, która rozwiązuje dowolny cel. Nie jest ona
    rzecz jasna wszechwiedząca i przez to rozwiązanego za jej pomocą celu
    nie można zapisać za pomocą komend <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> ani <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>, a jedynie za
    pomocą komendy <span class="inlinecode"><span class="id" title="var">Admitted</span></span>, która oszukańczo udowodnione twierdzenie
    przekształca w aksjomat.

<div class="paragraph"> </div>

    W CoqIDE oszustwo jest dobrze widoczne, gdyż zarówno taktyka <span class="inlinecode"><span class="id" title="var">admit</span></span>
    jak i komenda <span class="inlinecode"><span class="id" title="var">Admitted</span></span> podświetlają się na żółto, a nie na zielono,
    tak jak prawdziwe dowody. Wyświetlenie <span class="inlinecode"><span class="id" title="keyword">Print</span></span>em dowodu zakończonego
    komendą <span class="inlinecode"><span class="id" title="var">Admitted</span></span> również pokazuje, że ma on status aksjomatu.

<div class="paragraph"> </div>

    Na koniec zauważmy, że komendy <span class="inlinecode"><span class="id" title="var">Admitted</span></span> możemy użyć również bez
    wczesniejszego użycia taktyki <span class="inlinecode"><span class="id" title="var">admit</span></span>. Różnica między tymi dwoma bytami
    jest taka, że taktyka <span class="inlinecode"><span class="id" title="var">admit</span></span> służy do "udowodnienia" pojedynczego celu,
    a komenda <span class="inlinecode"><span class="id" title="var">Admitted</span></span> — całego twierdzenia. 
<div class="paragraph"> </div>

<a id="lab740"></a><h1 class="section">Średnie taktyki</h1>

<div class="paragraph"> </div>

<a id="lab741"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">case_eq</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">case_eq</span></span> to taktyka podobna do taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, ale nieco mądrzejsza,
    gdyż nie zdarza jej się "zapominać", jaka była struktura rozbitego przez
    nią termu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">n</span> = 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">n</span> + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">case_eq</span> (<span class="id" title="var">n</span> + <span class="id" title="var">n</span>); <span class="id" title="tactic">intro</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Różnice między <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> i <span class="inlinecode"><span class="id" title="var">case_eq</span></span> dobrze ilustruje powyższy przykład.
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> nadaje się jedynie do rozbijania termów, które są zmiennymi.
    Jeżeli rozbijemy coś, co nie jest zmienną (np. term <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>), to utracimy
    część informacji na jego temat. <span class="inlinecode"><span class="id" title="var">case_eq</span></span> potrafi rozbijać dowolne termy,
    gdyż poza samym rozbiciem dodaje też do celu dodatkową hipotezę, która
    zawiera równanie "pamiętające" informacje o rozbitym termie, o których
    zwykły <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> zapomina. 
<div class="paragraph"> </div>

<a id="lab742"></a><h4 class="section">Ćwiczenie (my_case_eq)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_case_eq</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">Heq</span></span>, która działa tak jak <span class="inlinecode"><span class="id" title="var">case_eq</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, ale
    nie dodaje równania jako hipotezę na początku celu, tylko bezpośrednio
    do kontekstu i nazywa je <span class="inlinecode"><span class="id" title="var">Heq</span></span>. Użyj taktyk <span class="inlinecode"><span class="id" title="var">remember</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">n</span> = 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">n</span> + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">case_eq</span> (<span class="id" title="var">n</span> + <span class="id" title="var">n</span>); <span class="id" title="tactic">intro</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">my_case_eq</span> (<span class="id" title="var">n</span> + <span class="id" title="var">n</span>) <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab743"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">contradiction</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">contradiction</span></span> to taktyka, która wprowadza do kontekstu wszystko co się
    da, a potem próbuje znaleźć sprzeczność. Potrafi rozpoznawać hipotezy
    takie jak <span class="inlinecode"><span class="id" title="var">False</span></span>, <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span>, <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">True</span></span>. Potrafi też znaleźć dwie hipotezy,
    które są ze sobą ewidentnie sprzeczne, np. <span class="inlinecode"><span class="id" title="var">P</span></span> oraz <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Nie potrafi
    jednak wykrywać lepiej ukrytych sprzeczności, np. nie jest w stanie
    odróżnić <span class="inlinecode"><span class="id" title="var">true</span></span> od <span class="inlinecode"><span class="id" title="var">false</span></span>. 
<div class="paragraph"> </div>

<a id="lab744"></a><h4 class="section">Ćwiczenie (my_contradiction)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_contradiction</span></span>, która działa tak jak standardowa
    taktyka <span class="inlinecode"><span class="id" title="var">contradiction</span></span>, a do tego jest w stanie udowodnić dowolny
    cel, jeżeli w kontekście jest hipoteza postaci <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span> lub
    <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">my_contradiction</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_contradiction_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">False</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_contradiction_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, ~ <span class="id" title="var">True</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_contradiction_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>), <span class="id" title="var">n</span> &lt;&gt; <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_contradiction_3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; ~ <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_contradiction_4</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">true</span> = <span class="id" title="var">false</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">my_contradiction_5</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">false</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">my_contradiction</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab745"></a><h4 class="section">Ćwiczenie (taktyki dla sprzeczności)</h4>

<div class="paragraph"> </div>

 Innymi taktykami, które mogą przydać się przy rozumowaniach przez
    sprowadzenie do sprzeczności, są <span class="inlinecode"><span class="id" title="var">absurd</span></span>, <span class="inlinecode"><span class="id" title="var">contradict</span></span> i <span class="inlinecode"><span class="id" title="var">exfalso</span></span>.
    Przeczytaj ich opisy w manualu i zbadaj ich działanie. 
<div class="paragraph"> </div>

<a id="lab746"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">constructor</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">constructor_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span> \/ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">constructor</span> 2. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">constructor</span></span> to taktyka ułatwiająca aplikowanie konstruktorów typów
    induktywnych. Jeżeli aktualnym celem jest <span class="inlinecode"><span class="id" title="var">T</span></span>, to taktyka <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span>
    jest równoważna wywołaniu jego i-tego konstruktora, gdzie porządek
    konstruktorów jest taki jak w definicji typu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">or</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;or&nbsp;(A&nbsp;B&nbsp;:&nbsp;Prop)&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or_introl&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B&nbsp;|&nbsp;or_intror&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
W powyższym przykładzie <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> <span class="inlinecode">2</span> działa tak jak <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">or_intror</span></span>
    (czyli tak samo jak taktyka <span class="inlinecode"><span class="id" title="tactic">right</span></span>), gdyż w definicji spójnika <span class="inlinecode"><span class="id" title="var">or</span></span>
    konstruktor <span class="inlinecode"><span class="id" title="var">or_intror</span></span> występuje jako drugi (licząc od góry).

<div class="paragraph"> </div>

    Użycie taktyki <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> bez liczby oznacza zaaplikowanie pierwszego
    konstruktora, który pasuje do celu, przy czym taktyka ta może wyzwalać
    backtracking. W drugim przykładzie powyżej <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> działa jak
    <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">or_intro</span></span> (czyli jak taktyka <span class="inlinecode"><span class="id" title="tactic">left</span></span>), gdyż zaaplikowanie tego
    konstruktora nie zawodzi.

<div class="paragraph"> </div>

    W trzecim przykładzie <span class="inlinecode"><span class="id" title="tactic">constructor</span>;</span> <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> działa tak: najpierw
    aplikowany jest konstruktor <span class="inlinecode"><span class="id" title="var">or_introl</span></span>, ale wtedy <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> zawodzi,
    więc następuje nawrót i aplikowany jest konstruktor <span class="inlinecode"><span class="id" title="var">or_intror</span></span>, a wtedy
    <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> rozwiązuje cel. 
<div class="paragraph"> </div>

<a id="lab747"></a><h4 class="section">Ćwiczenie (taktyki dla konstruktorów 2)</h4>

<div class="paragraph"> </div>

 Jaki jest związek taktyki <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> z taktykami <span class="inlinecode"><span class="id" title="tactic">split</span></span>, <span class="inlinecode"><span class="id" title="tactic">left</span></span>,
    <span class="inlinecode"><span class="id" title="tactic">right</span></span> i <span class="inlinecode"><span class="id" title="tactic">exists</span></span>? 
<div class="paragraph"> </div>

<a id="lab748"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">decompose</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">decompose_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>) /\ (<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">Q</span> <span class="id" title="var">n</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">R</span> <span class="id" title="var">n</span>) /\ (<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">S</span> <span class="id" title="var">n</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> \/ <span class="id" title="var">Q</span> <span class="id" title="var">n</span> \/ <span class="id" title="var">R</span> <span class="id" title="var">n</span> \/ <span class="id" title="var">S</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">decompose</span> [<span class="id" title="var">and</span> <span class="id" title="var">ex</span>] <span class="id" title="var">H</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">decompose</span></span> to bardzo użyteczna taktyka, która potrafi za jednym zamachem
    rozbić bardzo skomplikowane hipotezy. <span class="inlinecode"><span class="id" title="var">decompose</span></span> <span class="inlinecode">[<span class="id" title="var">t_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">t_n</span>]</span> <span class="inlinecode"><span class="id" title="var">H</span></span> rozbija
    rekurencyjnie hipotezę <span class="inlinecode"><span class="id" title="var">H</span></span> tak długo, jak jej typem jest jeden z typów
    <span class="inlinecode"><span class="id" title="var">t_i</span></span>. W powyższym przykładzie <span class="inlinecode"><span class="id" title="var">decompose</span></span> <span class="inlinecode">[<span class="id" title="var">and</span></span> <span class="inlinecode"><span class="id" title="var">ex</span>]</span> <span class="inlinecode"><span class="id" title="var">H</span></span> najpierw rozbija <span class="inlinecode"><span class="id" title="var">H</span></span>,
    gdyż jest ona koniunkcją, a następnie rozbija powstałe z niej hipotezy,
    gdyż są one kwantyfikacjami egzystencjalnymi ("exists" jest notacją dla
    <span class="inlinecode"><span class="id" title="var">ex</span></span>). <span class="inlinecode"><span class="id" title="var">decompose</span></span> nie usuwa z kontekstu hipotezy, na której działa, więc
    często następuje po niej taktyka <span class="inlinecode"><span class="id" title="tactic">clear</span></span>. 
<div class="paragraph"> </div>

<a id="lab749"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">intros</span></span></h2>

<div class="paragraph"> </div>

 Dotychczas używałeś taktyk <span class="inlinecode"><span class="id" title="tactic">intro</span></span> i <span class="inlinecode"><span class="id" title="tactic">intros</span></span> jedynie z nazwami lub
    wzorcami do rozbijania elementów typów induktywnych. Taktyki te potrafią
    jednak dużo więcej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">intros_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span> /\ <span class="id" title="var">R</span> -&gt; <span class="id" title="var">S</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> [<span class="id" title="var">p</span> [<span class="id" title="var">q</span> <span class="id" title="var">r</span>]].<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ?<span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>. <span class="id" title="tactic">intros</span> (<span class="id" title="var">p</span>, (<span class="id" title="var">p0</span>, <span class="id" title="var">q</span>)).<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> *.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> **.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> * <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszy przykład to standardowe użycie <span class="inlinecode"><span class="id" title="tactic">intros</span></span> — wprowadzamy cztery
    zmienne, która nazywamy kolejno <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="var">Q</span></span>, <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">S</span></span>, po czym wprowadzamy
    bezimienną hipotezę typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">R</span></span>, która natychmiast rozbijamy za
    pomocą wzorca <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">[<span class="id" title="var">q</span></span> <span class="inlinecode"><span class="id" title="var">r</span>]</span>.

<div class="paragraph"> </div>

    W kolejnym przykładzie mamy już nowości: wzorzec <span class="inlinecode">?</span> służy do nadania
    zmiennej domyślnej nazwy. W naszym przypadku wprowadzone do kontekstu
    zdanie zostaje nazwane <span class="inlinecode"><span class="id" title="var">P</span></span>, gdyż taką nazwę nosi w kwantyfikatorze,
    gdy jest jeszcze w celu.

<div class="paragraph"> </div>

    Wzorzec <span class="inlinecode">?<span class="id" title="var">P</span></span> służy do nadania zmiennej domyślnej nazwy zaczynając się
    od tego, co następuje po znaku <span class="inlinecode">?</span>. W naszym przypadku do konteksu
    wprowadzona zostaje zmienna <span class="inlinecode"><span class="id" title="var">P0</span></span>, gdyż żądamy nazwy zaczynającej się
    od "P", ale samo "P" jest już zajęte. Widzimy też wzorzec <span class="inlinecode">(<span class="id" title="var">p</span>,</span> <span class="inlinecode">(<span class="id" title="var">p0</span>,</span> <span class="inlinecode"><span class="id" title="var">q</span>))</span>,
    który służy do rozbicia hipotezy. Wzorce tego rodzaju działają tak samo
    jak wzorce w kwadratowych nawiasach, ale możemy używać ich tylko na
    elementach typu induktywnego z jednym konstruktorem.

<div class="paragraph"> </div>

    Wzorzec <span class="inlinecode">*</span> wprowadza do kontekstu wszystkie zmienne kwantyfikowane
    uniwersalnie i zatrzymuje sie na pierwszej nie-zależnej hipotezie. W
    naszym przykładzie uniwersalnie kwantyfikowane są <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="var">Q</span></span>, <span class="inlinecode"><span class="id" title="var">R</span></span> i <span class="inlinecode"><span class="id" title="var">S</span></span>,
    więc zostają wprowadzane, ale <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">R</span></span> nie jest już kwantyfikowane
    uniwersalnie — jest przesłanką implikacji — więc nie zostaje wprowadzone.

<div class="paragraph"> </div>

    Wzorzec <span class="inlinecode">**</span> wprowadza do kontekstu wszystko. Wobec tego <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode">**</span> jest
    synonimem <span class="inlinecode"><span class="id" title="tactic">intros</span></span>. Mimo tego nie jest on bezużyteczny — możemy użyć go
    po innych wzorcach, kiedy nie chcemy już więcej nazywać/rozbijać naszych
    zmiennych. Wtedy dużo szybciej napisać <span class="inlinecode">**</span> niż <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" title="tactic">intros</span></span>. W naszym
    przypadku chcemy nazwać jedynie pierwsze dwie zmienne, a resztę wrzucamy
    do kontekstu jak leci.

<div class="paragraph"> </div>

    Wzorzec <span class="inlinecode"><span class="id" title="var">_</span></span> pozwala pozbyć się zmiennej lub hipotezy. Taktyka <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>
    jest wobec tego równoważna <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> (przy założeniu, że <span class="inlinecode"><span class="id" title="var">H</span></span>
    jest wolne), ale dużo bardziej zwięzła w zapisie. Nie możemy jednak
    usunąć zmiennych lub hipotez, od których zależą inne zmienne lub hipotezy.
    W naszym przedostatnim przykładzie bez problemu usuwamy hipotezę <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span>
    <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">R</span></span>, gdyż żaden term od niej nie zależy. Jednak w ostatnim przykładzie
    nie możemy usunąć <span class="inlinecode"><span class="id" title="var">P</span></span>, gdyż zależy od niego hipoteza <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" title="var">R</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">intros_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P0</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span> <span class="id" title="var">P5</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P0</span> /\ <span class="id" title="var">P1</span> /\ <span class="id" title="var">P2</span> /\ <span class="id" title="var">P3</span> /\ <span class="id" title="var">P4</span> /\ <span class="id" title="var">P5</span> -&gt; <span class="id" title="var">P3</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> * [<span class="id" title="var">p0</span> [<span class="id" title="var">p1</span> [<span class="id" title="var">p2</span> [<span class="id" title="var">p3</span> [<span class="id" title="var">p4</span> <span class="id" title="var">p5</span>]]]]].<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> * (<span class="id" title="var">p0</span> &amp; <span class="id" title="var">p1</span> &amp; <span class="id" title="var">p2</span> &amp; <span class="id" title="var">p3</span> &amp; <span class="id" title="var">p4</span> &amp; <span class="id" title="var">p5</span>).<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Wzorce postaci <span class="inlinecode">(<span class="id" title="var">p_1</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode">...</span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" title="var">p_n</span>)</span> pozwalają rozbijać termy zagnieżdżonych
    typów induktywnych. Jak widać na przykładzie, im bardziej zagnieżdżony
    jest typ, tym bardziej opłaca się użyć tego rodzaju wzorca. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">intros_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> * -&gt;.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> * &lt;-.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Wzorców <span class="inlinecode">-&gt;</span> oraz <span class="inlinecode">&lt;-</span> możemy użyć, gdy chcemy wprowadzić do kontekstu
    równanie, przepisać je i natychmiast się go pozbyć. Wobec tego taktyka
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode">-&gt;</span> jest równoważna czemuś w stylu <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode">*;</span>
    <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> (oczywiście pod warunkiem, że nazwa <span class="inlinecode"><span class="id" title="var">H</span></span> nie jest zajęta). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">intros_3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> : <span class="id" title="var">nat</span>, (<span class="id" title="var">a</span>, <span class="id" title="var">b</span>) = (<span class="id" title="var">c</span>, <span class="id" title="var">d</span>) -&gt; <span class="id" title="var">a</span> = <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">intros</span> * [<span class="id" title="var">p1</span> <span class="id" title="var">p2</span>].<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> * [= <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>].<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Wzorzec postaci <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">p_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">p_n</span></span> pozwala rozbić równanie między parami
    (i nie tylko) na składowe. W naszym przypadu mamy równanie <span class="inlinecode">(<span class="id" title="var">a</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>)</span> <span class="inlinecode">=</span>
    <span class="inlinecode">(<span class="id" title="var">c</span>,</span> <span class="inlinecode"><span class="id" title="var">d</span>)</span> — zauważmy, że nie jest ono koniunkcją dwóch równości <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">c</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">d</span></span>, co jasno widać na przykładzie, ale można z niego ową
    koniunkjcę wywnioskować. Taki właśnie efekt ma wzorzec <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">p1</span></span> <span class="inlinecode"><span class="id" title="var">p2</span></span> —
    dodaje on nam do kontekstu hipotezy <span class="inlinecode"><span class="id" title="var">p1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">c</span></span> oraz <span class="inlinecode"><span class="id" title="var">p2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">d</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">intros_4</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) -&gt; (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">R</span>) -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">R</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="tactic">until</span> 2. <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="tactic">until</span> 2. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span> %<span class="id" title="var">H</span> %<span class="id" title="var">H0</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="tactic">until</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> wprowadza do kontekstu wszystkie zmienne jak
    leci dopóki nie natknie się na taką, która nazywa się "x". Taktyka
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="tactic">until</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbą, wprowadza do kontekstu wszyskto
    jak leci aż do n-tej nie-zależnej hipotezy (tj. przesłanki implikacji).
    W naszym przykładzie mamy 3 przesłanki implikacji: <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span>)</span>, <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">R</span>)</span>
    i <span class="inlinecode"><span class="id" title="var">P</span></span>, więc taktyka <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="tactic">until</span></span> <span class="inlinecode">2</span> wprowadza do kontekstu dwie pierwsze
    z nich oraz wszystko, co jest poprzedza.

<div class="paragraph"> </div>

    Wzorzec <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">%<span class="id" title="var">H_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode">%<span class="id" title="var">H_n</span></span> wprowadza do kontekstu zmienną <span class="inlinecode"><span class="id" title="var">x</span></span>, a następnie
    aplikuje do niej po kolei hipotezy <span class="inlinecode"><span class="id" title="var">H_1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">H_n</span></span>. Taki sam efekt można
    osiągnąć ręcznie za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="var">x</span>;</span> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">H_1</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span>;</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">H_n</span></span>
    <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
<div class="paragraph"> </div>

<a id="lab750"></a><h4 class="section">Ćwiczenie (intros)</h4>

<div class="paragraph"> </div>

 Taktyka <span class="inlinecode"><span class="id" title="tactic">intros</span></span> ma jeszcze trochę różnych wariantów. Poczytaj o nich
    w manualu. 
<div class="paragraph"> </div>

<a id="lab751"></a><h2 class="section"><span class="inlinecode"><span class="id" title="keyword">fix</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="keyword">fix</span></span> to taktyka służąca do dowodzenia bezpośrednio przez rekursję. W
    związku z tym nadeszła dobra pora, żeby pokazać wszystkie możliwe sposoby
    na użycie rekursji w Coqu. Żeby dużo nie pisać, przyjrzyjmy się przykładom:
    zdefiniujemy/udowodnimy regułę indukcyjną dla liczb naturalnych, którą
    powinieneś znać jak własną kieszeń (a jeżeli nie, to marsz robić zadania
    z liczb naturalnych!). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_ind_fix_term</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <span class="id" title="var">P</span> 0)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">H0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">HS</span> <span class="id" title="var">n'</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszy, najbardziej prymitywny sposób to użycie konstruktu <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. <span class="inlinecode"><span class="id" title="keyword">fix</span></span>
    to podstawowy budulec Coqowej rekursji, ale ma tę wadę, że trzeba się
    trochę napisać: w powyższym przykładzie najpierw piszemy <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span>
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, a następnie powtarzamy niemal to samo, pisząc
    <span class="inlinecode"><span class="id" title="keyword">fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_ind_Fixpoint_term</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <span class="id" title="var">P</span> 0)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">H0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">HS</span> <span class="id" title="var">n'</span> (<span class="id" title="var">nat_ind_Fixpoint_term</span> <span class="id" title="var">P</span> <span class="id" title="var">H0</span> <span class="id" title="var">HS</span> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Rozwiązaniem powyższej robnej niedogodności jest komenda <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>,
    która jest skrótem dla <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. Oszczędza nam ona pisania dwa razy tego
    samego, dzięki czemu definicja jest o linijkę krótsza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_ind_Fixpoint_tac</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <span class="id" title="var">P</span> 0)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind_Fixpoint_tac</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="keyword">Guarded</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;Długi&nbsp;komunikat&nbsp;o&nbsp;błędzie.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;(fix&nbsp;nat_ind_Fixpoint_tac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop)&nbsp;(H0&nbsp;:&nbsp;P&nbsp;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(HS&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;P&nbsp;n&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nat_ind_Fixpoint_tac&nbsp;P&nbsp;H0&nbsp;HS&nbsp;n)&nbsp;*)</span><br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">HS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind_Fixpoint_tac</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Guarded</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;condition&nbsp;holds&nbsp;up&nbsp;to&nbsp;here&nbsp;*)</span><br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
W trzecim podejściu również używamy komendy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, ale tym razem,
    zamiast ręcznie wpisywać term, definiujemy naszą regułę za pomocą taktyk.
    Sposób ten jest prawie zawsze (dużo) dłuższy niż poprzedni, ale jego
    zaletą jest to, że przy skomplikowanych celach jest dużo ławiejszy do
    ogarnięcia dla człowieka.

<div class="paragraph"> </div>

    Korzystając z okazji rzućmy okiem na komendę <span class="inlinecode"><span class="id" title="keyword">Guarded</span></span>. Jest ona przydatna
    gdy, tak jak wyżej, dowodzimy lub definiujemy bezpośrednio przez rekursję.
    Sprawdza ona, czy wszystkie dotychczasowe wywołania rekurencyjne odbyły
    się na strukturalnie mniejszych podtermach. Jeżeli nie, wyświetla ona
    wiadomość, która informuje nas, gdzie jest błąd. Niestety wiadomości te
    nie zawsze są czytelne.

<div class="paragraph"> </div>

    Tak właśnie jest, gdy w powyższym przykładzie używamy jej po raz pierwszy.
    Na szczęście ratuje nas komenda <span class="inlinecode"><span class="id" title="keyword">Show</span></span> <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>, która pokazuje, jak wygląda
    term, która póki co wygenerowały taktyki. Pokazuje on nam term postaci
    <span class="inlinecode"><span class="id" title="var">nat_ind_Fixpoint_tac</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode"><span class="id" title="var">HS</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">nat_ind_Fixpoint_tac</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode"><span class="id" title="var">HS</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, który
    próbuje wywołać się rekurencyjnie na tym samym argumencie, na którym sam
    został wywołany. Nie jest więc legalny.

<div class="paragraph"> </div>

    Jeżeli z wywołaniami rekurencyjnymi jest wszystko ok, to komenda <span class="inlinecode"><span class="id" title="keyword">Guarded</span></span>
    wyświetla przyjazny komunikat. Tak właśnie jest, gdy używamy jej po raz
    drugi — tym razem wywołanie rekurencyjne odbywa się na <span class="inlinecode"><span class="id" title="var">n'</span></span>, które jest
    podtermem <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_ind_fix_tac</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <span class="id" title="var">P</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">HS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>), <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;?Goal&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">IH</span> 4.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;===&gt;&nbsp;(fix&nbsp;nat_ind_fix_tac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop)&nbsp;(H0&nbsp;:&nbsp;P&nbsp;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(HS&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;P&nbsp;n&nbsp;:=&nbsp;...&nbsp;*)</span><br/>
&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">HS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyki <span class="inlinecode"><span class="id" title="keyword">fix</span></span> możemy użyć w dowolnym momencie, aby rozpocząć dowodzenie/
    definiowanie bezpośrednio przez rekursję. Jej argumentami są nazwa, którą
    chcemy nadać hipotezie indukcyjnej oraz numer argument głównego. W
    powyższym przykładzie chcemy robić rekursję po <span class="inlinecode"><span class="id" title="var">n</span></span>, który jest czwarty
    z kolei (po <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="var">H0</span></span> i <span class="inlinecode"><span class="id" title="var">HS</span></span>).

<div class="paragraph"> </div>

    Komenda <span class="inlinecode"><span class="id" title="keyword">Show</span></span> <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> pozwala nam odkryć, że użycie taktyki <span class="inlinecode"><span class="id" title="keyword">fix</span></span> w
    trybie dowodzenia odpowiada po prostu użyciu konstruktu <span class="inlinecode"><span class="id" title="keyword">fix</span></span> lub
    komendy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" title="keyword">fix</span></span> jest bardzo prymitywna i prawie nigdy nie jest używana,
    tak samo jak konstrukt <span class="inlinecode"><span class="id" title="keyword">fix</span></span> (najbardziej poręczne są sposoby, które
    widzieliśmy w przykladach 2 i 3), ale była dobrym pretekstem, żeby
    omówić wszystkie sposoby użycia rekursji w jednym miejscu. 
<div class="paragraph"> </div>

<a id="lab752"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span> i <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">inversion</span></span></h2>

<div class="paragraph"> </div>

 Taktyki <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span> i <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> są związane z
    pojęciem indukcji funkcyjnej. Dość szczegółowy opis tej pierwszej jest
    w notatkach na seminarium: https://zeimer.github.io/Seminar.html#lab247

<div class="paragraph"> </div>

    Drugą z nich póki co pominiemy. Kiedyś z pewnością napiszę coś więcej
    o indukcji funkcyjnej lub chociaż przetłumaczę zalinkowane notatki na
    polski. 
<div class="paragraph"> </div>

<a id="lab753"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> to taktyka będąca przeciwieństwem <span class="inlinecode"><span class="id" title="tactic">intro</span></span> — dzięki
    niej możemy przerzucić rzeczy znajdujące się w kontekście z powrotem do
    kontekstu. Nieformalnie odpowiada ona sposobowi rozumowania: aby pokazać,
    że cel zachodzi dla pewnego konkretnego <span class="inlinecode"><span class="id" title="var">x</span></span>, wystarczy czy pokazać, że
    zachodzi dla dowolnego <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    W rozumowaniu tym z twierdzenia bardziej ogólnego wyciągamy wniosek, że
    zachodzi twierdzenie bardziej szczegółowe. Nazwa <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> bierze się
    stąd, że w dedukcji naturalnej nasze rozumowania przeprowadzamy "od tyłu".
    Człon "dependent" bierze się stąd, że żeby zgeneralizować <span class="inlinecode"><span class="id" title="var">x</span></span>, musimy
    najpierw zgeneralizować wszystkie obiekty, które są od niego zależne. Na
    szczęście taktyka <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> robi to za nas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">generalize_dependent_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = <span class="id" title="var">m</span> -&gt; <span class="id" title="var">m</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Użycie <span class="inlinecode"><span class="id" title="tactic">intros</span></span> wprowadza do kontekstu <span class="inlinecode"><span class="id" title="var">n</span></span>, <span class="inlinecode"><span class="id" title="var">m</span></span> i <span class="inlinecode"><span class="id" title="var">H</span></span>. <span class="inlinecode"><span class="id" title="tactic">generalize</span></span>
    <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> przenosi <span class="inlinecode"><span class="id" title="var">n</span></span> z powrotem do celu, ale wymaga to, aby do
    celu przenieść również <span class="inlinecode"><span class="id" title="var">H</span></span>, gdyż typ <span class="inlinecode"><span class="id" title="var">H</span></span>, czyli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, zależy od <span class="inlinecode"><span class="id" title="var">n</span></span>. 
<div class="paragraph"> </div>

<a id="lab754"></a><h4 class="section">Ćwiczenie (generalize i revert)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> jest wariantem taktyki <span class="inlinecode"><span class="id" title="tactic">generalize</span></span>. Taktyką o
    niemal identycznym działaniu jest <span class="inlinecode"><span class="id" title="var">revert</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>, wariant taktyki
    <span class="inlinecode"><span class="id" title="var">revert</span></span>. Przeczytaj dokumentację <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> i <span class="inlinecode"><span class="id" title="var">revert</span></span> w manualu i
    sprawdź, jak działają. 
<div class="paragraph"> </div>

<a id="lab755"></a><h4 class="section">Ćwiczenie (my_rec)</h4>

<div class="paragraph"> </div>

 Zaimplementuj taktykę <span class="inlinecode"><span class="id" title="keyword">rec</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, która będzie pomagała przy dowodzeniu
    bezpośrednio przez rekursję po <span class="inlinecode"><span class="id" title="var">x</span></span>. Taktyka <span class="inlinecode"><span class="id" title="keyword">rec</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> ma działać jak
    <span class="inlinecode"><span class="id" title="keyword">fix</span></span> <span class="inlinecode"><span class="id" title="var">IH</span></span> <span class="inlinecode"><span class="id" title="var">n</span>;</span> <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> to pozycja argumentu <span class="inlinecode"><span class="id" title="var">x</span></span> w celu. Twoja
    taktyka powinna działać tak, żeby poniższy dowód zadziałał bez potrzeby
    wprowadzania modyfikacji.

<div class="paragraph"> </div>

    Wskazówka: połącz taktyki <span class="inlinecode"><span class="id" title="keyword">fix</span></span>, <span class="inlinecode"><span class="id" title="tactic">intros</span></span>, <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> i
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm_rec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + 1 = <span class="id" title="var">S</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">rec</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab756"></a><h1 class="section">Taktyki dla równości i równoważności</h1>

<div class="paragraph"> </div>

<a id="lab757"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span> i <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">reflexivity_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;= <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Znasz już taktykę <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. Mogłoby się wydawać, że służy ona do
    udowadniania celów postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> i jest w zasadzie równoważna taktyce
    <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>, ale nie jest tak. Taktyka <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> potrafi rozwiązać
    każdy cel postaci <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span> jest relacją zwrotną, a <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> są
    konwertowalne (oczywiście pod warunkiem, że udowodnimy wcześniej, że <span class="inlinecode"><span class="id" title="var">R</span></span>
    faktycznie jest zwrotna; w powyższym przykładzie odpowiedni fakt został
    zaimportowany z modułu <span class="inlinecode"><span class="id" title="var">Arith</span></span>).

<div class="paragraph"> </div>

    Żeby zilustrować ten fakt, zdefiniujmy nową relację zwrotną i zobaczmy,
    jak użyć taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> do radzenia sobie z nią. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eq_ext</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
W tym celu definiujemy relację <span class="inlinecode"><span class="id" title="var">eq_ext</span></span>, która głosi, że funkcja
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest w relacji z funkcją <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, jeżeli <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
    jest równe <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> dla dowolnego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">RelationClasses</span>.<br/>

<br/>
</div>

<div class="doc">
Moduł <span class="inlinecode"><span class="id" title="var">RelationClasses</span></span> zawiera definicję zwrotności <span class="inlinecode"><span class="id" title="var">Reflexive</span></span>, z której
    korzysta taktyka <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. Jeżeli udowodnimy odpowiednie twierdzenie,
    będziemy mogli używać taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> z relacją <span class="inlinecode"><span class="id" title="var">eq_ext</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Instance</span> <span class="id" title="var">Reflexive_eq_ext</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">Reflexive</span> (@<span class="id" title="var">eq_ext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Reflexive</span>, <span class="id" title="var">eq_ext</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
A oto i rzeczone twierdzenie oraz jego dowód. Zauważmy, że taktyki
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> nie używamy tutaj z relacją <span class="inlinecode"><span class="id" title="var">eq_ext</span></span>, a z relacją <span class="inlinecode">=</span>,
    gdyż używamy jej na celu postaci <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Uwaga: żeby taktyka <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> "widziała" ten dowód, musimy skorzystać
    ze słowa kluczowego <span class="inlinecode">#[<span class="id" title="tactic">refine</span>]</span>
<span class="inlinecode"><span class="id" title="keyword">Instance</span></span> zamiast z <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">reflexivity_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">eq_ext</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">nat</span> =&gt; 42) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">nat</span> =&gt; 21 + 21).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Voilà ! Od teraz możemy używać taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> z relacją <span class="inlinecode"><span class="id" title="var">eq_ext</span></span>.

<div class="paragraph"> </div>

    Są jeszcze dwie taktyki, które czasem przydają się przy dowodzeniu
    równości (oraz równoważności). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">symmetry_transitivity_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">nat</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">z</span> -&gt; <span class="id" title="var">z</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">transitivity</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby się wydawać, że taktyka <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span> zamienia cel postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>
    na <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>, zaś taktyka <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> rozwiązuje cel postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">z</span></span>
    i generuje w zamian dwa cele postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">z</span></span>. Rzeczywistość
    jest jednak bardziej hojna: podobnie jak w przypadku <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>,
    taktyki te działają z dowolnymi relacjami symetrycznymi i przechodnimi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Instance</span> <span class="id" title="var">Symmetric_eq_ext</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">Symmetric</span> (@<span class="id" title="var">eq_ext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Symmetric</span>, <span class="id" title="var">eq_ext</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Instance</span> <span class="id" title="var">Transitive_eq_ext</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">Transitive</span> (@<span class="id" title="var">eq_ext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Transitive</span>, <span class="id" title="var">eq_ext</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> <span class="id" title="var">H</span> <span class="id" title="var">H'</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">transitivity</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>); [<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> | <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>].<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Użycie w dowodach taktyk <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span> i <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span> jest legalne, gdyż
    nie używamy ich z relacją <span class="inlinecode"><span class="id" title="var">eq_ext</span></span>, a z relacją <span class="inlinecode">=</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">symmetry_transitivity_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_ext</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> -&gt; <span class="id" title="var">eq_ext</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> -&gt; <span class="id" title="var">eq_ext</span> <span class="id" title="var">h</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">transitivity</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Dzięki powyższym twierdzeniom możemy teraz posługiwać się taktykami
    <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span> i <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span> dowodząc faktów na temat relacji <span class="inlinecode"><span class="id" title="var">eq_ext</span></span>.
    To jednak wciąż nie wyczerpuje naszego arsenału taktyk do radzenia sobie
    z relacjami równoważności. 
<div class="paragraph"> </div>

<a id="lab758"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">f_equal</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="tactic">f_equal</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;f_equal&nbsp;:&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B)&nbsp;(x&nbsp;y&nbsp;:&nbsp;A),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;f&nbsp;x&nbsp;=&nbsp;f&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> to jedna z podstawowych właściwości relacji <span class="inlinecode"><span class="id" title="var">eq</span></span>, która głosi,
    że wszystkie funkcje zachowują równość. Innymi słowy: aby pokazać, że
    wartości zwracane przez funkcję są równe, wystarczy pokazać, że argumenty
    są równe. Ten sposób rozumowania, choć nie jest ani jedyny, ani skuteczny
    na wszystkie cele postaci <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, jest wystarczająco częsty, aby mieć
    swoją własną taktykę, którą zresztą powinieneś już dobrze znać — jest nią
    <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>.

<div class="paragraph"> </div>

    Taktyka ta sprowadza się w zasadzie do jak najsprytniejszego aplikowania
    faktu <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>. Nie potrafi ona wprowadzać zmiennych do kontekstu, a z
    wygenerowanych przez siebie podcelów rozwiązuje jedynie te postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>,
    ale nie potrafi rozwiązać tych, które zachodzą na mocy założenia. 
<div class="paragraph"> </div>

<a id="lab759"></a><h4 class="section">Ćwiczenie (my_f_equal)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_f_equal</span></span>, która działa jak <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> na sterydach, tj.
    poza standardową funkcjonalnością <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> potrafi też wprowadzać zmienne
    do kontekstu oraz rozwiązywać cele prawdziwe na mocy założenia.

<div class="paragraph"> </div>

    Użyj tylko jednej klauzuli <span class="inlinecode"><span class="id" title="keyword">match</span></span>a. Nie używaj taktyki <span class="inlinecode"><span class="id" title="tactic">subst</span></span>. Bonus:
    wykorzystaj kombinator <span class="inlinecode"><span class="id" title="tactic">first</span></span>, ale nie wciskaj go na siłę. Z czego
    łatwiej jest skorzystać: rekursji czy iteracji? 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">f_equal_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Nie&nbsp;działa,&nbsp;bo&nbsp;<span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span>&nbsp;nie&nbsp;jest&nbsp;podcelem<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wygenerowanym&nbsp;przez&nbsp;<span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>.&nbsp;*)</span><br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_f_equal</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">f_equal_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">f_equal</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_f_equal</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">f_equal_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span> <span class="id" title="var">E</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> <span class="id" title="var">f'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span> -&gt; <span class="id" title="var">D</span> -&gt; <span class="id" title="var">E</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a</span> <span class="id" title="var">a'</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> <span class="id" title="var">b'</span> : <span class="id" title="var">B</span>) (<span class="id" title="var">c</span> <span class="id" title="var">c'</span> : <span class="id" title="var">C</span>) (<span class="id" title="var">d</span> <span class="id" title="var">d'</span> : <span class="id" title="var">D</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> = <span class="id" title="var">f'</span> -&gt; <span class="id" title="var">a</span> = <span class="id" title="var">a'</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">b'</span> -&gt; <span class="id" title="var">c</span> = <span class="id" title="var">c'</span> -&gt; <span class="id" title="var">d</span> = <span class="id" title="var">d'</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> = <span class="id" title="var">f'</span> <span class="id" title="var">a'</span> <span class="id" title="var">b'</span> <span class="id" title="var">c'</span> <span class="id" title="var">d'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_f_equal</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab760"></a><h4 class="section">Ćwiczenie (właściwości <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>)</h4>

<div class="paragraph"> </div>

 Przyjrzyj się definicjom <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>, <span class="inlinecode"><span class="id" title="var">id</span></span>, <span class="inlinecode"><span class="id" title="var">compose</span></span>, <span class="inlinecode"><span class="id" title="var">eq_sym</span></span>, <span class="inlinecode"><span class="id" title="var">eq_trans</span></span>,
    a następnie udowodnij poniższe lematy. Ich sens na razie niech pozostanie
    ukryty — kiedyś być może napiszę coś na ten temat. Jeżeli intrygują cię
    one, przyjrzyj się książce https://homotopytypetheory.org/book/ 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Coq.Program.Basics</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="tactic">f_equal</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eq_sym</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eq_trans</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">compose</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">f_equal_properties</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">q</span> : <span class="id" title="var">y</span> = <span class="id" title="var">z</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_equal_refl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">x</span>) = <span class="id" title="var">eq_refl</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_equal_id</span> :<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span> <span class="id" title="var">id</span> <span class="id" title="var">p</span> = <span class="id" title="var">p</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">f_equal_compose</span> :<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span> <span class="id" title="var">g</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> <span class="id" title="var">p</span>) = <span class="id" title="tactic">f_equal</span> (<span class="id" title="var">compose</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span>) <span class="id" title="var">p</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eq_sym_map_distr</span> :<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> (<span class="id" title="var">eq_sym</span> <span class="id" title="var">p</span>) = <span class="id" title="var">eq_sym</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> <span class="id" title="var">p</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eq_trans_map_distr</span> :<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> (<span class="id" title="var">eq_trans</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>) = <span class="id" title="var">eq_trans</span> (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> <span class="id" title="var">p</span>) (<span class="id" title="tactic">f_equal</span> <span class="id" title="var">f</span> <span class="id" title="var">q</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">f_equal_properties</span>.<br/>

<br/>
</div>

<div class="doc">
Ostatnią taktyką, którą poznamy w tym podrozdziale, jest <span class="inlinecode"><span class="id" title="var">f_equiv</span></span>, czyli
    pewne uogólnienie taktyki <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>. Niech nie zmyli cię nazwa tej taktyki
    — bynajmniej nie przydaje się ona jedynie do rozumowań dotyczących relacji
    równoważności. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Classes.Morphisms</span>.<br/>

<br/>
</div>

<div class="doc">
Aby móc używać tej taktyki, musimy najpierw zaimportować moduł
    <span class="inlinecode"><span class="id" title="var">Classes.Morphisms</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">len_eq</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> <span class="id" title="var">l1</span> = <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>
</div>

<div class="doc">
W naszym przykładzie posłużymy się relacją <span class="inlinecode"><span class="id" title="var">len_eq</span></span>, która głosi, że
    dwie listy są w relacji gdy mają taką samą długość. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Instance</span> <span class="id" title="var">Proper_len_eq_map</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} :<br/>
&nbsp;&nbsp;<span class="id" title="var">Proper</span> (@<span class="id" title="var">len_eq</span> <span class="id" title="var">A</span> ==&gt; @<span class="id" title="var">len_eq</span> <span class="id" title="var">A</span> ==&gt; @<span class="id" title="var">len_eq</span> <span class="id" title="var">A</span>) (@<span class="id" title="var">app</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Locate</span> "==&gt;".<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Proper</span>, <span class="id" title="var">respectful</span>, <span class="id" title="var">len_eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">x</span> <span class="id" title="var">xs</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">inversion</span> 1; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHxs</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> działa na celach postaci <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">f</span></span> jest
    dowolne, albowiem wszystkie funkcje zachowują równość. Analogicznie
    taktyka <span class="inlinecode"><span class="id" title="var">f_equiv</span></span> działa na celach postaci <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span>)</span>, gdzie <span class="inlinecode"><span class="id" title="var">R</span></span>
    jest dowolną relacją, ale tylko pod warunkiem, że funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> zachowuje
    relację <span class="inlinecode"><span class="id" title="var">R</span></span>.

<div class="paragraph"> </div>

    Musi tak być, bo gdyby <span class="inlinecode"><span class="id" title="var">f</span></span> nie zachowywała <span class="inlinecode"><span class="id" title="var">R</span></span>, to mogłoby jednocześnie
    zachodzić <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> oraz <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span>)</span>, a wtedy sposób rozumowania
    analogiczny do tego z twierdzenia <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> byłby niepoprawny.

<div class="paragraph"> </div>

    Aby taktyka <span class="inlinecode"><span class="id" title="var">f_equiv</span></span> "widziała", że <span class="inlinecode"><span class="id" title="var">f</span></span> zachowuje <span class="inlinecode"><span class="id" title="var">R</span></span>, musimy znów
    posłużyć się komendą <span class="inlinecode"><span class="id" title="keyword">Instance</span></span> i użyć <span class="inlinecode"><span class="id" title="var">Proper</span></span>, które służy do
    zwięzłego wyrażania, które konkretnie relacje i w jaki sposób zachowuje
    dana funkcja.

<div class="paragraph"> </div>

    W naszym przypadku będziemy chcieli pokazać, że jeżeli listy <span class="inlinecode"><span class="id" title="var">l1</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">l1'</span></span> są w relacji <span class="inlinecode"><span class="id" title="var">len_eq</span></span> (czyli mają taką samą długość) i podobnie
    dla <span class="inlinecode"><span class="id" title="var">l2</span></span> oraz <span class="inlinecode"><span class="id" title="var">l2'</span></span>, to wtedy konkatenacja <span class="inlinecode"><span class="id" title="var">l1</span></span> i <span class="inlinecode"><span class="id" title="var">l2</span></span> jest w relacji
    <span class="inlinecode"><span class="id" title="var">len_eq</span></span> z konkatenacją <span class="inlinecode"><span class="id" title="var">l1'</span></span> i <span class="inlinecode"><span class="id" title="var">l2'</span></span>. Ten właśnie fakt jest wyrażany
    przez zapis <span class="inlinecode"><span class="id" title="var">Proper</span></span> <span class="inlinecode">(@<span class="id" title="var">len_eq</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">@<span class="id" title="var">len_eq</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">@<span class="id" title="var">len_eq</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(@<span class="id" title="var">app</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>.

<div class="paragraph"> </div>

    Należy też zauważyć, że strzałka <span class="inlinecode">==&gt;</span> jest jedynie notacją dla tworu
    zwanego <span class="inlinecode"><span class="id" title="var">respectful</span></span>, co możemy łatwo sprawdzić komendą <span class="inlinecode"><span class="id" title="keyword">Locate</span>.</span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">f_equiv_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l1'</span> <span class="id" title="var">l2</span> <span class="id" title="var">l2'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">len_eq</span> <span class="id" title="var">l1</span> <span class="id" title="var">l1'</span> -&gt; <span class="id" title="var">len_eq</span> <span class="id" title="var">l2</span> <span class="id" title="var">l2'</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">len_eq</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) (<span class="id" title="var">l1'</span> ++ <span class="id" title="var">l2'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">f_equiv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Voilà! Teraz możemy używać taktyki <span class="inlinecode"><span class="id" title="var">f_equiv</span></span> z relacją <span class="inlinecode"><span class="id" title="var">len_eq</span></span> oraz
    funkcją <span class="inlinecode"><span class="id" title="var">app</span></span> dokładnie tak, jak taktyki <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> z równością oraz
    dowolną funkcją.

<div class="paragraph"> </div>

    Trzeba przyznać, że próba użycia <span class="inlinecode"><span class="id" title="var">f_equiv</span></span> z różnymi kombinacjami
    relacji i funkcji może zakończyć się nagłym i niekontrolowanym
    rozmnożeniem lematów mówiących o tym, że funkcje zachowują relacje.
    Niestety, nie ma na to żadnego sposobu — jak przekonaliśmy się wyżej,
    udowodnienie takiego lematu to jedyny sposób, aby upewnić się, że nasz
    sposób rozumowania jest poprawny. 
<div class="paragraph"> </div>

<a id="lab761"></a><h4 class="section">Ćwiczenie (f_equiv_filter)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">stupid_id</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">true</span>) <span class="id" title="var">l</span>.<br/>

<br/>
</div>

<div class="doc">
Oto niezbyt mądry sposób na zapisanie funkcji identycznościowej na
    listach typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Pokaż, że <span class="inlinecode"><span class="id" title="var">stupid_id</span></span> zachowuje relację <span class="inlinecode"><span class="id" title="var">len_eq</span></span>,
    tak aby poniższy dowód zadziałał bez wpowadzania zmian. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">f_equiv_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">len_eq</span> <span class="id" title="var">l</span> <span class="id" title="var">l'</span> -&gt; <span class="id" title="var">len_eq</span> (<span class="id" title="var">stupid_id</span> <span class="id" title="var">l</span>) (<span class="id" title="var">stupid_id</span> <span class="id" title="var">l'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">f_equiv</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab762"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">rewrite</span></span></h2>

<div class="paragraph"> </div>

 Powinieneś być już nieźle wprawiony w używaniu taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. Czas
    najwyższy więc opisać wszystkie jej możliwości.

<div class="paragraph"> </div>

    Podstawowe wywołanie tej taktyki ma postać <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">H</span></span> jest
    typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x_1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A_1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">x_n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A_n</span>),</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">t_1</span></span> <span class="inlinecode"><span class="id" title="var">t_2</span></span>, zaś <span class="inlinecode"><span class="id" title="var">R</span></span> to <span class="inlinecode"><span class="id" title="var">eq</span></span>
    lub dowolna relacja równoważności. Przypomnijmy, że relacja równoważności
    to relacja, która jest zwrotna, symetryczna i przechodnia.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> znajduje pierwszy podterm celu, który pasuje do <span class="inlinecode"><span class="id" title="var">t_1</span></span> i
    zamienia go na <span class="inlinecode"><span class="id" title="var">t_2</span></span>, generując podcele <span class="inlinecode"><span class="id" title="var">A_1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">A_n</span></span>, z których
    część (a często całość) jest rozwiązywana automatycznie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">plus_n_Sm</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;plus_n_Sm&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;(n&nbsp;+&nbsp;m)&nbsp;=&nbsp;n&nbsp;+&nbsp;S&nbsp;m&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Goal</span> 2 + 3 = 6 -&gt; 4 + 4 = 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- !<span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">rewrite</span> &lt;- !<span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- ?<span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 4!<span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- 3?<span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">plus_n_Sm</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższy skrajnie bezsensowny przykład ilustruje fakt, że działanie
    taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> możemy zmieniać, poprzedzając hipotezę <span class="inlinecode"><span class="id" title="var">H</span></span> następującymi
    modyfikatorami:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">H</span></span> oznacza to samo, co <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span> <span class="inlinecode"><span class="id" title="var">H</span></span> zamienia pierwsze wystąpienie <span class="inlinecode"><span class="id" title="var">t_2</span></span> na <span class="inlinecode"><span class="id" title="var">t_1</span></span>, czyli
      przepisuje z prawa na lewo

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">?<span class="id" title="var">H</span></span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> 0 lub więcej razy

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">n</span>?<span class="id" title="var">H</span></span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> co najwyżej n razy

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">!<span class="id" title="var">H</span></span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> 1 lub więcej razy

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">n</span>!<span class="id" title="var">H</span></span> lub <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> dokładnie n razy 
</li>
</ul>

<div class="paragraph"> </div>

 Zauważmy, że modyfikator <span class="inlinecode">&lt;-</span> można łączyć z modyfikatorami określającymi
    ilość przepisań. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rewrite_ex_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, 42 = 42 -&gt; <span class="id" title="var">S</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) = <span class="id" title="var">n</span> + <span class="id" title="var">S</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">plus_n_Sm</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> 2 + 3 = 6 -&gt; 5 + 5 = 12 -&gt; (4 + 4) + ((5 + 5) + (6 + 6)) = 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span>, &lt;- <span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span> <span class="id" title="tactic">in</span> * |-.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> !<span class="id" title="var">plus_n_Sm</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">rewrite_ex_1</span>. 2: <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">rewrite_ex_1</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pozostałe warianty taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> przedstawiają się następująco:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H_1</span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">H_n</span></span> przepisuje kolejno hipotezy <span class="inlinecode"><span class="id" title="var">H_1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">H_n</span></span>.
      Każdą z hipotez możemy poprzedzić osobnym zestawem modyfikatorów.

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">H'</span></span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> nie w celu, ale w hipotezie <span class="inlinecode"><span class="id" title="var">H'</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode">*</span> <span class="inlinecode">|-</span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> we wszystkich hipotezach
      różnych od <span class="inlinecode"><span class="id" title="var">H</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode">*</span> przepisuje <span class="inlinecode"><span class="id" title="var">H</span></span> we wszystkich hipotezach różnych
      od <span class="inlinecode"><span class="id" title="var">H</span></span> oraz w celu

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">by</span></span> <span class="inlinecode"><span class="id" title="var">tac</span></span> działa jak <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, ale używa taktyki <span class="inlinecode"><span class="id" title="var">tac</span></span> do
      rozwiązania tych podcelów, które nie mogły zostać rozwiązane
      automatycznie 
</li>
</ul>

<div class="paragraph"> </div>

 Jest jeszcze wariant <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> (wymagający zaimportowania modułu
    <span class="inlinecode"><span class="id" title="var">Setoid</span></span>), który zamienia n-te (licząc od lewej) wystąpienie <span class="inlinecode"><span class="id" title="var">t_1</span></span> na
    <span class="inlinecode"><span class="id" title="var">t_2</span></span>. Zauważmy, że <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> znaczy to samo, co <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode">1</span>. 
<div class="paragraph"> </div>

<a id="lab763"></a><h1 class="section">Taktyki dla redukcji i obliczeń (TODO)</h1>

<div class="paragraph"> </div>

<a id="lab764"></a><h1 class="section">Procedury decyzyjne</h1>

<div class="paragraph"> </div>

 Procedury decyzyjne to taktyki, które potrafią zupełnie same rozwiązywać
    cele należące do pewnej konkretnej klasy, np. cele dotyczące funkcji
    boolowskich albo nierówności liniowych na liczbach całkowitych. W tym
    podrozdziale omówimy najprzydatniejsze z nich. 
<div class="paragraph"> </div>

<a id="lab765"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">btauto</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">btauto</span></span> to taktyka, która potrafi rozwiązywać równania boolowskie, czyli
    cele postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> są wyrażeniami mogącymi zawierać
    boolowskie koniunkcje, dysjunkcje, negacje i inne rzeczy (patrz manual).

<div class="paragraph"> </div>

    Taktykę można zaimportować komendą <span class="inlinecode"><span class="id" title="keyword">Require</span></span> <span class="inlinecode"><span class="id" title="keyword">Import</span></span> <span class="inlinecode"><span class="id" title="var">Btauto</span></span>. Uwaga: nie
    potrafi ona wprowadzać zmiennych do kontekstu. 
<div class="paragraph"> </div>

<a id="lab766"></a><h4 class="section">Ćwiczenie (my_btauto)</h4>

<div class="paragraph"> </div>

 Napisz następujące taktyki:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">my_btauto</span></span> — taktyka podobna do <span class="inlinecode"><span class="id" title="var">btauto</span></span>. Potrafi rozwiązywać cele,
      które są kwantyfikowanymi równaniami na wyrażeniach boolowskich,
      składającymi się z dowolnych funkcji boolowskich (np. <span class="inlinecode"><span class="id" title="var">andb</span></span>, <span class="inlinecode"><span class="id" title="var">orb</span></span>).
      W przeciwieństwie do <span class="inlinecode"><span class="id" title="var">btauto</span></span> powinna umieć wprowadzać zmienne do
      kontekstu.

</li>
<li> <span class="inlinecode"><span class="id" title="var">my_btauto_rec</span></span> — tak samo jak <span class="inlinecode"><span class="id" title="var">my_btauto</span></span>, ale bez używana
      kombinatora <span class="inlinecode"><span class="id" title="tactic">repeat</span></span>. Możesz używać jedynie rekurencji.

</li>
<li> <span class="inlinecode"><span class="id" title="var">my_btauto_iter</span></span> — tak samo jak <span class="inlinecode"><span class="id" title="var">my_btauto</span></span>, ale bez używania
      rekurencji. Możesz używać jedynie kombinatora <span class="inlinecode"><span class="id" title="tactic">repeat</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">my_btauto_no_intros</span></span> — tak samo jak <span class="inlinecode"><span class="id" title="var">my_btauto</span></span>, ale bez używania
      taktyk <span class="inlinecode"><span class="id" title="tactic">intro</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">intros</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Uwaga: twoja implementacja taktyki <span class="inlinecode"><span class="id" title="var">my_btauto</span></span> będzie diametralnie różnić
    się od implementacji taktyki <span class="inlinecode"><span class="id" title="var">btauto</span></span> z biblioteki standardowej. <span class="inlinecode"><span class="id" title="var">btauto</span></span>
    jest zaimplementowana za pomocą reflekcji. Dowód przez reflekcję omówimy
    później. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">my_btauto</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Bool</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Btauto</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_dist_orb</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">b1</span> &amp;&amp; (<span class="id" title="var">b2</span> || <span class="id" title="var">b3</span>) = (<span class="id" title="var">b1</span> &amp;&amp; <span class="id" title="var">b2</span>) || (<span class="id" title="var">b1</span> &amp;&amp; <span class="id" title="var">b3</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">btauto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto_rec</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto_iter</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto_no_intros</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_if</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">negb</span> (<span class="id" title="keyword">if</span> <span class="id" title="var">b1</span> <span class="id" title="keyword">then</span> <span class="id" title="var">b2</span> <span class="id" title="keyword">else</span> <span class="id" title="var">b3</span>) = <span class="id" title="keyword">if</span> <span class="id" title="var">negb</span> <span class="id" title="var">b1</span> <span class="id" title="keyword">then</span> <span class="id" title="var">negb</span> <span class="id" title="var">b3</span> <span class="id" title="keyword">else</span> <span class="id" title="var">negb</span> <span class="id" title="var">b2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">btauto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto_rec</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto_iter</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_btauto_no_intros</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Przetestuj działanie swoich taktyk na reszcie twierdzeń z rozdziału
    o logice boolowskiej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">my_btauto</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab767"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">congruence</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">congruence_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">true</span> &lt;&gt; <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">congruence</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">congruence_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>) (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">a</span> = <span class="id" title="var">f</span> <span class="id" title="var">a</span> -&gt; <span class="id" title="var">g</span> <span class="id" title="var">b</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) = <span class="id" title="var">f</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) -&gt; <span class="id" title="var">g</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> = <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">g</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> = <span class="id" title="var">a</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">congruence</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">congruence_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> * <span class="id" title="var">A</span>) (<span class="id" title="var">a</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> = <span class="id" title="var">pair</span> <span class="id" title="var">a</span> -&gt; <span class="id" title="var">Some</span> (<span class="id" title="var">f</span> <span class="id" title="var">c</span>) = <span class="id" title="var">Some</span> (<span class="id" title="var">f</span> <span class="id" title="var">d</span>) -&gt; <span class="id" title="var">c</span> = <span class="id" title="var">d</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">congruence</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">congruece</span></span> to taktyka, która potrafi rozwiązywać cele dotyczące
    nieinterpretowanych równości, czyli takie, których prawdziwość zależy
    jedynie od hipotez postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> i które można udowodnić ręcznie za
    pomocą mniejszej lub większej ilości <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>'ów. <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> potrafi
    też rozwiązywać cele dotyczące konstruktorów. W szczególności wie ona,
    że konstruktory są injektywne i potrafi odróżnić <span class="inlinecode"><span class="id" title="var">true</span></span> od <span class="inlinecode"><span class="id" title="var">false</span></span>. 
<div class="paragraph"> </div>

<a id="lab768"></a><h4 class="section">Ćwiczenie (congruence)</h4>

<div class="paragraph"> </div>

 Udowodnij przykłady <span class="inlinecode"><span class="id" title="var">congruence_1</span></span> i <span class="inlinecode"><span class="id" title="var">congruence_2</span></span> ręcznie. 
<div class="paragraph"> </div>

<a id="lab769"></a><h4 class="section">Ćwiczenie (discriminate)</h4>

<div class="paragraph"> </div>

 Inną taktyką, która potrafi rozróżniać konstruktory, jest <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>.
    Zbadaj, jak działa ta taktyka. Znajdź przykład celu, który <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>
    rozwiązuje, a na którym <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> zawodzi. Wskazówka: <span class="inlinecode"><span class="id" title="tactic">congruence</span></span>
    niebardzo potrafi odwijać definicje. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab770"></a><h4 class="section">Ćwiczenie (injection i simplify_eq)</h4>

<div class="paragraph"> </div>

 Kolejne dwie taktyki do walki z konstruktorami typów induktywnych to
    <span class="inlinecode"><span class="id" title="tactic">injection</span></span> i <span class="inlinecode"><span class="id" title="var">simplify_eq</span></span>. Przeczytaj ich opisy w manualu. Zbadaj,
    czy są one w jakikolwiek sposób przydatne (wskazówka: porównaj je z
    taktykami <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> i <span class="inlinecode"><span class="id" title="tactic">congruence</span></span>. 
<div class="paragraph"> </div>

<a id="lab771"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">decide</span></span> <span class="inlinecode"><span class="id" title="var">equality</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c0</span> : <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c1</span> : <span class="id" title="var">C</span> -&gt; <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c2</span> : <span class="id" title="var">C</span> -&gt; <span class="id" title="var">C</span> -&gt; <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c3</span> : <span class="id" title="var">C</span> -&gt; <span class="id" title="var">C</span> -&gt; <span class="id" title="var">C</span> -&gt; <span class="id" title="var">C</span>.<br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy się powyższemu, dosć enigmatycznemu typowi. Czy posiada on
    rozstrzygalną równość? Odpowiedź jest twierdząca: rozstrzygalną równość
    posiada każdy typ induktywny, którego konstruktory nie biorą argumentów
    będących dowodami, funkcjami ani termami typów zależnych. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">C_eq_dec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">C</span>, {<span class="id" title="var">x</span> = <span class="id" title="var">y</span>} + {<span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">y</span>}.<br/>

<br/>
</div>

<div class="doc">
Zanim przejdziesz dalej, udowodnij ręcznie powyższe twierdzenie. Przyznasz,
    że dowód nie jest zbyt przyjemny, prawda? Na szczęście nie musimy robić go
    ręcznie. Na ratunek przychodzi nam taktyka <span class="inlinecode"><span class="id" title="var">decide</span></span> <span class="inlinecode"><span class="id" title="var">equality</span></span>, która umie
    udowadniać cele postaci <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span>}</span> <span class="inlinecode">+</span> <span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">y</span>}</span>, gdzie <span class="inlinecode"><span class="id" title="var">T</span></span>
    spełnia warunki wymienione powyżej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">C_eq_dec'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">C</span>, {<span class="id" title="var">x</span> = <span class="id" title="var">y</span>} + {<span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">y</span>}.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">decide</span> <span class="id" title="var">equality</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab772"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Pokrewną taktyce <span class="inlinecode"><span class="id" title="var">decide</span></span> <span class="inlinecode"><span class="id" title="var">equality</span></span> jest taktyka <span class="inlinecode"><span class="id" title="var">compare</span></span>. Przeczytaj
    w manualu, co robi i jak działa. 
<div class="paragraph"> </div>

<a id="lab773"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">omega</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">omega</span></span> to taktyka, która potrafi rozwiązywać cele dotyczące arytmetyki
    Presburgera. Jej szerszy opis można znaleźć w manualu. Na nasze potrzeby
    przez arytmetykę Presburgera możemy rozumieć równania (<span class="inlinecode">=</span>), nie-równania
    (<span class="inlinecode">&lt;&gt;</span>) oraz nierówności (<span class="inlinecode">&lt;</span>, <span class="inlinecode">&lt;=</span>, <span class="inlinecode">&gt;</span>, <span class="inlinecode">&gt;=</span>) na typie <span class="inlinecode"><span class="id" title="var">nat</span></span>, które mogą
    zawierać zmienne, <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="var">S</span></span>, dodawanie i mnożenie przez stałą. Dodatkowo
    zdania tej postaci mogą być połączone spójnikami <span class="inlinecode">/\</span>, <span class="inlinecode">\/</span>, <span class="inlinecode">-&gt;</span> oraz
    <span class="inlinecode">~</span>, ale nie mogą być kwantyfikowane — <span class="inlinecode"><span class="id" title="tactic">omega</span></span> nie umie wprowadzać
    zmiennych do kontekstu.

<div class="paragraph"> </div>

    Uwaga: ta taktyka jest przestarzała, a jej opis znajduje się tutaj tylko
    dlatego, że jak go pisałem, to jeszcze nie była. Nie używaj jej! Zamiast
    <span class="inlinecode"><span class="id" title="tactic">omega</span></span> używaj <span class="inlinecode"><span class="id" title="var">lia</span></span>! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span> <span class="id" title="var">Omega</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">omega_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">n</span> = 2 * <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">omega</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">omega_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, 2 * <span class="id" title="var">n</span> + 1 &lt;&gt; 2 * <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">omega</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">omega_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> * <span class="id" title="var">m</span> = <span class="id" title="var">m</span> * <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Jedną z wad taktyki <span class="inlinecode"><span class="id" title="tactic">omega</span></span> jest rozmiar generowanych przez nią termów.
    Są tak wielkie, że wszelkie próby rozwinięcia definicji czy dowodów,
    które zostały przy jej pomocy skonstruowane, muszą z konieczności źle
    się skończyć. Zobaczmy to na przykładzie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">filter_length</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">filter</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span>) &lt;= <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>); <span class="id" title="var">cbn</span>; <span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">filter_length</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Proofterm&nbsp;o&nbsp;długości&nbsp;317&nbsp;linijek.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Oto jedna ze standardowych właściwości list: filtrowanie nie zwiększa
    jej rozmiaru. Term skonstruowany powyższym dowodem, będący świadkiem
    tego faktu, liczy sobie 317 linijek długości (po wypisaniu, wklejeniu
    do CoqIDE i usunięciu tego, co do termu nie należy). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">filter_length'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">filter</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span>) &lt;= <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_n_S</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">length</span> <span class="id" title="var">l</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_S</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">filter_length'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Proofterm&nbsp;o&nbsp;długości&nbsp;14&nbsp;linijek.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, ręczny dowód tego faktu daje w wyniku proofterm, który jest
    o ponad 300 linijek krótszy niż ten wyprodukowany przez taktykę <span class="inlinecode"><span class="id" title="tactic">omega</span></span>.
    Mogłoby się zdawać, że jesteśmy w sytuacji bez wyjścia: albo dowodzimy
    ręcznie, albo prooftermy będą tak wielkie, że nie będziemy mogli ich
    odwijać. 
<div class="paragraph"> </div>

<a id="lab774"></a><h2 class="section">Procedury decyzyjne dla logiki</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">tauto_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id" title="var">A</span> \/ ~ <span class="id" title="var">B</span> \/ ~ <span class="id" title="var">C</span> \/ ~ <span class="id" title="var">D</span> -&gt; ~ (<span class="id" title="var">A</span> /\ <span class="id" title="var">B</span> /\ <span class="id" title="var">C</span> /\ <span class="id" title="var">D</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">tauto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">tauto_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = 0 \/ <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">n</span> &lt;&gt; 0 -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">tauto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">tauto</span></span> to taktyka, która potrafi udowodnić każdą tautologię
    konstruktywnego rachunku zdań. Taktyka ta radzi sobie także z niektórymi
    nieco bardziej skomplikowanymi celami, w tym takimi, których nie potrafi
    udowodnić <span class="inlinecode"><span class="id" title="tactic">auto</span></span>. <span class="inlinecode"><span class="id" title="tactic">tauto</span></span> zawodzi, gdy nie potrafi udowodnić celu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">intuition_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">A</span> \/ (<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, ~ <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span>) -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, ~ ~ (<span class="id" title="var">A</span> \/ <span class="id" title="var">P</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">tauto</span>. <span class="id" title="tactic">intuition</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">intuition</span></span> to <span class="inlinecode"><span class="id" title="tactic">tauto</span></span> na sterydach — potrafi rozwiązać nieco więcej
    celów, a poza tym nigdy nie zawodzi. Jeżeli nie potrafi rozwiązać celu,
    upraszcza go.

<div class="paragraph"> </div>

    Może też przyjmować argument: <span class="inlinecode"><span class="id" title="tactic">intuition</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> najpierw upraszcza cel, a
    później próbuje go rozwiązać taktyką <span class="inlinecode"><span class="id" title="var">t</span></span>. Tak naprawdę <span class="inlinecode"><span class="id" title="tactic">tauto</span></span> jest
    jedynie synonimem dla <span class="inlinecode"><span class="id" title="tactic">intuition</span></span> <span class="inlinecode"><span class="id" title="tactic">fail</span></span>, zaś samo <span class="inlinecode"><span class="id" title="tactic">intuition</span></span> to synonim
    <span class="inlinecode"><span class="id" title="tactic">intuition</span></span> <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">*</span>, co też tłumaczy, dlaczego <span class="inlinecode"><span class="id" title="tactic">intuition</span></span> potrafi
    więcej niż <span class="inlinecode"><span class="id" title="tactic">tauto</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Record</span> <span class="id" title="var">and3</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span> : <span class="id" title="var">P</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mid</span> : <span class="id" title="var">Q</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span> : <span class="id" title="var">R</span>;<br/>
}.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">firstorder_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">and3</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) <span class="id" title="var">B</span> <span class="id" title="var">B</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">and3</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">y</span>) (<span class="id" title="var">P</span> 0) (<span class="id" title="var">P</span> 0) \/ <span class="id" title="var">B</span> /\ <span class="id" title="var">P</span> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intuition</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">firstorder</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">firstorder_1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">exists</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt; ~ <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">tauto</span>. <span class="id" title="tactic">intuition</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">firstorder</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jednak nawet <span class="inlinecode"><span class="id" title="tactic">intuition</span></span> nie jest w stanie sprostać niektórym prostym
    dla człowieka celom — powyższy przykład pokazuje, że nie potrafi ona
    posługiwać się niestandardowymi spójnikami logicznymi, takimi jak
    potrójna koniunkcja <span class="inlinecode"><span class="id" title="var">and3</span></span>.

<div class="paragraph"> </div>

    Najpotężniejszą taktyką potrafiącą dowodzić tautologii jest <span class="inlinecode"><span class="id" title="tactic">firstorder</span></span>.
    Nie tylko rozumie ona niestandardowe spójniki (co i tak nie ma większego
    praktycznego znaczenia), ale też świetnie radzi sobie z kwantyfikatorami.
    Drugi z powyższych przykładów pokazuje, że potrafi ona dowodzić tautologii
    konstruktywnego rachunku predykatów, z którymi problem ma <span class="inlinecode"><span class="id" title="tactic">intuition</span></span>. 
<div class="paragraph"> </div>

<a id="lab775"></a><h4 class="section">Ćwiczenie (my_tauto)</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_tauto</span></span>, która będzie potrafiła rozwiązać jak najwięcej
    tautologii konstruktywnego rachunku zdań.

<div class="paragraph"> </div>

    Wskazówka: połącz taktyki z poprzednich ćwiczeń. Przetestuj swoją taktykę
    na ćwiczeniach z rozdziału pierwszego — być może ujawni to problemy, o
    których nie pomyślałeś.

<div class="paragraph"> </div>

    Nie używaj żadnej zaawansowanej automatyzacji. Użyj jedynie <span class="inlinecode"><span class="id" title="tactic">unfold</span></span>,
    <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, <span class="inlinecode"><span class="id" title="tactic">repeat</span></span>, <span class="inlinecode"><span class="id" title="keyword">match</span></span>, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, <span class="inlinecode"><span class="id" title="tactic">clear</span></span>, <span class="inlinecode"><span class="id" title="tactic">exact</span></span>, <span class="inlinecode"><span class="id" title="tactic">split</span></span>,
    <span class="inlinecode"><span class="id" title="tactic">specialize</span></span> i <span class="inlinecode"><span class="id" title="tactic">apply</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab776"></a><h1 class="section">Ogólne taktyki automatyzacyjne</h1>

<div class="paragraph"> </div>

 W tym podrozdziale omówimy pozostałe taktyki przydające się przy
    automatyzacji. Ich cechą wspólną jest rozszerzalność — za pomocą
    specjalnych baz podpowiedzi będziemy mogli nauczyć je radzić sobie
    z każdym celem. 
<div class="paragraph"> </div>

<a id="lab777"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">auto</span></span> i <span class="inlinecode"><span class="id" title="tactic">trivial</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest najbardziej ogólną taktyką służącą do automatyzacji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span> <span class="id" title="var">E</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>) -&gt; (<span class="id" title="var">C</span> -&gt; <span class="id" title="var">D</span>) -&gt; (<span class="id" title="var">D</span> -&gt; <span class="id" title="var">E</span>) -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">E</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">auto</span></span> potrafi używać założeń, aplikować hipotezy i zna podstawowe
    własności równości — całkiem nieźle. Wprawdzie nie wystarczy to do
    udowodnienia żadnego nietrywialnego twierdzenia, ale przyda się z
    pewnością do rozwiązywania prostych podcelów generowanych przez
    inne taktyki. Często spotykanym idiomem jest <span class="inlinecode"><span class="id" title="var">t</span>;</span> <span class="inlinecode"><span class="id" title="tactic">auto</span></span> — "użyj
    taktyki <span class="inlinecode"><span class="id" title="var">t</span></span> i pozbądź się prostych podcelów za pomocą <span class="inlinecode"><span class="id" title="tactic">auto</span></span>". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">auto_ex4</span>.<br/>

<br/>
<span class="id" title="keyword">Parameter</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Parameter</span> <span class="id" title="var">p</span> : <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex4</span> : <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span> <span class="id" title="keyword">using</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widać na powyższym przykładzie, <span class="inlinecode"><span class="id" title="tactic">auto</span></span> nie widzi aksjomatów (ani
    definicji/lematów/twierdzeń etc.), nawet jeżeli zostały zadeklarowane
    dwie linijki wyżej. Tej przykrej sytuacji możemy jednak łatwo zaradzić,
    pisząc <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">t_1</span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">t_n</span></span>. Ten wariant taktyki <span class="inlinecode"><span class="id" title="tactic">auto</span></span>
    widzi definicje termów <span class="inlinecode"><span class="id" title="var">t_1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">t_n</span></span>.

<div class="paragraph"> </div>

    Co jednak w sytuacji, gdy będziemy wielokrotnie chcieli, żeby <span class="inlinecode"><span class="id" title="tactic">auto</span></span>
    widziało pewne definicje? Nietrudno wyobrazić sobie ogrom pisaniny,
    którą mogłoby spowodować użycie do tego celu klauzuli <span class="inlinecode"><span class="id" title="keyword">using</span></span>. Na
    szczęście możemy temu zaradzić za pomocą podpowiedzi, które bytują
    w specjalnych bazach. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">p</span> : <span class="id" title="var">my_hint_db</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex4'</span> : <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">my_hint_db</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Resolve</span></span> <span class="inlinecode"><span class="id" title="var">ident</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">db_name</span></span> dodaje lemat o nazwie <span class="inlinecode"><span class="id" title="var">ident</span></span>
    do bazy podpowiedzi o nazwie <span class="inlinecode"><span class="id" title="var">db_name</span></span>. Dzięki temu taktyka <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span>
    <span class="inlinecode"><span class="id" title="var">db_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">db_n</span></span> widzi wszystkie lematy dodane do baz <span class="inlinecode"><span class="id" title="var">db_1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">db_n</span></span>.
    Jeżeli to dla ciebie wciąż zbyt wiele pisania, uszy do góry! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex4''</span> : <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> *. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">*</span> widzi wszystkie możliwe bazy podpowiedzi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">p</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex4'''</span> : <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Resolve</span></span> <span class="inlinecode"><span class="id" title="var">ident</span></span> dodaje lemat o nazwie <span class="inlinecode"><span class="id" title="var">ident</span></span> do bazy
    podpowiedzi o nazwie <span class="inlinecode"><span class="id" title="var">core</span></span>. Taktyka <span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest zaś równoważna
    taktyce <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">core</span></span>. Dzięki temu nie musimy pisać już nic ponad
    zwykłe <span class="inlinecode"><span class="id" title="tactic">auto</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">auto_ex4</span>.<br/>

<br/>
</div>

<div class="doc">
Tym oto sposobem, używając komendy <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Resolve</span></span>, jesteśmy w stanie
    zaznajomić <span class="inlinecode"><span class="id" title="tactic">auto</span></span> z różnej maści lematami i twierdzeniami, które
    udowodniliśmy. Komendy tej możemy używać po każdym lemacie, dzięki
    czemu taktyka <span class="inlinecode"><span class="id" title="tactic">auto</span></span> rośnie w siłę w miarę rozwoju naszej teorii. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex5</span> : <span class="id" title="var">even</span> 8.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span> <span class="id" title="keyword">using</span> <span class="id" title="var">even0</span>, <span class="id" title="var">evenSS</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną słabością <span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest fakt, że taktyka ta nie potrafi budować
    wartości typów induktywnych. Na szczęście możemy temu zaradzić używając
    klauzuli <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">c_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">c_n</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">c_1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">c_n</span></span> są konstruktorami
    naszego typu, lub dodając je jako podpowiedzi za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Hint</span></span>
    <span class="inlinecode"><span class="id" title="keyword">Resolve</span></span> <span class="inlinecode"><span class="id" title="var">c_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">c_n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">db_name</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Constructors</span> <span class="id" title="var">even</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex5'</span> : <span class="id" title="var">even</span> 8.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Żeby jednak za dużo nie pisać (wypisanie nazw wszystkich konstruktorów
    mogłoby być bolesne), możemy posłużyć się komendą <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Constructors</span></span>
    <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">db_name</span></span>, która dodaje konstruktory typu induktywnego <span class="inlinecode"><span class="id" title="var">I</span></span> do bazy
    podpowiedzi <span class="inlinecode"><span class="id" title="var">db_name</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex6</span> : <span class="id" title="var">even</span> 10.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span> 6.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejnym celem, wobec którego <span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest bezsilne, jest <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">10</span>.
    Jak widać, nie wystarczy dodać konstruktorów typu induktywnego jako
    podpowiedzi, żeby wszystko było cacy. Niemoc <span class="inlinecode"><span class="id" title="tactic">auto</span></span> wynika ze sposobu
    działania tej taktyki. Wykonuje ona przeszukiwanie w głąb z nawrotami,
    które działa mniej więcej tak:
<ul class="doclist">
<li> zrób pierwszy lepszy możliwy krok dowodu

</li>
<li> jeżeli nie da się nic więcej zrobić, a cel nie został udowodniony,
      wykonaj nawrót i spróbuj czegoś innego

</li>
<li> w przeciwnym wypadku wykonaj następny krok dowodu i powtarzaj
      całą procedurę 
</li>
</ul>

<div class="paragraph"> </div>

 Żeby ograniczyć czas poświęcony na szukanie dowodu, który może być
    potencjalnie bardzo długi, <span class="inlinecode"><span class="id" title="tactic">auto</span></span> ogranicza się do wykonania jedynie
    kilku kroków w głąb (domyślnie jest to 5). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">auto_ex5'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;evenSS&nbsp;6&nbsp;(evenSS&nbsp;4&nbsp;(evenSS&nbsp;2&nbsp;(evenSS&nbsp;0&nbsp;even0)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;even&nbsp;8&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">auto_ex6</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;evenSS&nbsp;8&nbsp;(evenSS&nbsp;6&nbsp;(evenSS&nbsp;4&nbsp;(evenSS&nbsp;2&nbsp;(evenSS&nbsp;0&nbsp;even0))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;even&nbsp;10&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest w stanie udowodnić <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">8</span>, gdyż dowód tego faktu wymaga
    jedynie 5 kroków, mianowicie czeterokrotnego zaaplikowania konstruktora
    <span class="inlinecode"><span class="id" title="var">evenSS</span></span> oraz jednokrotnego zaaplikowania <span class="inlinecode"><span class="id" title="var">even0</span></span>. Jednak 5 kroków nie
    wystarcza już, by udowodnić <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">10</span>, gdyż tutaj dowód liczy sobie 6
    kroków: 5 użyć <span class="inlinecode"><span class="id" title="var">evenSS</span></span> oraz 1 użycie <span class="inlinecode"><span class="id" title="var">even0</span></span>.

<div class="paragraph"> </div>

    Nie wszystko jednak stracone — możemy kontrolować głębokość, na jaką
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> zapuszcza się, poszukując dowodu, piząc <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Zauważmy, że
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest równoważne taktyce <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode">5</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex7</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">z</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">auto</span> <span class="id" title="keyword">using</span> <span class="id" title="var">eq_trans</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejnym problemem taktyki <span class="inlinecode"><span class="id" title="tactic">auto</span></span> jest udowodnienie, że równość jest
    relacją przechodnią. Tym razem jednak problem jest poważniejszy, gdyż
    nie pomaga nawet próba użycia klauzuli <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">eq_trans</span></span>, czyli wskazanie
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> dokładnie tego samego twierdzenia, którego próbujemy dowieść!

<div class="paragraph"> </div>

    Powód znów jest dość prozaiczny i wynika ze sposobu działania taktyki
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> oraz postaci naszego celu. Otóż konkluzja celu jest postaci
    <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">z</span></span>, czyli występują w niej zmienne <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">z</span></span>, zaś kwantyfikujemy
    nie tylko po <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">z</span></span>, ale także po <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

    Wywnioskowanie, co wstawić za <span class="inlinecode"><span class="id" title="var">A</span></span> nie stanowi problemu, gdyż musi to
    być typ <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">z</span></span>. Problemem jest jednak zgadnięcie, co wstawić za <span class="inlinecode"><span class="id" title="var">y</span></span>,
    gdyż w ogólności możliwości może być wiele (nawet nieskończenie wiele).
    Taktyka <span class="inlinecode"><span class="id" title="tactic">auto</span></span> działa w ten sposób, że nawet nie próbuje tego zgadywać. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Extern</span> 0 =&gt;<br/>
<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : ?<span class="id" title="var">x</span> = ?<span class="id" title="var">y</span>, <span class="id" title="var">H'</span> : ?<span class="id" title="var">y</span> = ?<span class="id" title="var">z</span> |- ?<span class="id" title="var">x</span> = ?<span class="id" title="var">z</span> =&gt; <span class="id" title="tactic">apply</span> (@<span class="id" title="var">eq_trans</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>)<br/>
<span class="id" title="keyword">end</span> : <span class="id" title="var">extern_db</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex7</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">z</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">z</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">extern_db</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jest jednak sposób, żeby uporać się i z tym problemem: jest nim komenda
    <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Extern</span></span>. Jej ogólna postać to <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Extern</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="tactic">pattern</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">tactic</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">db</span></span>.
    W jej wyniku do bazy podpowiedzi <span class="inlinecode"><span class="id" title="var">db</span></span> zostanie dodana podpowiedź, która
    sprawi, że w dowolnym momencie dowodu taktyka <span class="inlinecode"><span class="id" title="tactic">auto</span></span>, jeżeli wypróbowała
    już wszystkie podpowiedzi o koszcie mniejszym niż <span class="inlinecode"><span class="id" title="var">n</span></span> i cel pasuje do
    wzorca <span class="inlinecode"><span class="id" title="tactic">pattern</span></span>, to spróbuje użyć taktyki <span class="inlinecode"><span class="id" title="var">tac</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku koszt podpowiedzi wynosi 0, a więc podpowiedź będzie
    odpalana niemal na samym początku dowodu. Wzorzec <span class="inlinecode"><span class="id" title="tactic">pattern</span></span> został
    pominięty, a więc <span class="inlinecode"><span class="id" title="tactic">auto</span></span> użyje naszej podpowiedzi niezależnie od tego,
    jak wygląda cel. Ostatecznie jeżeli w konktekście będą odpowiednie
    równania, to zaaplikowany zostanie lemat <span class="inlinecode">@<span class="id" title="var">eq_trans</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>, wobec
    czego wygenerowane zostaną dwa podcele, <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> oraz <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">z</span></span>, które
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> będzie potrafiło rozwiązać już bez naszej pomocy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Extern</span> 0 (?<span class="id" title="var">x</span> = ?<span class="id" title="var">z</span>) =&gt;<br/>
<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : ?<span class="id" title="var">x</span> = ?<span class="id" title="var">y</span>, <span class="id" title="var">H'</span> : ?<span class="id" title="var">y</span> = ?<span class="id" title="var">z</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">apply</span> (@<span class="id" title="var">eq_trans</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">auto_ex7'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">z</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">z</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A tak wygląda wersja <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Extern</span></span>, w której nie pominięto wzorca
    <span class="inlinecode"><span class="id" title="tactic">pattern</span></span>. Jest ona rzecz jasna równoważna z poprzednią.

<div class="paragraph"> </div>

    Jest to dobry moment, by opisać dokładniej działanie taktyki <span class="inlinecode"><span class="id" title="tactic">auto</span></span>.
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> najpierw próbuje rozwiązać cel za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">assumption</span></span>.
    Jeżeli się to nie powiedzie, to <span class="inlinecode"><span class="id" title="tactic">auto</span></span> używa taktyki <span class="inlinecode"><span class="id" title="tactic">intros</span></span>, a
    następnie dodaje do tymczasowej bazy podpowiedzi wszystkie hipotezy.
    Następnie przeszukuje ona bazę podpowiedzi dopasowując cel do wzorca
    stowarzyszonego z każdą podpowiedzią, zaczynając od podpowiedzi o
    najmniejszym koszcie (podpowiedzi pochodzące od komend <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Resolve</span></span>
    oraz <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Constructors</span></span> są skojarzone z pewnymi domyślnymi kosztami
    i wzorcami). Następnie <span class="inlinecode"><span class="id" title="tactic">auto</span></span> rekurencyjnie wywołuje się na podcelach
    (chyba, że przekroczona została maksymalna głębokość przeszukiwania —
    wtedy następuje nawrót). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial_ex0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">trivial</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial_ex1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span> <span class="id" title="var">E</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>) -&gt; (<span class="id" title="var">C</span> -&gt; <span class="id" title="var">D</span>) -&gt; (<span class="id" title="var">D</span> -&gt; <span class="id" title="var">E</span>) -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">E</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">trivial</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial_ex2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">trivial</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial_ex3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">trivial</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial_ex5</span> : <span class="id" title="var">even</span> 0.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">trivial</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial_ex5'</span> : <span class="id" title="var">even</span> 8.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">trivial</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>, którą już znasz, działa dokładnie tak samo jak <span class="inlinecode"><span class="id" title="tactic">auto</span></span>,
    ale jest nierekurencyjna. To tłumaczy, dlaczego potrafi ona posługiwać
    się założeniami i zna właciwości równości, ale nie umie używać implikacji
    i nie radzi sobie z celami pokroju <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">8</span>, mimo że potrafi udowodnić
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>. 
<div class="paragraph"> </div>

<a id="lab778"></a><h4 class="section">Ćwiczenie (auto i trivial)</h4>

<div class="paragraph"> </div>

 Przeczytaj w manualu dokładny opis działania taktyk <span class="inlinecode"><span class="id" title="tactic">auto</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>:
    https://coq.inria.fr/refman/proof-engine/tactics.htmlcoq:tacn.auto 
<div class="paragraph"> </div>

<a id="lab779"></a><h2 class="section"><span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> i <span class="inlinecode"><span class="id" title="var">autounfold</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> to bardzo pożyteczna taktyka umożliwiająca zautomatyzowanie
    części dowodów opierających się na przepisywaniu.

<div class="paragraph"> </div>

    Dlaczego tylko części? Zastanówmy się, jak zazwyczaj przebiegają dowody
    przez przepisywanie. W moim odczuciu są dwa rodzaje takich dowodów:
<ul class="doclist">
<li> dowody pierwszego rodzaju to te, w których wszystkie przepisania mają
      charakter upraszczający i dzięki temu możemy przepisywać zupełnie
      bezmyślnie

</li>
<li> dowody drugiego rodzaju to te, w których niektóre przepisania nie mają
      charakteru upraszczającego albo muszą zostać wykonane bardzo precyzyjnie.
      W takich przypadkach nie możemy przepisywać bezmyślnie, bo grozi to
      zapętleniem taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> lub po prostu porażką 
</li>
</ul>

<div class="paragraph"> </div>

 Dowody pierwszego rodzaju ze względu na swoją bezmyślność są dobrymi
    kandydatami do automatyzacji. Właśnie tutaj do gry wkracza taktyka
    <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">autorewrite_ex</span>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> <span class="id" title="var">l4</span> <span class="id" title="var">l5</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Zacznijmy od przykładu (a raczej ćwiczenia): udowodnij poniższe
    twierdzenie. Następnie udowodnij je w jednej linijce. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">autorewrite_intro</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l2</span> ++ <span class="id" title="var">rev</span> <span class="id" title="var">l3</span>) ++ <span class="id" title="var">rev</span> <span class="id" title="var">l4</span>) ++ <span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l5</span>)) =<br/>
&nbsp;&nbsp;(<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l5</span> ++ <span class="id" title="var">l1</span>)) ++ (<span class="id" title="var">l3</span> ++ <span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l2</span>))) ++ <span class="id" title="var">rev</span> <span class="id" title="var">l4</span>.<br/>

<br/>
</div>

<div class="doc">
Ten dowód nie był zbyt twórczy ani przyjemny, prawda? Wyobraź sobie
    teraz, co by było, gdybyś musiał udowodnić 100 takich twierdzeń (i
    to w czasach, gdy jeszcze nie można było pisać <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">?<span class="id" title="var">t_0</span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode">?<span class="id" title="var">t_n</span></span>).
    Jest to dość ponura wizja. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <span class="id" title="var">rev_app_distr</span> <span class="id" title="var">rev_involutive</span> : <span class="id" title="var">list_rw</span>.<br/>
<span class="id" title="keyword">Hint Rewrite</span> &lt;- <span class="id" title="var">app_assoc</span> : <span class="id" title="var">list_rw</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">autorewrite_ex</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l2</span> ++ <span class="id" title="var">rev</span> <span class="id" title="var">l3</span>) ++ <span class="id" title="var">rev</span> <span class="id" title="var">l4</span>) ++ <span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l5</span>)) =<br/>
&nbsp;&nbsp;(<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l5</span> ++ <span class="id" title="var">l1</span>)) ++ (<span class="id" title="var">l3</span> ++ <span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l2</span>))) ++ <span class="id" title="var">rev</span> <span class="id" title="var">l4</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">list_rw</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">autorewrite_ex</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Rewrite</span></span> <span class="inlinecode">[&lt;-]</span> <span class="inlinecode"><span class="id" title="var">ident_0</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">ident_n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">db_name</span></span> dodaje
    podpowiedzi <span class="inlinecode"><span class="id" title="var">ident_0</span></span>, ..., <span class="inlinecode"><span class="id" title="var">ident_n</span></span> do bazy podpowidzi <span class="inlinecode"><span class="id" title="var">db_nam</span></span>.
    Domyślnie będą one przepisywane z lewa na prawo, chyba że dodamy
    przełącznik <span class="inlinecode">&lt;-</span> — wtedy wszystkie będą przepisywane z prawa na
    lewo. W szczególności znaczy to, że jeżeli chcemy niektóre lematy
    przepisywać w jedną stronę, a inne w drugą, to musimy komendy
    <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Rewrite</span></span> użyć dwukrotnie.

<div class="paragraph"> </div>

    Sama taktyka <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">db_0</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">db_n</span></span> przepisuje lematy ze
    wszystkich baz podpowiedzi <span class="inlinecode"><span class="id" title="var">db_0</span></span>, ..., <span class="inlinecode"><span class="id" title="var">db_n</span></span> tak długo, jak to
    tylko możliwe (czyli tak długo, jak przepisywanie skutkuje dokonaniem
    postępu).

<div class="paragraph"> </div>

    Jest kilka ważnych cech, które powinna posiadać baza podpowiedzi:
<ul class="doclist">
<li> przede wszystkim nie może zawierać tego samego twierdzenia do
      przepisywania w obydwie strony. Jeżeli tak się stanie, taktyka
      <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> się zapętli, gdyż przepisanie tego twierdzenia w
      jedną lub drugą stronę zawsze będzie możliwe

</li>
<li> w ogólności, nie może zawierać żadnego zbioru twierdzeń, których
      przepisywanie powoduje zapętlenie

</li>
<li> baza powinna być deterministyczna, tzn. jedne przepisania nie
      powinny blokować kolejnych

</li>
<li> wszystkie przepisywania powinny być upraszczające 
</li>
</ul>

<div class="paragraph"> </div>

 Oczywiście dwa ostatnie kryteria nie są zbyt ścisłe — ciężko sprawdzić
    determinizm systemu przepisywania, zaś samo pojęcie "uproszczenia" jest
    bardzo zwodnicze i niejasne. 
<div class="paragraph"> </div>

<a id="lab780"></a><h4 class="section">Ćwiczenie (autorewrite)</h4>

<div class="paragraph"> </div>

 Przeczytaj opis taktyki <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> w manualu:
    coq.inria.fr/refman/proof-engine/tactics.htmlcoq:tacn.autorewrite 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">autounfold_ex</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wut</span> : <span class="id" title="var">nat</span> := 1.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wut'</span> : <span class="id" title="var">nat</span> := 1.<br/>

<br/>
<span class="id" title="keyword">Hint Unfold</span> <span class="id" title="var">wut</span> <span class="id" title="var">wut'</span> : <span class="id" title="var">wut_db</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">autounfold_ex</span> : <span class="id" title="var">wut</span> = <span class="id" title="var">wut'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">autounfold</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">autounfold</span> <span class="id" title="keyword">with</span> <span class="id" title="var">wut_db</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Na koniec omówimy taktykę <span class="inlinecode"><span class="id" title="var">autounfold</span></span>. Działa ona na podobnej zasadzie
    jak <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span>. Za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Unfold</span></span> dodajemy definicje do
    do bazy podpowiedzi, dzięki czemu taktyka <span class="inlinecode"><span class="id" title="var">autounfold</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">db_0</span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">db_n</span></span>
    potrafi odwinąć wszystkie definicje z baz <span class="inlinecode"><span class="id" title="var">db_0</span></span>, ..., <span class="inlinecode"><span class="id" title="var">db_n</span></span>.

<div class="paragraph"> </div>

    Jak pokazuje nasz głupi przykład, jest ona średnio użyteczna, gdyż taktyka
    <span class="inlinecode"><span class="id" title="tactic">auto</span></span> potrafi (przynajmniej do pewnego stopnia) odwijać definicje. Moim
    zdaniem najlepiej sprawdza się ona w zestawieniu z taktyką <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span>
    i kombinatorem <span class="inlinecode"><span class="id" title="tactic">repeat</span></span>, gdy potrzebujemy na przemian przepisywać lematy
    i odwijać definicje. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">autounfold_ex</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab781"></a><h4 class="section">Ćwiczenie (autounfold)</h4>

<div class="paragraph"> </div>

 Przeczytaj w manualu opis taktyki <span class="inlinecode"><span class="id" title="var">autounfold</span></span>:
    coq.inria.fr/refman/proof-engine/tactics.htmlcoq:tacn.autounfold 
<div class="paragraph"> </div>

<a id="lab782"></a><h4 class="section">Ćwiczenie (bazy podpowiedzi)</h4>

<div class="paragraph"> </div>

 Przeczytaj w manualu dokładny opis działania systemu baz podpowiedzi
    oraz komend pozwalających go kontrolować:
    coq.inria.fr/refman/proof-engine/tactics.htmlcontrolling-automation 
<div class="paragraph"> </div>

<a id="lab783"></a><h1 class="section">Pierścienie, ciała i arytmetyka</h1>

<div class="paragraph"> </div>

 Pierścień (ang. ring) to struktura algebraiczna składająca się z pewnego
    typu A oraz działań + i *, które zachowują się mniej więcej tak, jak
    dodawanie i mnożenie liczb całkowitych. Przykładów jest sporo: liczby
    wymierne i rzeczywiste z dodawaniem i mnożeniem, wartości boolowskie z
    dysjunkcją i koniunkcją oraz wiele innych, których na razie nie wymienię.

<div class="paragraph"> </div>

    Kiedyś z pewnością napiszę coś na temat algebry oraz pierścieni, ale z
    taktykami do radzenia sobie z nimi możemy zapoznać się już teraz. W Coqu
    dostępne są dwie taktyki do radzenia sobie z pierścieniami: taktyka
    <span class="inlinecode"><span class="id" title="var">ring_simplify</span></span> potrafi upraszczać wyrażenia w pierścieniach, zaś taktyka
    <span class="inlinecode"><span class="id" title="tactic">ring</span></span> potrafi rozwiązywać równania wielomianowe w pierścieniach.

<div class="paragraph"> </div>

    Ciało (ang. field) to pierścień na sterydach, w którym poza dodawaniem,
    odejmowaniem i mnożeniem jest także dzielenie. Przykładami ciał są
    liczby wymierne oraz liczby rzeczywiste, ale nie liczby naturalne ani
    całkowite (bo dzielenie naturalne/całkowitoliczbowe nie jest odwrotnością
    mnożenia). Je też kiedyś pewnie opiszę.

<div class="paragraph"> </div>

    W Coqu są 3 taktyki pomagające w walce z ciałami: <span class="inlinecode"><span class="id" title="var">field_simplify</span></span>
    upraszcza wyrażenia w ciałach, <span class="inlinecode"><span class="id" title="var">field_simplify_eq</span></span> upraszcza cele,
    które są równaniami w ciałach, zaś <span class="inlinecode"><span class="id" title="tactic">field</span></span> rozwiązuje równania w
    ciałach. 
<div class="paragraph"> </div>

<a id="lab784"></a><h4 class="section">Ćwiczenie (pierścienie i ciała)</h4>

<div class="paragraph"> </div>

 Przyczytaj w manualu opis 5 wymienionych wyżej taktyk:
    https://coq.inria.fr/refman/addendum/ring.html 
<div class="paragraph"> </div>

<a id="lab785"></a><h1 class="section">Zmienne egzystencjalne i ich taktyki (TODO)</h1>

<div class="paragraph"> </div>

 Napisać o co chodzi ze zmiennymi egzystencjalnymi. Opisać taktykę
    <span class="inlinecode"><span class="id" title="tactic">evar</span></span> i wspomnieć o taktykach takich jak <span class="inlinecode"><span class="id" title="tactic">eauto</span></span>, <span class="inlinecode"><span class="id" title="tactic">econstructor</span></span>,
    <span class="inlinecode"><span class="id" title="tactic">eexists</span></span>, <span class="inlinecode"><span class="id" title="var">edestruct</span></span>, <span class="inlinecode"><span class="id" title="var">erewrite</span></span> etc., a także taktykę <span class="inlinecode"><span class="id" title="var">shelve</span></span>
    i komendę <span class="inlinecode"><span class="id" title="var">Unshelve</span></span>. 
<div class="paragraph"> </div>

<a id="lab786"></a><h1 class="section">Taktyki do radzenia sobie z typami zależnymi (TODO)</h1>

<div class="paragraph"> </div>

 Opisać taktyki <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>, <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>,
    <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">destruction</span></span>, <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> etc. 
<div class="paragraph"> </div>

<a id="lab787"></a><h1 class="section">Dodatkowe ćwiczenia</h1>

<div class="paragraph"> </div>

<a id="lab788"></a><h4 class="section">Ćwiczenie (assert)</h4>

<div class="paragraph"> </div>

 Znasz już taktyki <span class="inlinecode"><span class="id" title="tactic">assert</span></span>, <span class="inlinecode"><span class="id" title="tactic">cut</span></span> i <span class="inlinecode"><span class="id" title="tactic">specialize</span></span>. Okazuje się, że dwie
    ostatnie są jedynie wariantami taktyki <span class="inlinecode"><span class="id" title="tactic">assert</span></span>. Przeczytaj w manualu
    opis taktyki <span class="inlinecode"><span class="id" title="tactic">assert</span></span> i wszystkich jej wariantów. 
<div class="paragraph"> </div>

<a id="lab789"></a><h4 class="section">Ćwiczenie (easy i now)</h4>

<div class="paragraph"> </div>

 Taktykami, których nie miałem nigdy okazji użyć, są <span class="inlinecode"><span class="id" title="var">easy</span></span> i jej
    wariant <span class="inlinecode"><span class="id" title="var">now</span></span>. Przeczytaj ich opisy w manualu. Zbadaj, czy są do
    czegokolwiek przydatne oraz czy są wygodne w porównaniu z innymi
    taktykami służącymi do podobnych celów. 
<div class="paragraph"> </div>

<a id="lab790"></a><h4 class="section">Ćwiczenie (inversion_sigma)</h4>

<div class="paragraph"> </div>

 Przeczytaj w manualu o wariantach taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>. Szczególnie
    interesująca wydaje się taktyka <span class="inlinecode"><span class="id" title="var">inversion_sigma</span></span>, która pojawiła
    się w wersji 8.7 Coqa. Zbadaj ją. Wymyśl jakiś przykład jej użycia. 
<div class="paragraph"> </div>

<a id="lab791"></a><h4 class="section">Ćwiczenie (pattern)</h4>

<div class="paragraph"> </div>

 Przypomnijmy, że podstawą wszelkich obliczeń w Coqu jest redkucja
    beta. Redukuje ona aplikację funkcji, np. <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">42</span>
    betaredukuje się do <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode">42</span>. Jej wykonywanie jest jednym z głównych
    zadań taktyk obliczeniowych.

<div class="paragraph"> </div>

    Przeciwieństwem redukcji beta jest ekspansja beta. Pozwala ona zamienić
    dowolny term na aplikację jakiejś funkcji do jakiegoś argumentu, np.
    term <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode">42</span> można betaekspandować do <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">42</span>.

<div class="paragraph"> </div>

    O ile redukcja beta jest trywialna do automatycznego wykonania, o tyle
    ekspansja beta już nie, gdyż występuje tu duża dowolność. Dla przykładu,
    term <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode">42</span> można też betaekspandować do <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode">42)</span> <span class="inlinecode">2</span>.

<div class="paragraph"> </div>

    Ekspansję beta implementuje taktyka <span class="inlinecode"><span class="id" title="tactic">pattern</span></span>. Rozumowanie za jej pomocą
    nie jest zbyt częstne, ale niemniej jednak kilka razy mi się przydało.
    Przeczytaj opis taktyki <span class="inlinecode"><span class="id" title="tactic">pattern</span></span> w manuaulu.

<div class="paragraph"> </div>

    TODO: być może ćwiczenie to warto byłoby rozszerzyć do pełnoprawnego
    podrozdziału. 
<div class="paragraph"> </div>

<a id="lab792"></a><h4 class="section">Ćwiczenie (arytmetyka)</h4>

<div class="paragraph"> </div>

 Poza taktykami radzącymi sobie z pierścieniami i ciałami jest też wiele
    taktyk do walki z arytmetyką. Poza omówioną już taktyką <span class="inlinecode"><span class="id" title="tactic">omega</span></span> są to
    <span class="inlinecode"><span class="id" title="var">lia</span></span>, <span class="inlinecode"><span class="id" title="var">nia</span></span>, <span class="inlinecode"><span class="id" title="var">lra</span></span>, <span class="inlinecode"><span class="id" title="var">nra</span></span>. Nazwy taktyk można zdekodować w następujący
    sposób:
<ul class="doclist">
<li> l — linear

</li>
<li> n — nonlinar

</li>
<li> i — integer

</li>
<li> r — real/rational

</li>
<li> a — arithmetic 
</li>
</ul>

<div class="paragraph"> </div>

 Spróbuj ogarnąć, co one robią:
    https://coq.inria.fr/refman/addendum/micromega.html 
<div class="paragraph"> </div>

<a id="lab793"></a><h4 class="section">Ćwiczenie (wyższa magia)</h4>

<div class="paragraph"> </div>

 Spróbuj ogarnąć, co robią taktyki <span class="inlinecode"><span class="id" title="var">nsatz</span></span>, <span class="inlinecode"><span class="id" title="var">psatz</span></span> i <span class="inlinecode"><span class="id" title="var">fourier</span></span>. 
<div class="paragraph"> </div>

<a id="lab794"></a><h1 class="section">Inne języki taktyk</h1>

<div class="paragraph"> </div>

 Ltac w pewnym sensie nie jest jedynym językiem taktyk, jakiego możemy
    użyć do dowodzenia w Coqu — są inne. Głównymi konkurentami Ltaca są:
<ul class="doclist">
<li> Rtac: gmalecha.github.io/reflections/2016/rtac-technical-overview

</li>
<li> Mtac: plv.mpi-sws.org/mtac/

</li>
<li> ssreflect:
      https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html
      oraz https://math-comp.github.io/math-comp/ 
</li>
</ul>

<div class="paragraph"> </div>

 Pierwsze dwa, <span class="inlinecode"><span class="id" title="var">Rtac</span></span> i <span class="inlinecode"><span class="id" title="var">Mtac</span></span>, faktycznie są osobnymi językami taktyk,
    znacznie różniącymi się od Ltaca. Nie będziemy się nimi zajmować,
    gdyż ich droga do praktycznej użyteczności jest jeszcze dość długa.

<div class="paragraph"> </div>

    ssreflect to nieco inna bajka. Nie jest on w zasadzie osobnym językiem
    taktyk, lecz jest oparty na Ltacu. Różni się on od niego filozofią,
    podstawowym zestawem taktyk i stylem dowodzenia. Od wersji 8.7 Coqa
    język ten jet dostępny w bibliotece standardowej, mimo że nie jest z
    nią w pełni kompatybilny. 
<div class="paragraph"> </div>

<a id="lab795"></a><h4 class="section">Ćwiczenie (ssreflect)</h4>

<div class="paragraph"> </div>

 Najbardziej wartościowym moim zdaniem elementem języka ssreflect jest
    taktyka <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, dużo potężniejsza od tej opisanej w tym rozdziale.
    Jest ona warta uwagi, gdyż:
<ul class="doclist">
<li> daje jeszcze większą kontrolę nad przepisywaniem, niż standardowa
      taktyka <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>

</li>
<li> pozwala łączyć kroki przepisywania z odwijaniem definicji i wykonywaniem
      obliczeń, a więc zastępuje taktyki <span class="inlinecode"><span class="id" title="tactic">unfold</span></span>, <span class="inlinecode"><span class="id" title="tactic">fold</span></span>, <span class="inlinecode"><span class="id" title="tactic">change</span></span>, <span class="inlinecode"><span class="id" title="tactic">replace</span></span>,
      <span class="inlinecode"><span class="id" title="var">cbn</span></span>, <span class="inlinecode"><span class="id" title="var">cbn</span></span> etc.

</li>
<li> daje większe możliwości radzenia sobie z generowanymi przez siebie
      podcelami 
</li>
</ul>

<div class="paragraph"> </div>

 Przeczytaj rozdział manuala opisujący język ssreflect. Jeżeli nie
    chce ci się tego robić, zapoznaj się chociaż z jego taktyką <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. 
<div class="paragraph"> </div>

<a id="lab796"></a><h1 class="section">Konkluzja</h1>

<div class="paragraph"> </div>

 W niniejszym rozdziale przyjrzeliśmy się bliżej znacznej części Coqowych
    taktyk. Moje ich opisanie nie jest aż tak kompletne i szczegółowe jak to
    z manuala, ale nadrabia (mam nadzieję) wplecionymi w tekst przykładami i
    zadaniami. Jeżeli jednak uważasz je za upośledzone, nie jesteś jeszcze
    stracony! Alternatywne opisy niektórych taktyk dostępne są też tu:
<ul class="doclist">
<li> pjreddie.com/coq-tactics/

</li>
<li> cs.cornell.edu/courses/cs3110/2017fa/a5/coq-tactics-cheatsheet.html

</li>
<li> typesofnote.com/posts/coq-cheat-sheet.html 
</li>
</ul>

<div class="paragraph"> </div>

 Poznawszy podstawy Ltaca oraz całe zoo przeróżnych taktyk, do zostania
    pełnoprawnym inżynierem dowodu (ang. proof engineer, ukute przez analogię
    do software engineer) brakuje ci jeszcze tylko umiejętności dowodzenia
    przez reflekcję, którą zajmiemy się już niedługo. 
</div>
<div class="code">
</div>
